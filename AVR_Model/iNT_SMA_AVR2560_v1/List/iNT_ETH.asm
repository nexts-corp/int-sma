
;CodeVisionAVR C Compiler V2.05.3 Standard
;(C) Copyright 1998-2011 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com

;Chip type                : ATmega2560
;Program type             : Application
;Clock frequency          : 8.000000 MHz
;Memory model             : Large
;Optimize for             : Size
;(s)printf features       : float, width, precision
;(s)scanf features        : long, width
;External RAM size        : 0
;Data Stack size          : 2800 byte(s)
;Heap size                : 2048 byte(s)
;Promote 'char' to 'int'  : Yes
;'char' is unsigned       : Yes
;8 bit enums              : Yes
;Global 'const' stored in FLASH     : Yes
;Enhanced function parameter passing: Yes
;Enhanced core instructions         : On
;Smart register allocation          : On
;Automatic register allocation      : On

	#pragma AVRPART ADMIN PART_NAME ATmega2560
	#pragma AVRPART MEMORY PROG_FLASH 262144
	#pragma AVRPART MEMORY EEPROM 4096
	#pragma AVRPART MEMORY INT_SRAM SIZE 8703
	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200

	#define CALL_SUPPORTED 1

	.LISTMAC
	.EQU EERE=0x0
	.EQU EEWE=0x1
	.EQU EEMWE=0x2
	.EQU UDRE=0x5
	.EQU RXC=0x7
	.EQU EECR=0x1F
	.EQU EEDR=0x20
	.EQU EEARL=0x21
	.EQU EEARH=0x22
	.EQU SPSR=0x2D
	.EQU SPDR=0x2E
	.EQU SMCR=0x33
	.EQU MCUSR=0x34
	.EQU MCUCR=0x35
	.EQU WDTCSR=0x60
	.EQU UCSR0A=0xC0
	.EQU UDR0=0xC6
	.EQU RAMPZ=0x3B
	.EQU EIND=0x3C
	.EQU SPL=0x3D
	.EQU SPH=0x3E
	.EQU SREG=0x3F
	.EQU XMCRA=0x74
	.EQU XMCRB=0x75
	.EQU GPIOR0=0x1E

	.DEF R0X0=R0
	.DEF R0X1=R1
	.DEF R0X2=R2
	.DEF R0X3=R3
	.DEF R0X4=R4
	.DEF R0X5=R5
	.DEF R0X6=R6
	.DEF R0X7=R7
	.DEF R0X8=R8
	.DEF R0X9=R9
	.DEF R0XA=R10
	.DEF R0XB=R11
	.DEF R0XC=R12
	.DEF R0XD=R13
	.DEF R0XE=R14
	.DEF R0XF=R15
	.DEF R0X10=R16
	.DEF R0X11=R17
	.DEF R0X12=R18
	.DEF R0X13=R19
	.DEF R0X14=R20
	.DEF R0X15=R21
	.DEF R0X16=R22
	.DEF R0X17=R23
	.DEF R0X18=R24
	.DEF R0X19=R25
	.DEF R0X1A=R26
	.DEF R0X1B=R27
	.DEF R0X1C=R28
	.DEF R0X1D=R29
	.DEF R0X1E=R30
	.DEF R0X1F=R31

	.EQU __SRAM_START=0x0200
	.EQU __SRAM_END=0x21FF
	.EQU __DSTACK_SIZE=0x0AF0
	.EQU __HEAP_SIZE=0x0800
	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1

	.MACRO __CPD1N
	CPI  R30,LOW(@0)
	LDI  R26,HIGH(@0)
	CPC  R31,R26
	LDI  R26,BYTE3(@0)
	CPC  R22,R26
	LDI  R26,BYTE4(@0)
	CPC  R23,R26
	.ENDM

	.MACRO __CPD2N
	CPI  R26,LOW(@0)
	LDI  R30,HIGH(@0)
	CPC  R27,R30
	LDI  R30,BYTE3(@0)
	CPC  R24,R30
	LDI  R30,BYTE4(@0)
	CPC  R25,R30
	.ENDM

	.MACRO __CPWRR
	CP   R@0,R@2
	CPC  R@1,R@3
	.ENDM

	.MACRO __CPWRN
	CPI  R@0,LOW(@2)
	LDI  R30,HIGH(@2)
	CPC  R@1,R30
	.ENDM

	.MACRO __ADDB1MN
	SUBI R30,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDB2MN
	SUBI R26,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDW1MN
	SUBI R30,LOW(-@0-(@1))
	SBCI R31,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW2MN
	SUBI R26,LOW(-@0-(@1))
	SBCI R27,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	SBCI R22,BYTE3(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1N
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	SBCI R22,BYTE3(-@0)
	SBCI R23,BYTE4(-@0)
	.ENDM

	.MACRO __ADDD2N
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	SBCI R24,BYTE3(-@0)
	SBCI R25,BYTE4(-@0)
	.ENDM

	.MACRO __SUBD1N
	SUBI R30,LOW(@0)
	SBCI R31,HIGH(@0)
	SBCI R22,BYTE3(@0)
	SBCI R23,BYTE4(@0)
	.ENDM

	.MACRO __SUBD2N
	SUBI R26,LOW(@0)
	SBCI R27,HIGH(@0)
	SBCI R24,BYTE3(@0)
	SBCI R25,BYTE4(@0)
	.ENDM

	.MACRO __ANDBMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ANDWMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ANDI R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ANDD1N
	ANDI R30,LOW(@0)
	ANDI R31,HIGH(@0)
	ANDI R22,BYTE3(@0)
	ANDI R23,BYTE4(@0)
	.ENDM

	.MACRO __ANDD2N
	ANDI R26,LOW(@0)
	ANDI R27,HIGH(@0)
	ANDI R24,BYTE3(@0)
	ANDI R25,BYTE4(@0)
	.ENDM

	.MACRO __ORBMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ORWMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ORI  R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ORD1N
	ORI  R30,LOW(@0)
	ORI  R31,HIGH(@0)
	ORI  R22,BYTE3(@0)
	ORI  R23,BYTE4(@0)
	.ENDM

	.MACRO __ORD2N
	ORI  R26,LOW(@0)
	ORI  R27,HIGH(@0)
	ORI  R24,BYTE3(@0)
	ORI  R25,BYTE4(@0)
	.ENDM

	.MACRO __DELAY_USB
	LDI  R24,LOW(@0)
__DELAY_USB_LOOP:
	DEC  R24
	BRNE __DELAY_USB_LOOP
	.ENDM

	.MACRO __DELAY_USW
	LDI  R24,LOW(@0)
	LDI  R25,HIGH(@0)
__DELAY_USW_LOOP:
	SBIW R24,1
	BRNE __DELAY_USW_LOOP
	.ENDM

	.MACRO __GETD1S
	LDD  R30,Y+@0
	LDD  R31,Y+@0+1
	LDD  R22,Y+@0+2
	LDD  R23,Y+@0+3
	.ENDM

	.MACRO __GETD2S
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	LDD  R24,Y+@0+2
	LDD  R25,Y+@0+3
	.ENDM

	.MACRO __PUTD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R31
	STD  Y+@0+2,R22
	STD  Y+@0+3,R23
	.ENDM

	.MACRO __PUTD2S
	STD  Y+@0,R26
	STD  Y+@0+1,R27
	STD  Y+@0+2,R24
	STD  Y+@0+3,R25
	.ENDM

	.MACRO __PUTDZ2
	STD  Z+@0,R26
	STD  Z+@0+1,R27
	STD  Z+@0+2,R24
	STD  Z+@0+3,R25
	.ENDM

	.MACRO __CLRD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R30
	STD  Y+@0+2,R30
	STD  Y+@0+3,R30
	.ENDM

	.MACRO __POINTB1MN
	LDI  R30,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW1MN
	LDI  R30,LOW(@0+(@1))
	LDI  R31,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTD1M
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __POINTW1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	.ENDM

	.MACRO __POINTD1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	LDI  R22,BYTE3(2*@0+(@1))
	LDI  R23,BYTE4(2*@0+(@1))
	.ENDM

	.MACRO __POINTB2MN
	LDI  R26,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW2MN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTW2FN
	LDI  R26,LOW(2*@0+(@1))
	LDI  R27,HIGH(2*@0+(@1))
	.ENDM

	.MACRO __POINTD2FN
	LDI  R26,LOW(2*@0+(@1))
	LDI  R27,HIGH(2*@0+(@1))
	LDI  R24,BYTE3(2*@0+(@1))
	LDI  R25,BYTE4(2*@0+(@1))
	.ENDM

	.MACRO __POINTBRM
	LDI  R@0,LOW(@1)
	.ENDM

	.MACRO __POINTWRM
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __POINTBRMN
	LDI  R@0,LOW(@1+(@2))
	.ENDM

	.MACRO __POINTWRMN
	LDI  R@0,LOW(@2+(@3))
	LDI  R@1,HIGH(@2+(@3))
	.ENDM

	.MACRO __POINTWRFN
	LDI  R@0,LOW(@2*2+(@3))
	LDI  R@1,HIGH(@2*2+(@3))
	.ENDM

	.MACRO __GETD1N
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __GETD2N
	LDI  R26,LOW(@0)
	LDI  R27,HIGH(@0)
	LDI  R24,BYTE3(@0)
	LDI  R25,BYTE4(@0)
	.ENDM

	.MACRO __GETB1MN
	LDS  R30,@0+(@1)
	.ENDM

	.MACRO __GETB1HMN
	LDS  R31,@0+(@1)
	.ENDM

	.MACRO __GETW1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	.ENDM

	.MACRO __GETD1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	LDS  R22,@0+(@1)+2
	LDS  R23,@0+(@1)+3
	.ENDM

	.MACRO __GETBRMN
	LDS  R@0,@1+(@2)
	.ENDM

	.MACRO __GETWRMN
	LDS  R@0,@2+(@3)
	LDS  R@1,@2+(@3)+1
	.ENDM

	.MACRO __GETWRZ
	LDD  R@0,Z+@2
	LDD  R@1,Z+@2+1
	.ENDM

	.MACRO __GETD2Z
	LDD  R26,Z+@0
	LDD  R27,Z+@0+1
	LDD  R24,Z+@0+2
	LDD  R25,Z+@0+3
	.ENDM

	.MACRO __GETB2MN
	LDS  R26,@0+(@1)
	.ENDM

	.MACRO __GETW2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	.ENDM

	.MACRO __GETD2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	LDS  R24,@0+(@1)+2
	LDS  R25,@0+(@1)+3
	.ENDM

	.MACRO __PUTB1MN
	STS  @0+(@1),R30
	.ENDM

	.MACRO __PUTW1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	.ENDM

	.MACRO __PUTD1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	STS  @0+(@1)+2,R22
	STS  @0+(@1)+3,R23
	.ENDM

	.MACRO __PUTB1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRB
	.ENDM

	.MACRO __PUTW1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRW
	.ENDM

	.MACRO __PUTD1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRD
	.ENDM

	.MACRO __PUTBR0MN
	STS  @0+(@1),R0
	.ENDM

	.MACRO __PUTBMRN
	STS  @0+(@1),R@2
	.ENDM

	.MACRO __PUTWMRN
	STS  @0+(@1),R@2
	STS  @0+(@1)+1,R@3
	.ENDM

	.MACRO __PUTBZR
	STD  Z+@1,R@0
	.ENDM

	.MACRO __PUTWZR
	STD  Z+@2,R@0
	STD  Z+@2+1,R@1
	.ENDM

	.MACRO __GETW1R
	MOV  R30,R@0
	MOV  R31,R@1
	.ENDM

	.MACRO __GETW2R
	MOV  R26,R@0
	MOV  R27,R@1
	.ENDM

	.MACRO __GETWRN
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __PUTW1R
	MOV  R@0,R30
	MOV  R@1,R31
	.ENDM

	.MACRO __PUTW2R
	MOV  R@0,R26
	MOV  R@1,R27
	.ENDM

	.MACRO __ADDWRN
	SUBI R@0,LOW(-@2)
	SBCI R@1,HIGH(-@2)
	.ENDM

	.MACRO __ADDWRR
	ADD  R@0,R@2
	ADC  R@1,R@3
	.ENDM

	.MACRO __SUBWRN
	SUBI R@0,LOW(@2)
	SBCI R@1,HIGH(@2)
	.ENDM

	.MACRO __SUBWRR
	SUB  R@0,R@2
	SBC  R@1,R@3
	.ENDM

	.MACRO __ANDWRN
	ANDI R@0,LOW(@2)
	ANDI R@1,HIGH(@2)
	.ENDM

	.MACRO __ANDWRR
	AND  R@0,R@2
	AND  R@1,R@3
	.ENDM

	.MACRO __ORWRN
	ORI  R@0,LOW(@2)
	ORI  R@1,HIGH(@2)
	.ENDM

	.MACRO __ORWRR
	OR   R@0,R@2
	OR   R@1,R@3
	.ENDM

	.MACRO __EORWRR
	EOR  R@0,R@2
	EOR  R@1,R@3
	.ENDM

	.MACRO __GETWRS
	LDD  R@0,Y+@2
	LDD  R@1,Y+@2+1
	.ENDM

	.MACRO __PUTBSR
	STD  Y+@1,R@0
	.ENDM

	.MACRO __PUTWSR
	STD  Y+@2,R@0
	STD  Y+@2+1,R@1
	.ENDM

	.MACRO __MOVEWRR
	MOV  R@0,R@2
	MOV  R@1,R@3
	.ENDM

	.MACRO __INWR
	IN   R@0,@2
	IN   R@1,@2+1
	.ENDM

	.MACRO __OUTWR
	OUT  @2+1,R@1
	OUT  @2,R@0
	.ENDM

	.MACRO __GETBRPF
	OUT  RAMPZ,R22
	ELPM R@0,Z
	.ENDM

	.MACRO __GETBRPF_INC
	OUT  RAMPZ,R22
	ELPM R@0,Z+
	.ENDM

	.MACRO __CALL1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	LDS  R22,@0+(@1)+2
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	LDI  R22,BYTE3(2*@0+(@1))
	CALL __GETD1PF
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL1FX
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	SBCI R22,BYTE3(-@0)
	CALL __GETD1PF
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL2EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMRDD
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL2EX
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	CALL __EEPROMRDD
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __GETW1STACK
	IN   R26,SPL
	IN   R27,SPH
	ADIW R26,@0+1
	LD   R30,X+
	LD   R31,X
	.ENDM

	.MACRO __GETD1STACK
	IN   R26,SPL
	IN   R27,SPH
	ADIW R26,@0+1
	LD   R30,X+
	LD   R31,X+
	LD   R22,X
	.ENDM

	.MACRO __NBST
	BST  R@0,@1
	IN   R30,SREG
	LDI  R31,0x40
	EOR  R30,R31
	OUT  SREG,R30
	.ENDM


	.MACRO __PUTB1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RNS
	MOVW R26,R@0
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	CALL __PUTDP1
	.ENDM


	.MACRO __GETB1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R30,Z
	.ENDM

	.MACRO __GETB1HSX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	.ENDM

	.MACRO __GETW1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R31,Z
	MOV  R30,R0
	.ENDM

	.MACRO __GETD1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R1,Z+
	LD   R22,Z+
	LD   R23,Z
	MOVW R30,R0
	.ENDM

	.MACRO __GETB2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R26,X
	.ENDM

	.MACRO __GETW2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	.ENDM

	.MACRO __GETD2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R1,X+
	LD   R24,X+
	LD   R25,X
	MOVW R26,R0
	.ENDM

	.MACRO __GETBRSX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	LD   R@0,Z
	.ENDM

	.MACRO __GETWRSX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	LD   R@0,Z+
	LD   R@1,Z
	.ENDM

	.MACRO __GETBRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	LD   R@0,X
	.ENDM

	.MACRO __GETWRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	LD   R@0,X+
	LD   R@1,X
	.ENDM

	.MACRO __LSLW8SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	CLR  R30
	.ENDM

	.MACRO __PUTB1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __CLRW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __CLRD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R30
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __PUTB2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z,R26
	.ENDM

	.MACRO __PUTW2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z,R27
	.ENDM

	.MACRO __PUTD2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z+,R27
	ST   Z+,R24
	ST   Z,R25
	.ENDM

	.MACRO __PUTBSRX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	ST   Z,R@0
	.ENDM

	.MACRO __PUTWSRX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	ST   Z+,R@0
	ST   Z,R@1
	.ENDM

	.MACRO __PUTB1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __MULBRR
	MULS R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRRU
	MUL  R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRR0
	MULS R@0,R@1
	.ENDM

	.MACRO __MULBRRU0
	MUL  R@0,R@1
	.ENDM

	.MACRO __MULBNWRU
	LDI  R26,@2
	MUL  R26,R@0
	MOVW R30,R0
	MUL  R26,R@1
	ADD  R31,R0
	.ENDM

;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
	.DEF _pviQueueData1=R4
	.DEF _piDeviceTask=R6
	.DEF _rxPackageIndex3=R9
	.DEF _rxPackageIndexCount3=R8
	.DEF _flagCountStart0=R10
	.DEF _rx0IndexWriteConn=R12

;GPIOR0 INITIALIZATION VALUE
	.EQU __GPIOR0_INIT=0x00

	.CSEG
	.ORG 0x00

;START OF CODE MARKER
__START_OF_CODE:

;INTERRUPT VECTORS
	JMP  __RESET
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _wdt_timeout_isr
	JMP  0x00
	JMP  0x00
	JMP  _timer2_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer1_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  _timer0_ovf_isr
	JMP  0x00
	JMP  _usart0_rx_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer3_ovf_isr
	JMP  _usart1_rx_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer4_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _usart2_rx_isr
	JMP  0x00
	JMP  0x00
	JMP  _usart3_rx_isr
	JMP  0x00
	JMP  0x00

_error_msg:
	.DB  LOW(_0x240000*2),HIGH(_0x240000*2),BYTE3(_0x240000*2),BYTE4(_0x240000*2),LOW(_0x240000*2+1),HIGH(_0x240000*2+1),BYTE3(_0x240000*2+1),BYTE4(_0x240000*2+1)
	.DB  LOW(_0x240000*2+13),HIGH(_0x240000*2+13),BYTE3(_0x240000*2+13),BYTE4(_0x240000*2+13),LOW(_0x240000*2+24),HIGH(_0x240000*2+24),BYTE3(_0x240000*2+24),BYTE4(_0x240000*2+24)
	.DB  LOW(_0x240000*2+37),HIGH(_0x240000*2+37),BYTE3(_0x240000*2+37),BYTE4(_0x240000*2+37),LOW(_0x240000*2+48),HIGH(_0x240000*2+48),BYTE3(_0x240000*2+48),BYTE4(_0x240000*2+48)
	.DB  LOW(_0x240000*2+59),HIGH(_0x240000*2+59),BYTE3(_0x240000*2+59),BYTE4(_0x240000*2+59),LOW(_0x240000*2+75),HIGH(_0x240000*2+75),BYTE3(_0x240000*2+75),BYTE4(_0x240000*2+75)
	.DB  LOW(_0x240000*2+85),HIGH(_0x240000*2+85),BYTE3(_0x240000*2+85),BYTE4(_0x240000*2+85),LOW(_0x240000*2+94),HIGH(_0x240000*2+94),BYTE3(_0x240000*2+94),BYTE4(_0x240000*2+94)
	.DB  LOW(_0x240000*2+112),HIGH(_0x240000*2+112),BYTE3(_0x240000*2+112),BYTE4(_0x240000*2+112),LOW(_0x240000*2+131),HIGH(_0x240000*2+131),BYTE3(_0x240000*2+131),BYTE4(_0x240000*2+131)
	.DB  LOW(_0x240000*2+148),HIGH(_0x240000*2+148),BYTE3(_0x240000*2+148),BYTE4(_0x240000*2+148),LOW(_0x240000*2+163),HIGH(_0x240000*2+163),BYTE3(_0x240000*2+163),BYTE4(_0x240000*2+163)
	.DB  LOW(_0x240000*2+180),HIGH(_0x240000*2+180),BYTE3(_0x240000*2+180),BYTE4(_0x240000*2+180),LOW(_0x240000*2+196),HIGH(_0x240000*2+196),BYTE3(_0x240000*2+196),BYTE4(_0x240000*2+196)
_cmdSetRTCDateTime:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x44,0x54,0x0
_cmdResetAlarmStatus:
	.DB  0x24,0x43,0x4D,0x44,0x52,0x41,0x53,0x0
_cmdClearLogFile:
	.DB  0x24,0x43,0x4D,0x44,0x43,0x4C,0x46,0x0
_cmdSetVref:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x56,0x52,0x0
_cmdSensorSelect:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x4E,0x53,0x0
_cmdDeviceEnable:
	.DB  0x24,0x43,0x4D,0x44,0x44,0x45,0x4E,0x0
_cmdDeviceDisable:
	.DB  0x24,0x43,0x4D,0x44,0x44,0x44,0x53,0x0
_cmdSetSerialNumber:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x53,0x4E,0x0
_cmdReadSerialNumber:
	.DB  0x24,0x43,0x4D,0x44,0x52,0x53,0x4E,0x0
_cmdGetCal:
	.DB  0x24,0x43,0x4D,0x44,0x47,0x43,0x4C,0x0
_cmdSetCal:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x43,0x4C,0x0
_cmdConfirmCal:
	.DB  0x24,0x43,0x4D,0x44,0x43,0x43,0x4C,0x0
_cmdGetCurSensor:
	.DB  0x24,0x43,0x4D,0x44,0x47,0x43,0x53,0x0
_k1:
	.DB  0x20,0x22,0x2A,0x2B,0x2C,0x5B,0x3D,0x5D
	.DB  0x7C,0x7F,0x0

;HEAP START MARKER INITIALIZATION
__HEAP_START_MARKER:
	.DW  0,0

_0x17:
	.DB  0x0,0x0,0x0,0x0
_0x0:
	.DB  0x5B,0x6D,0x61,0x69,0x6E,0x5D,0x49,0x6E
	.DB  0x69,0x74,0x69,0x61,0x6C,0x2E,0x2E,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x6D,0x61,0x69,0x6E
	.DB  0x5D,0x4C,0x61,0x6E,0x20,0x43,0x6F,0x6E
	.DB  0x6E,0x65,0x63,0x74,0x65,0x64,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x6D,0x61,0x69,0x6E,0x5D
	.DB  0x4C,0x61,0x6E,0x20,0x46,0x61,0x69,0x6C
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x6D,0x61,0x69
	.DB  0x6E,0x5D,0x2C,0x70,0x76,0x69,0x51,0x75
	.DB  0x65,0x75,0x65,0x53,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x54,0x6F,0x4D,0x61,0x6E,0x67,0x20
	.DB  0x63,0x61,0x6E,0x20,0x6E,0x6F,0x74,0x20
	.DB  0x63,0x72,0x65,0x61,0x74,0x65,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x6D,0x61,0x69,0x6E,0x5D
	.DB  0x2C,0x70,0x76,0x69,0x51,0x75,0x65,0x75
	.DB  0x65,0x53,0x65,0x6E,0x73,0x6F,0x72,0x54
	.DB  0x6F,0x4D,0x61,0x6E,0x67,0x20,0x63,0x61
	.DB  0x6E,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x6D,0x61,0x69
	.DB  0x6E,0x5D,0x2C,0x70,0x76,0x69,0x51,0x75
	.DB  0x65,0x75,0x65,0x4D,0x61,0x6E,0x67,0x54
	.DB  0x6F,0x43,0x6F,0x6E,0x66,0x69,0x67,0x20
	.DB  0x63,0x61,0x6E,0x20,0x6E,0x6F,0x74,0x20
	.DB  0x63,0x72,0x65,0x61,0x74,0x65,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x6D,0x61,0x69,0x6E,0x5D
	.DB  0x2C,0x70,0x76,0x69,0x51,0x75,0x65,0x75
	.DB  0x65,0x4D,0x61,0x6E,0x67,0x54,0x6F,0x43
	.DB  0x6F,0x6E,0x66,0x69,0x67,0x20,0x63,0x61
	.DB  0x6E,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x6D,0x61,0x69
	.DB  0x6E,0x5D,0x2C,0x70,0x76,0x69,0x51,0x75
	.DB  0x65,0x75,0x65,0x44,0x65,0x76,0x69,0x63
	.DB  0x65,0x54,0x6F,0x4D,0x61,0x6E,0x67,0x20
	.DB  0x63,0x61,0x6E,0x20,0x6E,0x6F,0x74,0x20
	.DB  0x63,0x72,0x65,0x61,0x74,0x65,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x6D,0x61,0x69,0x6E,0x5D
	.DB  0x2C,0x70,0x76,0x69,0x51,0x75,0x65,0x75
	.DB  0x65,0x44,0x65,0x76,0x69,0x63,0x65,0x54
	.DB  0x6F,0x4D,0x61,0x6E,0x67,0x20,0x63,0x61
	.DB  0x6E,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0,0x6C,0x6F,0x67,0x67
	.DB  0x65,0x72,0x0,0x3C,0x6D,0x61,0x69,0x6E
	.DB  0x3E,0x6C,0x6F,0x67,0x54,0x61,0x73,0x6B
	.DB  0x20,0x61,0x64,0x64,0x72,0x20,0x3A,0x20
	.DB  0x25,0x70,0xD,0xA,0x0,0x64,0x61,0x74
	.DB  0x61,0x41,0x6E,0x64,0x53,0x74,0x61,0x74
	.DB  0x75,0x73,0x0,0x3C,0x6D,0x61,0x69,0x6E
	.DB  0x3E,0x73,0x65,0x6E,0x73,0x6F,0x72,0x54
	.DB  0x61,0x73,0x6B,0x20,0x61,0x64,0x64,0x72
	.DB  0x20,0x3A,0x20,0x25,0x70,0xD,0xA,0x0
	.DB  0x6D,0x61,0x6E,0x67,0x0,0x3C,0x6D,0x61
	.DB  0x69,0x6E,0x3E,0x6D,0x61,0x6E,0x61,0x67
	.DB  0x65,0x72,0x54,0x61,0x73,0x6B,0x20,0x61
	.DB  0x64,0x64,0x72,0x20,0x3A,0x20,0x25,0x70
	.DB  0xD,0xA,0x0,0x65,0x76,0x65,0x6E,0x74
	.DB  0x0,0x3C,0x6D,0x61,0x69,0x6E,0x3E,0x65
	.DB  0x76,0x65,0x6E,0x74,0x54,0x61,0x73,0x6B
	.DB  0x20,0x61,0x64,0x64,0x72,0x20,0x3A,0x20
	.DB  0x25,0x70,0xD,0xA,0x0
_0x20000:
	.DB  0xD,0xA,0x50,0x6F,0x77,0x65,0x72,0x2D
	.DB  0x6F,0x6E,0x20,0x52,0x65,0x73,0x65,0x74
	.DB  0xD,0xA,0x0,0xD,0xA,0x45,0x78,0x74
	.DB  0x65,0x72,0x6E,0x61,0x6C,0x20,0x52,0x65
	.DB  0x73,0x65,0x74,0xD,0xA,0x0,0xD,0xA
	.DB  0x42,0x72,0x6F,0x77,0x6E,0x2D,0x6F,0x75
	.DB  0x74,0x20,0x52,0x65,0x73,0x65,0x74,0xD
	.DB  0xA,0x0,0xD,0xA,0x57,0x61,0x74,0x63
	.DB  0x68,0x64,0x6F,0x67,0x20,0x52,0x65,0x73
	.DB  0x65,0x74,0xD,0xA,0x0,0xD,0xA,0x4A
	.DB  0x54,0x41,0x47,0x20,0x52,0x65,0x73,0x65
	.DB  0x74,0xD,0xA,0x0,0x3C,0x69,0x6E,0x69
	.DB  0x74,0x69,0x61,0x6C,0x5F,0x73,0x79,0x73
	.DB  0x74,0x65,0x6D,0x3E,0x20,0x53,0x44,0x5F
	.DB  0x69,0x6E,0x69,0x74,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
_0x40042:
	.DB  0x0,0x0,0x0,0x0
_0x40000:
	.DB  0xD,0xA,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0xD,0xA,0x0,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x20,0x45,0x74,0x68,0x20,0x42
	.DB  0x75,0x66,0x66,0x65,0x72,0x20,0x4F,0x76
	.DB  0x65,0x72,0x66,0x6C,0x6F,0x77,0x20,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x0
_0x60000:
	.DB  0x3C,0x54,0x49,0x4D,0x45,0x52,0x5F,0x73
	.DB  0x65,0x74,0x54,0x69,0x6D,0x65,0x72,0x3E
	.DB  0x20,0x45,0x52,0x52,0x3A,0x20,0x70,0x65
	.DB  0x72,0x69,0x6F,0x64,0x20,0x3D,0x20,0x30
	.DB  0xD,0xA,0x0,0x3C,0x54,0x49,0x4D,0x45
	.DB  0x52,0x5F,0x73,0x65,0x74,0x54,0x69,0x6D
	.DB  0x65,0x72,0x3E,0x20,0x62,0x61,0x73,0x65
	.DB  0x43,0x6F,0x75,0x6E,0x74,0x65,0x72,0x5B
	.DB  0x25,0x6C,0x64,0x5D,0x20,0x2B,0x20,0x70
	.DB  0x65,0x72,0x69,0x6F,0x64,0x5B,0x25,0x6C
	.DB  0x64,0x5D,0x20,0x3D,0x20,0x25,0x6C,0x64
	.DB  0x20,0x4F,0x56,0x45,0x52,0x46,0x4C,0x4F
	.DB  0x57,0x21,0x21,0xD,0xA,0x0,0x3C,0x57
	.DB  0x44,0x54,0x3E,0x20,0x57,0x61,0x74,0x63
	.DB  0x68,0x44,0x6F,0x67,0x20,0x54,0x69,0x6D
	.DB  0x65,0x72,0x20,0x52,0x65,0x73,0x65,0x74
	.DB  0x21,0x21,0xD,0xA,0x0
_0x80000:
	.DB  0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79,0x43
	.DB  0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B,0x65
	.DB  0x79,0x20,0x4D,0x4F,0x44,0x45,0xD,0xA
	.DB  0x0,0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79
	.DB  0x43,0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B
	.DB  0x65,0x79,0x20,0x55,0x50,0xD,0xA,0x0
	.DB  0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79,0x43
	.DB  0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B,0x65
	.DB  0x79,0x20,0x44,0x4F,0x57,0x4E,0xD,0xA
	.DB  0x0,0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79
	.DB  0x43,0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B
	.DB  0x65,0x79,0x20,0x4F,0x4B,0xD,0xA,0x0
_0xA0000:
	.DB  0x49,0x6E,0x69,0x74,0x69,0x61,0x6C,0x69
	.DB  0x7A,0x69,0x6E,0x67,0x20,0x41,0x44,0x43
	.DB  0x2E,0x2E,0x20,0x0,0x4F,0x4B,0xD,0xA
	.DB  0x0
_0xC0003:
	.DB  0x63,0x0,0x0,0x0,0x63,0x0,0x0,0x0
	.DB  0x63,0x0,0x0,0x0
_0xC0000:
	.DB  0x63,0x5F,0x74,0x69,0x6D,0x65,0x5B,0x25
	.DB  0x6C,0x64,0x5D,0x20,0x26,0x20,0x73,0x5F
	.DB  0x74,0x69,0x6D,0x65,0x5B,0x25,0x6C,0x64
	.DB  0x5D,0x20,0x3D,0x3E,0x20,0x64,0x69,0x66
	.DB  0x66,0x5B,0x25,0x6C,0x64,0x5D,0xD,0xA
	.DB  0x0,0x3E,0x3E,0x20,0x52,0x54,0x43,0x5F
	.DB  0x73,0x65,0x74,0x42,0x69,0x6E,0x61,0x72
	.DB  0x79,0x20,0x52,0x54,0x43,0x20,0x53,0x79
	.DB  0x6E,0x63,0x2E,0xD,0xA,0x0,0x3C,0x52
	.DB  0x54,0x43,0x5F,0x73,0x65,0x74,0x44,0x61
	.DB  0x74,0x65,0x54,0x69,0x6D,0x65,0x3E,0x20
	.DB  0x54,0x69,0x6D,0x65,0x7A,0x6F,0x6E,0x65
	.DB  0x20,0x6F,0x75,0x74,0x20,0x6F,0x66,0x20
	.DB  0x72,0x61,0x6E,0x67,0x65,0x20,0x28,0x25
	.DB  0x2B,0x64,0x29,0xD,0xA,0x0,0x4D,0x6F
	.DB  0x6E,0x2E,0x20,0x0,0x54,0x75,0x65,0x2E
	.DB  0x20,0x0,0x57,0x65,0x64,0x2E,0x20,0x0
	.DB  0x54,0x68,0x75,0x2E,0x20,0x0,0x46,0x72
	.DB  0x69,0x2E,0x20,0x0,0x53,0x61,0x74,0x2E
	.DB  0x20,0x0,0x53,0x75,0x6E,0x2E,0x20,0x0
	.DB  0x5B,0x25,0x64,0x5D,0x25,0x30,0x34,0x64
	.DB  0x2D,0x25,0x30,0x32,0x64,0x2D,0x25,0x30
	.DB  0x32,0x64,0x20,0x25,0x30,0x32,0x64,0x3A
	.DB  0x25,0x30,0x32,0x64,0x3A,0x25,0x30,0x32
	.DB  0x64,0xD,0xA,0x0,0x52,0x75,0x6E,0x6E
	.DB  0x69,0x6E,0x67,0x20,0x77,0x69,0x74,0x68
	.DB  0x20,0x53,0x79,0x73,0x74,0x65,0x6D,0x20
	.DB  0x43,0x6C,0x6F,0x63,0x6B,0x20,0x40,0x20
	.DB  0x0
_0x120000:
	.DB  0x3C,0x45,0x54,0x48,0x5F,0x73,0x77,0x69
	.DB  0x74,0x63,0x68,0x4D,0x6F,0x64,0x65,0x3E
	.DB  0x20,0x73,0x77,0x69,0x74,0x63,0x68,0x20
	.DB  0x74,0x6F,0x20,0x43,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x20,0x6D,0x6F,0x64,0x65,0xD,0xA
	.DB  0x0,0x3C,0x45,0x54,0x48,0x5F,0x73,0x77
	.DB  0x69,0x74,0x63,0x68,0x4D,0x6F,0x64,0x65
	.DB  0x3E,0x20,0x73,0x77,0x69,0x74,0x63,0x68
	.DB  0x20,0x74,0x6F,0x20,0x4E,0x6F,0x72,0x6D
	.DB  0x61,0x6C,0x20,0x6D,0x6F,0x64,0x65,0xD
	.DB  0xA,0x0
_0x140000:
	.DB  0x3C,0x73,0x74,0x61,0x74,0x75,0x73,0x52
	.DB  0x65,0x71,0x75,0x65,0x73,0x74,0x50,0x61
	.DB  0x72,0x73,0x65,0x72,0x3E,0x20,0x6D,0x61
	.DB  0x6C,0x6C,0x6F,0x63,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x63
	.DB  0x6F,0x6E,0x66,0x69,0x67,0x4D,0x61,0x6E
	.DB  0x61,0x67,0x65,0x50,0x61,0x72,0x73,0x65
	.DB  0x72,0x3E,0xD,0xA,0x0,0x3C,0x63,0x6F
	.DB  0x6E,0x66,0x69,0x67,0x4D,0x61,0x6E,0x61
	.DB  0x67,0x65,0x50,0x61,0x72,0x73,0x65,0x72
	.DB  0x3E,0x20,0x52,0x45,0x41,0x44,0x49,0x4E
	.DB  0x47,0xD,0xA,0x0,0x3C,0x63,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x4D,0x61,0x6E,0x61,0x67
	.DB  0x65,0x50,0x61,0x72,0x73,0x65,0x72,0x3E
	.DB  0x20,0x57,0x52,0x49,0x54,0x49,0x4E,0x47
	.DB  0xD,0xA,0x0,0x3C,0x63,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x4D,0x61,0x6E,0x61,0x67,0x65
	.DB  0x50,0x61,0x72,0x73,0x65,0x72,0x3E,0x20
	.DB  0x63,0x6F,0x6E,0x66,0x4C,0x65,0x6E,0x20
	.DB  0x3D,0x20,0x25,0x64,0xD,0xA,0x0,0x3C
	.DB  0x63,0x6F,0x6E,0x66,0x69,0x67,0x4D,0x61
	.DB  0x6E,0x61,0x67,0x65,0x50,0x61,0x72,0x73
	.DB  0x65,0x72,0x3E,0x20,0x6D,0x61,0x6C,0x6C
	.DB  0x6F,0x63,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x6E,0x65,0x74
	.DB  0x77,0x6F,0x72,0x6B,0x4D,0x61,0x69,0x6E
	.DB  0x74,0x65,0x6E,0x61,0x6E,0x63,0x65,0x50
	.DB  0x61,0x72,0x73,0x65,0x72,0x3E,0x20,0x6D
	.DB  0x61,0x6C,0x6C,0x6F,0x63,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0x20,0x28,0x25,0x64
	.DB  0x29,0xD,0xA,0x0
_0x1A0011:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x94,0x41,0x0,0x0,0x0,0x0
_0x1A0000:
	.DB  0x53,0x65,0x6E,0x73,0x6F,0x72,0x20,0x63
	.DB  0x68,0x5B,0x25,0x64,0x5D,0x20,0x69,0x73
	.DB  0x20,0x61,0x20,0x72,0x61,0x77,0x20,0x64
	.DB  0x61,0x74,0x61,0x5B,0x25,0x30,0x2E,0x32
	.DB  0x66,0x5D,0x20,0x2C,0x20,0x63,0x61,0x6C
	.DB  0x50,0x72,0x6F,0x63,0x65,0x73,0x73,0x5B
	.DB  0x25,0x30,0x2E,0x32,0x66,0x5D,0xD,0xA
	.DB  0x0
_0x240003:
	.DB  0x30,0x3A,0x2F
_0x240000:
	.DB  0x0,0x46,0x52,0x5F,0x44,0x49,0x53,0x4B
	.DB  0x5F,0x45,0x52,0x52,0x0,0x46,0x52,0x5F
	.DB  0x49,0x4E,0x54,0x5F,0x45,0x52,0x52,0x0
	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x54,0x5F,0x52
	.DB  0x45,0x41,0x44,0x59,0x0,0x46,0x52,0x5F
	.DB  0x4E,0x4F,0x5F,0x46,0x49,0x4C,0x45,0x0
	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x5F,0x50,0x41
	.DB  0x54,0x48,0x0,0x46,0x52,0x5F,0x49,0x4E
	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x4E,0x41
	.DB  0x4D,0x45,0x0,0x46,0x52,0x5F,0x44,0x45
	.DB  0x4E,0x49,0x45,0x44,0x0,0x46,0x52,0x5F
	.DB  0x45,0x58,0x49,0x53,0x54,0x0,0x46,0x52
	.DB  0x5F,0x49,0x4E,0x56,0x41,0x4C,0x49,0x44
	.DB  0x5F,0x4F,0x42,0x4A,0x45,0x43,0x54,0x0
	.DB  0x46,0x52,0x5F,0x57,0x52,0x49,0x54,0x45
	.DB  0x5F,0x50,0x52,0x4F,0x54,0x45,0x43,0x54
	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x49,0x4E
	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x44,0x52
	.DB  0x49,0x56,0x45,0x0,0x46,0x52,0x5F,0x4E
	.DB  0x4F,0x54,0x5F,0x45,0x4E,0x41,0x42,0x4C
	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x4E,0x4F
	.DB  0x5F,0x46,0x49,0x4C,0x45,0x53,0x59,0x53
	.DB  0x54,0x45,0x4D,0x0,0x46,0x52,0x5F,0x4D
	.DB  0x4B,0x46,0x53,0x5F,0x41,0x42,0x4F,0x52
	.DB  0x54,0x45,0x44,0x0,0x46,0x52,0x5F,0x54
	.DB  0x49,0x4D,0x45,0x4F,0x55,0x54,0x0,0x3C
	.DB  0x45,0x52,0x52,0x3E,0x20,0x25,0x70,0x2E
	.DB  0xD,0xA,0x0,0x3C,0x53,0x44,0x5F,0x77
	.DB  0x72,0x69,0x74,0x65,0x44,0x61,0x74,0x61
	.DB  0x3E,0x20,0x53,0x44,0x20,0x43,0x61,0x72
	.DB  0x64,0x20,0x6E,0x6F,0x74,0x20,0x72,0x65
	.DB  0x61,0x64,0x79,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x3E,0x20,0x66,0x5F,0x6C
	.DB  0x73,0x65,0x65,0x6B,0x28,0x25,0x75,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0x21
	.DB  0x21,0xD,0xA,0x0,0x3C,0x53,0x44,0x5F
	.DB  0x77,0x72,0x69,0x74,0x65,0x44,0x61,0x74
	.DB  0x61,0x3E,0x20,0x66,0x5F,0x77,0x72,0x69
	.DB  0x74,0x65,0x28,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x3E,0x20,0x61,0x63,0x74
	.DB  0x75,0x61,0x6C,0x5F,0x77,0x72,0x69,0x74
	.DB  0x65,0x5B,0x25,0x75,0x5D,0x20,0x21,0x3D
	.DB  0x20,0x6C,0x65,0x6E,0x5B,0x25,0x75,0x5D
	.DB  0xD,0xA,0x0,0x3C,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x3E
	.DB  0x20,0x53,0x44,0x20,0x43,0x61,0x72,0x64
	.DB  0x20,0x6E,0x6F,0x74,0x20,0x72,0x65,0x61
	.DB  0x64,0x79,0xD,0xA,0x0,0x3C,0x53,0x44
	.DB  0x5F,0x72,0x65,0x61,0x64,0x44,0x61,0x74
	.DB  0x61,0x3E,0x20,0x66,0x5F,0x6C,0x73,0x65
	.DB  0x65,0x6B,0x28,0x25,0x75,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0x21,0x21,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x72,0x65
	.DB  0x61,0x64,0x44,0x61,0x74,0x61,0x3E,0x20
	.DB  0x66,0x5F,0x72,0x65,0x61,0x64,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x77,0x72
	.DB  0x69,0x74,0x65,0x44,0x61,0x74,0x61,0x3E
	.DB  0x20,0x61,0x63,0x74,0x75,0x61,0x6C,0x5F
	.DB  0x72,0x65,0x61,0x64,0x5B,0x25,0x75,0x5D
	.DB  0x20,0x21,0x3D,0x20,0x6C,0x65,0x6E,0x5B
	.DB  0x25,0x75,0x5D,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x72,0x65,0x61,0x64,0x4D,0x65
	.DB  0x6D,0x6F,0x72,0x79,0x52,0x65,0x6D,0x61
	.DB  0x69,0x6E,0x3E,0x20,0x66,0x5F,0x67,0x65
	.DB  0x74,0x66,0x72,0x65,0x65,0x28,0x25,0x73
	.DB  0x29,0x20,0x65,0x72,0x72,0x6F,0x72,0x21
	.DB  0x21,0xD,0xA,0x0,0x4C,0x6F,0x67,0x69
	.DB  0x63,0x61,0x6C,0x20,0x64,0x72,0x69,0x76
	.DB  0x65,0x20,0x30,0x3A,0x20,0x6D,0x6F,0x75
	.DB  0x6E,0x74,0x65,0x64,0x20,0x45,0x52,0x52
	.DB  0x4F,0x52,0xD,0xA,0x0,0x4C,0x6F,0x67
	.DB  0x69,0x63,0x61,0x6C,0x20,0x64,0x72,0x69
	.DB  0x76,0x65,0x20,0x30,0x3A,0x20,0x6D,0x6F
	.DB  0x75,0x6E,0x74,0x65,0x64,0x20,0x4F,0x4B
	.DB  0xD,0xA,0x0,0x4C,0x6F,0x67,0x69,0x63
	.DB  0x61,0x6C,0x20,0x64,0x72,0x69,0x76,0x65
	.DB  0x20,0x30,0x3A,0x20,0x75,0x6E,0x6D,0x6F
	.DB  0x75,0x6E,0x74,0x65,0x64,0x20,0x45,0x52
	.DB  0x52,0x4F,0x52,0xD,0xA,0x0,0x4C,0x6F
	.DB  0x67,0x69,0x63,0x61,0x6C,0x20,0x64,0x72
	.DB  0x69,0x76,0x65,0x20,0x30,0x3A,0x20,0x75
	.DB  0x6E,0x6D,0x6F,0x75,0x6E,0x74,0x65,0x64
	.DB  0x20,0x4F,0x4B,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x72,0x65,0x6D,0x6F,0x75,0x6E
	.DB  0x74,0x3E,0x20,0x53,0x44,0x5F,0x75,0x6E
	.DB  0x6D,0x6F,0x75,0x6E,0x74,0x28,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x53,0x44,0x5F,0x72,0x65,0x6D
	.DB  0x6F,0x75,0x6E,0x74,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x6D,0x6F,0x75,0x6E,0x74,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x53,0x44,0x20,0x43,0x61,0x72
	.DB  0x64,0x20,0x6E,0x6F,0x74,0x20,0x72,0x65
	.DB  0x61,0x64,0x79,0xD,0xA,0x0,0x25,0x73
	.DB  0x25,0x73,0x0,0x3C,0x53,0x44,0x5F,0x63
	.DB  0x72,0x65,0x61,0x74,0x65,0x46,0x69,0x6C
	.DB  0x65,0x3E,0x20,0x66,0x5F,0x6F,0x70,0x65
	.DB  0x6E,0x28,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x53,0x44
	.DB  0x5F,0x63,0x72,0x65,0x61,0x74,0x65,0x46
	.DB  0x69,0x6C,0x65,0x3E,0x20,0x66,0x5F,0x63
	.DB  0x6C,0x6F,0x73,0x65,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x53,0x44,0x5F,0x6F,0x70,0x65,0x6E
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x53,0x44
	.DB  0x20,0x43,0x61,0x72,0x64,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x72,0x65,0x61,0x64,0x79,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x6F,0x70
	.DB  0x65,0x6E,0x46,0x69,0x6C,0x65,0x3E,0x20
	.DB  0x66,0x5F,0x6F,0x70,0x65,0x6E,0x28,0x29
	.DB  0x20,0x5B,0x25,0x73,0x5D,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x53,0x44,0x5F,0x63,0x6C,0x6F,0x73,0x65
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x53,0x44
	.DB  0x20,0x43,0x61,0x72,0x64,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x72,0x65,0x61,0x64,0x79,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x63,0x6C
	.DB  0x6F,0x73,0x65,0x46,0x69,0x6C,0x65,0x3E
	.DB  0x20,0x66,0x5F,0x63,0x6C,0x6F,0x73,0x65
	.DB  0x28,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x53,0x44,0x5F
	.DB  0x69,0x6E,0x69,0x74,0x3E,0x20,0x53,0x74
	.DB  0x61,0x72,0x74,0x20,0x69,0x6E,0x69,0x74
	.DB  0x69,0x61,0x6C,0x20,0x6D,0x65,0x6D,0x6F
	.DB  0x72,0x79,0x20,0x63,0x61,0x72,0x64,0xD
	.DB  0xA,0x0,0xD,0xA,0x3C,0x53,0x44,0x5F
	.DB  0x69,0x6E,0x69,0x74,0x3E,0x20,0x4D,0x6F
	.DB  0x75,0x6E,0x74,0x69,0x6E,0x67,0x20,0x53
	.DB  0x44,0x20,0x43,0x61,0x72,0x64,0x2E,0x2E
	.DB  0x2E,0x0,0x3C,0x53,0x44,0x5F,0x69,0x6E
	.DB  0x69,0x74,0x3E,0x20,0x53,0x44,0x5F,0x6D
	.DB  0x6F,0x75,0x6E,0x74,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0xD,0xA,0x3C,0x53,0x44,0x5F,0x69,0x6E
	.DB  0x69,0x74,0x3E,0x20,0x43,0x68,0x65,0x63
	.DB  0x6B,0x20,0x43,0x61,0x72,0x64,0x20,0x53
	.DB  0x69,0x7A,0x65,0x2E,0x2E,0x2E,0x0,0x3C
	.DB  0x53,0x44,0x5F,0x69,0x6E,0x69,0x74,0x3E
	.DB  0x20,0x53,0x44,0x5F,0x72,0x65,0x61,0x64
	.DB  0x4D,0x65,0x6D,0x6F,0x72,0x79,0x52,0x65
	.DB  0x6D,0x61,0x69,0x6E,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x53,0x44,0x5F,0x69,0x6E,0x69,0x74
	.DB  0x3E,0x20,0x46,0x72,0x65,0x65,0x20,0x73
	.DB  0x70,0x61,0x63,0x65,0x20,0x6F,0x6E,0x20
	.DB  0x6C,0x6F,0x67,0x69,0x63,0x61,0x6C,0x20
	.DB  0x64,0x72,0x69,0x76,0x65,0x20,0x30,0x3A
	.DB  0x20,0x25,0x6C,0x75,0x20,0x6B,0x62,0x79
	.DB  0x74,0x65,0x73,0xD,0xA,0x0
_0x260003:
	.DB  0x64,0x61,0x74,0x61,0x2E,0x6C,0x6F,0x67
_0x260004:
	.DB  0x65,0x76,0x65,0x6E,0x74,0x2E,0x6C,0x6F
	.DB  0x67
_0x260005:
	.DB  0x65,0x72,0x72,0x6F,0x72,0x2E,0x6C,0x6F
	.DB  0x67
_0x260006:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
_0x260007:
	.DB  LOW(_SD_openFile),HIGH(_SD_openFile),BYTE3(_SD_openFile),BYTE4(_SD_openFile)
_0x260008:
	.DB  LOW(_SD_closeFile),HIGH(_SD_closeFile),BYTE3(_SD_closeFile),BYTE4(_SD_closeFile)
_0x260000:
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x69,0x6E,0x73
	.DB  0x65,0x72,0x74,0x44,0x61,0x74,0x61,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x49,0x6E,0x73,0x65
	.DB  0x72,0x74,0x28,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x73,0x65,0x72
	.DB  0x74,0x44,0x61,0x74,0x61,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x28,0x66,0x6C,0x61,0x67
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x69,0x6E,0x73,0x65,0x72,0x74,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x53,0x44,0x5F,0x77
	.DB  0x72,0x69,0x74,0x65,0x44,0x61,0x74,0x61
	.DB  0x28,0x74,0x69,0x6D,0x65,0x73,0x74,0x61
	.DB  0x6D,0x70,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x69,0x6E,0x73,0x65,0x72,0x74
	.DB  0x44,0x61,0x74,0x61,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x77,0x72,0x69,0x74,0x65,0x44,0x61
	.DB  0x74,0x61,0x28,0x63,0x68,0x61,0x6E,0x6E
	.DB  0x65,0x6C,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x69,0x6E,0x73,0x65,0x72,0x74
	.DB  0x44,0x61,0x74,0x61,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x77,0x72,0x69,0x74,0x65,0x44,0x61
	.DB  0x74,0x61,0x28,0x76,0x61,0x6C,0x75,0x65
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x69,0x6E,0x73,0x65,0x72,0x74,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x4C,0x4F,0x47,0x5F
	.DB  0x73,0x65,0x74,0x4C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x28,0x25,0x6C
	.DB  0x64,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x44,0x61,0x74
	.DB  0x61,0x3E,0x20,0x4C,0x4F,0x47,0x5F,0x67
	.DB  0x65,0x74,0x4C,0x61,0x73,0x74,0x49,0x6E
	.DB  0x73,0x65,0x72,0x74,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x3E,0x20,0x4C
	.DB  0x4F,0x47,0x5F,0x67,0x65,0x74,0x4C,0x61
	.DB  0x73,0x74,0x53,0x65,0x6E,0x64,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x72
	.DB  0x65,0x61,0x64,0x45,0x76,0x65,0x6E,0x74
	.DB  0x3E,0x20,0x6C,0x61,0x73,0x74,0x53,0x65
	.DB  0x6E,0x64,0x2F,0x6C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x20,0x20,0x2D
	.DB  0x2D,0x3E,0x20,0x25,0x6C,0x64,0x2F,0x25
	.DB  0x6C,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x4C,0x6F,0x67,0x20
	.DB  0x65,0x6D,0x70,0x74,0x79,0x2E,0x2E,0x21
	.DB  0x21,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x43,0x6C,0x65,0x61,0x72
	.DB  0x4C,0x6F,0x67,0x46,0x69,0x6C,0x65,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x28
	.DB  0x25,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x28
	.DB  0x66,0x6C,0x61,0x67,0x29,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x44,0x61,0x74,0x61,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x72,0x65,0x61,0x64,0x44,0x61,0x74
	.DB  0x61,0x28,0x74,0x69,0x6D,0x65,0x73,0x74
	.DB  0x61,0x6D,0x70,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x3E,0x20,0x53,0x44,0x5F
	.DB  0x72,0x65,0x61,0x64,0x44,0x61,0x74,0x61
	.DB  0x28,0x63,0x68,0x61,0x6E,0x6E,0x65,0x6C
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x72,0x65,0x61,0x64,0x44,0x61,0x74,0x61
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x72,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x28,0x76,0x61
	.DB  0x6C,0x75,0x65,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x73,0x65,0x72
	.DB  0x74,0x45,0x76,0x65,0x6E,0x74,0x3E,0x20
	.DB  0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74,0x4C
	.DB  0x61,0x73,0x74,0x49,0x6E,0x73,0x65,0x72
	.DB  0x74,0x28,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x69,0x6E,0x73,0x65,0x72,0x74
	.DB  0x45,0x76,0x65,0x6E,0x74,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x28,0x66,0x6C,0x61,0x67
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x69,0x6E,0x73,0x65,0x72,0x74,0x45,0x76
	.DB  0x65,0x6E,0x74,0x3E,0x20,0x53,0x44,0x5F
	.DB  0x77,0x72,0x69,0x74,0x65,0x44,0x61,0x74
	.DB  0x61,0x28,0x74,0x69,0x6D,0x65,0x73,0x74
	.DB  0x61,0x6D,0x70,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x73,0x65,0x72
	.DB  0x74,0x45,0x76,0x65,0x6E,0x74,0x3E,0x20
	.DB  0x53,0x44,0x5F,0x77,0x72,0x69,0x74,0x65
	.DB  0x44,0x61,0x74,0x61,0x28,0x69,0x64,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x69
	.DB  0x6E,0x73,0x65,0x72,0x74,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x53,0x44,0x5F,0x77
	.DB  0x72,0x69,0x74,0x65,0x44,0x61,0x74,0x61
	.DB  0x28,0x73,0x74,0x61,0x74,0x75,0x73,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x69
	.DB  0x6E,0x73,0x65,0x72,0x74,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x4C,0x4F,0x47,0x5F
	.DB  0x73,0x65,0x74,0x4C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x28,0x25,0x6C
	.DB  0x64,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x4C,0x4F,0x47,0x5F
	.DB  0x67,0x65,0x74,0x4C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x28,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x72,0x65
	.DB  0x61,0x64,0x45,0x76,0x65,0x6E,0x74,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x53,0x65,0x6E,0x64
	.DB  0x28,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x4C,0x6F,0x67,0x20
	.DB  0x65,0x6D,0x70,0x74,0x79,0x2E,0x2E,0x21
	.DB  0x21,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x28
	.DB  0x66,0x6C,0x61,0x67,0x29,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x45,0x76,0x65,0x6E,0x74,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x28,0x74,0x69,0x6D,0x65,0x73
	.DB  0x74,0x61,0x6D,0x70,0x29,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x45,0x76,0x65,0x6E,0x74,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x28,0x69,0x64,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61
	.DB  0x64,0x45,0x76,0x65,0x6E,0x74,0x3E,0x20
	.DB  0x53,0x44,0x5F,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x28,0x73,0x74,0x61,0x74
	.DB  0x75,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x67,0x65,0x74,0x4C,0x61,0x73
	.DB  0x74,0x49,0x6E,0x73,0x65,0x72,0x74,0x3E
	.DB  0x20,0x53,0x44,0x5F,0x72,0x65,0x61,0x64
	.DB  0x44,0x61,0x74,0x61,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x49,0x6E,0x73,0x65
	.DB  0x72,0x74,0x3E,0x20,0x67,0x6F,0x74,0x20
	.DB  0x25,0x6C,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x73,0x65,0x74,0x4C,0x61
	.DB  0x73,0x74,0x49,0x6E,0x73,0x65,0x72,0x74
	.DB  0x3E,0x20,0x77,0x72,0x69,0x74,0x69,0x6E
	.DB  0x67,0x20,0x25,0x6C,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x73,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x49,0x6E,0x73,0x65
	.DB  0x72,0x74,0x3E,0x20,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x28
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x67,0x65,0x74,0x4C,0x61,0x73,0x74,0x53
	.DB  0x65,0x6E,0x64,0x3E,0x20,0x53,0x44,0x5F
	.DB  0x72,0x65,0x61,0x64,0x44,0x61,0x74,0x61
	.DB  0x28,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x67,0x65,0x74,0x4C,0x61,0x73,0x74
	.DB  0x53,0x65,0x6E,0x64,0x3E,0x20,0x67,0x6F
	.DB  0x74,0x20,0x25,0x6C,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x73,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x53,0x65,0x6E,0x64
	.DB  0x3E,0x20,0x77,0x72,0x69,0x74,0x69,0x6E
	.DB  0x67,0x20,0x25,0x6C,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x73,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x53,0x65,0x6E,0x64
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x72,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x28,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x28
	.DB  0x25,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x25,0x73
	.DB  0x20,0x61,0x6C,0x72,0x65,0x61,0x64,0x79
	.DB  0x20,0x65,0x78,0x69,0x73,0x74,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x25,0x73,0x20,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65,0x61
	.DB  0x74,0x65,0x46,0x69,0x6C,0x65,0x3E,0x20
	.DB  0x25,0x73,0x20,0x63,0x6F,0x6E,0x74,0x61
	.DB  0x69,0x6E,0x65,0x64,0x20,0x6E,0x6F,0x20
	.DB  0x69,0x6E,0x69,0x74,0x69,0x61,0x6C,0x20
	.DB  0x64,0x61,0x74,0x61,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65,0x61
	.DB  0x74,0x65,0x46,0x69,0x6C,0x65,0x3E,0x20
	.DB  0x53,0x44,0x5F,0x6F,0x70,0x65,0x6E,0x46
	.DB  0x69,0x6C,0x65,0x28,0x25,0x73,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x77,0x72,0x69,0x74,0x69,0x6E
	.DB  0x67,0x20,0x69,0x6E,0x69,0x74,0x69,0x61
	.DB  0x6C,0x20,0x64,0x61,0x74,0x61,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x77,0x72,0x69
	.DB  0x74,0x65,0x44,0x61,0x74,0x61,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0x20
	.DB  0x57,0x72,0x69,0x74,0x69,0x6E,0x67,0x2E
	.DB  0x2E,0x20,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x63,0x6C,0x6F,0x73,0x65,0x46,0x69
	.DB  0x6C,0x65,0x28,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x69,0x74,0x3E
	.DB  0x20,0x49,0x6E,0x69,0x74,0x69,0x61,0x6C
	.DB  0x20,0x6C,0x6F,0x67,0x20,0x66,0x69,0x6C
	.DB  0x65,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x69,0x6E,0x69,0x74,0x3E,0x20,0x4C
	.DB  0x4F,0x47,0x5F,0x63,0x72,0x65,0x61,0x74
	.DB  0x65,0x46,0x69,0x6C,0x65,0x28,0x25,0x73
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0
_0x280000:
	.DB  0xD,0xA,0xD,0xA,0x3C,0x61,0x64,0x64
	.DB  0x44,0x61,0x74,0x61,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x3E,0x20,0x57,0x41
	.DB  0x52,0x4E,0x49,0x4E,0x47,0x20,0x3A,0x20
	.DB  0x64,0x61,0x74,0x61,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x20,0x46,0x55,0x4C
	.DB  0x4C,0xD,0xA,0xD,0xA,0x0,0xD,0xA
	.DB  0x3C,0x61,0x64,0x64,0x44,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x3E,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x41,0x64,0x64,0x65
	.DB  0x64,0x20,0x28,0x25,0x30,0x32,0x58,0x29
	.DB  0x20,0x74,0x6F,0x20,0x64,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x5B,0x25,0x64,0x5D,0x20,0x43,0x6F,0x75
	.DB  0x6E,0x74,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x3C,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x4C,0x6F,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x3E,0x20,0x57,0x41,0x52
	.DB  0x4E,0x3A,0x20,0x64,0x61,0x74,0x61,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x20
	.DB  0x65,0x6D,0x70,0x74,0x79,0x21,0x21,0xD
	.DB  0xA,0x0,0x3C,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x4C,0x6F,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x3E,0x20,0x57,0x41,0x52
	.DB  0x4E,0x3A,0x20,0x6E,0x6F,0x74,0x20,0x66
	.DB  0x6F,0x75,0x6E,0x64,0x20,0x69,0x64,0x5B
	.DB  0x30,0x78,0x25,0x30,0x32,0x58,0x5D,0x20
	.DB  0x69,0x6E,0x20,0x64,0x61,0x74,0x61,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0xD
	.DB  0xA,0x0,0xD,0xA,0x3C,0x72,0x65,0x6D
	.DB  0x6F,0x76,0x65,0x44,0x61,0x74,0x61,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x3E
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x52,0x65,0x6D,0x6F,0x76,0x65,0x64,0x20
	.DB  0x28,0x25,0x30,0x32,0x58,0x29,0x20,0x66
	.DB  0x72,0x6F,0x6D,0x20,0x64,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x5B,0x25,0x64,0x5D,0xD,0xA,0x0,0x3C
	.DB  0x72,0x65,0x6D,0x6F,0x76,0x65,0x44,0x61
	.DB  0x74,0x61,0x4C,0x6F,0x67,0x51,0x75,0x65
	.DB  0x75,0x65,0x3E,0x20,0x57,0x41,0x52,0x4E
	.DB  0x3A,0x20,0x6E,0x6F,0x74,0x20,0x66,0x6F
	.DB  0x75,0x6E,0x64,0x20,0x69,0x64,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x58,0x5D,0x20,0x69
	.DB  0x6E,0x20,0x64,0x61,0x74,0x61,0x4C,0x6F
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0xD,0xA
	.DB  0x0,0xD,0xA,0xD,0xA,0x3C,0x61,0x64
	.DB  0x64,0x45,0x76,0x65,0x6E,0x74,0x4C,0x6F
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0x3E,0x20
	.DB  0x57,0x41,0x52,0x4E,0x49,0x4E,0x47,0x20
	.DB  0x3A,0x20,0x65,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x20
	.DB  0x46,0x55,0x4C,0x4C,0xD,0xA,0xD,0xA
	.DB  0x0,0xD,0xA,0x3C,0x61,0x64,0x64,0x45
	.DB  0x76,0x65,0x6E,0x74,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x3E,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x41,0x64
	.DB  0x64,0x65,0x64,0x20,0x28,0x25,0x30,0x32
	.DB  0x58,0x29,0x20,0x74,0x6F,0x20,0x65,0x76
	.DB  0x65,0x6E,0x74,0x4C,0x6F,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x5B,0x25,0x64,0x5D,0x20
	.DB  0x43,0x6F,0x75,0x6E,0x74,0x20,0x3D,0x20
	.DB  0x25,0x64,0xD,0xA,0x0,0x3C,0x72,0x65
	.DB  0x61,0x64,0x45,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x3E
	.DB  0x20,0x57,0x41,0x52,0x4E,0x3A,0x20,0x65
	.DB  0x76,0x65,0x6E,0x74,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x20,0x65,0x6D,0x70
	.DB  0x74,0x79,0x21,0x21,0xD,0xA,0x0,0x3C
	.DB  0x72,0x65,0x61,0x64,0x45,0x76,0x65,0x6E
	.DB  0x74,0x4C,0x6F,0x67,0x51,0x75,0x65,0x75
	.DB  0x65,0x3E,0x20,0x57,0x41,0x52,0x4E,0x3A
	.DB  0x20,0x6E,0x6F,0x74,0x20,0x66,0x6F,0x75
	.DB  0x6E,0x64,0x20,0x69,0x64,0x5B,0x30,0x78
	.DB  0x25,0x30,0x32,0x58,0x5D,0x20,0x69,0x6E
	.DB  0x20,0x65,0x76,0x65,0x6E,0x74,0x4C,0x6F
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0xD,0xA
	.DB  0x0,0xD,0xA,0x3C,0x72,0x65,0x6D,0x6F
	.DB  0x76,0x65,0x45,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x3E
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x52,0x65
	.DB  0x6D,0x6F,0x76,0x65,0x64,0x20,0x28,0x25
	.DB  0x30,0x32,0x58,0x29,0x20,0x66,0x72,0x6F
	.DB  0x6D,0x20,0x65,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x5B
	.DB  0x25,0x64,0x5D,0xD,0xA,0x0,0x3C,0x72
	.DB  0x65,0x6D,0x6F,0x76,0x65,0x45,0x76,0x65
	.DB  0x6E,0x74,0x4C,0x6F,0x67,0x51,0x75,0x65
	.DB  0x75,0x65,0x3E,0x20,0x57,0x41,0x52,0x4E
	.DB  0x3A,0x20,0x6E,0x6F,0x74,0x20,0x66,0x6F
	.DB  0x75,0x6E,0x64,0x20,0x69,0x64,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x58,0x5D,0x20,0x69
	.DB  0x6E,0x20,0x65,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0xD
	.DB  0xA,0x0
_0x2A0003:
	.DB  0x9
_0x2A0000:
	.DB  0xD,0xA,0x3C,0x44,0x65,0x62,0x75,0x67
	.DB  0x3E,0x47,0x65,0x74,0x43,0x75,0x72,0x53
	.DB  0x65,0x6E,0x73,0x6F,0x72,0x3A,0x20,0xD
	.DB  0xA,0x0,0x43,0x68,0x61,0x6E,0x6E,0x65
	.DB  0x6C,0x20,0x49,0x44,0x3A,0x25,0x64,0x20
	.DB  0xD,0xA,0x0,0x63,0x75,0x72,0x72,0x65
	.DB  0x6E,0x74,0x20,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x20,0x63,0x68,0x5B,0x25,0x64,0x5D
	.DB  0x20,0x2C,0x20,0x76,0x61,0x6C,0x75,0x65
	.DB  0x3A,0x25,0x30,0x2E,0x32,0x66,0xD,0xA
	.DB  0x0,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C
	.DB  0x20,0x49,0x44,0x20,0x69,0x73,0x20,0x69
	.DB  0x6E,0x20,0x72,0x61,0x6E,0x67,0x65,0x2E
	.DB  0xD,0xA,0x0,0xD,0xA,0x3C,0x44,0x65
	.DB  0x62,0x75,0x67,0x3E,0x47,0x65,0x74,0x43
	.DB  0x61,0x6C,0x3A,0x20,0xD,0xA,0x0,0x73
	.DB  0x74,0x64,0x52,0x65,0x66,0x5B,0x25,0x64
	.DB  0x5D,0x20,0x3A,0x20,0x25,0x30,0x2E,0x32
	.DB  0x66,0x20,0x2C,0x20,0x0,0x73,0x65,0x6E
	.DB  0x73,0x6F,0x72,0x52,0x65,0x66,0x5B,0x25
	.DB  0x64,0x5D,0x20,0x3A,0x20,0x25,0x30,0x2E
	.DB  0x32,0x66,0xD,0xA,0x0,0x43,0x61,0x6C
	.DB  0x54,0x79,0x70,0x65,0x20,0x3A,0x20,0x43
	.DB  0x41,0x4C,0x5F,0x44,0x45,0x46,0x41,0x55
	.DB  0x4C,0x54,0x0,0x43,0x61,0x6C,0x54,0x79
	.DB  0x70,0x65,0x20,0x3A,0x20,0x43,0x41,0x4C
	.DB  0x5F,0x45,0x58,0x54,0x4F,0x46,0x46,0x53
	.DB  0x45,0x54,0x0,0x43,0x61,0x6C,0x54,0x79
	.DB  0x70,0x65,0x20,0x3A,0x20,0x43,0x41,0x4C
	.DB  0x5F,0x45,0x58,0x54,0x4C,0x49,0x4E,0x45
	.DB  0x41,0x52,0x0,0x43,0x61,0x6C,0x54,0x79
	.DB  0x70,0x65,0x20,0x3A,0x20,0x43,0x41,0x4C
	.DB  0x5F,0x45,0x58,0x54,0x50,0x4F,0x4C,0x59
	.DB  0x4E,0x4F,0x4D,0x49,0x41,0x4C,0x0,0xD
	.DB  0xA,0x3C,0x44,0x65,0x62,0x75,0x67,0x3E
	.DB  0x53,0x65,0x74,0x43,0x61,0x6C,0x3A,0x20
	.DB  0xD,0xA,0x0,0x50,0x6F,0x69,0x6E,0x74
	.DB  0x20,0x49,0x44,0x3A,0x25,0x64,0x20,0xD
	.DB  0xA,0x0,0x70,0x6F,0x69,0x6E,0x74,0x56
	.DB  0x61,0x6C,0x75,0x65,0x28,0x6D,0x65,0x74
	.DB  0x65,0x72,0x52,0x65,0x66,0x29,0x20,0x3A
	.DB  0x25,0x30,0x2E,0x32,0x66,0x20,0xD,0xA
	.DB  0x0,0xD,0xA,0x3C,0x44,0x65,0x62,0x75
	.DB  0x67,0x3E,0x43,0x6F,0x6E,0x66,0x69,0x72
	.DB  0x6D,0x43,0x61,0x6C,0x3A,0x20,0xD,0xA
	.DB  0x0,0x67,0x65,0x74,0x20,0x79,0x65,0x61
	.DB  0x72,0x20,0x3D,0x20,0x25,0x64,0xD,0xA
	.DB  0x0,0x67,0x65,0x74,0x20,0x6D,0x6F,0x6E
	.DB  0x74,0x68,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x67,0x65,0x74,0x20,0x64,0x61
	.DB  0x74,0x65,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x67,0x65,0x74,0x20,0x68,0x6F
	.DB  0x75,0x72,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x67,0x65,0x74,0x20,0x6D,0x69
	.DB  0x6E,0x20,0x3D,0x20,0x25,0x64,0xD,0xA
	.DB  0x0,0x67,0x65,0x74,0x20,0x73,0x65,0x63
	.DB  0x20,0x3D,0x20,0x25,0x64,0xD,0xA,0x0
	.DB  0x67,0x65,0x74,0x20,0x74,0x69,0x6D,0x65
	.DB  0x7A,0x6F,0x6E,0x65,0x20,0x3D,0x20,0x25
	.DB  0x2B,0x64,0xD,0xA,0x0,0xD,0xA,0x3C
	.DB  0x44,0x45,0x42,0x55,0x47,0x3E,0x20,0x41
	.DB  0x6C,0x61,0x72,0x6D,0x20,0x53,0x74,0x61
	.DB  0x74,0x75,0x73,0x20,0x52,0x65,0x73,0x65
	.DB  0x74,0x2E,0x2E,0x21,0x21,0xD,0xA,0x0
	.DB  0x3C,0x44,0x45,0x42,0x55,0x47,0x5F,0x43
	.DB  0x6C,0x65,0x61,0x72,0x4C,0x6F,0x67,0x46
	.DB  0x69,0x6C,0x65,0x3E,0x20,0x52,0x65,0x2D
	.DB  0x69,0x6E,0x69,0x74,0x69,0x61,0x74,0x65
	.DB  0x20,0x6C,0x6F,0x67,0x20,0x66,0x69,0x6C
	.DB  0x65,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x43,0x6C,0x65,0x61,0x72
	.DB  0x4C,0x6F,0x67,0x46,0x69,0x6C,0x65,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x28
	.DB  0x25,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x44,0x45
	.DB  0x42,0x55,0x47,0x5F,0x73,0x65,0x74,0x52
	.DB  0x65,0x61,0x6C,0x56,0x72,0x65,0x66,0x3E
	.DB  0x20,0x67,0x65,0x74,0x20,0x73,0x65,0x74
	.DB  0x20,0x56,0x72,0x65,0x66,0x3C,0x73,0x74
	.DB  0x72,0x69,0x6E,0x67,0x3E,0x20,0x25,0x73
	.DB  0xD,0xA,0x0,0x3C,0x44,0x45,0x42,0x55
	.DB  0x47,0x5F,0x73,0x65,0x74,0x52,0x65,0x61
	.DB  0x6C,0x56,0x72,0x65,0x66,0x3E,0x20,0x41
	.DB  0x66,0x74,0x65,0x72,0x20,0x63,0x6F,0x6E
	.DB  0x76,0x65,0x72,0x74,0x20,0x3D,0x20,0x25
	.DB  0x66,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x53,0x65,0x6C,0x65,0x63,0x74,0x3E
	.DB  0x20,0x54,0x68,0x69,0x73,0x20,0x54,0x45
	.DB  0x4D,0x50,0x5F,0x53,0x45,0x4C,0x20,0x6E
	.DB  0x6F,0x74,0x20,0x73,0x75,0x70,0x70,0x6F
	.DB  0x72,0x74,0xD,0xA,0xD,0xA,0x0,0x3C
	.DB  0x44,0x45,0x42,0x55,0x47,0x5F,0x73,0x65
	.DB  0x6E,0x73,0x6F,0x72,0x53,0x65,0x6C,0x65
	.DB  0x63,0x74,0x3E,0x20,0x44,0x65,0x73,0x65
	.DB  0x6C,0x65,0x63,0x74,0x20,0x73,0x65,0x6E
	.DB  0x73,0x6F,0x72,0xD,0xA,0xD,0xA,0x0
	.DB  0x3C,0x44,0x45,0x42,0x55,0x47,0x5F,0x73
	.DB  0x65,0x6E,0x73,0x6F,0x72,0x53,0x65,0x6C
	.DB  0x65,0x63,0x74,0x3E,0x20,0x53,0x65,0x6C
	.DB  0x65,0x63,0x74,0x65,0x64,0x20,0x73,0x65
	.DB  0x6E,0x73,0x6F,0x72,0x20,0x25,0x64,0xD
	.DB  0xA,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x53,0x65,0x6C,0x65,0x63,0x74,0x3E
	.DB  0x20,0x45,0x52,0x52,0x4F,0x52,0x20,0x3A
	.DB  0x20,0x53,0x65,0x6C,0x65,0x63,0x74,0x69
	.DB  0x6E,0x67,0x20,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x20,0x5B,0x25,0x63,0x5D,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x58,0x5D,0xD,0xA
	.DB  0xD,0xA,0x0,0x3C,0x44,0x45,0x42,0x55
	.DB  0x47,0x5F,0x73,0x65,0x74,0x53,0x65,0x72
	.DB  0x69,0x61,0x6C,0x4E,0x75,0x6D,0x62,0x65
	.DB  0x72,0x3E,0x20,0x69,0x6E,0x76,0x61,0x6C
	.DB  0x69,0x64,0x20,0x73,0x65,0x74,0x74,0x69
	.DB  0x6E,0x67,0x20,0x73,0x74,0x72,0x69,0x6E
	.DB  0x67,0x20,0x28,0x25,0x63,0x29,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x5D,0xD,0xA,0x0
	.DB  0x3C,0x44,0x45,0x42,0x55,0x47,0x5F,0x73
	.DB  0x65,0x74,0x53,0x65,0x72,0x69,0x61,0x6C
	.DB  0x4E,0x75,0x6D,0x62,0x65,0x72,0x3E,0x20
	.DB  0x52,0x65,0x70,0x6C,0x61,0x63,0x69,0x6E
	.DB  0x67,0x20,0x44,0x45,0x56,0x49,0x43,0x45
	.DB  0x5F,0x53,0x45,0x52,0x49,0x41,0x4C,0x2E
	.DB  0x2E,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x74,0x53,0x65
	.DB  0x72,0x69,0x61,0x6C,0x4E,0x75,0x6D,0x62
	.DB  0x65,0x72,0x3E,0x20,0x53,0x65,0x74,0x20
	.DB  0x53,0x74,0x72,0x69,0x6E,0x67,0x20,0x2D
	.DB  0x2D,0x3E,0x20,0x0,0x5B,0x25,0x63,0x0
	.DB  0x25,0x63,0x5D,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x74,0x53,0x65
	.DB  0x72,0x69,0x61,0x6C,0x4E,0x75,0x6D,0x62
	.DB  0x65,0x72,0x3E,0x20,0x53,0x75,0x63,0x63
	.DB  0x65,0x73,0x73,0x21,0x21,0x20,0x44,0x45
	.DB  0x56,0x5F,0x53,0x45,0x52,0x49,0x41,0x4C
	.DB  0x20,0x3D,0x3D,0x3E,0x20,0x0,0x5B,0x25
	.DB  0x30,0x32,0x58,0x5D,0x0,0x3C,0x44,0x45
	.DB  0x42,0x55,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x53,0x65,0x72,0x69,0x61,0x6C,0x4E,0x75
	.DB  0x6D,0x62,0x65,0x72,0x3E,0x20,0x44,0x45
	.DB  0x56,0x5F,0x53,0x45,0x52,0x49,0x41,0x4C
	.DB  0x20,0x3D,0x3D,0x3E,0x20,0x0,0x47,0x65
	.DB  0x74,0x20,0x44,0x65,0x62,0x75,0x67,0x20
	.DB  0x52,0x65,0x71,0x2E,0x3A,0x0,0x25,0x30
	.DB  0x35,0x64,0x20,0x20,0x20,0x0,0x25,0x30
	.DB  0x32,0x78,0x20,0x0,0x2E,0x0
_0x2C0003:
	.DB  0x3
_0x2E0007:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0
_0x300022:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
_0x300000:
	.DB  0x3C,0x43,0x61,0x6C,0x20,0x53,0x74,0x64
	.DB  0x20,0x72,0x65,0x66,0x3E,0x63,0x68,0x5B
	.DB  0x25,0x64,0x5D,0x2C,0x66,0x6F,0x72,0x6D
	.DB  0x61,0x74,0x54,0x79,0x70,0x65,0x3A,0x25
	.DB  0x30,0x2E,0x32,0x66,0xD,0xA,0x0,0x73
	.DB  0x74,0x64,0x52,0x65,0x66,0x3A,0x25,0x30
	.DB  0x2E,0x32,0x66,0x2C,0x73,0x65,0x6E,0x73
	.DB  0x6F,0x72,0x52,0x65,0x66,0x3A,0x25,0x30
	.DB  0x2E,0x32,0x66,0xD,0xA,0x0,0x3C,0x63
	.DB  0x61,0x6C,0x69,0x62,0x72,0x61,0x74,0x69
	.DB  0x6F,0x6E,0x3E,0x43,0x61,0x6C,0x20,0x70
	.DB  0x72,0x6F,0x70,0x65,0x72,0x74,0x69,0x65
	.DB  0x73,0x3A,0x73,0x65,0x74,0x20,0x63,0x61
	.DB  0x6E,0x20,0x6E,0x6F,0x74,0x20,0x67,0x65
	.DB  0x74,0x20,0x76,0x61,0x6C,0x75,0x65,0x2E
	.DB  0x0,0x3C,0x63,0x61,0x6C,0x69,0x62,0x72
	.DB  0x61,0x74,0x69,0x6F,0x6E,0x3E,0x43,0x61
	.DB  0x6C,0x20,0x70,0x72,0x6F,0x70,0x65,0x72
	.DB  0x74,0x69,0x65,0x73,0x3A,0x67,0x65,0x74
	.DB  0x20,0x63,0x61,0x6E,0x20,0x6E,0x6F,0x74
	.DB  0x20,0x73,0x65,0x74,0x20,0x76,0x61,0x6C
	.DB  0x75,0x65,0x2E,0x0,0x3C,0x43,0x61,0x6C
	.DB  0x20,0x53,0x74,0x64,0x20,0x72,0x65,0x66
	.DB  0x3E,0x63,0x68,0x5B,0x25,0x64,0x5D,0x2C
	.DB  0x66,0x6F,0x72,0x6D,0x61,0x74,0x54,0x79
	.DB  0x70,0x65,0x3A,0x25,0x64,0xD,0xA,0x0
_0x320003:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0
_0x320000:
	.DB  0x5B,0x69,0x50,0x54,0x43,0x70,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x53,0x74,0x61,0x72
	.DB  0x74,0x20,0x44,0x65,0x6C,0x69,0x6D,0x69
	.DB  0x74,0x65,0x72,0x20,0x4F,0x4B,0x28,0x25
	.DB  0x30,0x32,0x78,0x29,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x50,0x54,0x43,0x70,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x4C,0x65,0x6E,0x67
	.DB  0x74,0x68,0x20,0x28,0x25,0x64,0x29,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x50,0x54,0x43
	.DB  0x70,0x61,0x72,0x73,0x65,0x72,0x5D,0x43
	.DB  0x68,0x65,0x63,0x6B,0x20,0x73,0x75,0x6D
	.DB  0x20,0x28,0x25,0x30,0x32,0x78,0x29,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x50,0x54,0x43
	.DB  0x70,0x61,0x72,0x73,0x65,0x72,0x5D,0x43
	.DB  0x68,0x65,0x63,0x6B,0x20,0x73,0x75,0x6D
	.DB  0x20,0x63,0x6F,0x72,0x72,0x65,0x63,0x74
	.DB  0x28,0x25,0x64,0x29,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x50,0x54,0x43,0x70,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x43,0x68,0x65,0x63
	.DB  0x6B,0x20,0x73,0x75,0x6D,0x20,0x69,0x6E
	.DB  0x63,0x6F,0x72,0x72,0x65,0x63,0x74,0x28
	.DB  0x25,0x64,0x29,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x50,0x54,0x43,0x43,0x68,0x65,0x63
	.DB  0x6B,0x48,0x6F,0x73,0x74,0x52,0x65,0x71
	.DB  0x5D,0x4D,0x54,0x49,0x28,0x25,0x30,0x32
	.DB  0x78,0x25,0x30,0x32,0x78,0x29,0x0,0x5B
	.DB  0x69,0x50,0x54,0x43,0x43,0x68,0x65,0x63
	.DB  0x6B,0x48,0x6F,0x73,0x74,0x52,0x65,0x71
	.DB  0x5D,0x48,0x6F,0x73,0x74,0x20,0x52,0x65
	.DB  0x71,0x75,0x65,0x73,0x74,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x50,0x54,0x43,0x43,0x68
	.DB  0x65,0x63,0x6B,0x48,0x6F,0x73,0x74,0x52
	.DB  0x65,0x71,0x5D,0x48,0x6F,0x73,0x74,0x20
	.DB  0x69,0x73,0x20,0x6E,0x6F,0x74,0x20,0x52
	.DB  0x65,0x71,0x75,0x65,0x73,0x74,0x2E,0xD
	.DB  0xA,0x0
_0x340003:
	.DB  0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x2,0x0,0x2A,0x6,0x11,0x4
	.DB  0xCD,0xCC,0xC7,0x42,0x2A,0x6,0x12,0x4
	.DB  0x0,0x0,0x0,0x0,0x2A,0x6,0x13,0x4
	.DB  0x0,0x0,0xE0,0x41,0x5A,0x7,0x31,0xC
	.DB  0xD,0x0,0x0,0x0,0x0,0x5A,0x7,0x32
	.DB  0xD,0xD,0x1,0xF,0xF0,0x3B,0x5A,0x7
	.DB  0x41,0xA,0x9,0x0,0xF,0xE0,0x41,0x5A
	.DB  0x7,0x42,0xA,0xB,0x0,0xF,0x8,0x42
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
_0x340028:
	.DB  0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1
	.DB  0x8,0x0
_0x34002A:
	.DB  0x4B,0x2,0x10,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x8,0x0
_0x340000:
	.DB  0x5B,0x6D,0x61,0x6E,0x61,0x67,0x65,0x72
	.DB  0x54,0x61,0x73,0x6B,0x5D,0x54,0x61,0x73
	.DB  0x6B,0x20,0x52,0x75,0x6E,0x6E,0x69,0x6E
	.DB  0x67,0x2E,0x2E,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x6D,0x61,0x6E,0x61,0x67,0x65,0x72,0x54
	.DB  0x61,0x73,0x6B,0x5D,0x64,0x61,0x74,0x61
	.DB  0x20,0x61,0x6E,0x64,0x20,0x73,0x74,0x73
	.DB  0x74,0x75,0x73,0x20,0x63,0x61,0x6E,0x27
	.DB  0x74,0x20,0x61,0x6C,0x6C,0x6F,0x63,0x61
	.DB  0x74,0x65,0x20,0x6D,0x65,0x6D,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x6D,0x61,0x6E,0x61,0x67
	.DB  0x65,0x72,0x54,0x61,0x73,0x6B,0x5D,0x52
	.DB  0x65,0x63,0x6F,0x72,0x64,0x20,0x49,0x44
	.DB  0x28,0x25,0x30,0x34,0x6C,0x64,0x29,0xD
	.DB  0xA,0x0,0x5B,0x6D,0x61,0x6E,0x61,0x67
	.DB  0x65,0x72,0x54,0x61,0x73,0x6B,0x5D,0x50
	.DB  0x72,0x69,0x6E,0x74,0x2E,0x5B,0xD,0xA
	.DB  0x0,0x5D,0xD,0xA,0x0,0x5B,0x69,0x48
	.DB  0x6F,0x73,0x74,0x52,0x65,0x71,0x50,0x72
	.DB  0x6F,0x63,0x65,0x73,0x73,0x5D,0x54,0x58
	.DB  0x20,0x50,0x72,0x69,0x6E,0x74,0x20,0x31
	.DB  0x2E,0x5B,0xD,0xA,0x0,0x5B,0x69,0x48
	.DB  0x6F,0x73,0x74,0x52,0x65,0x71,0x50,0x72
	.DB  0x6F,0x63,0x65,0x73,0x73,0x5D,0x52,0x58
	.DB  0x20,0x50,0x72,0x69,0x6E,0x74,0x20,0x32
	.DB  0x2E,0x5B,0xD,0xA,0x0,0x5B,0x69,0x48
	.DB  0x6F,0x73,0x74,0x52,0x65,0x71,0x50,0x72
	.DB  0x6F,0x63,0x65,0x73,0x73,0x5D,0x50,0x72
	.DB  0x69,0x6E,0x74,0x2E,0x5B,0xD,0xA,0x0
	.DB  0x5B,0x69,0x54,0x65,0x72,0x41,0x63,0x6B
	.DB  0x42,0x79,0x54,0x61,0x67,0x42,0x5D,0x4E
	.DB  0x6F,0x74,0x20,0x61,0x6C,0x6C,0x6F,0x63
	.DB  0x61,0x74,0x65,0x20,0x6D,0x65,0x6D,0x6F
	.DB  0x72,0x79,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x54,0x61,0x67,0x50,0x61,0x72,0x73,0x65
	.DB  0x72,0x5D,0x48,0x6F,0x73,0x74,0x20,0x72
	.DB  0x65,0x73,0x70,0x6F,0x6E,0x73,0x65,0xD
	.DB  0xA,0x0,0x5B,0x69,0x54,0x61,0x67,0x50
	.DB  0x61,0x72,0x73,0x65,0x72,0x5D,0x4C,0x65
	.DB  0x6E,0x28,0x25,0x64,0x29,0xD,0xA,0x0
	.DB  0x5B,0x69,0x54,0x61,0x67,0x50,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x54,0x61,0x67,0x3A
	.DB  0x25,0x30,0x32,0x78,0x28,0x25,0x64,0x29
	.DB  0xD,0xA,0x0,0x5B,0x69,0x54,0x61,0x67
	.DB  0x50,0x61,0x72,0x73,0x65,0x72,0x5D,0x48
	.DB  0x6F,0x73,0x74,0x20,0x6E,0x65,0x65,0x64
	.DB  0x20,0x74,0x6F,0x20,0x63,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x28,0x50,0x72,0x6F,0x70,0x65
	.DB  0x72,0x74,0x69,0x65,0x73,0x29,0xD,0xA
	.DB  0x0,0x5B,0x69,0x54,0x61,0x67,0x50,0x61
	.DB  0x72,0x73,0x65,0x72,0x5D,0x48,0x6F,0x73
	.DB  0x74,0x20,0x6E,0x65,0x65,0x64,0x20,0x74
	.DB  0x6F,0x20,0x63,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x28,0x4F,0x70,0x65,0x72,0x61,0x74,0x69
	.DB  0x6E,0x67,0x29,0xD,0xA,0x0,0x5B,0x69
	.DB  0x54,0x61,0x67,0x50,0x61,0x72,0x73,0x65
	.DB  0x72,0x5D,0x48,0x6F,0x73,0x74,0x20,0x6E
	.DB  0x65,0x65,0x64,0x20,0x74,0x6F,0x20,0x63
	.DB  0x6F,0x6E,0x66,0x69,0x67,0x28,0x42,0x75
	.DB  0x7A,0x7A,0x65,0x72,0x29,0xD,0xA,0x0
	.DB  0x5B,0x69,0x54,0x61,0x67,0x50,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x48,0x6F,0x73,0x74
	.DB  0x20,0x6E,0x65,0x65,0x64,0x20,0x74,0x6F
	.DB  0x20,0x63,0x6F,0x6E,0x66,0x69,0x67,0x28
	.DB  0x45,0x6E,0x76,0x69,0x72,0x6F,0x6E,0x6D
	.DB  0x65,0x6E,0x74,0x20,0x41,0x6C,0x61,0x72
	.DB  0x6D,0x20,0x43,0x6F,0x6E,0x64,0x69,0x74
	.DB  0x69,0x6F,0x6E,0x29,0xD,0xA,0x0,0x5B
	.DB  0x69,0x54,0x61,0x67,0x50,0x61,0x72,0x73
	.DB  0x65,0x72,0x5D,0x48,0x6F,0x73,0x74,0x20
	.DB  0x6E,0x65,0x65,0x64,0x20,0x74,0x6F,0x20
	.DB  0x63,0x6F,0x6E,0x66,0x69,0x67,0x28,0x44
	.DB  0x69,0x67,0x69,0x74,0x61,0x6C,0x20,0x49
	.DB  0x6E,0x70,0x75,0x74,0x29,0xD,0xA,0x0
	.DB  0x5B,0x69,0x54,0x61,0x67,0x50,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x48,0x6F,0x73,0x74
	.DB  0x20,0x6E,0x65,0x65,0x64,0x20,0x74,0x6F
	.DB  0x20,0x63,0x6F,0x6E,0x66,0x69,0x67,0x28
	.DB  0x44,0x69,0x67,0x69,0x74,0x61,0x6C,0x20
	.DB  0x4F,0x75,0x74,0x70,0x75,0x74,0x29,0xD
	.DB  0xA,0x0,0x5B,0x69,0x54,0x61,0x67,0x50
	.DB  0x61,0x72,0x73,0x65,0x72,0x5D,0x48,0x6F
	.DB  0x73,0x74,0x20,0x6E,0x65,0x65,0x64,0x20
	.DB  0x74,0x6F,0x20,0x63,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x28,0x41,0x6E,0x61,0x6C,0x6F,0x67
	.DB  0x20,0x49,0x6E,0x70,0x75,0x74,0x29,0xD
	.DB  0xA,0x0,0x5B,0x69,0x54,0x61,0x67,0x50
	.DB  0x61,0x72,0x73,0x65,0x72,0x5D,0x48,0x6F
	.DB  0x73,0x74,0x20,0x6E,0x65,0x65,0x64,0x20
	.DB  0x74,0x6F,0x20,0x63,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x28,0x41,0x6E,0x61,0x6C,0x6F,0x67
	.DB  0x20,0x4F,0x75,0x74,0x70,0x75,0x74,0x29
	.DB  0xD,0xA,0x0,0x5B,0x69,0x54,0x61,0x67
	.DB  0x50,0x61,0x72,0x73,0x65,0x72,0x5D,0x48
	.DB  0x6F,0x73,0x74,0x20,0x72,0x65,0x73,0x70
	.DB  0x6F,0x6E,0x73,0x65,0x20,0x75,0x6E,0x6B
	.DB  0x6E,0x6F,0x77,0x28,0x25,0x30,0x32,0x78
	.DB  0x29,0x2E,0xD,0xA,0x0,0x5B,0x69,0x4D
	.DB  0x61,0x6E,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x41,0x64,0x64,0x49,0x74,0x65,0x6D,0x5D
	.DB  0x41,0x64,0x64,0x20,0x62,0x79,0x20,0x46
	.DB  0x49,0x44,0x28,0x25,0x30,0x32,0x78,0x25
	.DB  0x30,0x32,0x78,0x29,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x4D,0x61,0x6E,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x41,0x64,0x64,0x49,0x74
	.DB  0x65,0x6D,0x5D,0x63,0x61,0x6E,0x27,0x74
	.DB  0x20,0x61,0x6C,0x6C,0x6F,0x63,0x61,0x74
	.DB  0x65,0x20,0x6D,0x65,0x6D,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x4D,0x61,0x6E,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x41,0x64,0x64,0x49
	.DB  0x74,0x65,0x6D,0x5D,0x4D,0x61,0x6E,0x67
	.DB  0x51,0x75,0x65,0x75,0x65,0x20,0x46,0x75
	.DB  0x6C,0x6C,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x4D,0x61,0x6E,0x67,0x51,0x75,0x65,0x75
	.DB  0x65,0x44,0x65,0x6C,0x49,0x74,0x65,0x6D
	.DB  0x5D,0x44,0x65,0x6C,0x20,0x62,0x79,0x20
	.DB  0x46,0x49,0x44,0x28,0x25,0x30,0x32,0x78
	.DB  0x25,0x30,0x32,0x78,0x29,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x4D,0x61,0x6E,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x44,0x65,0x6C,0x49
	.DB  0x74,0x65,0x6D,0x5D,0x51,0x75,0x65,0x75
	.DB  0x65,0x20,0x69,0x73,0x20,0x65,0x6D,0x70
	.DB  0x74,0x79,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x4D,0x61,0x6E,0x67,0x51,0x75,0x65,0x75
	.DB  0x65,0x44,0x65,0x6C,0x49,0x74,0x65,0x6D
	.DB  0x5D,0x46,0x49,0x44,0x20,0x69,0x6E,0x76
	.DB  0x61,0x6C,0x69,0x64,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x4D,0x61,0x6E,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x44,0x69,0x73,0x70,0x6C
	.DB  0x61,0x79,0x5D,0x51,0x75,0x65,0x75,0x65
	.DB  0x20,0x25,0x64,0x2E,0x5B,0xD,0xA,0x0
	.DB  0x45,0x6D,0x70,0x74,0x79,0xD,0xA,0x0
	.DB  0x5B,0x69,0x4D,0x61,0x6E,0x67,0x43,0x68
	.DB  0x65,0x63,0x6B,0x52,0x65,0x74,0x72,0x61
	.DB  0x6E,0x73,0x6D,0x69,0x74,0x5D,0x52,0x65
	.DB  0x74,0x72,0x61,0x6E,0x73,0x6D,0x69,0x74
	.DB  0x20,0x72,0x65,0x6D,0x61,0x69,0x6E,0x20
	.DB  0x25,0x64,0x2E,0xD,0xA,0x0,0x54,0x68
	.DB  0x65,0x72,0x65,0x20,0x69,0x73,0x20,0x6E
	.DB  0x6F,0x20,0x46,0x49,0x44,0x28,0x25,0x30
	.DB  0x32,0x78,0x25,0x30,0x32,0x78,0x29,0x20
	.DB  0x69,0x6E,0x20,0x71,0x75,0x65,0x75,0x65
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x70,0x72,0x69
	.DB  0x6E,0x74,0x43,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x5D,0x44,0x61,0x74,0x61,0x3A,0x5B,0xD
	.DB  0xA,0x0,0x25,0x30,0x34,0x64,0x9,0x9
	.DB  0x0,0x25,0x30,0x32,0x78,0x0,0xD,0xA
	.DB  0x5D,0xD,0xA,0x0
_0x360000:
	.DB  0x5B,0x69,0x51,0x75,0x65,0x75,0x65,0x43
	.DB  0x72,0x65,0x61,0x74,0x65,0x5D,0x2C,0x69
	.DB  0x74,0x65,0x6D,0x43,0x6F,0x75,0x6E,0x74
	.DB  0x28,0x25,0x64,0x29,0xD,0xA,0x0,0x5B
	.DB  0x69,0x51,0x75,0x65,0x75,0x65,0x43,0x72
	.DB  0x65,0x61,0x74,0x65,0x5D,0x2C,0x51,0x75
	.DB  0x65,0x75,0x65,0x28,0x45,0x6C,0x65,0x6E
	.DB  0x20,0x73,0x69,0x7A,0x65,0x29,0x20,0x69
	.DB  0x73,0x20,0x6E,0x6F,0x74,0x20,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x64,0x21,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x51,0x75,0x65,0x75
	.DB  0x65,0x43,0x72,0x65,0x61,0x74,0x65,0x5D
	.DB  0x2C,0x51,0x75,0x65,0x75,0x65,0x20,0x69
	.DB  0x73,0x20,0x6E,0x6F,0x74,0x20,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x64,0x21,0x2E,0xD
	.DB  0xA,0x0,0x3C,0x69,0x51,0x75,0x65,0x75
	.DB  0x65,0x53,0x65,0x6E,0x64,0x3E,0x73,0x74
	.DB  0x61,0x74,0x75,0x73,0x28,0x65,0x6D,0x70
	.DB  0x74,0x79,0x29,0xD,0xA,0x0,0x3C,0x69
	.DB  0x51,0x75,0x65,0x75,0x65,0x53,0x65,0x6E
	.DB  0x64,0x3E,0x73,0x74,0x61,0x74,0x75,0x73
	.DB  0x28,0x69,0x74,0x65,0x6D,0x20,0x63,0x6F
	.DB  0x75,0x6E,0x74,0x20,0x69,0x73,0x20,0x6E
	.DB  0x6F,0x74,0x20,0x72,0x61,0x6E,0x67,0x65
	.DB  0x29,0xD,0xA,0x29,0x0,0x3C,0x69,0x51
	.DB  0x75,0x65,0x75,0x65,0x53,0x65,0x6E,0x64
	.DB  0x3E,0x73,0x74,0x61,0x74,0x75,0x73,0x28
	.DB  0x66,0x75,0x6C,0x6C,0x20,0x61,0x6E,0x64
	.DB  0x20,0x77,0x61,0x69,0x74,0x29,0xD,0xA
	.DB  0x0,0x3C,0x69,0x51,0x75,0x65,0x75,0x65
	.DB  0x53,0x65,0x6E,0x64,0x3E,0x63,0x6F,0x75
	.DB  0x6E,0x74,0x28,0x25,0x64,0x29,0xD,0xA
	.DB  0x0,0x3C,0x69,0x51,0x75,0x65,0x75,0x65
	.DB  0x52,0x65,0x63,0x65,0x69,0x76,0x65,0x3E
	.DB  0x51,0x75,0x65,0x75,0x65,0x49,0x74,0x65
	.DB  0x6D,0x20,0x69,0x73,0x20,0x65,0x6D,0x70
	.DB  0x74,0x79,0x20,0x69,0x74,0x20,0x63,0x61
	.DB  0x6E,0x20,0x6E,0x6F,0x74,0x20,0x72,0x65
	.DB  0x61,0x64,0x2E,0xD,0xA,0x0,0x3C,0x69
	.DB  0x51,0x75,0x65,0x75,0x65,0x52,0x65,0x63
	.DB  0x65,0x69,0x76,0x65,0x3E,0x51,0x75,0x65
	.DB  0x75,0x65,0x49,0x74,0x65,0x6D,0x20,0x69
	.DB  0x73,0x20,0x65,0x78,0x69,0x73,0x74,0x2E
	.DB  0xD,0xA,0x0,0x3C,0x69,0x51,0x75,0x65
	.DB  0x75,0x65,0x52,0x65,0x63,0x65,0x69,0x76
	.DB  0x65,0x3E,0x63,0x6F,0x75,0x6E,0x74,0x28
	.DB  0x25,0x64,0x29,0xD,0xA,0x0
_0x3A0000:
	.DB  0x3C,0x69,0x54,0x61,0x73,0x6B,0x43,0x72
	.DB  0x65,0x61,0x74,0x65,0x3E,0x54,0x61,0x73
	.DB  0x6B,0x20,0x63,0x61,0x6E,0x20,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x2E,0xD,0xA,0x0
	.DB  0x3C,0x69,0x54,0x61,0x73,0x6B,0x43,0x72
	.DB  0x65,0x61,0x74,0x65,0x3E,0x54,0x61,0x73
	.DB  0x6B,0x20,0x63,0x61,0x6E,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0
_0x3C0000:
	.DB  0x3C,0x64,0x65,0x62,0x75,0x67,0x54,0x61
	.DB  0x73,0x6B,0x3E,0x54,0x61,0x73,0x6B,0x20
	.DB  0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67,0x2E
	.DB  0x2E,0x2E,0xD,0xA,0x0
_0x3E0000:
	.DB  0x3C,0x63,0x6F,0x6D,0x6D,0x75,0x6E,0x69
	.DB  0x63,0x61,0x74,0x65,0x54,0x61,0x73,0x6B
	.DB  0x3E,0x54,0x61,0x73,0x6B,0x20,0x52,0x75
	.DB  0x6E,0x6E,0x69,0x6E,0x67,0x2E,0x2E,0x2E
	.DB  0xD,0xA,0x0
_0x400003:
	.DB  0x7E,0x0,0x10,0x8,0x0,0x1,0x1,0x1
	.DB  0x1,0x1,0x1,0x1,0x1,0x64,0x75,0xC9
	.DB  0x55,0x0,0x0,0xD8
_0x400000:
	.DB  0x5B,0x69,0x4C,0x61,0x6E,0x52,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x5D,0x69,0x57
	.DB  0x69,0x7A,0x52,0x65,0x61,0x64,0x3A,0x4F
	.DB  0x4B,0x2E,0xD,0xA,0x0,0x5B,0x69,0x4C
	.DB  0x61,0x6E,0x52,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x5D,0x44,0x61,0x74,0x61,0x3A
	.DB  0x4F,0x4B,0x5B,0xD,0xA,0x0,0x5D,0xD
	.DB  0xA,0x0,0x5B,0x69,0x4C,0x61,0x6E,0x52
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x5D
	.DB  0x69,0x57,0x69,0x7A,0x52,0x65,0x61,0x64
	.DB  0x3A,0x65,0x6D,0x70,0x74,0x79,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x4C,0x61,0x6E,0x49
	.DB  0x6E,0x69,0x74,0x5D,0x53,0x74,0x61,0x74
	.DB  0x75,0x73,0x3A,0x43,0x6F,0x6E,0x6E,0x65
	.DB  0x63,0x74,0x65,0x64,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x4C,0x61,0x6E,0x49,0x6E,0x69
	.DB  0x74,0x5D,0x53,0x74,0x61,0x74,0x75,0x73
	.DB  0x3A,0x43,0x6C,0x6F,0x73,0x65,0x2E,0xD
	.DB  0xA,0x0
_0x42001E:
	.DB  0xD,0xA,0x43,0x6F,0x6E,0x74,0x65,0x6E
	.DB  0x74,0x2D,0x4C,0x65,0x6E,0x67,0x74,0x68
	.DB  0x3A,0x20,0x0,0xD,0xA,0x43,0x6F,0x6E
	.DB  0x6E,0x65,0x63,0x74,0x69,0x6F,0x6E,0x3A
	.DB  0x20,0x63,0x6C,0x6F,0x73,0x65,0x0,0xD
	.DB  0xA,0x58,0x2D,0x43,0x4C,0x49,0x45,0x4E
	.DB  0x54,0x2D,0x55,0x55,0x49,0x44,0x3A,0x20
	.DB  0x0,0xD,0xA,0x48,0x6F,0x73,0x74,0x3A
	.DB  0x20,0x73,0x6D,0x61,0x73,0x6D,0x61,0x72
	.DB  0x74,0x64,0x65,0x76,0x69,0x63,0x65,0x2E
	.DB  0x61,0x70,0x70,0x73,0x70,0x6F,0x74,0x2E
	.DB  0x63,0x6F,0x6D,0x0,0x50,0x4F,0x53,0x54
	.DB  0x20,0x2F,0x73,0x6D,0x61,0x73,0x6D,0x61
	.DB  0x72,0x74,0x64,0x65,0x76,0x69,0x63,0x65
	.DB  0x20,0x48,0x54,0x54,0x50,0x2F,0x31,0x2E
	.DB  0x31,0x0
_0x420034:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0
_0x420052:
	.DB  0x3C,0x57,0x52,0x3E,0x0,0x3C,0x52,0x57
	.DB  0x3E,0x0,0x3C,0x52,0x54,0x3E,0x0,0x3C
	.DB  0x52,0x42,0x3E,0x0,0x3C,0x52,0x4B,0x3E
	.DB  0x0,0x3C,0x52,0x4D,0x3E,0x0,0x3C,0x52
	.DB  0x44,0x3E,0x0,0x3C,0x52,0x50,0x3E,0x0
	.DB  0x3C,0x52,0x47,0x3E,0x0,0x3C,0x52,0x53
	.DB  0x3E,0x0,0x3C,0x52,0x49,0x3E,0x0,0x3C
	.DB  0x52,0x41,0x3E,0x0,0x2B,0x2B,0x2B,0x0
_0x420000:
	.DB  0x3C,0x69,0x57,0x69,0x7A,0x52,0x58,0x54
	.DB  0x69,0x6D,0x65,0x4F,0x75,0x74,0x3E,0xD
	.DB  0xA,0x0,0x20,0x0,0x32,0x30,0x30,0x0
	.DB  0x5B,0x52,0x65,0x73,0x20,0x63,0x6F,0x64
	.DB  0x65,0x3A,0x20,0x25,0x73,0x5D,0xD,0xA
	.DB  0x0,0x43,0x6F,0x6E,0x74,0x65,0x6E,0x74
	.DB  0x2D,0x4C,0x65,0x6E,0x67,0x74,0x68,0x0
	.DB  0x5B,0x52,0x65,0x73,0x20,0x6C,0x65,0x6E
	.DB  0x3A,0x20,0x25,0x73,0x5D,0xD,0xA,0x0
	.DB  0x5B,0x52,0x65,0x73,0x20,0x6C,0x65,0x6E
	.DB  0x3A,0x20,0x25,0x64,0x5D,0xD,0xA,0x0
	.DB  0x5B,0x4E,0x6F,0x74,0x66,0x6F,0x75,0x6E
	.DB  0x64,0x20,0x52,0x65,0x73,0x20,0x6C,0x65
	.DB  0x6E,0x5D,0xD,0xA,0x0,0x5B,0x77,0x69
	.DB  0x7A,0x43,0x6F,0x6E,0x74,0x65,0x6E,0x74
	.DB  0x4C,0x65,0x6E,0x5D,0x63,0x61,0x6E,0x20
	.DB  0x27,0x74,0x20,0x61,0x6C,0x6C,0x6F,0x63
	.DB  0x61,0x74,0x65,0x20,0x6D,0x65,0x6D,0x2E
	.DB  0xD,0xA,0x0,0x3E,0x20,0x43,0x6F,0x6E
	.DB  0x6E,0x65,0x63,0x74,0x65,0x64,0x0,0x3E
	.DB  0x20,0x43,0x6C,0x6F,0x73,0x65,0x64,0x0
	.DB  0x5B,0x77,0x69,0x7A,0x53,0x74,0x61,0x74
	.DB  0x5D,0x63,0x61,0x6E,0x20,0x27,0x74,0x20
	.DB  0x61,0x6C,0x6C,0x6F,0x63,0x61,0x74,0x65
	.DB  0x20,0x6D,0x65,0x6D,0x2E,0xD,0xA,0x0
	.DB  0x25,0x64,0xD,0xA,0xD,0xA,0x0,0x5B
	.DB  0x77,0x69,0x7A,0x53,0x65,0x6E,0x64,0x5D
	.DB  0x63,0x61,0x6E,0x20,0x27,0x74,0x20,0x61
	.DB  0x6C,0x6C,0x6F,0x63,0x61,0x74,0x65,0x20
	.DB  0x6D,0x65,0x6D,0x2E,0xD,0xA,0x0,0x69
	.DB  0x6E,0x64,0x65,0x78,0x30,0x42,0x75,0x66
	.DB  0x66,0x65,0x72,0x28,0x25,0x64,0x29,0xD
	.DB  0xA,0x0,0x25,0x63,0x0,0x5B,0x69,0x57
	.DB  0x69,0x7A,0x43,0x6F,0x6E,0x6E,0x65,0x63
	.DB  0x74,0x65,0x64,0x20,0x6C,0x65,0x6E,0x28
	.DB  0x25,0x64,0x29,0x5D,0xD,0xA,0x0,0x3E
	.DB  0x0,0x5B,0x44,0x61,0x74,0x61,0x20,0x73
	.DB  0x70,0x6C,0x69,0x74,0x5D,0x25,0x73,0xD
	.DB  0xA,0x0,0x20,0x4C,0x69,0x73,0x74,0x65
	.DB  0x6E,0x20,0x3A,0x20,0x4F,0x4B,0x0,0x48
	.DB  0x54,0x54,0x50,0x2F,0x0,0x3C,0x45,0x3E
	.DB  0x0,0x5B,0x69,0x57,0x69,0x7A,0x52,0x65
	.DB  0x61,0x64,0x43,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x5D,0x4D,0x41,0x43,0x3A,0x0,0x25,0x30
	.DB  0x32,0x78,0x3A,0x0,0x25,0x30,0x32,0x78
	.DB  0x0,0x5B,0x69,0x57,0x69,0x7A,0x52,0x65
	.DB  0x61,0x64,0x43,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x5D,0x49,0x50,0x3A,0x0,0x25,0x30,0x32
	.DB  0x78,0x2E,0x0,0x5B,0x69,0x57,0x69,0x7A
	.DB  0x52,0x65,0x61,0x64,0x43,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x5D,0x53,0x75,0x62,0x6E,0x65
	.DB  0x74,0x20,0x6D,0x61,0x73,0x6B,0x3A,0x0
	.DB  0x5B,0x69,0x57,0x69,0x7A,0x52,0x65,0x61
	.DB  0x64,0x43,0x6F,0x6E,0x66,0x69,0x67,0x5D
	.DB  0x47,0x61,0x74,0x65,0x77,0x61,0x79,0x3A
	.DB  0x0,0x5B,0x69,0x57,0x69,0x7A,0x52,0x65
	.DB  0x61,0x64,0x43,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x5D,0x53,0x44,0x4E,0x3A,0x25,0x73,0xD
	.DB  0xA,0x0,0x3C,0x53,0x3E,0x0,0x3C,0x53
	.DB  0x0,0x25,0x73,0x0
_0x440003:
	.DB  0xFF,0xFF
_0x440004:
	.DB  0xFF,0xFF
_0x440000:
	.DB  0x3C,0x69,0x6E,0x74,0x65,0x72,0x72,0x75
	.DB  0x70,0x74,0x54,0x61,0x73,0x6B,0x3E,0x54
	.DB  0x61,0x73,0x6B,0x20,0x52,0x75,0x6E,0x6E
	.DB  0x69,0x6E,0x67,0x2E,0x2E,0x2E,0xD,0xA
	.DB  0x0,0x3C,0x69,0x6E,0x74,0x65,0x72,0x72
	.DB  0x75,0x70,0x74,0x54,0x61,0x73,0x6B,0x3E
	.DB  0x70,0x76,0x69,0x55,0x61,0x72,0x74,0x30
	.DB  0x54,0x69,0x6D,0x65,0x4F,0x75,0x74,0x28
	.DB  0x25,0x64,0x29,0x2C,0x77,0x69,0x7A,0x31
	.DB  0x30,0x30,0x73,0x72,0x53,0x65,0x74,0x54
	.DB  0x69,0x6D,0x65,0x72,0x28,0x25,0x64,0x29
	.DB  0xD,0xA,0x0,0x3C,0x69,0x6E,0x74,0x65
	.DB  0x72,0x72,0x75,0x70,0x74,0x54,0x61,0x73
	.DB  0x6B,0x3E,0x73,0x74,0x61,0x72,0x74,0x20
	.DB  0x63,0x6F,0x75,0x6E,0x74,0x20,0x70,0x76
	.DB  0x69,0x55,0x61,0x72,0x74,0x30,0x54,0x69
	.DB  0x6D,0x65,0x4F,0x75,0x74,0xD,0xA,0x0
	.DB  0x3C,0x69,0x6E,0x74,0x65,0x72,0x72,0x75
	.DB  0x70,0x74,0x54,0x61,0x73,0x6B,0x3E,0x77
	.DB  0x69,0x7A,0x31,0x30,0x30,0x73,0x72,0x53
	.DB  0x65,0x74,0x54,0x69,0x6D,0x65,0x72,0x28
	.DB  0x74,0x69,0x6D,0x65,0x6F,0x75,0x74,0x20
	.DB  0x25,0x64,0x29,0xD,0xA,0x0
_0x460000:
	.DB  0x5B,0x64,0x65,0x76,0x69,0x63,0x65,0x54
	.DB  0x61,0x73,0x6B,0x5D,0x54,0x61,0x73,0x6B
	.DB  0x20,0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67
	.DB  0x2E,0x2E,0x2E,0xD,0xA,0x0,0x5B,0x64
	.DB  0x65,0x76,0x69,0x63,0x65,0x54,0x61,0x73
	.DB  0x6B,0x5D,0x54,0x68,0x65,0x72,0x65,0x20
	.DB  0x69,0x73,0x20,0x63,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x75,0x72,0x61,0x74,0x69,0x6F,0x6E
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x64,0x65,0x76
	.DB  0x69,0x63,0x65,0x54,0x61,0x73,0x6B,0x5D
	.DB  0x54,0x68,0x65,0x72,0x65,0x20,0x69,0x73
	.DB  0x20,0x6E,0x6F,0x74,0x20,0x63,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x2E,0xD,0xA,0x0
_0x4A0000:
	.DB  0x5B,0x6C,0x6F,0x67,0x54,0x61,0x73,0x6B
	.DB  0x5D,0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67
	.DB  0x2E,0x2E,0x2E,0xD,0xA,0x0
_0x4C0003:
	.DB  0x52,0x65,0x63,0x6F,0x72,0x64
_0x4C0004:
	.DB  0x4C,0x6F,0x67
_0x4C0005:
	.DB  0x45,0x76,0x65,0x6E,0x74
_0x4C0006:
	.DB  0x53,0x74,0x61,0x74,0x75,0x73
_0x4C0007:
	.DB  0x45,0x72,0x72,0x6F,0x72
_0x4C0008:
	.DB  0x43,0x6F,0x6E,0x66,0x69,0x67
_0x4C0009:
	.DB  0x30,0x3A,0x2F
_0x4C000A:
	.DB  0x30,0x3A,0x2F,0x52,0x45,0x43,0x4F,0x52
	.DB  0x44
_0x4C000B:
	.DB  0x30,0x3A,0x2F,0x4C,0x4F,0x47
_0x4C000C:
	.DB  0x30,0x3A,0x2F,0x45,0x56,0x45,0x4E,0x54
_0x4C000D:
	.DB  0x30,0x3A,0x2F,0x53,0x54,0x41,0x54,0x55
	.DB  0x53
_0x4C000E:
	.DB  0x30,0x3A,0x2F,0x45,0x52,0x52,0x4F,0x52
_0x4C000F:
	.DB  0x30,0x3A,0x2F,0x43,0x4F,0x4E,0x46,0x49
	.DB  0x47
_0x4C0010:
	.DB  0x30,0x3A,0x2E,0x2F,0x30,0x30,0x30,0x30
	.DB  0x30,0x30,0x30,0x30,0x2E,0x6E,0x63
_0x4C0011:
	.DB  0x30,0x3A,0x2E,0x2F,0x64,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x31,0x2E,0x6E,0x63
_0x4C0012:
	.DB  0x30,0x3A,0x2E,0x2F,0x65,0x76,0x65,0x6E
	.DB  0x74,0x31,0x2E,0x6E,0x63
_0x4C0013:
	.DB  0x30,0x3A,0x2E,0x2F,0x73,0x74,0x61,0x74
	.DB  0x75,0x73,0x31,0x2E,0x6E,0x63
_0x4C0014:
	.DB  0x30,0x3A,0x2E,0x2F,0x65,0x72,0x72,0x6F
	.DB  0x72,0x31,0x2E,0x6E,0x63
_0x4C0015:
	.DB  0x30,0x3A,0x2E,0x2F,0x63,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x31,0x2E,0x6E,0x63
_0x4C0000:
	.DB  0x5B,0x69,0x49,0x6E,0x69,0x74,0x53,0x44
	.DB  0x43,0x61,0x72,0x64,0x5D,0x52,0x65,0x63
	.DB  0x6F,0x72,0x64,0x20,0x64,0x69,0x72,0x20
	.DB  0x69,0x73,0x20,0x65,0x78,0x69,0x73,0x74
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x49,0x6E
	.DB  0x69,0x74,0x53,0x44,0x43,0x61,0x72,0x64
	.DB  0x5D,0x6D,0x6B,0x64,0x69,0x72,0x20,0x52
	.DB  0x65,0x63,0x6F,0x72,0x64,0x20,0x73,0x75
	.DB  0x63,0x63,0x65,0x73,0x73,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x49,0x6E,0x69,0x74,0x53
	.DB  0x44,0x43,0x61,0x72,0x64,0x5D,0x6D,0x6B
	.DB  0x64,0x69,0x72,0x20,0x52,0x65,0x63,0x6F
	.DB  0x72,0x64,0x20,0x65,0x72,0x72,0x6F,0x72
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x49,0x6E
	.DB  0x69,0x74,0x53,0x44,0x43,0x61,0x72,0x64
	.DB  0x5D,0x44,0x61,0x74,0x61,0x4C,0x6F,0x67
	.DB  0x20,0x64,0x69,0x72,0x20,0x69,0x73,0x20
	.DB  0x65,0x78,0x69,0x73,0x74,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x49,0x6E,0x69,0x74,0x53
	.DB  0x44,0x43,0x61,0x72,0x64,0x5D,0x6D,0x6B
	.DB  0x64,0x69,0x72,0x20,0x44,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x20,0x73,0x75,0x63,0x63
	.DB  0x65,0x73,0x73,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x49,0x6E,0x69,0x74,0x53,0x44,0x43
	.DB  0x61,0x72,0x64,0x5D,0x6D,0x6B,0x64,0x69
	.DB  0x72,0x20,0x44,0x61,0x74,0x61,0x4C,0x6F
	.DB  0x67,0x20,0x65,0x72,0x72,0x6F,0x72,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x49,0x6E,0x69
	.DB  0x74,0x53,0x44,0x43,0x61,0x72,0x64,0x5D
	.DB  0x45,0x76,0x65,0x6E,0x74,0x20,0x64,0x69
	.DB  0x72,0x20,0x69,0x73,0x20,0x65,0x78,0x69
	.DB  0x73,0x74,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x49,0x6E,0x69,0x74,0x53,0x44,0x43,0x61
	.DB  0x72,0x64,0x5D,0x6D,0x6B,0x64,0x69,0x72
	.DB  0x20,0x45,0x76,0x65,0x6E,0x74,0x20,0x73
	.DB  0x75,0x63,0x63,0x65,0x73,0x73,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x49,0x6E,0x69,0x74
	.DB  0x53,0x44,0x43,0x61,0x72,0x64,0x5D,0x6D
	.DB  0x6B,0x64,0x69,0x72,0x20,0x45,0x76,0x65
	.DB  0x6E,0x74,0x20,0x65,0x72,0x72,0x6F,0x72
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x49,0x6E
	.DB  0x69,0x74,0x53,0x44,0x43,0x61,0x72,0x64
	.DB  0x5D,0x53,0x74,0x61,0x74,0x75,0x73,0x20
	.DB  0x64,0x69,0x72,0x20,0x69,0x73,0x20,0x65
	.DB  0x78,0x69,0x73,0x74,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x49,0x6E,0x69,0x74,0x53,0x44
	.DB  0x43,0x61,0x72,0x64,0x5D,0x6D,0x6B,0x64
	.DB  0x69,0x72,0x20,0x53,0x74,0x61,0x74,0x75
	.DB  0x73,0x20,0x73,0x75,0x63,0x63,0x65,0x73
	.DB  0x73,0x2E,0xD,0xA,0x0,0x5B,0x69,0x49
	.DB  0x6E,0x69,0x74,0x53,0x44,0x43,0x61,0x72
	.DB  0x64,0x5D,0x6D,0x6B,0x64,0x69,0x72,0x20
	.DB  0x53,0x74,0x61,0x74,0x75,0x73,0x20,0x65
	.DB  0x72,0x72,0x6F,0x72,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x49,0x6E,0x69,0x74,0x53,0x44
	.DB  0x43,0x61,0x72,0x64,0x5D,0x45,0x72,0x72
	.DB  0x6F,0x72,0x20,0x64,0x69,0x72,0x20,0x69
	.DB  0x73,0x20,0x65,0x78,0x69,0x73,0x74,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x49,0x6E,0x69
	.DB  0x74,0x53,0x44,0x43,0x61,0x72,0x64,0x5D
	.DB  0x6D,0x6B,0x64,0x69,0x72,0x20,0x45,0x72
	.DB  0x72,0x6F,0x72,0x20,0x73,0x75,0x63,0x63
	.DB  0x65,0x73,0x73,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x49,0x6E,0x69,0x74,0x53,0x44,0x43
	.DB  0x61,0x72,0x64,0x5D,0x6D,0x6B,0x64,0x69
	.DB  0x72,0x20,0x45,0x72,0x72,0x6F,0x72,0x20
	.DB  0x65,0x72,0x72,0x6F,0x72,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x49,0x6E,0x69,0x74,0x53
	.DB  0x44,0x43,0x61,0x72,0x64,0x5D,0x43,0x6F
	.DB  0x6E,0x66,0x69,0x67,0x20,0x64,0x69,0x72
	.DB  0x20,0x69,0x73,0x20,0x65,0x78,0x69,0x73
	.DB  0x74,0x2E,0xD,0xA,0x0,0x5B,0x69,0x49
	.DB  0x6E,0x69,0x74,0x53,0x44,0x43,0x61,0x72
	.DB  0x64,0x5D,0x6D,0x6B,0x64,0x69,0x72,0x20
	.DB  0x43,0x6F,0x6E,0x66,0x69,0x67,0x20,0x73
	.DB  0x75,0x63,0x63,0x65,0x73,0x73,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x49,0x6E,0x69,0x74
	.DB  0x53,0x44,0x43,0x61,0x72,0x64,0x5D,0x6D
	.DB  0x6B,0x64,0x69,0x72,0x20,0x43,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x20,0x65,0x72,0x72,0x6F
	.DB  0x72,0x2E,0xD,0xA,0x0,0x63,0x6F,0x75
	.DB  0x6C,0x64,0x6E,0x27,0x74,0x20,0x66,0x69
	.DB  0x6E,0x64,0x20,0x74,0x68,0x65,0x20,0x70
	.DB  0x61,0x74,0x68,0x2E,0xD,0xA,0x0,0x74
	.DB  0x68,0x65,0x20,0x64,0x69,0x72,0x65,0x63
	.DB  0x74,0x6F,0x72,0x79,0x20,0x6E,0x61,0x6D
	.DB  0x65,0x20,0x69,0x73,0x20,0x69,0x6E,0x76
	.DB  0x61,0x6C,0x69,0x64,0x2E,0xD,0xA,0x0
	.DB  0x74,0x68,0x65,0x20,0x64,0x72,0x69,0x76
	.DB  0x65,0x20,0x6E,0x75,0x6D,0x62,0x65,0x72
	.DB  0x20,0x69,0x73,0x20,0x69,0x6E,0x76,0x61
	.DB  0x6C,0x69,0x64,0x2E,0xD,0xA,0x0,0x6E
	.DB  0x6F,0x20,0x64,0x69,0x73,0x6B,0x20,0x61
	.DB  0x63,0x63,0x65,0x73,0x73,0x20,0x77,0x61
	.DB  0x73,0x20,0x70,0x6F,0x73,0x73,0x69,0x62
	.DB  0x6C,0x65,0x20,0x64,0x75,0x65,0x20,0x74
	.DB  0x6F,0x20,0x6D,0x69,0x73,0x73,0x69,0x6E
	.DB  0x67,0x20,0x6D,0x65,0x64,0x69,0x61,0x20
	.DB  0x6F,0x72,0x20,0x6F,0x74,0x68,0x65,0x72
	.DB  0x20,0x72,0x65,0x61,0x73,0x6F,0x6E,0x2E
	.DB  0xD,0xA,0x0,0x74,0x68,0x65,0x20,0x66
	.DB  0x75,0x6E,0x63,0x74,0x69,0x6F,0x6E,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0x20,0x62
	.DB  0x65,0x63,0x61,0x75,0x73,0x65,0x20,0x6F
	.DB  0x66,0x20,0x61,0x20,0x70,0x68,0x79,0x73
	.DB  0x69,0x63,0x61,0x6C,0x20,0x64,0x69,0x73
	.DB  0x6B,0x20,0x61,0x63,0x63,0x65,0x73,0x73
	.DB  0x20,0x66,0x75,0x6E,0x63,0x74,0x69,0x6F
	.DB  0x6E,0x20,0x66,0x61,0x69,0x6C,0x75,0x72
	.DB  0x65,0x2E,0xD,0xA,0x0,0x74,0x68,0x65
	.DB  0x20,0x66,0x75,0x6E,0x63,0x74,0x69,0x6F
	.DB  0x6E,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0x20,0x64,0x75,0x65,0x20,0x74,0x6F,0x20
	.DB  0x61,0x20,0x77,0x72,0x6F,0x6E,0x67,0x20
	.DB  0x46,0x41,0x54,0x20,0x73,0x74,0x72,0x75
	.DB  0x63,0x74,0x75,0x72,0x65,0x20,0x6F,0x72
	.DB  0x20,0x61,0x6E,0x20,0x69,0x6E,0x74,0x65
	.DB  0x72,0x6E,0x61,0x6C,0x20,0x65,0x72,0x72
	.DB  0x6F,0x72,0x2E,0xD,0xA,0x0,0x74,0x68
	.DB  0x65,0x20,0x6C,0x6F,0x67,0x69,0x63,0x61
	.DB  0x6C,0x20,0x64,0x72,0x69,0x76,0x65,0x20
	.DB  0x77,0x61,0x73,0x20,0x6E,0x6F,0x74,0x20
	.DB  0x6D,0x6F,0x75,0x6E,0x74,0x65,0x64,0x20
	.DB  0x77,0x69,0x74,0x68,0x20,0x66,0x5F,0x6D
	.DB  0x6F,0x75,0x6E,0x74,0x2E,0xD,0xA,0x0
	.DB  0x74,0x68,0x65,0x72,0x65,0x20,0x69,0x73
	.DB  0x20,0x6E,0x6F,0x20,0x76,0x61,0x6C,0x69
	.DB  0x64,0x20,0x46,0x41,0x54,0x20,0x70,0x61
	.DB  0x72,0x74,0x69,0x74,0x69,0x6F,0x6E,0x20
	.DB  0x6F,0x6E,0x20,0x74,0x68,0x65,0x20,0x64
	.DB  0x69,0x73,0x6B,0x2E,0xD,0xA,0x0,0x66
	.DB  0x69,0x6C,0x65,0x20,0x61,0x63,0x63,0x65
	.DB  0x73,0x73,0x20,0x77,0x61,0x73,0x20,0x64
	.DB  0x65,0x6E,0x69,0x65,0x64,0x20,0x62,0x65
	.DB  0x63,0x61,0x75,0x73,0x65,0x20,0x69,0x74
	.DB  0x20,0x77,0x61,0x73,0x20,0x6F,0x70,0x65
	.DB  0x6E,0x65,0x64,0x20,0x69,0x6E,0x20,0x72
	.DB  0x65,0x61,0x64,0x2D,0x6F,0x6E,0x6C,0x79
	.DB  0x20,0x6D,0x6F,0x64,0x65,0x2E,0xD,0xA
	.DB  0x0,0x74,0x68,0x65,0x20,0x66,0x69,0x6C
	.DB  0x65,0x20,0x77,0x61,0x73,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x6F,0x70,0x65,0x6E,0x65,0x64
	.DB  0x20,0x77,0x69,0x74,0x68,0x20,0x66,0x5F
	.DB  0x6F,0x70,0x65,0x6E,0x2E,0xD,0xA,0x0
	.DB  0x63,0x6F,0x75,0x6C,0x64,0x6E,0x27,0x74
	.DB  0x20,0x66,0x69,0x6E,0x64,0x20,0x74,0x68
	.DB  0x65,0x20,0x66,0x69,0x6C,0x65,0x20,0x6F
	.DB  0x72,0x20,0x64,0x69,0x72,0x65,0x63,0x74
	.DB  0x6F,0x72,0x79,0x2E,0xD,0xA,0x0,0x74
	.DB  0x68,0x65,0x20,0x6D,0x65,0x64,0x69,0x61
	.DB  0x20,0x69,0x6E,0x20,0x74,0x68,0x65,0x20
	.DB  0x64,0x72,0x69,0x76,0x65,0x20,0x69,0x73
	.DB  0x20,0x77,0x72,0x69,0x74,0x65,0x20,0x70
	.DB  0x72,0x6F,0x74,0x65,0x63,0x74,0x65,0x64
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x46,0x43
	.DB  0x72,0x65,0x61,0x74,0x65,0x5D,0x43,0x75
	.DB  0x72,0x72,0x65,0x6E,0x74,0x20,0x64,0x69
	.DB  0x72,0x65,0x63,0x74,0x6F,0x72,0x79,0x20
	.DB  0x3A,0x20,0x25,0x73,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x43,0x72,0x65,0x61,0x74
	.DB  0x65,0x5D,0x46,0x69,0x6C,0x65,0x20,0x25
	.DB  0x73,0x20,0x69,0x73,0x20,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x64,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x43,0x72,0x65,0x61,0x74
	.DB  0x65,0x5D,0x46,0x69,0x6C,0x65,0x20,0x25
	.DB  0x73,0x20,0x3A,0x20,0x25,0x73,0x2E,0x5B
	.DB  0xD,0xA,0x0,0x5D,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x43,0x72,0x65,0x61,0x74,0x65
	.DB  0x5D,0x64,0x69,0x72,0x65,0x63,0x74,0x6F
	.DB  0x72,0x79,0x20,0x3A,0x20,0x25,0x73,0x2E
	.DB  0x5B,0xD,0xA,0x0,0x5B,0x69,0x46,0x52
	.DB  0x77,0x69,0x74,0x65,0x5D,0x43,0x75,0x72
	.DB  0x72,0x65,0x6E,0x74,0x20,0x64,0x69,0x72
	.DB  0x65,0x63,0x74,0x6F,0x72,0x79,0x20,0x3A
	.DB  0x20,0x25,0x73,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x52,0x77,0x69,0x74,0x65,0x5D
	.DB  0x46,0x69,0x6C,0x65,0x20,0x25,0x73,0x20
	.DB  0x69,0x73,0x20,0x6F,0x70,0x65,0x6E,0x6E
	.DB  0x65,0x64,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x46,0x52,0x77,0x69,0x74,0x65,0x5D,0x46
	.DB  0x69,0x6C,0x65,0x20,0x73,0x69,0x7A,0x65
	.DB  0x28,0x25,0x6C,0x64,0x29,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x52,0x77,0x69,0x74
	.DB  0x65,0x5D,0x50,0x6F,0x69,0x6E,0x74,0x65
	.DB  0x72,0x28,0x73,0x65,0x65,0x6B,0x29,0x20
	.DB  0x6F,0x66,0x20,0x46,0x69,0x6C,0x65,0x20
	.DB  0x6D,0x6F,0x76,0x65,0x64,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x52,0x77,0x69,0x74
	.DB  0x65,0x5D,0x25,0x64,0x20,0x62,0x79,0x74
	.DB  0x65,0x73,0x20,0x77,0x72,0x69,0x74,0x74
	.DB  0x65,0x6E,0x20,0x6F,0x66,0x20,0x25,0x64
	.DB  0xD,0xA,0x0,0x5B,0x69,0x46,0x52,0x77
	.DB  0x69,0x74,0x65,0x5D,0x57,0x72,0x69,0x74
	.DB  0x65,0x20,0x65,0x72,0x72,0x6F,0x72,0x28
	.DB  0x25,0x64,0x29,0xD,0xA,0x0,0x5B,0x69
	.DB  0x46,0x52,0x77,0x69,0x74,0x65,0x5D,0x46
	.DB  0x69,0x6C,0x65,0x20,0x25,0x73,0x20,0x3A
	.DB  0x20,0x25,0x73,0x2E,0x5B,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x52,0x77,0x69,0x74,0x65
	.DB  0x5D,0x64,0x69,0x72,0x65,0x63,0x74,0x6F
	.DB  0x72,0x79,0x20,0x3A,0x20,0x25,0x73,0x2E
	.DB  0x5B,0xD,0xA,0x0,0x5B,0x69,0x46,0x52
	.DB  0x77,0x69,0x74,0x65,0x5D,0x63,0x61,0x6E
	.DB  0x27,0x74,0x20,0x61,0x6C,0x6C,0x6F,0x63
	.DB  0x61,0x74,0x65,0x20,0x6D,0x65,0x6D,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x46,0x44,0x65
	.DB  0x6C,0x65,0x74,0x65,0x5D,0x43,0x75,0x72
	.DB  0x72,0x65,0x6E,0x74,0x20,0x64,0x69,0x72
	.DB  0x65,0x63,0x74,0x6F,0x72,0x79,0x20,0x3A
	.DB  0x20,0x25,0x73,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x44,0x65,0x6C,0x65,0x74,0x65
	.DB  0x5D,0x46,0x69,0x6C,0x65,0x20,0x25,0x73
	.DB  0x20,0x69,0x73,0x20,0x64,0x65,0x6C,0x65
	.DB  0x74,0x65,0x64,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x44,0x65,0x6C,0x65,0x74,0x65
	.DB  0x5D,0x46,0x69,0x6C,0x65,0x20,0x25,0x73
	.DB  0x20,0x3A,0x20,0x25,0x73,0x2E,0x20,0x63
	.DB  0x61,0x6E,0x27,0x74,0x20,0x64,0x65,0x6C
	.DB  0x65,0x74,0x65,0x2E,0x5B,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x44,0x65,0x6C,0x65,0x74
	.DB  0x65,0x5D,0x64,0x69,0x72,0x65,0x63,0x74
	.DB  0x6F,0x72,0x79,0x20,0x3A,0x20,0x25,0x73
	.DB  0x2E,0x5B,0xD,0xA,0x0,0x5B,0x69,0x46
	.DB  0x53,0x69,0x7A,0x65,0x5D,0x43,0x75,0x72
	.DB  0x72,0x65,0x6E,0x74,0x20,0x64,0x69,0x72
	.DB  0x65,0x63,0x74,0x6F,0x72,0x79,0x20,0x3A
	.DB  0x20,0x25,0x73,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x53,0x69,0x7A,0x65,0x5D,0x46
	.DB  0x69,0x6C,0x65,0x20,0x25,0x73,0x20,0x69
	.DB  0x73,0x20,0x6F,0x70,0x65,0x6E,0x6E,0x65
	.DB  0x64,0x2E,0xD,0xA,0x0,0x5B,0x69,0x46
	.DB  0x53,0x69,0x7A,0x65,0x5D,0x46,0x69,0x6C
	.DB  0x65,0x20,0x73,0x69,0x7A,0x65,0x28,0x25
	.DB  0x6C,0x64,0x29,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x53,0x69,0x7A,0x65,0x5D,0x46
	.DB  0x69,0x6C,0x65,0x20,0x25,0x73,0x20,0x3A
	.DB  0x20,0x25,0x73,0x2E,0x5B,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x53,0x69,0x7A,0x65,0x5D
	.DB  0x64,0x69,0x72,0x65,0x63,0x74,0x6F,0x72
	.DB  0x79,0x20,0x3A,0x20,0x25,0x73,0x2E,0x5B
	.DB  0xD,0xA,0x0,0x5B,0x69,0x46,0x53,0x69
	.DB  0x7A,0x65,0x5D,0x63,0x61,0x6E,0x27,0x74
	.DB  0x20,0x61,0x6C,0x6C,0x6F,0x63,0x61,0x74
	.DB  0x65,0x20,0x6D,0x65,0x6D,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x43,0x72,0x65,0x61
	.DB  0x74,0x65,0x46,0x69,0x6C,0x65,0x44,0x61
	.DB  0x69,0x6C,0x79,0x5D,0x43,0x75,0x72,0x72
	.DB  0x65,0x6E,0x74,0x20,0x64,0x69,0x72,0x65
	.DB  0x63,0x74,0x6F,0x72,0x79,0x20,0x3A,0x20
	.DB  0x25,0x73,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x46,0x43,0x72,0x65,0x61,0x74,0x65,0x46
	.DB  0x69,0x6C,0x65,0x44,0x61,0x69,0x6C,0x79
	.DB  0x5D,0x44,0x61,0x74,0x61,0x20,0x64,0x69
	.DB  0x72,0x20,0x69,0x73,0x20,0x65,0x78,0x69
	.DB  0x73,0x74,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x47,0x65,0x6E,0x46,0x69,0x6C,0x65,0x44
	.DB  0x61,0x69,0x6C,0x79,0x5D,0x46,0x69,0x6C
	.DB  0x65,0x20,0x25,0x73,0x20,0x69,0x73,0x20
	.DB  0x6F,0x70,0x65,0x6E,0x6E,0x65,0x64,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x46,0x43,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x44,0x61,0x69,0x6C,0x79,0x5D,0x64,0x69
	.DB  0x72,0x65,0x63,0x74,0x6F,0x72,0x79,0x20
	.DB  0x3A,0x20,0x25,0x73,0x2E,0x5B,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x52,0x65,0x61,0x64
	.DB  0x5D,0x43,0x75,0x72,0x72,0x65,0x6E,0x74
	.DB  0x20,0x64,0x69,0x72,0x65,0x63,0x74,0x6F
	.DB  0x72,0x79,0x20,0x3A,0x20,0x25,0x73,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x46,0x52,0x65
	.DB  0x61,0x64,0x5D,0x46,0x69,0x6C,0x65,0x20
	.DB  0x25,0x73,0x20,0x69,0x73,0x20,0x6F,0x70
	.DB  0x65,0x6E,0x6E,0x65,0x64,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x52,0x65,0x61,0x64
	.DB  0x5D,0x50,0x6F,0x69,0x6E,0x74,0x65,0x72
	.DB  0x28,0x73,0x65,0x65,0x6B,0x29,0x20,0x6F
	.DB  0x66,0x20,0x46,0x69,0x6C,0x65,0x20,0x6D
	.DB  0x6F,0x76,0x65,0x64,0x28,0x25,0x6C,0x64
	.DB  0x29,0x2E,0xD,0xA,0x0,0x5B,0x69,0x46
	.DB  0x52,0x65,0x61,0x64,0x5D,0x25,0x64,0x20
	.DB  0x62,0x79,0x74,0x65,0x73,0x20,0x52,0x65
	.DB  0x61,0x64,0x69,0x6E,0x67,0x20,0x6F,0x66
	.DB  0x20,0x25,0x64,0xD,0xA,0x0,0x5B,0x69
	.DB  0x46,0x52,0x65,0x61,0x64,0x5D,0x52,0x65
	.DB  0x61,0x64,0x20,0x65,0x72,0x72,0x6F,0x72
	.DB  0x28,0x25,0x64,0x29,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x52,0x65,0x61,0x64,0x5D,0x46
	.DB  0x69,0x6C,0x65,0x20,0x25,0x73,0x20,0x3A
	.DB  0x20,0x25,0x73,0x2E,0x5B,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x52,0x65,0x61,0x64,0x5D
	.DB  0x64,0x69,0x72,0x65,0x63,0x74,0x6F,0x72
	.DB  0x79,0x20,0x3A,0x20,0x25,0x73,0x2E,0x5B
	.DB  0xD,0xA,0x0,0x5B,0x69,0x46,0x52,0x65
	.DB  0x61,0x64,0x5D,0x63,0x61,0x6E,0x27,0x74
	.DB  0x20,0x61,0x6C,0x6C,0x6F,0x63,0x61,0x74
	.DB  0x65,0x20,0x6D,0x65,0x6D,0x2E,0xD,0xA
	.DB  0x0
_0x4E0003:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4E
_0x4E0008:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
_0x4E0000:
	.DB  0x5B,0x69,0x44,0x61,0x74,0x61,0x49,0x6E
	.DB  0x73,0x65,0x72,0x74,0x5D,0x49,0x6E,0x73
	.DB  0x65,0x72,0x74,0x20,0x69,0x73,0x20,0x73
	.DB  0x75,0x63,0x63,0x65,0x73,0x73,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x44,0x61,0x74,0x61
	.DB  0x49,0x6E,0x73,0x65,0x72,0x74,0x5D,0x44
	.DB  0x61,0x74,0x61,0x62,0x75,0x66,0x66,0x5F
	.DB  0x61,0x72,0x67,0x20,0x63,0x61,0x6E,0x27
	.DB  0x74,0x20,0x61,0x6C,0x6C,0x6F,0x63,0x61
	.DB  0x74,0x65,0x20,0x6D,0x65,0x6D,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x44,0x61,0x74,0x61
	.DB  0x53,0x65,0x6C,0x65,0x63,0x74,0x5D,0x46
	.DB  0x69,0x6C,0x65,0x20,0x69,0x73,0x20,0x65
	.DB  0x6D,0x70,0x74,0x79,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x44,0x61,0x74,0x61,0x53,0x65
	.DB  0x6C,0x65,0x63,0x74,0x5D,0x46,0x69,0x6C
	.DB  0x65,0x20,0x73,0x69,0x7A,0x65,0x28,0x25
	.DB  0x6C,0x64,0x29,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x44,0x61,0x74,0x61,0x53,0x65,0x6C
	.DB  0x65,0x63,0x74,0x5D,0x69,0x44,0x61,0x74
	.DB  0x61,0x53,0x65,0x6C,0x65,0x63,0x74,0x20
	.DB  0x69,0x73,0x20,0x73,0x75,0x63,0x63,0x65
	.DB  0x73,0x73,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x44,0x61,0x74,0x61,0x53,0x65,0x6C,0x65
	.DB  0x63,0x74,0x5D,0x44,0x61,0x74,0x61,0x62
	.DB  0x75,0x66,0x66,0x5F,0x61,0x72,0x67,0x20
	.DB  0x63,0x61,0x6E,0x27,0x74,0x20,0x61,0x6C
	.DB  0x6C,0x6F,0x63,0x61,0x74,0x65,0x20,0x6D
	.DB  0x65,0x6D,0x2E,0xD,0xA,0x0
_0x500000:
	.DB  0x5B,0x69,0x53,0x65,0x6E,0x73,0x6F,0x72
	.DB  0x52,0x65,0x61,0x64,0x5D,0x44,0x61,0x74
	.DB  0x61,0x3A,0x5B,0xD,0xA,0x0,0x5D,0xD
	.DB  0xA,0x0,0x5B,0x69,0x53,0x65,0x6E,0x73
	.DB  0x6F,0x72,0x52,0x65,0x61,0x64,0x42,0x79
	.DB  0x54,0x79,0x70,0x65,0x5D,0x43,0x68,0x61
	.DB  0x6E,0x6E,0x65,0x6C,0x5B,0x25,0x64,0x5D
	.DB  0x20,0x64,0x61,0x74,0x61,0x20,0x3A,0x20
	.DB  0x25,0x66,0xD,0xA,0x0
_0x520000:
	.DB  0x5B,0x69,0x53,0x74,0x61,0x74,0x75,0x73
	.DB  0x52,0x65,0x61,0x64,0x5D,0x44,0x61,0x74
	.DB  0x61,0x3A,0x5B,0xD,0xA,0x0,0x5D,0xD
	.DB  0xA,0x0
_0x540000:
	.DB  0x5B,0x64,0x61,0x74,0x61,0x41,0x6E,0x64
	.DB  0x53,0x74,0x61,0x74,0x75,0x73,0x54,0x61
	.DB  0x73,0x6B,0x5D,0x54,0x61,0x73,0x6B,0x20
	.DB  0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67,0x2E
	.DB  0x2E,0x2E,0xD,0xA,0x0
_0x560000:
	.DB  0x5B,0x64,0x61,0x74,0x61,0x41,0x6E,0x64
	.DB  0x53,0x74,0x61,0x74,0x75,0x73,0x54,0x61
	.DB  0x73,0x6B,0x5D,0x54,0x61,0x73,0x6B,0x20
	.DB  0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67,0x2E
	.DB  0x2E,0x2E,0xD,0xA,0x0
_0x580000:
	.DB  0x5B,0x69,0x50,0x72,0x69,0x6E,0x74,0x45
	.DB  0x76,0x65,0x6E,0x74,0x42,0x79,0x43,0x61
	.DB  0x73,0x65,0x5D,0x69,0x64,0x28,0x25,0x30
	.DB  0x32,0x58,0x29,0xD,0xA,0x0
_0x5A0000:
	.DB  0x30,0x3A,0x2E,0x2F,0x30,0x30,0x30,0x30
	.DB  0x30,0x30,0x30,0x30,0x0,0x5B,0x69,0x47
	.DB  0x65,0x6E,0x46,0x69,0x6C,0x65,0x44,0x61
	.DB  0x69,0x6C,0x79,0x5D,0xD,0xA,0x0,0x30
	.DB  0x3A,0x2E,0x2F,0x25,0x30,0x34,0x64,0x25
	.DB  0x30,0x32,0x64,0x25,0x30,0x32,0x64,0x2E
	.DB  0x6E,0x63,0x0,0x5B,0x69,0x47,0x65,0x6E
	.DB  0x46,0x69,0x6C,0x65,0x44,0x61,0x69,0x6C
	.DB  0x79,0x5D,0x46,0x69,0x6C,0x65,0x20,0x6E
	.DB  0x61,0x6D,0x65,0x3A,0x20,0x25,0x73,0xD
	.DB  0xA,0x0
_0x2000003:
	.DB  0x1
_0x2040000:
	.DB  0x2D,0x4E,0x41,0x4E,0x0
_0x2060060:
	.DB  0x1
_0x2060000:
	.DB  0x2D,0x4E,0x41,0x4E,0x0,0x49,0x4E,0x46
	.DB  0x0

__GLOBAL_INI_TBL:
	.DW  0x04
	.DW  0x1A00
	.DD  __HEAP_START_MARKER*2

	.DW  0x07
	.DW  _0xE
	.DD  _0x0*2+324

	.DW  0x0E
	.DW  _0xE+7
	.DD  _0x0*2+357

	.DW  0x05
	.DW  _0xE+21
	.DD  _0x0*2+400

	.DW  0x06
	.DW  _0xE+26
	.DD  _0x0*2+435

	.DW  0x04
	.DW  0x04
	.DD  _0x17*2

	.DW  0x2B
	.DW  _0x40009
	.DD  _0x40000*2

	.DW  0x26
	.DW  _0x40009+43
	.DD  _0x40000*2+43

	.DW  0x2B
	.DW  _0x40009+81
	.DD  _0x40000*2

	.DW  0x2B
	.DW  _0x40009+124
	.DD  _0x40000*2

	.DW  0x26
	.DW  _0x40009+167
	.DD  _0x40000*2+43

	.DW  0x2B
	.DW  _0x40009+205
	.DD  _0x40000*2

	.DW  0x2B
	.DW  _0x40009+248
	.DD  _0x40000*2

	.DW  0x26
	.DW  _0x40009+291
	.DD  _0x40000*2+43

	.DW  0x2B
	.DW  _0x40009+329
	.DD  _0x40000*2

	.DW  0x04
	.DW  0x0A
	.DD  _0x40042*2

	.DW  0x03
	.DW  _root_path
	.DD  _0x240003*2

	.DW  0x08
	.DW  _LOGFILE_DATA
	.DD  _0x260003*2

	.DW  0x09
	.DW  _LOGFILE_EVENT
	.DD  _0x260004*2

	.DW  0x09
	.DW  _LOGFILE_ERROR
	.DD  _0x260005*2

	.DW  0x10
	.DW  _LOG_INIT_STR
	.DD  _0x260006*2

	.DW  0x01
	.DW  _hwCalId
	.DD  _0x2A0003*2

	.DW  0x01
	.DW  _n
	.DD  _0x2C0003*2

	.DW  0x04
	.DW  _0x42000B
	.DD  _0x420000*2+20

	.DW  0x0F
	.DW  _0x420011
	.DD  _0x420000*2+41

	.DW  0x0C
	.DW  _0x420017
	.DD  _0x420000*2+147

	.DW  0x09
	.DW  _0x420017+12
	.DD  _0x420000*2+159

	.DW  0x0B
	.DW  _0x42002F
	.DD  _0x420000*2+148

	.DW  0x0D
	.DW  _0x42002F+11
	.DD  _0x420000*2+306

	.DW  0x06
	.DW  _0x42003F
	.DD  _0x420000*2+319

	.DW  0x04
	.DW  _0x42003F+6
	.DD  _0x420000*2+20

	.DW  0x0F
	.DW  _0x42003F+10
	.DD  _0x420000*2+41

	.DW  0x05
	.DW  _0x42003F+25
	.DD  _0x420000*2+202

	.DW  0x04
	.DW  _0x42005A
	.DD  _0x420000*2+325

	.DW  0x04
	.DW  _0x42005A+4
	.DD  _0x420000*2+466

	.DW  0x03
	.DW  _0x420086
	.DD  _0x420000*2+470

	.DW  0x02
	.DW  _wiz100srSetTimer
	.DD  _0x440003*2

	.DW  0x02
	.DW  _pviUart0TimeOut
	.DD  _0x440004*2

	.DW  0x06
	.DW  _viFolderDataName
	.DD  _0x4C0003*2

	.DW  0x03
	.DW  _viFolderDataLogName
	.DD  _0x4C0004*2

	.DW  0x05
	.DW  _viFolderEventName
	.DD  _0x4C0005*2

	.DW  0x06
	.DW  _viFolderStatusName
	.DD  _0x4C0006*2

	.DW  0x05
	.DW  _viFolderErrorName
	.DD  _0x4C0007*2

	.DW  0x06
	.DW  _viFolderConfigName
	.DD  _0x4C0008*2

	.DW  0x09
	.DW  _viDirDataPath
	.DD  _0x4C000A*2

	.DW  0x06
	.DW  _viDirDataLogPath
	.DD  _0x4C000B*2

	.DW  0x08
	.DW  _viDirEventPath
	.DD  _0x4C000C*2

	.DW  0x09
	.DW  _viDirStatusPath
	.DD  _0x4C000D*2

	.DW  0x08
	.DW  _viDirErrorPath
	.DD  _0x4C000E*2

	.DW  0x09
	.DW  _viDirConfigPath
	.DD  _0x4C000F*2

	.DW  0x0F
	.DW  _viDataFName
	.DD  _0x4C0010*2

	.DW  0x0D
	.DW  _0x5A0005
	.DD  _0x5A0000*2

	.DW  0x01
	.DW  _status_G100
	.DD  _0x2000003*2

	.DW  0x01
	.DW  __seed_G103
	.DD  _0x2060060*2

_0xFFFFFFFF:
	.DW  0

__RESET:
	CLI
	CLR  R30
	OUT  EECR,R30

;INTERRUPT VECTORS ARE PLACED
;AT THE START OF FLASH
	LDI  R31,1
	OUT  MCUCR,R31
	OUT  MCUCR,R30
	STS  XMCRA,R30
	STS  XMCRB,R30

;DISABLE WATCHDOG
	LDI  R31,0x18
	WDR
	IN   R26,MCUSR
	CBR  R26,8
	OUT  MCUSR,R26
	STS  WDTCSR,R31
	STS  WDTCSR,R30

;CLEAR R2-R14
	LDI  R24,(14-2)+1
	LDI  R26,2
	CLR  R27
__CLEAR_REG:
	ST   X+,R30
	DEC  R24
	BRNE __CLEAR_REG

;CLEAR SRAM
	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
	LDI  R26,LOW(__SRAM_START)
	LDI  R27,HIGH(__SRAM_START)
__CLEAR_SRAM:
	ST   X+,R30
	SBIW R24,1
	BRNE __CLEAR_SRAM

;GLOBAL VARIABLES INITIALIZATION
	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
	LDI  R29,BYTE3(__GLOBAL_INI_TBL*2)
__GLOBAL_INI_NEXT:
	OUT  RAMPZ,R29
	ELPM R24,Z+
	ELPM R25,Z+
	SBIW R24,0
	BREQ __GLOBAL_INI_END
	ELPM R26,Z+
	ELPM R27,Z+
	ELPM R0,Z+
	ELPM R1,Z+
	ELPM R28,Z+
	ELPM R29,Z+
	MOVW R22,R30
	IN   R29,RAMPZ
	MOVW R30,R0
	OUT  RAMPZ,R28
__GLOBAL_INI_LOOP:
	ELPM R0,Z+
	ST   X+,R0
	SBIW R24,1
	BRNE __GLOBAL_INI_LOOP
	MOVW R30,R22
	RJMP __GLOBAL_INI_NEXT
__GLOBAL_INI_END:

;GPIOR0 INITIALIZATION
	LDI  R30,__GPIOR0_INIT
	OUT  GPIOR0,R30

;HARDWARE STACK POINTER INITIALIZATION
	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
	OUT  SPL,R30
	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
	OUT  SPH,R30

;DATA STACK POINTER INITIALIZATION
	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)

	JMP  _main

	.ESEG
	.ORG 0

	.DSEG
	.ORG 0xCF0

	.CSEG
;/*****************************************************
;Project : SMA_AVR2560_V1 : 1
;Date    : 17/7/2012
;Author  : Nexs-Crop Team
;Company : Nexs-Crop Co.,Ltd.
;Comments:
;Version Format : 1Major.2Minor.1Edition
;
;
;Chip type               : ATmega2560
;Program type            : Application
;AVR Core Clock frequency: 8.000000 MHz
;*****************************************************/
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;//#include <stdlib.h>
;//#include <string.h>
;#include <delay.h>
;#include "main.h"
;#include "ims_eth_header.h"
;#include "debug.h"
;#include "uart.h"
;//#include "queue.h"
;#include "dataAndStatusTask.h"
;#include "managerTask.h"
;#include "debugTask.h"
;#include "communicateTask.h"
;#include "interruptTask.h"
;#include "deviceTask.h"
;#include "logTask.h"
;#include "eventTask.h"
;#include "lan.h"
;#include "smaProtocol.h"
;#include "sdManager.h"
;#include "database.h"
;
;#define MAX(a,b)                (((a) > (b)) ? (a) : (b))
;#define MIN(a,b)                (((a) < (b)) ? (a) : (b))
;//#define RANDOM(a,b)             ((rand() % (MAX(a,b) - MIN(a,b))) + MIN(a,b))
;
;#define PERIOD_CHECK_MEMORY     300
;
;// I2C Bus functions (for INT-AVXB-00-04)
;#asm
   .equ __i2c_port=0x0B ;PORTD
   .equ __sda_bit=1
   .equ __scl_bit=0
; 0000 002F #endasm
;
;//unsigned char FIRMWARE_VERSION[] = "COMM-ETH-0.01a";
;
;piQueueHandle_t pviQueueData1 = NULL;
;piQueueHandle_t pviQueueSensorToMang = NULL;
;piQueueHandle_t pviQueueMangToSensor = NULL;
;//piQueueHandle_t pviQueueMangToSDCard = NULL;
;
;piQueueHandle_t pviQueueMangToConfig = NULL;
;piQueueHandle_t pviQueueDeviceToMang = NULL;
;
;itaskHandel_t piDeviceTask = NULL;
;iData_t viBuffData;
;iData_t viRXData;
;iData_t viTXData;
;
;iDataMini_t viDataReport;
;iDataMini_t viStatusReport;
;iDataMini_t viEventReport;
;
;/*============================================================*/
;void main(void){
; 0000 0045 void main(void){

	.CSEG
_main:
; 0000 0046     //int a = 6;
; 0000 0047     //int b;
; 0000 0048     //unsigned int viLenData = 0;
; 0000 0049     //char *pviBufferU0;
; 0000 004A     //char *pviPointBufferU0;
; 0000 004B     //int indexReadUart0 = 0;
; 0000 004C     //char * pch;
; 0000 004D     //int viConnect = 0;
; 0000 004E     //char *b2;
; 0000 004F 
; 0000 0050 //    unsigned char fileNameCreate[20];
; 0000 0051 //    //char fileNameCreate1[] = "FileFF";
; 0000 0052 //    int retFile = 0;
; 0000 0053 //    char viPath[20]="0:/";
; 0000 0054 //    DIR pviDir;
; 0000 0055 //    FIL pviFilePtr;
; 0000 0056 //    iChar_t viDirectoryPath[] = "0:/DATA";
; 0000 0057 //    iChar_t viFileName[] = "0:./data7.txt";
; 0000 0058 //    iChar_t viCurrentDirect[50];
; 0000 0059 //    iChar_t viDataBuffTest[100] = "Data Test 11111119999999999999999999999999999";               //N=not send
; 0000 005A     //FRESULT
; 0000 005B 
; 0000 005C 
; 0000 005D     int err,i=0,k=0,res,last_status;
; 0000 005E     do{ err = initial_system();  }while(err);
	SBIW R28,4
;	err -> R16,R17
;	i -> R18,R19
;	k -> R20,R21
;	res -> Y+2
;	last_status -> Y+0
	__GETWRN 18,19,0
	__GETWRN 20,21,0
_0x4:
	RCALL _initial_system
	MOVW R16,R30
	MOV  R0,R16
	OR   R0,R17
	BRNE _0x4
; 0000 005F 
; 0000 0060     printDebug("[main]Initial...\r\n");
	__POINTD1FN _0x0,0
	CALL SUBOPT_0x0
; 0000 0061 
; 0000 0062 //    pviQueueData1 = iQueueCreate(10,sizeof(int));
; 0000 0063 //	printDebug("<main>pviQueueData1 adr : %p\r\n",pviQueueData1);
; 0000 0064 //
; 0000 0065 //    if(iQueueSend(pviQueueData1,&a)==1){
; 0000 0066 //
; 0000 0067 //	}else{
; 0000 0068 //		printDebug("<main>data can not sent a data(b) to pviQueueData1.\r\n");
; 0000 0069 //	}
; 0000 006A //
; 0000 006B //    if(iQueueReceive(pviQueueData1,&b)==1){
; 0000 006C //        printDebug("<main>data : %d\r\n",b);
; 0000 006D //	}else{
; 0000 006E //		printDebug("<main>data can not sent a data(b) to pviQueueData1.\r\n");
; 0000 006F //	}
; 0000 0070     delay_ms(5000);
	LDI  R26,LOW(5000)
	LDI  R27,HIGH(5000)
	CALL _delay_ms
; 0000 0071     delay_ms(5000);
	LDI  R26,LOW(5000)
	LDI  R27,HIGH(5000)
	CALL _delay_ms
; 0000 0072     //delay_ms(5000);
; 0000 0073     iWizReadConfig();
	CALL _iWizReadConfig
; 0000 0074 //    while(1){
; 0000 0075 //     #asm("wdr")
; 0000 0076 //     delay_ms(1000);
; 0000 0077 //    }
; 0000 0078 
; 0000 0079 //    ETH_switchMode((unsigned char) MODE_NORM);
; 0000 007A     if(iLanInit()){
	CALL _iLanInit
	CPI  R30,0
	BREQ _0x6
; 0000 007B         printDebug("[main]Lan Connected.\r\n");
	__POINTD1FN _0x0,19
	CALL SUBOPT_0x0
; 0000 007C     }else{
	RJMP _0x7
_0x6:
; 0000 007D         printDebug("[main]Lan Fail.\r\n");
	__POINTD1FN _0x0,42
	CALL SUBOPT_0x0
; 0000 007E         iLanInit();
	CALL _iLanInit
; 0000 007F     }
_0x7:
; 0000 0080 
; 0000 0081     iInitSDCard();
	CALL _iInitSDCard
; 0000 0082 
; 0000 0083     ///////////////create queue////////////////
; 0000 0084     pviQueueSensorToMang = iQueueCreate(2,sizeof(iSensorData_t));
	LDI  R30,LOW(2)
	LDI  R31,HIGH(2)
	CALL SUBOPT_0x1
	CALL _iQueueCreate
	STS  _pviQueueSensorToMang,R30
	STS  _pviQueueSensorToMang+1,R31
; 0000 0085     if(pviQueueSensorToMang == (int *)(-1)){
	LDS  R26,_pviQueueSensorToMang
	LDS  R27,_pviQueueSensorToMang+1
	CPI  R26,LOW(0xFFFF)
	LDI  R30,HIGH(0xFFFF)
	CPC  R27,R30
	BRNE _0x8
; 0000 0086        printDebug("[main],pviQueueSensorToMang can not create.\r\n");
	__POINTD1FN _0x0,60
	RJMP _0x14
; 0000 0087     }else{
_0x8:
; 0000 0088        printDebug("[main],pviQueueSensorToMang can create.\r\n");
	__POINTD1FN _0x0,106
_0x14:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0000 0089 //       printDebug("[main],Queue->Quantity(%d).\r\n",((iQueue_t *)pviQueueSensorToMang)->itemCount);
; 0000 008A     }
; 0000 008B 
; 0000 008C     pviQueueMangToConfig = iQueueCreate(2,sizeof(iConfigFormat_t));
	LDI  R30,LOW(2)
	LDI  R31,HIGH(2)
	CALL SUBOPT_0x3
	CALL _iQueueCreate
	STS  _pviQueueMangToConfig,R30
	STS  _pviQueueMangToConfig+1,R31
; 0000 008D     if(pviQueueMangToConfig == (int *)(-1)){
	LDS  R26,_pviQueueMangToConfig
	LDS  R27,_pviQueueMangToConfig+1
	CPI  R26,LOW(0xFFFF)
	LDI  R30,HIGH(0xFFFF)
	CPC  R27,R30
	BRNE _0xA
; 0000 008E        printDebug("[main],pviQueueMangToConfig can not create.\r\n");
	__POINTD1FN _0x0,148
	RJMP _0x15
; 0000 008F     }else{
_0xA:
; 0000 0090        printDebug("[main],pviQueueMangToConfig can create.\r\n");
	__POINTD1FN _0x0,194
_0x15:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0000 0091     }
; 0000 0092 
; 0000 0093     pviQueueDeviceToMang = iQueueCreate(1,sizeof(unsigned char));
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CALL SUBOPT_0x4
	CALL _iQueueCreate
	STS  _pviQueueDeviceToMang,R30
	STS  _pviQueueDeviceToMang+1,R31
; 0000 0094     if(pviQueueDeviceToMang == (int *)(-1)){
	LDS  R26,_pviQueueDeviceToMang
	LDS  R27,_pviQueueDeviceToMang+1
	CPI  R26,LOW(0xFFFF)
	LDI  R30,HIGH(0xFFFF)
	CPC  R27,R30
	BRNE _0xC
; 0000 0095        printDebug("[main],pviQueueDeviceToMang can not create.\r\n");
	__POINTD1FN _0x0,236
	RJMP _0x16
; 0000 0096     }else{
_0xC:
; 0000 0097        printDebug("[main],pviQueueDeviceToMang can create.\r\n");
	__POINTD1FN _0x0,282
_0x16:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0000 0098     }
; 0000 0099 
; 0000 009A //    pviQueueMangToSensor = iQueueCreate(10,sizeof(int));
; 0000 009B //    if(pviQueueMangToSensor == (int *)(-1)){
; 0000 009C //       printDebug("<main>pviQueueSensorToMang can not create.\r\n");
; 0000 009D //    }
; 0000 009E 
; 0000 009F     ///////////////create task////////////////
; 0000 00A0     piDeviceTask = iTaskCreate(logTask,"logger",5);
	__POINTD1M _logTask
	CALL __PUTPARD1
	__POINTW1MN _0xE,0
	CALL SUBOPT_0x5
; 0000 00A1     if(piDeviceTask){
	BREQ _0xF
; 0000 00A2         printDebug("<main>logTask addr : %p\r\n",piDeviceTask);
	__POINTD1FN _0x0,331
	CALL SUBOPT_0x6
; 0000 00A3     }
; 0000 00A4 
; 0000 00A5     piDeviceTask = iTaskCreate(dataAndStatusTask,"dataAndStatus",5);
_0xF:
	__POINTD1M _dataAndStatusTask
	CALL __PUTPARD1
	__POINTW1MN _0xE,7
	CALL SUBOPT_0x5
; 0000 00A6     if(piDeviceTask){
	BREQ _0x10
; 0000 00A7         printDebug("<main>sensorTask addr : %p\r\n",piDeviceTask);
	__POINTD1FN _0x0,371
	CALL SUBOPT_0x6
; 0000 00A8     }
; 0000 00A9 //    printDebug("[main],Queue->Quantity(%d).\r\n",((iQueue_t *)pviQueueSensorToMang)->itemCount);
; 0000 00AA     piDeviceTask = iTaskCreate(managerTask,"mang",5);
_0x10:
	__POINTD1M _managerTask
	CALL __PUTPARD1
	__POINTW1MN _0xE,21
	CALL SUBOPT_0x5
; 0000 00AB     if(piDeviceTask){
	BREQ _0x11
; 0000 00AC         printDebug("<main>managerTask addr : %p\r\n",piDeviceTask);
	__POINTD1FN _0x0,405
	CALL SUBOPT_0x6
; 0000 00AD     }
; 0000 00AE 
; 0000 00AF 
; 0000 00B0 //
; 0000 00B1 //    piDeviceTask = iTaskCreate(debugTask,"debug",5);
; 0000 00B2 //    if(piDeviceTask){
; 0000 00B3 //        printDebug("<main>debugTask addr : %p\r\n",&piDeviceTask);
; 0000 00B4 //    }
; 0000 00B5 //
; 0000 00B6 //    piDeviceTask = iTaskCreate(communicateTask,"commu",5);
; 0000 00B7 //    if(piDeviceTask){
; 0000 00B8 //        printDebug("<main>communicateTask addr : %p\r\n",&piDeviceTask);
; 0000 00B9 //    }
; 0000 00BA //
; 0000 00BB //    piDeviceTask = iTaskCreate(interruptTask,"intp",10);
; 0000 00BC //    if(piDeviceTask){
; 0000 00BD //        printDebug("<main>interruptTask addr : %p\r\n",&piDeviceTask);
; 0000 00BE //    }
; 0000 00BF //
; 0000 00C0 //    piDeviceTask = iTaskCreate(deviceTask,"device",5);
; 0000 00C1 //    if(piDeviceTask){
; 0000 00C2 //        printDebug("<main>deviceTask addr : %p\r\n",&piDeviceTask);
; 0000 00C3 //    }
; 0000 00C4 
; 0000 00C5     piDeviceTask = iTaskCreate(eventTask,"event",5);
_0x11:
	__POINTD1M _eventTask
	CALL __PUTPARD1
	__POINTW1MN _0xE,26
	CALL SUBOPT_0x5
; 0000 00C6     if(piDeviceTask){
	BREQ _0x12
; 0000 00C7         printDebug("<main>eventTask addr : %p\r\n",piDeviceTask);
	__POINTD1FN _0x0,441
	CALL SUBOPT_0x6
; 0000 00C8     }
; 0000 00C9 
; 0000 00CA    startSchedulerTask();
_0x12:
	CALL _startSchedulerTask
; 0000 00CB }
	ADIW R28,4
_0x13:
	RJMP _0x13

	.DSEG
_0xE:
	.BYTE 0x20
;#include <delay.h>
;#include <stdlib.h>
;#include <i2c.h>
;#include "initial_sys.h"
;#include "uart.h"
;#include "timer.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "io.h"
;#include "ds1672.h"
;#include "config.h"
;//#include "oled.h"
;#include "adc.h"
;#include "debug.h"
;#include "log.h"
;#include "sdcard.h"
;
;/*============================================================*/
;int initial_system(void)
; 0001 0012 {

	.CSEG
_initial_system:
; 0001 0013     int res=0;
; 0001 0014 
; 0001 0015     // Crystal Oscillator division factor: 1
; 0001 0016     #pragma optsize-
; 0001 0017     CLKPR=0x80;
	ST   -Y,R17
	ST   -Y,R16
;	res -> R16,R17
	__GETWRN 16,17,0
	LDI  R30,LOW(128)
	STS  97,R30
; 0001 0018     CLKPR=0x00;
	LDI  R30,LOW(0)
	STS  97,R30
; 0001 0019     #ifdef _OPTIMIZE_SIZE_
; 0001 001A     #pragma optsize+
; 0001 001B     #endif
; 0001 001C 
; 0001 001D     init_uart();
	RCALL _init_uart
; 0001 001E 
; 0001 001F     if(MCUSR & (1<<PORF)){
	IN   R30,0x34
	SBRS R30,0
	RJMP _0x20003
; 0001 0020         printDebug("\r\nPower-on Reset\r\n");
	__POINTD1FN _0x20000,0
	CALL SUBOPT_0x0
; 0001 0021         MCUSR &= ~(1<<PORF);
	IN   R30,0x34
	ANDI R30,0xFE
	OUT  0x34,R30
; 0001 0022     }
; 0001 0023     if(MCUSR & (1<<EXTRF)){
_0x20003:
	IN   R30,0x34
	SBRS R30,1
	RJMP _0x20004
; 0001 0024         printDebug("\r\nExternal Reset\r\n");
	__POINTD1FN _0x20000,19
	CALL SUBOPT_0x0
; 0001 0025         MCUSR &= ~(1<<EXTRF);
	IN   R30,0x34
	ANDI R30,0xFD
	OUT  0x34,R30
; 0001 0026     }
; 0001 0027     if(MCUSR & (1<<BORF)){
_0x20004:
	IN   R30,0x34
	SBRS R30,2
	RJMP _0x20005
; 0001 0028         printDebug("\r\nBrown-out Reset\r\n");
	__POINTD1FN _0x20000,38
	CALL SUBOPT_0x0
; 0001 0029         MCUSR &= ~(1<<BORF);
	IN   R30,0x34
	ANDI R30,0xFB
	OUT  0x34,R30
; 0001 002A     }
; 0001 002B     if(MCUSR & (1<<WDRF)){
_0x20005:
	IN   R30,0x34
	SBRS R30,3
	RJMP _0x20006
; 0001 002C         printDebug("\r\nWatchdog Reset\r\n");
	__POINTD1FN _0x20000,58
	CALL SUBOPT_0x0
; 0001 002D         MCUSR &= ~(1<<WDRF);
	IN   R30,0x34
	ANDI R30,0XF7
	OUT  0x34,R30
; 0001 002E     }
; 0001 002F     if(MCUSR & (1<<JTRF)){
_0x20006:
	IN   R30,0x34
	SBRS R30,4
	RJMP _0x20007
; 0001 0030         printDebug("\r\nJTAG Reset\r\n");
	__POINTD1FN _0x20000,77
	CALL SUBOPT_0x0
; 0001 0031         MCUSR &= ~(1<<JTRF);
	IN   R30,0x34
	ANDI R30,0xEF
	OUT  0x34,R30
; 0001 0032     }
; 0001 0033 
; 0001 0034     // -------- Peripheral Initialize ----------- //
; 0001 0035     init_io();
_0x20007:
	CALL _init_io
; 0001 0036     init_i2c();
	RCALL _init_i2c
; 0001 0037     init_spi();
	RCALL _init_spi
; 0001 0038     init_adc();
	CALL _init_adc
; 0001 0039     init_timer();
	CALL _init_timer
; 0001 003A     init_common();
	RCALL _init_common
; 0001 003B 
; 0001 003C     enable_interrupt(2);
	CALL SUBOPT_0x7
	CALL _enable_interrupt
; 0001 003D 
; 0001 003E     delay_ms(500);
	LDI  R26,LOW(500)
	LDI  R27,HIGH(500)
	CALL _delay_ms
; 0001 003F 
; 0001 0040     // -------- Module Initialize ----------- //
; 0001 0041     BUZZER = 0;                 // BUZZER Off.
	CBI  0xE,7
; 0001 0042     init_RTC();         delay_ms(100);
	CALL _init_RTC
	CALL SUBOPT_0x8
; 0001 0043     //init_oled();        delay_ms(100);
; 0001 0044     adc_init_read();            //getting first ADC to initial
	CALL _adc_init_read
; 0001 0045 
; 0001 0046     enable_interrupt(1);        // -- adc_sampling
	LDI  R26,LOW(1)
	CALL SUBOPT_0x9
; 0001 0047     enable_interrupt(3);        // -- 1 sec timer
	LDI  R26,LOW(3)
	CALL SUBOPT_0x9
; 0001 0048     enable_interrupt(4);        // -- 0.5 sec timer
	LDI  R26,LOW(4)
	CALL SUBOPT_0x9
; 0001 0049 
; 0001 004A     //getAllConfig();
; 0001 004B 
; 0001 004C 
; 0001 004D     // -- Initialize Complete -- //
; 0001 004E     /*bongkot*/
; 0001 004F     //playBeep();
; 0001 0050     showLedInitComplete();
	RCALL _showLedInitComplete
; 0001 0051     showDebugInitComplete();
	RCALL _showDebugInitComplete
; 0001 0052 
; 0001 0053     if(SD_init() == 0)
	CALL _SD_init
	SBIW R30,0
	BREQ _0x2000B
; 0001 0054     {
; 0001 0055 //        if(LOG_init() < 0)
; 0001 0056 //        {
; 0001 0057 //            // -- log status = error -- //
; 0001 0058 //            printDebug("<initial_system> LOG_init() failed\r\n");
; 0001 0059 //        }
; 0001 005A 
; 0001 005B         // -- log status = ok -- //
; 0001 005C     }
; 0001 005D     else
; 0001 005E     {
; 0001 005F         // -- sd status = error -- //
; 0001 0060         printDebug("<initial_system> SD_init() failed\r\n");
	__POINTD1FN _0x20000,92
	CALL SUBOPT_0x0
; 0001 0061     }
_0x2000B:
; 0001 0062 
; 0001 0063     srand((unsigned int)raw_rtc + (unsigned int)(read_adc(8) * 13));        // set random seed
	LDI  R26,LOW(8)
	CALL _read_adc
	LDI  R26,LOW(13)
	LDI  R27,HIGH(13)
	CALL __MULW12U
	LDS  R26,_raw_rtc
	LDS  R27,_raw_rtc+1
	ADD  R26,R30
	ADC  R27,R31
	CALL _srand
; 0001 0064 
; 0001 0065     // -------- Configuration Initialize ----------- //
; 0001 0066 //    readConfig();
; 0001 0067 //    initAlarm();        //delay_ms(100);
; 0001 0068 //
; 0001 0069 //    if(init_logfile() < 0){
; 0001 006A //        printDebug("init_logdata() failed\r\n");
; 0001 006B //        return -1;
; 0001 006C //    }
; 0001 006D 
; 0001 006E 
; 0001 006F     return res;
	MOVW R30,R16
	JMP  _0x20E003D
; 0001 0070 }
;/*============================================================*/
;void init_i2c(void)
; 0001 0073 {
_init_i2c:
; 0001 0074     // I2C Bus initialization
; 0001 0075     i2c_init();
	CALL _i2c_init
; 0001 0076 }
	RET
;/*============================================================*/
;void init_spi(void)
; 0001 0079 {
_init_spi:
; 0001 007A     // SPI initialization
; 0001 007B     // SPI Type: Master
; 0001 007C     // SPI Clock Rate: 2000.000 kHz
; 0001 007D     // SPI Clock Phase: Cycle Start
; 0001 007E     // SPI Clock Polarity: Low
; 0001 007F     // SPI Data Order: MSB First
; 0001 0080     SPCR=0x50;
	LDI  R30,LOW(80)
	OUT  0x2C,R30
; 0001 0081     SPSR=0x00;
	LDI  R30,LOW(0)
	OUT  0x2D,R30
; 0001 0082 }
	RET
;/*============================================================*/
;void init_common(void)
; 0001 0085 {
_init_common:
; 0001 0086     // External Interrupt(s) initialization
; 0001 0087     // INT0: Off, INT1: Off, INT2: Off, INT3: Off, INT4: Off, INT5: Off, INT6: Off, INT7: Off
; 0001 0088     EICRA=0x00;
	LDI  R30,LOW(0)
	STS  105,R30
; 0001 0089     EICRB=0x00;
	STS  106,R30
; 0001 008A     EIMSK=0x00;
	OUT  0x1D,R30
; 0001 008B 
; 0001 008C     PCMSK0=0x00;
	STS  107,R30
; 0001 008D     PCMSK1=0x00;
	STS  108,R30
; 0001 008E     PCMSK2=0x00;
	STS  109,R30
; 0001 008F     PCICR=0x00;
	STS  104,R30
; 0001 0090 
; 0001 0091     // Analog Comparator initialization
; 0001 0092     // Analog Comparator: Off
; 0001 0093     // Analog Comparator Input Capture by Timer/Counter 1: Off
; 0001 0094     ACSR=0x80;
	LDI  R30,LOW(128)
	OUT  0x30,R30
; 0001 0095     ADCSRB=0x00;
	LDI  R30,LOW(0)
	STS  123,R30
; 0001 0096     DIDR1=0x00;
	STS  127,R30
; 0001 0097 
; 0001 0098     // TWI initialization
; 0001 0099     // TWI disabled
; 0001 009A     TWCR=0x00;
	STS  188,R30
; 0001 009B }
	RET
;/*============================================================*/
;void playBeep(void)
; 0001 009E {
; 0001 009F     BUZZER = 1;                                     // Buzzer ON Starting
; 0001 00A0     delay_ms(200);
; 0001 00A1     BUZZER = 0;
; 0001 00A2 }
;/*============================================================*/
;void showDebugInitComplete(void)
; 0001 00A5 {
_showDebugInitComplete:
; 0001 00A6 //    struct rtc_structure time;
; 0001 00A7 //    struct prop_cnfg_st properties_config;
; 0001 00A8 //
; 0001 00A9 //    printDebug("Initial Device Completed at - ");
; 0001 00AA //    RTC_getDateTime(&time,properties_config.timeZone);
; 0001 00AB //    printDebug("%04d-%02d-%02d %02d:%02d:%02d\r\n",
; 0001 00AC //            time.year,time.month,time.date,time.hour,time.min,time.sec);
; 0001 00AD }
	RET
;/*============================================================*/
;void showLedInitComplete(void)
; 0001 00B0 {
_showLedInitComplete:
; 0001 00B1     LED_ON(BIT_LED_ALARM);
	LDS  R30,258
	ANDI R30,0xBF
	CALL SUBOPT_0xA
; 0001 00B2     delay_ms(200);
; 0001 00B3 
; 0001 00B4     LED_ON(BIT_LED_LINK);
	ANDI R30,0xDF
	CALL SUBOPT_0xA
; 0001 00B5     delay_ms(200);
; 0001 00B6 
; 0001 00B7     LED_ON(BIT_LED_TEMP);
	ANDI R30,0xEF
	CALL SUBOPT_0xA
; 0001 00B8     delay_ms(200);
; 0001 00B9 
; 0001 00BA     LED_ON(BIT_LED_PWR);
	ANDI R30,0XF7
	CALL SUBOPT_0xA
; 0001 00BB     delay_ms(200);
; 0001 00BC 
; 0001 00BD     LED_OFF(BIT_LED_PWR|BIT_LED_TEMP|BIT_LED_LINK|BIT_LED_ALARM);
	ORI  R30,LOW(0x78)
	CALL SUBOPT_0xA
; 0001 00BE     delay_ms(200);
; 0001 00BF 
; 0001 00C0     LED_ON(BIT_LED_PWR);
	ANDI R30,0XF7
	STS  258,R30
; 0001 00C1     delay_ms(50);
	CALL SUBOPT_0xB
; 0001 00C2 }
	RET
;/*============================================================*/
;
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <stdio.h>
;#include <string.h>
;#include <ctype.h>
;#include <delay.h>
;#include "uart.h"
;#include "io.h"
;#include "ethcomm.h"
;#include "wiz100rs.h"
;#include "interruptTask.h"
;
;/*============================================================*/
;char flag_PackageTerminate3 = 0;
;
;flash unsigned char charHeader = '$';
;flash unsigned char charTerminate = '#';
;
;bit                 flag_oled_ack      = 0;
;
;unsigned char       rxPackageIndex3;
;unsigned char       rxPackage3[64];
;unsigned char       rxPackageIndexCount3;
;/*============================================================*/
;// USART0 Receiver buffer
;//char rx_buffer0[RX_BUFFER_SIZE0];
;char rx_buffer0[2];
;
;unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
;
;// This flag is set on USART0 Receiver buffer overflow
;bit rx_buffer_overflow0;
;
;unsigned char       configRd[CONF_READ_BUFFER];      // for reading config
;int                 configLen=0;
;
;char                config_start    = 0;
;char                config_ready    = 0;    // 1 = failed, 2 = success
;char                config_end      = 0;
;char                config_response = 0;
;
;unsigned int    rxBeginCount     = 0;
;char            rxComplete  = 0;
;
;char rx0Buffer[400];
;unsigned int index0Buffer = 0;
;int flagDataUart0 = 0;
;int flagCountStart0 = 0;
;//char rx0ConnectBuff[50];
;unsigned int rx0IndexWriteConn = 0;
;//int flagConnected0 = 0;
;
;char uart0LockAccess = 0;
;
;extern piInterrupt_t pviUart0TimeOut;
;extern int (*piWizCallBack)(char *,unsigned int);
;//extern iHTTP_t iHTTPStatus;
;//iUartQueue_t iUartQueue = {0,0,0,511};
;
;// USART0 Receiver interrupt service routine
;interrupt [USART0_RXC] void usart0_rx_isr(void)
; 0002 003D {

	.CSEG
_usart0_rx_isr:
	CALL SUBOPT_0xC
; 0002 003E 
; 0002 003F     char status,data;
; 0002 0040     int iRetuen = 0;
; 0002 0041 
; 0002 0042 //    if((iUartQueue.ToWrite >= iUartQueue.ToRead) || iUartQueue.){
; 0002 0043 //
; 0002 0044 //    }
; 0002 0045     status=UCSR0A;
	CALL SUBOPT_0xD
;	status -> R17
;	data -> R16
;	iRetuen -> R18,R19
	LDS  R17,192
; 0002 0046     data=UDR0;
	LDS  R16,198
; 0002 0047 
; 0002 0048     if((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0){
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
	BREQ PC+3
	JMP _0x40003
; 0002 0049 //        if(data == '>'){
; 0002 004A //            rx0IndexWriteConn = 0;
; 0002 004B //            rx0ConnectBuff[rx0IndexWriteConn++] = data;
; 0002 004C //        }else if(rx0IndexWriteConn > 0){
; 0002 004D //            rx0ConnectBuff[rx0IndexWriteConn++] = data;
; 0002 004E //            if(rx0IndexWriteConn >=50){
; 0002 004F //               //function callback
; 0002 0050 //
; 0002 0051 //               piWizCallBack = &iWizStatusConnected;
; 0002 0052 //               piWizCallBack(rx0ConnectBuff,rx0IndexWriteConn);
; 0002 0053 //               rx0IndexWriteConn = 0;
; 0002 0054 //            }
; 0002 0055 //        }
; 0002 0056 
; 0002 0057         //iWizRXMode = 5;
; 0002 0058         //putchar3(data);
; 0002 0059         if(iWizRXMode == WIZ_RX_STAT_MODE){
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x1)
	BRNE _0x40004
; 0002 005A             if(index0Buffer == 0){
	LDS  R30,_index0Buffer
	LDS  R31,_index0Buffer+1
	SBIW R30,0
	BRNE _0x40005
; 0002 005B                  flagCountStart0 = 0;
	CLR  R10
	CLR  R11
; 0002 005C             }
; 0002 005D 
; 0002 005E             if(data == '>'){
_0x40005:
	CPI  R16,62
	BRNE _0x40006
; 0002 005F                 flagCountStart0 = 1;
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	MOVW R10,R30
; 0002 0060             }
; 0002 0061 
; 0002 0062             if(flagCountStart0 == 1){
_0x40006:
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CP   R30,R10
	CPC  R31,R11
	BRNE _0x40007
; 0002 0063                 putchar3(data);
	MOV  R26,R16
	RCALL _putchar3
; 0002 0064                 rx0Buffer[index0Buffer++] = data;
	CALL SUBOPT_0xE
; 0002 0065                 putchar3(data);
; 0002 0066                 if(index0Buffer >= 400){
	BRLO _0x40008
; 0002 0067                     //if full will disable interrupt
; 0002 0068                     //UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0069                     send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	LDI  R30,LOW(3)
	ST   -Y,R30
	__POINTW2MN _0x40009,0
	CALL SUBOPT_0xF
; 0002 006A                     send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
	__POINTW2MN _0x40009,43
	CALL SUBOPT_0xF
; 0002 006B                     send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	__POINTW2MN _0x40009,81
	CALL SUBOPT_0x10
; 0002 006C                     index0Buffer = 0;
; 0002 006D                 }
; 0002 006E             }
_0x40008:
; 0002 006F 
; 0002 0070         }else if(iWizRXMode == WIZ_RX_DATA_MODE){
_0x40007:
	RJMP _0x4000A
_0x40004:
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x2)
	BRNE _0x4000B
; 0002 0071             rx0Buffer[index0Buffer++] = data;
	CALL SUBOPT_0xE
; 0002 0072             putchar3(data);
; 0002 0073             if(index0Buffer >= 400){
	BRLO _0x4000C
; 0002 0074                 //if full will disable interrupt
; 0002 0075                 //UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0076                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	LDI  R30,LOW(3)
	ST   -Y,R30
	__POINTW2MN _0x40009,124
	CALL SUBOPT_0xF
; 0002 0077                 send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
	__POINTW2MN _0x40009,167
	CALL SUBOPT_0xF
; 0002 0078                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	__POINTW2MN _0x40009,205
	CALL SUBOPT_0x10
; 0002 0079                 index0Buffer = 0;
; 0002 007A             }
; 0002 007B 
; 0002 007C         }else if(iWizRXMode == WIZ_CONFIG_READ_MODE){
_0x4000C:
	RJMP _0x4000D
_0x4000B:
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x4)
	BRNE _0x4000E
; 0002 007D            rx0Buffer[index0Buffer++] = data;
	LDI  R26,LOW(_index0Buffer)
	LDI  R27,HIGH(_index0Buffer)
	CALL SUBOPT_0x11
	SBIW R30,1
	SUBI R30,LOW(-_rx0Buffer)
	SBCI R31,HIGH(-_rx0Buffer)
	ST   Z,R16
; 0002 007E            if(index0Buffer >= 400){
	CALL SUBOPT_0x12
	CPI  R26,LOW(0x190)
	LDI  R30,HIGH(0x190)
	CPC  R27,R30
	BRLO _0x4000F
; 0002 007F                 //if full will disable interrupt
; 0002 0080                 //UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0081                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	LDI  R30,LOW(3)
	ST   -Y,R30
	__POINTW2MN _0x40009,248
	CALL SUBOPT_0xF
; 0002 0082                 send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
	__POINTW2MN _0x40009,291
	CALL SUBOPT_0xF
; 0002 0083                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	__POINTW2MN _0x40009,329
	CALL SUBOPT_0x10
; 0002 0084                 index0Buffer = 0;
; 0002 0085             }
; 0002 0086         }
_0x4000F:
; 0002 0087 
; 0002 0088 
; 0002 0089         //putchar3(data);
; 0002 008A     }
_0x4000E:
_0x4000D:
_0x4000A:
; 0002 008B 
; 0002 008C      //putchar3(data);
; 0002 008D 
; 0002 008E //    if(iWizRXMode == WIZ_RX_STAT_MODE){
; 0002 008F //        if(data == '>'){
; 0002 0090 //           //flagDataUart0 = 1;
; 0002 0091 //           iWizStatus = WIZ_STAT_UPDATE;
; 0002 0092 //        }else if(data != '>' && iWizStatus != WIZ_STAT_UPDATE){
; 0002 0093 //           putchar3(data);
; 0002 0094 //        }
; 0002 0095 //
; 0002 0096 //
; 0002 0097 //
; 0002 0098 //        if(iWizStatus == WIZ_STAT_UPDATE){
; 0002 0099 //           rx0Buffer[index0Buffer++] = data;
; 0002 009A //           if(index0Buffer == 512){
; 0002 009B //              index0Buffer = 0;
; 0002 009C //           }
; 0002 009D //           if(data == 0x0D){
; 0002 009E //                //callback check status
; 0002 009F //               //callBackChekStat();
; 0002 00A0 //               piWizCallBack = &iWizCBChekStat;
; 0002 00A1 //               piWizCallBack((char * const )rx0Buffer,index0Buffer);
; 0002 00A2 //               iWizStatus = WIZ_STAT_READ_SUCCESS;
; 0002 00A3 //               index0Buffer = 0;
; 0002 00A4 //           }
; 0002 00A5 //        }
; 0002 00A6 //    }else if(iWizRXMode == WIZ_RX_DATA_MODE){
; 0002 00A7 //        rx0Buffer[index0Buffer++] = data;
; 0002 00A8 //        if(index0Buffer == 512){
; 0002 00A9 //           index0Buffer = 0;
; 0002 00AA //        }
; 0002 00AB //        if(data == 0x0A){
; 0002 00AC //           //check http -> response code
; 0002 00AD //           if(iHTTPStatus.responseCode != WIZ_HTTP_RES_CODE_OK){
; 0002 00AE //               piWizCallBack = &iWizCBCheckHTTPResCode;
; 0002 00AF //               iRetuen = piWizCallBack((char * const )rx0Buffer,index0Buffer);
; 0002 00B0 //               if(iRetuen == WIZ_HTTP_RES_CODE_OK){
; 0002 00B1 //                   iHTTPStatus.responseCode = WIZ_HTTP_RES_CODE_OK;
; 0002 00B2 //                   //index0Buffer = 0;
; 0002 00B3 //               }else{
; 0002 00B4 //                   iHTTPStatus.responseCode = WIZ_HTTP_RES_CODE_UNKNOW;
; 0002 00B5 //                   index0Buffer = 0;
; 0002 00B6 //               }
; 0002 00B7 //           }
; 0002 00B8 ////           else if(iHTTPStatus.responseCode == WIZ_HTTP_RES_CODE_OK && iHTTPStatus.contentLength == 0){
; 0002 00B9 ////                  //iHTTPStatus.contentLength
; 0002 00BA ////                  piWizCallBack = &iWizCBCheckHTTPContextLen;
; 0002 00BB ////                  iRetuen = piWizCallBack((char * const )rx0Buffer,index0Buffer);
; 0002 00BC ////                  if(iRetuen != 1){
; 0002 00BD ////                     index0Buffer = 0;
; 0002 00BE ////                  }
; 0002 00BF //////                  if(iRetuen == WIZ_HTTP_CONTEXT_LEN_NOTFOUND){
; 0002 00C0 //////                     index0Buffer = 0;
; 0002 00C1 //////                  }
; 0002 00C2 //////                  else if((iRetuen != WIZ_HTTP_CONTEXT_LEN_LESS) && (iRetuen != WIZ_HTTP_CONTEXT_LEN_OVER)){
; 0002 00C3 //////                      iHTTPStatus.contentLength = iRetuen;
; 0002 00C4 //////                      //index0Buffer = 0;
; 0002 00C5 //////                  }else{
; 0002 00C6 //////                      //index0Buffer = 0;
; 0002 00C7 //////                  }
; 0002 00C8 ////           }
; 0002 00C9 //        }
; 0002 00CA //    }
; 0002 00CB //
; 0002 00CC 
; 0002 00CD 
; 0002 00CE 
; 0002 00CF //    if(uart0LockAccess != UART0_LOCK_ACCESS){
; 0002 00D0 //        //putchar3(data);
; 0002 00D1 //
; 0002 00D2 //        if(data=='<'){   //'<' = start config delimeter
; 0002 00D3 //          //call function pointer noti that end of data
; 0002 00D4 //          //copy data from buffer
; 0002 00D5 ////           if(rx0Buffer[(rxBeginCount-1)] == 0x0A){
; 0002 00D6 ////                  //model wiz100rs and version display
; 0002 00D7 ////                  pfiWiz100rs = &iWizRXdata;
; 0002 00D8 ////                  pfiWiz100rs();
; 0002 00D9 ////                  //rxBeginCount = 0;
; 0002 00DA ////           }else if(rx0Buffer[(rxBeginCount-1)] == 0x0D){
; 0002 00DB ////                  //model wiz100rs config data display
; 0002 00DC ////                  //rxBeginCount = 0;
; 0002 00DD ////           }
; 0002 00DE //
; 0002 00DF ////            putchar3('k');
; 0002 00E0 //            //timeout start
; 0002 00E1 //
; 0002 00E2 //
; 0002 00E3 //            rxBeginCount = 0;
; 0002 00E4 //            rx0Buffer[rxBeginCount] = data;
; 0002 00E5 //            //putchar3(data);
; 0002 00E6 //            rxBeginCount++;
; 0002 00E7 //        }
; 0002 00E8 //
; 0002 00E9 //        if(rxBeginCount > 0){
; 0002 00EA //            if(data==0x0A){
; 0002 00EB //                rx0Buffer[rxBeginCount] = data;
; 0002 00EC //               // putchar3(data);
; 0002 00ED //                pfiWiz100rs = &iWizRXdata;
; 0002 00EE //                pfiWiz100rs();
; 0002 00EF //                rxBeginCount = 0;
; 0002 00F0 //                //pviUart0TimeOut = rxBeginCount;
; 0002 00F1 //                pviUart0TimeOut = 1;
; 0002 00F2 //            }else{
; 0002 00F3 //                rx0Buffer[rxBeginCount] = data;
; 0002 00F4 //              //  putchar3(data);
; 0002 00F5 //                rxBeginCount++;
; 0002 00F6 //                //pviUart0TimeOut = rxBeginCount;
; 0002 00F7 //                pviUart0TimeOut = 1;
; 0002 00F8 //            }
; 0002 00F9 //        }
; 0002 00FA //
; 0002 00FB //
; 0002 00FC //        if(rxBeginCount==RX_BUFFER_SIZE0){
; 0002 00FD //           rxBeginCount = 0;
; 0002 00FE //           //call function pointer noti that buffer over flow
; 0002 00FF //        }
; 0002 0100 //    }
; 0002 0101 
; 0002 0102 
; 0002 0103 
; 0002 0104 
; 0002 0105 
; 0002 0106 //    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
; 0002 0107 //    {   ETH_current_mode  == MODE_CONF;
; 0002 0108 //        if(ETH_current_mode != MODE_CONF)
; 0002 0109 //        {
; 0002 010A //        //bongkot edit;
; 0002 010B //            //putchar3(data);
; 0002 010C //
; 0002 010D //
; 0002 010E //            rx_buffer0[rx_wr_index0++]  =   data;
; 0002 010F //
; 0002 0110 //            if (rx_wr_index0 == RX_BUFFER_SIZE0)
; 0002 0111 //            {
; 0002 0112 //                rx_wr_index0=0;
; 0002 0113 //            }
; 0002 0114 //            if (++rx_counter0 == RX_BUFFER_SIZE0)
; 0002 0115 //            {
; 0002 0116 //                rx_counter0=0;
; 0002 0117 //                rx_buffer_overflow0=1;
; 0002 0118 //                send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
; 0002 0119 //                send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
; 0002 011A //                send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
; 0002 011B //            }
; 0002 011C //        }
; 0002 011D //        else{
; 0002 011E //            putchar3(data);
; 0002 011F //
; 0002 0120 //            if (configLen == CONF_READ_BUFFER)
; 0002 0121 //            {
; 0002 0122 //                configLen=0;
; 0002 0123 //            }
; 0002 0124 //
; 0002 0125 //            if((data == '<') && (config_start == 0)){
; 0002 0126 //                config_start            = 1;
; 0002 0127 //                config_response         = 0;
; 0002 0128 //                config_ready            = 0;
; 0002 0129 //            }
; 0002 012A //            else if((data == 0x0D) && (config_end == 0) && (config_start == 1) && (config_response != 0)){
; 0002 012B //                config_end  = 0x0D;
; 0002 012C //            }
; 0002 012D //            else if((data == 0x0A) && (config_end == 0x0D) && (config_start == 1) && (config_response != 0)){
; 0002 012E //                config_end              = 0x0A;
; 0002 012F //                config_ready            = 1;
; 0002 0130 //            }
; 0002 0131 //            else if((data == 'E') && (config_start == 1) && (config_response == 0)){
; 0002 0132 //                config_response         = 'E';
; 0002 0133 //            }
; 0002 0134 //            else if((data == 'S') && (config_start == 1) && (config_response == 0)){
; 0002 0135 //                config_response         = 'S';
; 0002 0136 //            }
; 0002 0137 //            else if((config_start == 1) && (config_response != 0)){
; 0002 0138 //                configRd[configLen++]   =   data;
; 0002 0139 //            }
; 0002 013A //        }
; 0002 013B //    }
; 0002 013C }
_0x40003:
	CALL __LOADLOCR4
	ADIW R28,4
	RJMP _0x40040

	.DSEG
_0x40009:
	.BYTE 0x174
;
;#ifndef _DEBUG_TERMINAL_IO_
;// Get a character from the USART0 Receiver buffer
;#define _ALTERNATE_GETCHAR_
;
;#pragma used+
;char getchar(void)
; 0002 0144 {

	.CSEG
; 0002 0145     char data;
; 0002 0146     while (rx_counter0==0);
;	data -> R17
; 0002 0147     data=rx_buffer0[rx_rd_index0++];
; 0002 0148  //   #if RX_BUFFER_SIZE0 != 256
; 0002 0149     if (rx_rd_index0 == RX_BUFFER_SIZE0)
; 0002 014A         rx_rd_index0=0;
; 0002 014B //    #endif
; 0002 014C     #asm("cli")
; 0002 014D     --rx_counter0;
; 0002 014E     #asm("sei")
; 0002 014F     return data;
; 0002 0150 }
;#pragma used-
;// Write a character to the USART0 Transmitter
;#pragma used+
;void putchar0(char c)
; 0002 0155 {
_putchar0:
; 0002 0156     while ((UCSR0A & DATA_REGISTER_EMPTY)==0);
	ST   -Y,R26
;	c -> Y+0
_0x40014:
	LDS  R30,192
	ANDI R30,LOW(0x20)
	BREQ _0x40014
; 0002 0157     UDR0=c;
	LD   R30,Y
	STS  198,R30
; 0002 0158 }
	RJMP _0x20E003F
;#pragma used-
;#endif
;
;int read_uart0(char *readbuf, int maxread,int interchar)
; 0002 015D {
; 0002 015E     char data;
; 0002 015F     int len=0;
; 0002 0160 
; 0002 0161     while (rx_counter0 > 0)
;	*readbuf -> Y+8
;	maxread -> Y+6
;	interchar -> Y+4
;	data -> R17
;	len -> R18,R19
; 0002 0162     {
; 0002 0163         data=rx_buffer0[rx_rd_index0++];
; 0002 0164         if (rx_rd_index0 == RX_BUFFER_SIZE0){
; 0002 0165             rx_rd_index0=0;
; 0002 0166         }
; 0002 0167         UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0168 
; 0002 0169         --rx_counter0;
; 0002 016A 
; 0002 016B         UCSR0B |= 0x80;          // -- enable uart0 interrupt -- //
; 0002 016C 
; 0002 016D         memcpy(readbuf++,&data,1);
; 0002 016E         len++;
; 0002 016F 
; 0002 0170         if(len == maxread){
; 0002 0171             break;
; 0002 0172         }
; 0002 0173         delay_ms(interchar);
; 0002 0174     }
; 0002 0175     return len;
; 0002 0176 }
;
;int write_uart0(char writebuf[], int len)
; 0002 0179 {
_write_uart0:
; 0002 017A     int i;
; 0002 017B     for(i=0;i<len;i++){
	CALL SUBOPT_0x13
;	writebuf -> Y+4
;	len -> Y+2
;	i -> R16,R17
	__GETWRN 16,17,0
_0x4001D:
	CALL SUBOPT_0x14
	BRGE _0x4001E
; 0002 017C         putchar0(writebuf[i]);
	MOVW R30,R16
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL SUBOPT_0x15
; 0002 017D     }
	__ADDWRN 16,17,1
	RJMP _0x4001D
_0x4001E:
; 0002 017E     return i;
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,6
	RET
; 0002 017F }
;/*============================================================*/
;// USART1 Receiver interrupt service routine
;interrupt [USART1_RXC] void usart1_rx_isr(void)
; 0002 0183 {
_usart1_rx_isr:
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0002 0184     char status,data;
; 0002 0185     status=UCSR1A;
	ST   -Y,R17
	ST   -Y,R16
;	status -> R17
;	data -> R16
	LDS  R17,200
; 0002 0186     data=UDR1;
	LDS  R16,206
; 0002 0187 
; 0002 0188     if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
; 0002 0189     {
; 0002 018A         if(data);
; 0002 018B     }
; 0002 018C }
	RJMP _0x40041
;
;/*============================================================*/
;// USART2 Receiver interrupt service routine
;interrupt [USART2_RXC] void usart2_rx_isr(void)
; 0002 0191 {
_usart2_rx_isr:
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0002 0192     char status,data;
; 0002 0193     status=UCSR2A;
	ST   -Y,R17
	ST   -Y,R16
;	status -> R17
;	data -> R16
	LDS  R17,208
; 0002 0194     data=UDR2;
	LDS  R16,214
; 0002 0195     if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
	BRNE _0x40021
; 0002 0196     {
; 0002 0197         if(data=='K'){
	CPI  R16,75
	BRNE _0x40022
; 0002 0198             flag_oled_ack = 1;
	SBI  0x1E,0
; 0002 0199         }
; 0002 019A         else{
_0x40022:
; 0002 019B             //putchar3(data);
; 0002 019C         }
; 0002 019D     }
; 0002 019E }
_0x40021:
_0x40041:
	LD   R16,Y+
	LD   R17,Y+
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	RETI
;
;// Write a character to the USART2 Transmitter
;#pragma used+
;void putchar2(char c)
; 0002 01A3 {
_putchar2:
; 0002 01A4     while ((UCSR2A & DATA_REGISTER_EMPTY)==0);
	ST   -Y,R26
;	c -> Y+0
_0x40026:
	LDS  R30,208
	ANDI R30,LOW(0x20)
	BREQ _0x40026
; 0002 01A5     UDR2=c;
	LD   R30,Y
	STS  214,R30
; 0002 01A6 }
	RJMP _0x20E003F
;#pragma used-
;
;
;/*============================================================*/
;// USART3 Receiver interrupt service routine
;interrupt [USART3_RXC] void usart3_rx_isr(void)
; 0002 01AD {
_usart3_rx_isr:
	CALL SUBOPT_0xC
; 0002 01AE     char status,data;
; 0002 01AF     status=UCSR3A;
	ST   -Y,R17
	ST   -Y,R16
;	status -> R17
;	data -> R16
	LDS  R17,304
; 0002 01B0     data=UDR3;
	LDS  R16,310
; 0002 01B1 
; 0002 01B2 
; 0002 01B3     //putchar3(data);
; 0002 01B4     putchar0(data);
	MOV  R26,R16
	RCALL _putchar0
; 0002 01B5     if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
	BRNE _0x40029
; 0002 01B6     {
; 0002 01B7         putchar3(data);
	MOV  R26,R16
	RCALL _putchar3
; 0002 01B8 //        putchar0(data);
; 0002 01B9         // Detect Package Header
; 0002 01BA         if(data == charHeader)
	CPI  R16,36
	BRNE _0x4002A
; 0002 01BB         {
; 0002 01BC             rxPackageIndex3 = 0;
	CLR  R9
; 0002 01BD         }
; 0002 01BE 
; 0002 01BF         rxPackage3[rxPackageIndex3++] = data;
_0x4002A:
	MOV  R30,R9
	INC  R9
	LDI  R31,0
	SUBI R30,LOW(-_rxPackage3)
	SBCI R31,HIGH(-_rxPackage3)
	ST   Z,R16
; 0002 01C0 
; 0002 01C1         if(rxPackageIndex3 >= 64) rxPackageIndex3 = 0;
	LDI  R30,LOW(64)
	CP   R9,R30
	BRLO _0x4002B
	CLR  R9
; 0002 01C2 
; 0002 01C3         if(data == charTerminate)
_0x4002B:
	CPI  R16,35
	BRNE _0x4002C
; 0002 01C4         {
; 0002 01C5             rxPackageIndexCount3 = rxPackageIndex3-1;
	MOV  R30,R9
	SUBI R30,LOW(1)
	MOV  R8,R30
; 0002 01C6             rxPackageIndex3 = 0;
	CLR  R9
; 0002 01C7             flag_PackageTerminate3 = 1;
	LDI  R30,LOW(1)
	STS  _flag_PackageTerminate3,R30
; 0002 01C8         }
; 0002 01C9     }
_0x4002C:
; 0002 01CA }
_0x40029:
	LD   R16,Y+
	LD   R17,Y+
_0x40040:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	OUT  EIND,R30
	LD   R30,Y+
	OUT  RAMPZ,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R24,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R15,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;
;/*============================================================*/
;// Write a character to the USART3 Transmitter
;#pragma used+
;void putchar3(char c)
; 0002 01D0 {
_putchar3:
; 0002 01D1     while ((UCSR3A & DATA_REGISTER_EMPTY)==0);
	ST   -Y,R26
;	c -> Y+0
_0x4002D:
	LDS  R30,304
	ANDI R30,LOW(0x20)
	BREQ _0x4002D
; 0002 01D2     UDR3=c;
	LD   R30,Y
	STS  310,R30
; 0002 01D3 }
_0x20E003F:
	ADIW R28,1
	RET
;#pragma used-
;
;/*============================================================*/
;void send_uart(char port,char *buffer)
; 0002 01D8 {
_send_uart:
; 0002 01D9     char i = 0;
; 0002 01DA 
; 0002 01DB     switch (port)
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
;	port -> Y+3
;	*buffer -> Y+1
;	i -> R17
	LDI  R17,0
	LDD  R30,Y+3
	CALL SUBOPT_0x16
; 0002 01DC     {
; 0002 01DD         case 0: puts(buffer);
	BRNE _0x40033
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CALL _puts
; 0002 01DE                 break;
	RJMP _0x40032
; 0002 01DF 
; 0002 01E0         case 1: while(buffer[i] != 0)
_0x40033:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x40034
_0x40035:
	CALL SUBOPT_0x17
	BREQ _0x40037
; 0002 01E1                 {
; 0002 01E2                     //putchar1(buffer[i]);
; 0002 01E3                     i++;
	SUBI R17,-1
; 0002 01E4                 }
	RJMP _0x40035
_0x40037:
; 0002 01E5                 break;
	RJMP _0x40032
; 0002 01E6 
; 0002 01E7         case 2: while(buffer[i] != 0)
_0x40034:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x40038
_0x40039:
	CALL SUBOPT_0x17
	BREQ _0x4003B
; 0002 01E8                 {
; 0002 01E9                     putchar2(buffer[i]);
	CALL SUBOPT_0x18
	RCALL _putchar2
; 0002 01EA                     i++;
	SUBI R17,-1
; 0002 01EB                 }
	RJMP _0x40039
_0x4003B:
; 0002 01EC                 break;
	RJMP _0x40032
; 0002 01ED 
; 0002 01EE         case 3: while(buffer[i] != 0)
_0x40038:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x40032
_0x4003D:
	CALL SUBOPT_0x17
	BREQ _0x4003F
; 0002 01EF                 {
; 0002 01F0                     putchar3(buffer[i]);
	CALL SUBOPT_0x18
	RCALL _putchar3
; 0002 01F1                     i++;
	SUBI R17,-1
; 0002 01F2                 }
	RJMP _0x4003D
_0x4003F:
; 0002 01F3                 break;
; 0002 01F4     }
_0x40032:
; 0002 01F5 }
	LDD  R17,Y+0
	RJMP _0x20E003E
;
;/*============================================================*/
;void init_uart(void)
; 0002 01F9 {
_init_uart:
; 0002 01FA //    // USART0 initialization
; 0002 01FB //    // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 01FC //    // USART0 Receiver: On
; 0002 01FD //    // USART0 Transmitter: On
; 0002 01FE //    // USART0 Mode: Asynchronous
; 0002 01FF //    // USART0 Baud Rate: 38400
; 0002 0200 //    UCSR0A=0x00;
; 0002 0201 //    UCSR0B=0x98;
; 0002 0202 //    UCSR0C=0x06;
; 0002 0203 //    UBRR0H=0x00;
; 0002 0204 //    UBRR0L=0x0C;
; 0002 0205 
; 0002 0206     // USART0 initialization
; 0002 0207     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0208     // USART0 Receiver: On
; 0002 0209     // USART0 Transmitter: On
; 0002 020A     // USART0 Mode: Asynchronous
; 0002 020B     // USART0 Baud Rate: 9600
; 0002 020C 
; 0002 020D     /*bongkot comment*/
; 0002 020E     UCSR0A=0x00;
	LDI  R30,LOW(0)
	STS  192,R30
; 0002 020F     UCSR0B=0x98;
	LDI  R30,LOW(152)
	STS  193,R30
; 0002 0210     UCSR0C=0x06;
	LDI  R30,LOW(6)
	STS  194,R30
; 0002 0211     UBRR0H=0x00;
	LDI  R30,LOW(0)
	STS  197,R30
; 0002 0212     UBRR0L=0x33;
	LDI  R30,LOW(51)
	STS  196,R30
; 0002 0213 
; 0002 0214     // USART0 initialization
; 0002 0215     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0216     // USART0 Receiver: On
; 0002 0217     // USART0 Transmitter: On
; 0002 0218     // USART0 Mode: Asynchronous
; 0002 0219     // USART0 Baud Rate: 57600
; 0002 021A //    UCSR0A=0x00;
; 0002 021B //    UCSR0B=0x98;
; 0002 021C //    UCSR0C=0x06;
; 0002 021D //    UBRR0H=0x00;
; 0002 021E //    UBRR0L=0x08;
; 0002 021F 
; 0002 0220 
; 0002 0221 
; 0002 0222 
; 0002 0223 
; 0002 0224     // USART1 initialization
; 0002 0225     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0226     // USART1 Receiver: On
; 0002 0227     // USART1 Transmitter: On
; 0002 0228     // USART1 Mode: Asynchronous
; 0002 0229     // USART1 Baud Rate: 38400
; 0002 022A     UCSR1A=0x00;
	LDI  R30,LOW(0)
	STS  200,R30
; 0002 022B     UCSR1B=0x98;
	LDI  R30,LOW(152)
	STS  201,R30
; 0002 022C     UCSR1C=0x06;
	LDI  R30,LOW(6)
	STS  202,R30
; 0002 022D     UBRR1H=0x00;
	LDI  R30,LOW(0)
	STS  205,R30
; 0002 022E     UBRR1L=0x0C;
	LDI  R30,LOW(12)
	STS  204,R30
; 0002 022F 
; 0002 0230 //    // USART2 initialization
; 0002 0231 //    // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0232 //    // USART2 Receiver: On
; 0002 0233 //    // USART2 Transmitter: On
; 0002 0234 //    // USART2 Mode: Asynchronous
; 0002 0235 //    // USART2 Baud Rate: 115200 (Double Speed Mode)
; 0002 0236 //    UCSR2A=0x02;
; 0002 0237 //    UCSR2B=0x98;
; 0002 0238 //    UCSR2C=0x06;
; 0002 0239 //    UBRR2H=0x00;
; 0002 023A //    UBRR2L=0x08;
; 0002 023B 
; 0002 023C     // USART2 initialization
; 0002 023D     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 023E     // USART2 Receiver: On
; 0002 023F     // USART2 Transmitter: On
; 0002 0240     // USART2 Mode: Asynchronous
; 0002 0241     // USART2 Baud Rate: 38400
; 0002 0242     UCSR2A=0x00;
	LDI  R30,LOW(0)
	STS  208,R30
; 0002 0243     UCSR2B=0x98;
	LDI  R30,LOW(152)
	STS  209,R30
; 0002 0244     UCSR2C=0x06;
	LDI  R30,LOW(6)
	STS  210,R30
; 0002 0245     UBRR2H=0x00;
	LDI  R30,LOW(0)
	STS  213,R30
; 0002 0246     UBRR2L=0x0C;
	LDI  R30,LOW(12)
	STS  212,R30
; 0002 0247 
; 0002 0248     // USART3 initialization
; 0002 0249     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 024A     // USART3 Receiver: On
; 0002 024B     // USART3 Transmitter: On
; 0002 024C     // USART3 Mode: Asynchronous
; 0002 024D     // USART3 Baud Rate: 38400
; 0002 024E     UCSR3A=0x00;
	LDI  R30,LOW(0)
	STS  304,R30
; 0002 024F     UCSR3B=0x98;
	LDI  R30,LOW(152)
	STS  305,R30
; 0002 0250     UCSR3C=0x06;
	LDI  R30,LOW(6)
	STS  306,R30
; 0002 0251     UBRR3H=0x00;
	LDI  R30,LOW(0)
	STS  309,R30
; 0002 0252     UBRR3L=0x0C;
	LDI  R30,LOW(12)
	STS  308,R30
; 0002 0253 }
	RET
;
;/*============================================================*/
;
;#include "timer.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "ds1672.h"
;#include "adc.h"
;#include "io.h"
;#include "debug.h"
;#include "memcard.h"
;
;TIMER       baseCounter         = 0;    // -- increase continually by 1 second timer. use for timer comparison -- //
;bit         timer_1sec_flag     = 0;    // -- 1 second trigger flag for main loop -- //
;
;bit         buzzer_on           = 0;    // -- buzzer control [0:1] => [on:off] -- //
;
;unsigned int countTimerIntpTask  = 0;//set count of interrupt task
;
;/**************************************************************/
;/******************* Software Timer Support *******************/
;/**************************************************************/
;/*============================================================*/
;TIMER TIMER_checkTimeLeft(TIMER time)
; 0003 0014 {

	.CSEG
; 0003 0015     if(baseCounter < time){
;	time -> Y+0
; 0003 0016         return ( time - baseCounter );
; 0003 0017     }
; 0003 0018     else{
; 0003 0019         return 0;
; 0003 001A     }
; 0003 001B }
;/*============================================================*/
;int TIMER_checkTimerExceed(TIMER keeper)
; 0003 001E {
_TIMER_checkTimerExceed:
; 0003 001F     if(keeper == 0){
	CALL SUBOPT_0x19
;	keeper -> Y+0
	CALL __CPD10
	BRNE _0x60005
; 0003 0020         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E003E
; 0003 0021     }
; 0003 0022 
; 0003 0023     if((unsigned long int)baseCounter < (unsigned long int)keeper){
_0x60005:
	CALL SUBOPT_0x1A
	CALL SUBOPT_0x1B
	CALL __CPD21
	BRSH _0x60006
; 0003 0024         return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E003E
; 0003 0025     }
; 0003 0026     else{                             // -- time exceed -- //
_0x60006:
; 0003 0027         return 1;
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
; 0003 0028     }
; 0003 0029 }
_0x20E003E:
	ADIW R28,4
	RET
;/*============================================================*/
;int TIMER_setTimer(TIMER *keeper, unsigned long int period)
; 0003 002C {
_TIMER_setTimer:
; 0003 002D     unsigned long int t;
; 0003 002E 
; 0003 002F     if(period == 0){
	CALL __PUTPARD2
	SBIW R28,4
;	*keeper -> Y+8
;	period -> Y+4
;	t -> Y+0
	CALL SUBOPT_0x1C
	CALL __CPD10
	BRNE _0x60008
; 0003 0030         printDebug("<TIMER_setTimer> ERR: period = 0\r\n");
	__POINTD1FN _0x60000,0
	CALL SUBOPT_0x0
; 0003 0031         *keeper = 0xFFFFFFFF;
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL SUBOPT_0x1D
	CALL __PUTDP1
; 0003 0032         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	ADIW R28,10
	RET
; 0003 0033     }
; 0003 0034 
; 0003 0035     t = baseCounter + period;
_0x60008:
	CALL SUBOPT_0x1C
	CALL SUBOPT_0x1B
	CALL __ADDD12
	CALL SUBOPT_0x1E
; 0003 0036 
; 0003 0037     *keeper = t;
	CALL SUBOPT_0x1A
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL __PUTDP1
; 0003 0038 
; 0003 0039     if(t <= baseCounter){
	CALL SUBOPT_0x1F
	CALL SUBOPT_0x20
	CALL __CPD12
	BRLO _0x60009
; 0003 003A         printDebug("<TIMER_setTimer> baseCounter[%ld] + period[%ld] = %ld OVERFLOW!!\r\n",baseCounter,period,t);
	__POINTD1FN _0x60000,35
	CALL __PUTPARD1
	CALL SUBOPT_0x1F
	CALL SUBOPT_0x21
	CALL SUBOPT_0x21
	CALL SUBOPT_0x22
; 0003 003B         *keeper = 0;
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL SUBOPT_0x23
	CALL __PUTDP1
; 0003 003C         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	JMP  _0x20E003B
; 0003 003D     }
; 0003 003E     else{
_0x60009:
; 0003 003F         return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	JMP  _0x20E003B
; 0003 0040     }
; 0003 0041 }
;/*============================================================*/
;
;/**************************************************************/
;/********************** Hardware Support **********************/
;/**************************************************************/
;/*============================================================*/
;// Watchdog timeout interrupt service routine
;interrupt [WDT] void wdt_timeout_isr(void)
; 0003 004A {
_wdt_timeout_isr:
	CALL SUBOPT_0xC
; 0003 004B     // Place your code here
; 0003 004C     printDebug("<WDT> WatchDog Timer Reset!!\r\n");
	__POINTD1FN _0x60000,102
	CALL SUBOPT_0x0
; 0003 004D     return;
	RJMP _0x6002B
; 0003 004E }
;/*============================================================*/
;// Timer 0 overflow interrupt service routine
;interrupt [TIM0_OVF] void timer0_ovf_isr(void)
; 0003 0052 {
_timer0_ovf_isr:
	ST   -Y,R30
; 0003 0053     // Reinitialize Timer 0 value
; 0003 0054     TCNT0=0x64;
	LDI  R30,LOW(100)
	OUT  0x26,R30
; 0003 0055     // Place your code here
; 0003 0056 
; 0003 0057 }
	RJMP _0x6002A
;/*============================================================*/
;// Timer1 overflow interrupt service routine
;interrupt [TIM1_OVF] void timer1_ovf_isr(void)
; 0003 005B {
_timer1_ovf_isr:
	ST   -Y,R30
; 0003 005C     // Reinitialize Timer1 value
; 0003 005D //    TCNT1H=0xFF64 >> 8;
; 0003 005E //    TCNT1L=0xFF64 & 0xff;
; 0003 005F     TCNT1H=0xFE79 >> 8;
	CALL SUBOPT_0x24
; 0003 0060     TCNT1L=0xFE79 & 0xff;
; 0003 0061 
; 0003 0062     //adc_sampling();
; 0003 0063 }
	RJMP _0x6002A
;/*============================================================*/
;// Timer2 overflow interrupt service routine    (100Hz)
;interrupt [TIM2_OVF] void timer2_ovf_isr(void)
; 0003 0067 {
_timer2_ovf_isr:
	CALL SUBOPT_0xC
; 0003 0068     // Reinitialize Timer2 value
; 0003 0069     TCNT2=0xb2;
	LDI  R30,LOW(178)
	STS  178,R30
; 0003 006A 
; 0003 006B     /* card access low level timing function */
; 0003 006C     disk_timerproc();
	CALL _disk_timerproc
; 0003 006D 
; 0003 006E }
_0x6002B:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	OUT  EIND,R30
	LD   R30,Y+
	OUT  RAMPZ,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R24,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R15,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;/*============================================================*/
;// Timer1 overflow interrupt service routine  (1 second)
;interrupt [TIM3_OVF] void timer3_ovf_isr(void)
; 0003 0072 {
_timer3_ovf_isr:
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
; 0003 0073     // Reinitialize Timer1 value
; 0003 0074     TCNT3H=0x85ED >> 8;
	CALL SUBOPT_0x25
; 0003 0075     TCNT3L=0x85ED & 0xff;
; 0003 0076 
; 0003 0077     // Place your code here
; 0003 0078     timer_1sec_flag = 1;
	SBI  0x1E,2
; 0003 0079 
; 0003 007A     countTimerIntpTask++;
	LDI  R26,LOW(_countTimerIntpTask)
	LDI  R27,HIGH(_countTimerIntpTask)
	CALL SUBOPT_0x11
; 0003 007B     if(countTimerIntpTask==100){
	LDS  R26,_countTimerIntpTask
	LDS  R27,_countTimerIntpTask+1
	CPI  R26,LOW(0x64)
	LDI  R30,HIGH(0x64)
	CPC  R27,R30
	BRNE _0x6000D
; 0003 007C        countTimerIntpTask = 0;
	LDI  R30,LOW(0)
	STS  _countTimerIntpTask,R30
	STS  _countTimerIntpTask+1,R30
; 0003 007D     }
; 0003 007E 
; 0003 007F     baseCounter++;
_0x6000D:
	LDI  R26,LOW(_baseCounter)
	LDI  R27,HIGH(_baseCounter)
	CALL SUBOPT_0x26
; 0003 0080 
; 0003 0081     raw_rtc++;                          // -- update backup RTC
	LDI  R26,LOW(_raw_rtc)
	LDI  R27,HIGH(_raw_rtc)
	CALL SUBOPT_0x26
; 0003 0082 
; 0003 0083     //printDebug("<%d>\r\n",baseCounter);
; 0003 0084 }
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R23,Y+
	LD   R22,Y+
	RETI
;/*============================================================*/
;// Timer4 overflow interrupt service routine (0.5 sec)
;interrupt [TIM4_OVF] void timer4_ovf_isr(void)
; 0003 0088 {
_timer4_ovf_isr:
	ST   -Y,R30
; 0003 0089     static bit toggle = 0;
; 0003 008A     // Reinitialize Timer4 value
; 0003 008B     TCNT4H=0x85ED >> 8;
	CALL SUBOPT_0x27
; 0003 008C     TCNT4L=0x85ED & 0xff;
; 0003 008D 
; 0003 008E     // Place your code here
; 0003 008F     toggle = !toggle;
	SBIS 0x1E,4
	RJMP _0x6000E
	CBI  0x1E,4
	RJMP _0x6000F
_0x6000E:
	SBI  0x1E,4
_0x6000F:
; 0003 0090 
; 0003 0091     if(buzzer_on){
	SBIS 0x1E,3
	RJMP _0x60010
; 0003 0092         if(toggle)  {   BUZZER = 1; }
	SBIS 0x1E,4
	RJMP _0x60011
	SBI  0xE,7
; 0003 0093         else        {   BUZZER = 0; }
	RJMP _0x60014
_0x60011:
	CBI  0xE,7
_0x60014:
; 0003 0094     }
; 0003 0095     else{
	RJMP _0x60017
_0x60010:
; 0003 0096         BUZZER = 0;
	CBI  0xE,7
; 0003 0097     }
_0x60017:
; 0003 0098 
; 0003 0099 }
_0x6002A:
	LD   R30,Y+
	RETI
;
;//// Timer5 overflow interrupt service routine
;//interrupt [TIM5_OVF] void timer5_ovf_isr(void)
;//{
;//// Place your code here
;//
;//}
;/*============================================================*/
;void init_timer(void)
; 0003 00A3 {
_init_timer:
; 0003 00A4 
; 0003 00A5     // Timer/Counter 0 initialization
; 0003 00A6     // Clock source: System Clock
; 0003 00A7     // Clock value: 7.813 kHz
; 0003 00A8     // Mode: Normal top=0xFF
; 0003 00A9     // OC0A output: Disconnected
; 0003 00AA     // OC0B output: Disconnected
; 0003 00AB     TCCR0A=0x00;
	LDI  R30,LOW(0)
	OUT  0x24,R30
; 0003 00AC     TCCR0B=0x05;
	LDI  R30,LOW(5)
	OUT  0x25,R30
; 0003 00AD     TCNT0=0x64;
	LDI  R30,LOW(100)
	OUT  0x26,R30
; 0003 00AE     OCR0A=0x00;
	LDI  R30,LOW(0)
	OUT  0x27,R30
; 0003 00AF     OCR0B=0x00;
	OUT  0x28,R30
; 0003 00B0 
; 0003 00B1     // Timer/Counter 1 initialization
; 0003 00B2     // Clock source: System Clock
; 0003 00B3     // Clock value: 7.813 kHz
; 0003 00B4     // Mode: Normal top=0xFFFF
; 0003 00B5     // OC1A output: Discon.
; 0003 00B6     // OC1B output: Discon.
; 0003 00B7     // OC1C output: Discon.
; 0003 00B8     // Noise Canceler: Off
; 0003 00B9     // Input Capture on Falling Edge
; 0003 00BA     // Timer1 Overflow Interrupt: On
; 0003 00BB     // Input Capture Interrupt: Off
; 0003 00BC     // Compare A Match Interrupt: Off
; 0003 00BD     // Compare B Match Interrupt: Off
; 0003 00BE     // Compare C Match Interrupt: Off
; 0003 00BF     TCCR1A=0x00;
	STS  128,R30
; 0003 00C0     TCCR1B=0x05;
	LDI  R30,LOW(5)
	STS  129,R30
; 0003 00C1     //TCNT1H=0xFF;
; 0003 00C2     //TCNT1L=0x64;
; 0003 00C3     TCNT1H=0xFE;
	CALL SUBOPT_0x24
; 0003 00C4     TCNT1L=0x79;
; 0003 00C5     ICR1H=0x00;
	LDI  R30,LOW(0)
	STS  135,R30
; 0003 00C6     ICR1L=0x00;
	STS  134,R30
; 0003 00C7     OCR1AH=0x00;
	STS  137,R30
; 0003 00C8     OCR1AL=0x00;
	STS  136,R30
; 0003 00C9     OCR1BH=0x00;
	STS  139,R30
; 0003 00CA     OCR1BL=0x00;
	STS  138,R30
; 0003 00CB     OCR1CH=0x00;
	STS  141,R30
; 0003 00CC     OCR1CL=0x00;
	STS  140,R30
; 0003 00CD 
; 0003 00CE     // Timer/Counter 2 initialization
; 0003 00CF     // Clock source: System Clock
; 0003 00D0     // Clock value: 7.813 kHz
; 0003 00D1     // Mode: Normal top=0xFF
; 0003 00D2     // OC2A output: Disconnected
; 0003 00D3     // OC2B output: Disconnected
; 0003 00D4     ASSR=0x00;
	STS  182,R30
; 0003 00D5     TCCR2A=0x00;
	STS  176,R30
; 0003 00D6     TCCR2B=0x07;
	LDI  R30,LOW(7)
	STS  177,R30
; 0003 00D7     TCNT2=0xb2;
	LDI  R30,LOW(178)
	STS  178,R30
; 0003 00D8     OCR2A=0x00;
	LDI  R30,LOW(0)
	STS  179,R30
; 0003 00D9     OCR2B=0x00;
	STS  180,R30
; 0003 00DA 
; 0003 00DB     // Timer/Counter 3 initialization
; 0003 00DC     // Clock source: System Clock
; 0003 00DD     // Clock value: 31.250 kHz
; 0003 00DE     // Mode: Normal top=0xFFFF
; 0003 00DF     // OC3A output: Discon.
; 0003 00E0     // OC3B output: Discon.
; 0003 00E1     // OC3C output: Discon.
; 0003 00E2     // Noise Canceler: Off
; 0003 00E3     // Input Capture on Falling Edge
; 0003 00E4     // Timer3 Overflow Interrupt: On
; 0003 00E5     // Input Capture Interrupt: Off
; 0003 00E6     // Compare A Match Interrupt: Off
; 0003 00E7     // Compare B Match Interrupt: Off
; 0003 00E8     // Compare C Match Interrupt: Off
; 0003 00E9     TCCR3A=0x00;
	STS  144,R30
; 0003 00EA     TCCR3B=0x04;
	LDI  R30,LOW(4)
	STS  145,R30
; 0003 00EB     TCNT3H=0x85;
	CALL SUBOPT_0x25
; 0003 00EC     TCNT3L=0xED;
; 0003 00ED     ICR3H=0x00;
	LDI  R30,LOW(0)
	STS  151,R30
; 0003 00EE     ICR3L=0x00;
	STS  150,R30
; 0003 00EF     OCR3AH=0x00;
	STS  153,R30
; 0003 00F0     OCR3AL=0x00;
	STS  152,R30
; 0003 00F1     OCR3BH=0x00;
	STS  155,R30
; 0003 00F2     OCR3BL=0x00;
	STS  154,R30
; 0003 00F3     OCR3CH=0x00;
	STS  157,R30
; 0003 00F4     OCR3CL=0x00;
	STS  156,R30
; 0003 00F5 
; 0003 00F6     // Timer/Counter 4 initialization
; 0003 00F7     // Clock source: System Clock
; 0003 00F8     // Clock value: 125.000 kHz
; 0003 00F9     // Mode: Normal top=0xFFFF
; 0003 00FA     // OC4A output: Discon.
; 0003 00FB     // OC4B output: Discon.
; 0003 00FC     // OC4C output: Discon.
; 0003 00FD     // Noise Canceler: Off
; 0003 00FE     // Input Capture on Falling Edge
; 0003 00FF     // Timer4 Overflow Interrupt: On
; 0003 0100     // Input Capture Interrupt: Off
; 0003 0101     // Compare A Match Interrupt: Off
; 0003 0102     // Compare B Match Interrupt: Off
; 0003 0103     // Compare C Match Interrupt: Off
; 0003 0104     TCCR4A=0x00;
	STS  160,R30
; 0003 0105     TCCR4B=0x03;
	LDI  R30,LOW(3)
	STS  161,R30
; 0003 0106     TCNT4H=0x85;
	CALL SUBOPT_0x27
; 0003 0107     TCNT4L=0xED;
; 0003 0108     ICR4H=0x00;
	LDI  R30,LOW(0)
	STS  167,R30
; 0003 0109     ICR4L=0x00;
	STS  166,R30
; 0003 010A     OCR4AH=0x00;
	STS  169,R30
; 0003 010B     OCR4AL=0x00;
	STS  168,R30
; 0003 010C     OCR4BH=0x00;
	STS  171,R30
; 0003 010D     OCR4BL=0x00;
	STS  170,R30
; 0003 010E     OCR4CH=0x00;
	STS  173,R30
; 0003 010F     OCR4CL=0x00;
	STS  172,R30
; 0003 0110 
; 0003 0111     // Timer/Counter 5 initialization
; 0003 0112     // Clock source: System Clock
; 0003 0113     // Clock value: Timer5 Stopped
; 0003 0114     // Mode: Normal top=0xFFFF
; 0003 0115     // OC5A output: Discon.
; 0003 0116     // OC5B output: Discon.
; 0003 0117     // OC5C output: Discon.
; 0003 0118     // Noise Canceler: Off
; 0003 0119     // Input Capture on Falling Edge
; 0003 011A     // Timer5 Overflow Interrupt: Off
; 0003 011B     // Input Capture Interrupt: Off
; 0003 011C     // Compare A Match Interrupt: Off
; 0003 011D     // Compare B Match Interrupt: Off
; 0003 011E     // Compare C Match Interrupt: Off
; 0003 011F     TCCR5A=0x00;
	STS  288,R30
; 0003 0120     TCCR5B=0x00;
	STS  289,R30
; 0003 0121     TCNT5H=0x00;
	STS  293,R30
; 0003 0122     TCNT5L=0x00;
	STS  292,R30
; 0003 0123     ICR5H=0x00;
	STS  295,R30
; 0003 0124     ICR5L=0x00;
	STS  294,R30
; 0003 0125     OCR5AH=0x00;
	STS  297,R30
; 0003 0126     OCR5AL=0x00;
	STS  296,R30
; 0003 0127     OCR5BH=0x00;
	STS  299,R30
; 0003 0128     OCR5BL=0x00;
	STS  298,R30
; 0003 0129     OCR5CH=0x00;
	STS  301,R30
; 0003 012A     OCR5CL=0x00;
	STS  300,R30
; 0003 012B 
; 0003 012C     // Watchdog Timer initialization
; 0003 012D     // Watchdog Timer Prescaler: OSC/1024k
; 0003 012E     // Watchdog Timer interrupt: On
; 0003 012F     #pragma optsize-
; 0003 0130     #asm("wdr")
	wdr
; 0003 0131     WDTCSR=0x79;
	LDI  R30,LOW(121)
	STS  96,R30
; 0003 0132     WDTCSR=0x69;
	LDI  R30,LOW(105)
	STS  96,R30
; 0003 0133 
; 0003 0134     #ifdef _OPTIMIZE_SIZE_
; 0003 0135     #pragma optsize+
; 0003 0136     #endif
; 0003 0137 
; 0003 0138 
; 0003 0139     // Timer/Counter 0 Interrupt(s) initialization
; 0003 013A     TIMSK0=0x00;
	LDI  R30,LOW(0)
	STS  110,R30
; 0003 013B 
; 0003 013C     // Timer/Counter 1 Interrupt(s) initialization
; 0003 013D     TIMSK1=0x00;
	STS  111,R30
; 0003 013E 
; 0003 013F     // Timer/Counter 2 Interrupt(s) initialization
; 0003 0140     TIMSK2=0x00;
	STS  112,R30
; 0003 0141 
; 0003 0142     // Timer/Counter 3 Interrupt(s) initialization
; 0003 0143     TIMSK3=0x00;
	STS  113,R30
; 0003 0144 
; 0003 0145     // Timer/Counter 4 Interrupt(s) initialization
; 0003 0146     TIMSK4=0x00;
	STS  114,R30
; 0003 0147 
; 0003 0148     // Timer/Counter 5 Interrupt(s) initialization
; 0003 0149     TIMSK5=0x00;
	STS  115,R30
; 0003 014A }
	RET
;/*============================================================*/
;void enable_interrupt(int ch)
; 0003 014D {
_enable_interrupt:
; 0003 014E 
; 0003 014F     // -------------- enable timer ---------------  //
; 0003 0150 
; 0003 0151     switch(ch){
	CALL SUBOPT_0x28
;	ch -> Y+0
; 0003 0152         case 0: // Timer/Counter 0 Interrupt(s) initialization
	SBIW R30,0
	BREQ _0x6001C
; 0003 0153                 //TIMSK0=0x01;
; 0003 0154                 break;
; 0003 0155         case 1: // Timer/Counter 1 Interrupt(s) initialization
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x6001E
; 0003 0156                 TIMSK1=0x01;
	LDI  R30,LOW(1)
	STS  111,R30
; 0003 0157                 break;
	RJMP _0x6001C
; 0003 0158         case 2: // Timer/Counter 2 Interrupt(s) initialization
_0x6001E:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x6001F
; 0003 0159                 TIMSK2=0x01;
	LDI  R30,LOW(1)
	STS  112,R30
; 0003 015A                 break;
	RJMP _0x6001C
; 0003 015B         case 3: // Timer/Counter 3 Interrupt(s) initialization
_0x6001F:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x60020
; 0003 015C                 TIMSK3=0x01;
	LDI  R30,LOW(1)
	STS  113,R30
; 0003 015D                 break;
	RJMP _0x6001C
; 0003 015E         case 4: // Timer/Counter 4 Interrupt(s) initialization
_0x60020:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x6001C
; 0003 015F                 TIMSK4=0x01;
	LDI  R30,LOW(1)
	STS  114,R30
; 0003 0160                 break;
; 0003 0161     }
_0x6001C:
; 0003 0162     // Global enable interrupts
; 0003 0163     #asm("sei")
	sei
; 0003 0164 }
	ADIW R28,2
	RET
;/*============================================================*/
;void disable_interrupt(int ch)
; 0003 0167 {
; 0003 0168 
; 0003 0169     // -------------- enable timer ---------------  //
; 0003 016A 
; 0003 016B     switch(ch){
;	ch -> Y+0
; 0003 016C         case 0: // Timer/Counter 0 Interrupt(s) initialization
; 0003 016D                 //TIMSK0=0x00;
; 0003 016E                 break;
; 0003 016F         case 1: // Timer/Counter 1 Interrupt(s) initialization
; 0003 0170                 TIMSK1=0x00;
; 0003 0171                 break;
; 0003 0172         case 2: // Timer/Counter 2 Interrupt(s) initialization
; 0003 0173                 TIMSK2=0x00;
; 0003 0174                 break;
; 0003 0175         case 3: // Timer/Counter 3 Interrupt(s) initialization
; 0003 0176                 TIMSK3=0x00;
; 0003 0177                 break;
; 0003 0178         case 4: // Timer/Counter 4 Interrupt(s) initialization
; 0003 0179                 TIMSK4=0x00;
; 0003 017A                 break;
; 0003 017B     }
; 0003 017C     // Global enable interrupts
; 0003 017D     #asm("sei")
; 0003 017E }
;/*============================================================*/
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <delay.h>
;#include "io.h"
;#include "debug.h"
;
;//unsigned char   d_out[USE_DOUT] = {0xFF,0xFF};
;
;/*============================================================*/
;void init_io(void)
; 0004 000A {

	.CSEG
_init_io:
; 0004 000B     // Input/Output Ports initialization
; 0004 000C     // Port A initialization
; 0004 000D     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=Out Func1=In Func0=In
; 0004 000E     // State7=T State6=T State5=T State4=T State3=T State2=0 State1=T State0=T
; 0004 000F     PORTA=0x00;
	LDI  R30,LOW(0)
	OUT  0x2,R30
; 0004 0010     DDRA=0x04;
	LDI  R30,LOW(4)
	OUT  0x1,R30
; 0004 0011 
; 0004 0012     // Port B initialization
; 0004 0013     // Func7=Out Func6=Out Func5=Out Func4=Out Func3=In Func2=Out Func1=Out Func0=Out
; 0004 0014     // State7=1 State6=1 State5=1 State4=1 State3=P State2=1 State1=1 State0=1
; 0004 0015     PORTB=0xFF;
	LDI  R30,LOW(255)
	OUT  0x5,R30
; 0004 0016     DDRB=0xF7;
	LDI  R30,LOW(247)
	OUT  0x4,R30
; 0004 0017 
; 0004 0018     // Port C initialization
; 0004 0019     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 001A     // State7=P State6=P State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 001B     PORTC=0xC0;
	LDI  R30,LOW(192)
	OUT  0x8,R30
; 0004 001C     DDRC=0x00;
	LDI  R30,LOW(0)
	OUT  0x7,R30
; 0004 001D 
; 0004 001E     // Port C initialization
; 0004 001F     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0020     // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0021     //PORTC=0x80;
; 0004 0022     //DDRC=0x00;
; 0004 0023 
; 0004 0024     // Port D initialization
; 0004 0025     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0026     // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0027     PORTD=0x80;
	LDI  R30,LOW(128)
	OUT  0xB,R30
; 0004 0028     DDRD=0x00;
	LDI  R30,LOW(0)
	OUT  0xA,R30
; 0004 0029 
; 0004 002A     // Port E initialization
; 0004 002B     // Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=Out Func1=In Func0=In
; 0004 002C     // State7=1 State6=1 State5=1 State4=1 State3=1 State2=P State1=T State0=T
; 0004 002D     PORTE=0xFC;
	LDI  R30,LOW(252)
	OUT  0xE,R30
; 0004 002E     DDRE=0xFC;
	OUT  0xD,R30
; 0004 002F 
; 0004 0030     // Port F initialization
; 0004 0031     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0032     // State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0033     PORTF=0x00;
	LDI  R30,LOW(0)
	OUT  0x11,R30
; 0004 0034     DDRF=0x00;
	OUT  0x10,R30
; 0004 0035 
; 0004 0036     // Port G initialization
; 0004 0037     // Func5=Out Func4=Out Func3=In Func2=In Func1=In Func0=In
; 0004 0038     // State5=1 State4=1 State3=T State2=T State1=T State0=T
; 0004 0039     //PORTG=0x20;
; 0004 003A     //DDRG=0x20;
; 0004 003B     PORTG=0x30;
	LDI  R30,LOW(48)
	OUT  0x14,R30
; 0004 003C     DDRG=0x30;
	OUT  0x13,R30
; 0004 003D 
; 0004 003E     // Port H initialization
; 0004 003F     // Func7=In Func6=Out Func5=Out Func4=Out Func3=Out Func2=In Func1=In Func0=In
; 0004 0040     // State7=P State6=1 State5=1 State4=1 State3=1 State2=T State1=T State0=T
; 0004 0041     PORTH=0xF8;
	LDI  R30,LOW(248)
	STS  258,R30
; 0004 0042     DDRH=0xF8;
	STS  257,R30
; 0004 0043 
; 0004 0044 //    // Port J initialization
; 0004 0045 //    // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0046 //    // State7=P State6=P State5=P State4=P State3=P State2=P State1=T State0=T
; 0004 0047 //    PORTJ=0xFC;
; 0004 0048 //    DDRJ=0x00;
; 0004 0049 
; 0004 004A     // Port J initialization
; 0004 004B     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 004C     // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 004D     PORTJ=0x80;
	LDI  R30,LOW(128)
	STS  261,R30
; 0004 004E     DDRJ=0x00;
	LDI  R30,LOW(0)
	STS  260,R30
; 0004 004F 
; 0004 0050     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
	CALL SUBOPT_0x29
	BREQ _0x80004
	CALL SUBOPT_0x29
	CPI  R30,LOW(0x3)
	BRNE _0x80003
_0x80004:
; 0004 0051         // Port K initialization
; 0004 0052         // Func7=In Func6=In Func5=In Func4=In Func3=Out Func2=Out Func1=Out Func0=In
; 0004 0053         // State7=P State6=T State5=T State4=P State3=0 State2=0 State1=0 State0=T
; 0004 0054         PORTK=0x90;
	LDI  R30,LOW(144)
	STS  264,R30
; 0004 0055         DDRK=0x0E;
	LDI  R30,LOW(14)
	RJMP _0x80032
; 0004 0056     }
; 0004 0057     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
_0x80003:
	CALL SUBOPT_0x2A
	BREQ _0x80008
	CALL SUBOPT_0x29
	CPI  R30,LOW(0x2)
	BRNE _0x80007
_0x80008:
; 0004 0058         // Port K initialization
; 0004 0059         // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 005A         // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 005B         PORTK=0x80;
	LDI  R30,LOW(128)
	STS  264,R30
; 0004 005C         DDRK=0x00;
	LDI  R30,LOW(0)
_0x80032:
	STS  263,R30
; 0004 005D     }
; 0004 005E 
; 0004 005F     // Port L initialization
; 0004 0060     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0061     // State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0062     PORTL=0x00;
_0x80007:
	LDI  R30,LOW(0)
	STS  267,R30
; 0004 0063     DDRL=0x00;
	STS  266,R30
; 0004 0064 
; 0004 0065 }
	RET
;/*============================================================*/
;void IO_dout(int ch, char state)
; 0004 0068 {
; 0004 0069 //    /*bongkot edit output is actived high(1)*/
; 0004 006A //    //triger state input function
; 0004 006B //    state = !state;
; 0004 006C //    /* end edit*/
; 0004 006D 
; 0004 006E //    switch(ch){
; 0004 006F //        case 0  :   DOUT1       =   !state;
; 0004 0070 //                    d_out[0]    =   state;
; 0004 0071 //                    //printDebug("<IO_dout> dout0 %d\r\n",d_out[0]);
; 0004 0072 //                    break;
; 0004 0073 //        case 1  :   DOUT2       =   !state;
; 0004 0074 //                    d_out[1]    =   state;
; 0004 0075 //                    //printDebug("<IO_dout> dout1 %d\r\n",d_out[1]);
; 0004 0076 //                    break;
; 0004 0077 //        default :   break;
; 0004 0078 //    }
; 0004 0079 }
;/*============================================================*/
;char IO_keyCheck(void)
; 0004 007C {
; 0004 007D     static char flag_hold_MODE   = 0;
; 0004 007E     static char flag_hold_UP     = 0;
; 0004 007F     static char flag_hold_DOWN   = 0;
; 0004 0080     static char flag_hold_OK     = 0;
; 0004 0081 
; 0004 0082     if( KEY_PRESS_CHK_MODE && !flag_hold_MODE )
; 0004 0083     {
; 0004 0084         delay_ms(KEY_DELAY);
; 0004 0085 
; 0004 0086         if( KEY_PRESS_CHK_MODE && !flag_hold_MODE )
; 0004 0087         {
; 0004 0088             flag_hold_MODE = 1;
; 0004 0089             return 0;
; 0004 008A         }
; 0004 008B     }
; 0004 008C     else if( KEY_RELEASE_CHK_MODE && flag_hold_MODE)
; 0004 008D     {
; 0004 008E         printDebug("<IO_keyCheck> key MODE\r\n");
; 0004 008F         flag_hold_MODE = 0;
; 0004 0090         return KEY_MODE;
; 0004 0091     }
; 0004 0092 
; 0004 0093     if( KEY_PRESS_CHK_UP && !flag_hold_UP )
; 0004 0094     {
; 0004 0095         delay_ms(KEY_DELAY);
; 0004 0096 
; 0004 0097         if( KEY_PRESS_CHK_UP && !flag_hold_UP )
; 0004 0098         {
; 0004 0099             flag_hold_UP = 1;
; 0004 009A             return 0;
; 0004 009B         }
; 0004 009C     }
; 0004 009D     else if( KEY_RELEASE_CHK_UP && flag_hold_UP)
; 0004 009E     {
; 0004 009F         printDebug("<IO_keyCheck> key UP\r\n");
; 0004 00A0         flag_hold_UP = 0;
; 0004 00A1         return KEY_UP;
; 0004 00A2     }
; 0004 00A3 
; 0004 00A4     if( KEY_PRESS_CHK_DOWN && !flag_hold_DOWN )
; 0004 00A5     {
; 0004 00A6         delay_ms(KEY_DELAY);
; 0004 00A7 
; 0004 00A8         if( KEY_PRESS_CHK_DOWN && !flag_hold_DOWN )
; 0004 00A9         {
; 0004 00AA             flag_hold_DOWN = 1;
; 0004 00AB             return 0;
; 0004 00AC         }
; 0004 00AD     }
; 0004 00AE     else if( KEY_RELEASE_CHK_DOWN && flag_hold_DOWN)
; 0004 00AF     {
; 0004 00B0         printDebug("<IO_keyCheck> key DOWN\r\n");
; 0004 00B1         flag_hold_DOWN = 0;
; 0004 00B2         return KEY_DOWN;
; 0004 00B3     }
; 0004 00B4 
; 0004 00B5     if( KEY_PRESS_CHK_OK && !flag_hold_OK )
; 0004 00B6     {
; 0004 00B7         delay_ms(KEY_DELAY);
; 0004 00B8 
; 0004 00B9         if( KEY_PRESS_CHK_OK && !flag_hold_OK )
; 0004 00BA         {
; 0004 00BB             flag_hold_OK = 1;
; 0004 00BC             return 0;
; 0004 00BD         }
; 0004 00BE     }
; 0004 00BF     else if( KEY_RELEASE_CHK_OK && flag_hold_OK)
; 0004 00C0     {
; 0004 00C1         printDebug("<IO_keyCheck> key OK\r\n");
; 0004 00C2         flag_hold_OK = 0;
; 0004 00C3         return KEY_OK;
; 0004 00C4     }
; 0004 00C5 
; 0004 00C6     return 0;
; 0004 00C7 }
;
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <delay.h>
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "adc.h"
;#include "debug.h"
;
;float           adcData[5];
;float           adcBatt;
;
;eeprom float    eep_vref_val = 2.56;
;
;/*============================================================*/
;unsigned int read_adc(unsigned char adc_input)
; 0005 0010 {

	.CSEG
_read_adc:
; 0005 0011     unsigned int adc_data = 0x0000;
; 0005 0012 
; 0005 0013     ADMUX  &= ADC_VREF_TYPE;
	ST   -Y,R26
	ST   -Y,R17
	ST   -Y,R16
;	adc_input -> Y+2
;	adc_data -> R16,R17
	__GETWRN 16,17,0
	LDS  R30,124
	ANDI R30,LOW(0x40)
	STS  124,R30
; 0005 0014     ADCSRB &= 0xf7;
	LDS  R30,123
	ANDI R30,0XF7
	STS  123,R30
; 0005 0015 
; 0005 0016     ADMUX  |= (adc_input & 0x07) | (ADC_VREF_TYPE & 0xff);
	LDI  R26,LOW(124)
	LDI  R27,HIGH(124)
	MOV  R0,R26
	LD   R26,X
	LDD  R30,Y+2
	ANDI R30,LOW(0x7)
	ORI  R30,0x40
	OR   R30,R26
	MOV  R26,R0
	ST   X,R30
; 0005 0017 
; 0005 0018     if(adc_input > 7)
	LDD  R26,Y+2
	CPI  R26,LOW(0x8)
	BRLO _0xA0003
; 0005 0019     {
; 0005 001A         ADCSRB |= 0x08;
	LDS  R30,123
	ORI  R30,8
	RJMP _0xA0020
; 0005 001B     }
; 0005 001C     else
_0xA0003:
; 0005 001D     {
; 0005 001E         ADCSRB &= 0xf7;
	LDS  R30,123
	ANDI R30,0XF7
_0xA0020:
	STS  123,R30
; 0005 001F     }
; 0005 0020 
; 0005 0021     // Delay needed for the stabilization of the ADC input voltage
; 0005 0022     delay_us(20);
	__DELAY_USB 53
; 0005 0023 
; 0005 0024     // Start the AD conversion
; 0005 0025     ADCSRA  |= 0x80; //ENABLE ADC
	LDS  R30,122
	ORI  R30,0x80
	STS  122,R30
; 0005 0026     ADCSRA  |= 0x40;
	LDS  R30,122
	ORI  R30,0x40
	STS  122,R30
; 0005 0027 
; 0005 0028     // Wait for the AD conversion to complete
; 0005 0029     //while ( ((ADCSRA & 0x10)==0) || ((ADCSRA & 0x40) == 0x40));
; 0005 002A     while ( (ADCSRA & 0x10)==0);
_0xA0005:
	LDS  R30,122
	ANDI R30,LOW(0x10)
	BREQ _0xA0005
; 0005 002B     adc_data = ADCL;
	LDS  R16,120
	CLR  R17
; 0005 002C     adc_data |= (ADCH & 0x00ff) << 8;
	LDS  R30,121
	LDI  R31,0
	ANDI R31,HIGH(0xFF)
	MOV  R31,R30
	LDI  R30,0
	__ORWRR 16,17,30,31
; 0005 002D 
; 0005 002E     ADCSRA  |=0x10;
	LDS  R30,122
	ORI  R30,0x10
	STS  122,R30
; 0005 002F 
; 0005 0030     delay_us(50);
	__DELAY_USB 133
; 0005 0031 
; 0005 0032     return adc_data;
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,3
	RET
; 0005 0033 }
;/*============================================================*/
;unsigned char adc_sampling(void)
; 0005 0036 {
; 0005 0037     static int      i = 0;
; 0005 0038     static char     batt_read_flag = 0;
; 0005 0039 
; 0005 003A     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
; 0005 003B         /*
; 0005 003C         printDebug("<%d>",i);
; 0005 003D         SENSOR_SELECT(i);
; 0005 003E         delay_ms(20);
; 0005 003F         adcData[i] = (float)((adcData[i] * 9.0) + (float)(read_adc(8) * 1.0))/10;           // Temp Sensor Low-Pass Filter
; 0005 0040         if(++i >= 5){   i = 0;  }
; 0005 0041         */
; 0005 0042     }
; 0005 0043     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
; 0005 0044 //        for( i=0 ; i<5 ; i++ ){
; 0005 0045 //            adcData[i] = (float)((adcData[i] * 9.9) + (float)(read_adc(8+i) * 0.1))/10;     // Temp Sensor Low-Pass Filter
; 0005 0046 //        }
; 0005 0047     }
; 0005 0048 
; 0005 0049 //    if(++batt_read_flag > 25){
; 0005 004A //        adcBatt = (float)((adcBatt * 9.9) + (float)(read_adc(14) * 0.1))/10;                // Battery Read
; 0005 004B //        batt_read_flag = 0;
; 0005 004C //    }
; 0005 004D 
; 0005 004E     return 0;
; 0005 004F }
;/*============================================================*/
;float readBattery(void)
; 0005 0052 {
; 0005 0053     float   vBATT;
; 0005 0054 
; 0005 0055     adcBatt = (float)((adcBatt * 9.9) + (float)(read_adc(14) * 0.1))/10;                // Battery Read
;	vBATT -> Y+0
; 0005 0056 
; 0005 0057     vBATT   = adcBatt*ADC_CONV_FAC*1.8;                                // from voltage divider 120k & 150k
; 0005 0058     //printDebug("                                                     -- volt[%f]\r\n", vBATT);    // padding line
; 0005 0059 
; 0005 005A     return vBATT;
; 0005 005B }
;/*============================================================*/
;void adc_init_read(void)
; 0005 005E {
_adc_init_read:
; 0005 005F     int i;
; 0005 0060     printDebug("Initializing ADC.. ");
	ST   -Y,R17
	ST   -Y,R16
;	i -> R16,R17
	__POINTD1FN _0xA0000,0
	CALL SUBOPT_0x0
; 0005 0061 
; 0005 0062     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
	CALL SUBOPT_0x29
	BREQ _0xA0010
	CALL SUBOPT_0x29
	CPI  R30,LOW(0x3)
	BRNE _0xA000F
_0xA0010:
; 0005 0063         for(i=0;i<5;i++){ \
; 0005 0064             SENSOR_SELECT(i);
	__GETWRN 16,17,0
_0xA0013:
	__CPWRN 16,17,5
	BRGE _0xA0014
	LDS  R30,264
	ANDI R30,LOW(0xF1)
	STS  264,R30
	LDI  R26,LOW(264)
	LDI  R27,HIGH(264)
	MOV  R0,R26
	LD   R26,X
	MOV  R30,R16
	LSL  R30
	OR   R30,R26
	MOV  R26,R0
	ST   X,R30
; 0005 0065             delay_ms(20);
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0005 0066             adcData[i] = read_adc(8);
	MOVW R30,R16
	LDI  R26,LOW(_adcData)
	LDI  R27,HIGH(_adcData)
	CALL __LSLW2
	ADD  R30,R26
	ADC  R31,R27
	PUSH R31
	PUSH R30
	LDI  R26,LOW(8)
	RCALL _read_adc
	POP  R26
	POP  R27
	CALL SUBOPT_0x2C
; 0005 0067         }
	__ADDWRN 16,17,1
	RJMP _0xA0013
_0xA0014:
; 0005 0068     }
; 0005 0069     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
	RJMP _0xA0015
_0xA000F:
	CALL SUBOPT_0x2A
	BREQ _0xA0017
	CALL SUBOPT_0x29
	CPI  R30,LOW(0x2)
	BRNE _0xA0016
_0xA0017:
; 0005 006A         adcData[0] = read_adc(8);
	LDI  R26,LOW(8)
	RCALL _read_adc
	LDI  R26,LOW(_adcData)
	LDI  R27,HIGH(_adcData)
	CALL SUBOPT_0x2C
; 0005 006B         adcData[1] = read_adc(9);
	LDI  R26,LOW(9)
	RCALL _read_adc
	__POINTW2MN _adcData,4
	CALL SUBOPT_0x2C
; 0005 006C         adcData[2] = read_adc(10);
	LDI  R26,LOW(10)
	RCALL _read_adc
	__POINTW2MN _adcData,8
	CALL SUBOPT_0x2C
; 0005 006D         adcData[3] = read_adc(11);
	LDI  R26,LOW(11)
	RCALL _read_adc
	__POINTW2MN _adcData,12
	CALL SUBOPT_0x2C
; 0005 006E         adcData[4] = read_adc(12);
	LDI  R26,LOW(12)
	RCALL _read_adc
	__POINTW2MN _adcData,16
	CALL SUBOPT_0x2C
; 0005 006F     }
; 0005 0070 
; 0005 0071     adcBatt = read_adc(14);
_0xA0016:
_0xA0015:
	LDI  R26,LOW(14)
	RCALL _read_adc
	LDI  R26,LOW(_adcBatt)
	LDI  R27,HIGH(_adcBatt)
	CALL SUBOPT_0x2C
; 0005 0072 
; 0005 0073     printDebug("OK\r\n");
	__POINTD1FN _0xA0000,20
	CALL SUBOPT_0x0
; 0005 0074 }
_0x20E003D:
	LD   R16,Y+
	LD   R17,Y+
	RET
;/*============================================================*/
;void init_adc(void)
; 0005 0077 {
_init_adc:
; 0005 0078     // ADC initialization
; 0005 0079     // ADC Clock frequency: 1000.000 kHz
; 0005 007A     // ADC Voltage Reference: 2.56V, cap. on AREF
; 0005 007B     // ADC Auto Trigger Source: Free Running
; 0005 007C     // Digital input buffers on ADC0: On, ADC1: On, ADC2: On, ADC3: On
; 0005 007D     // ADC4: On, ADC5: On, ADC6: On, ADC7: On
; 0005 007E     DIDR0=0x00;
	LDI  R30,LOW(0)
	STS  126,R30
; 0005 007F 
; 0005 0080 
; 0005 0081     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
	CALL SUBOPT_0x29
	BREQ _0xA001A
	CALL SUBOPT_0x29
	CPI  R30,LOW(0x3)
	BRNE _0xA0019
_0xA001A:
; 0005 0082         // Digital input buffers on ADC8: Off, ADC9: On, ADC10: On, ADC11: On
; 0005 0083         // ADC12: On, ADC13: Off, ADC14: Off, ADC15: On
; 0005 0084         DIDR2=0x61;
	LDI  R30,LOW(97)
	RJMP _0xA0021
; 0005 0085     }
; 0005 0086     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
_0xA0019:
	CALL SUBOPT_0x2A
	BREQ _0xA001E
	CALL SUBOPT_0x29
	CPI  R30,LOW(0x2)
	BRNE _0xA001D
_0xA001E:
; 0005 0087         // Digital input buffers on ADC8: Off, ADC9: Off, ADC10: Off, ADC11: Off
; 0005 0088         // ADC12: Off, ADC13: Off, ADC14: Off, ADC15: On
; 0005 0089         DIDR2=0x7F;
	LDI  R30,LOW(127)
_0xA0021:
	STS  125,R30
; 0005 008A     }
; 0005 008B 
; 0005 008C     ADMUX   = ADC_VREF_TYPE;
_0xA001D:
	LDI  R30,LOW(64)
	STS  124,R30
; 0005 008D     ADCSRA  = (1<<7) |          // ADEN:    ADC enable
; 0005 008E               (0<<6) |          // ADSC:    ADC Start Conversion
; 0005 008F               (0<<5) |          // ADATE:   ADC Auto Trigger Enable
; 0005 0090               (0<<4) |          // ADIF:    ADC Interrupt Flag
; 0005 0091               (0<<3) |          // ADIE:    ADC Interrupt
; 0005 0092               (1<<2) |          //-----
; 0005 0093               (1<<1) |          //- ADPS2-0: ADC Prescaler Select Bits      (011 = clk/8) (110 = clk/64)
; 0005 0094               (0<<0);           //-----
	LDI  R30,LOW(134)
	STS  122,R30
; 0005 0095 
; 0005 0096     ADCSRB  = 0;
	LDI  R30,LOW(0)
	STS  123,R30
; 0005 0097 
; 0005 0098     //adc_init_read();
; 0005 0099 }
	RET
;/*============================================================*/
;#include <i2c.h>
;#include <delay.h>
;#include <string.h>
;#include <stdlib.h>
;#include <stdio.h>
;#include "ds1672.h"
;
;/*============================================================*/
;unsigned long raw_rtc;
;/*============================================================*/
;int DS1672_trickerChargeEnable(void) /* ----- enable the trickle-charger ------ */
; 0006 000C {

	.CSEG
_DS1672_trickerChargeEnable:
; 0006 000D     #asm("cli")
	cli
; 0006 000E     i2c_start();
	CALL SUBOPT_0x2D
; 0006 000F     i2c_write(ADDRTC);
; 0006 0010     i2c_write(5);
	LDI  R26,LOW(5)
	CALL _i2c_write
; 0006 0011     i2c_write(0xA6);            /* enable the trickle-charger : No diode, 2k ohm resistor */
	LDI  R26,LOW(166)
	CALL SUBOPT_0x2E
; 0006 0012     i2c_stop();
; 0006 0013     #asm("sei")
	sei
; 0006 0014 
; 0006 0015     /* 10ms delay to complete the write operation */
; 0006 0016     delay_ms(10);
	CALL SUBOPT_0x2F
; 0006 0017 
; 0006 0018     return 0;
	RET
; 0006 0019 }
;/*============================================================*/
;unsigned long int DS1672_read(void)
; 0006 001C {
_DS1672_read:
; 0006 001D     unsigned long int z;
; 0006 001E     unsigned char rtc_reg1, rtc_reg2, rtc_reg3, rtc_reg4;
; 0006 001F 
; 0006 0020     #asm("cli")
	SBIW R28,4
	CALL __SAVELOCR4
;	z -> Y+4
;	rtc_reg1 -> R17
;	rtc_reg2 -> R16
;	rtc_reg3 -> R19
;	rtc_reg4 -> R18
	cli
; 0006 0021     i2c_start();
	CALL SUBOPT_0x2D
; 0006 0022     i2c_write(ADDRTC);                      /* write slave address, write 1672 */
; 0006 0023     i2c_write(0x00);                        /* write register address, 1st clock register */
	LDI  R26,LOW(0)
	CALL _i2c_write
; 0006 0024     i2c_start();
	CALL _i2c_start
; 0006 0025     i2c_write(ADDRTC | 1);                  /* write slave address, read 1672 */
	LDI  R26,LOW(209)
	CALL _i2c_write
; 0006 0026     rtc_reg1 = i2c_read(ACK);                 /* starts w/last address stored in register pointer */
	LDI  R26,LOW(1)
	CALL _i2c_read
	MOV  R17,R30
; 0006 0027     rtc_reg2 = i2c_read(ACK);
	LDI  R26,LOW(1)
	CALL _i2c_read
	MOV  R16,R30
; 0006 0028     rtc_reg3 = i2c_read(ACK);
	LDI  R26,LOW(1)
	CALL _i2c_read
	MOV  R19,R30
; 0006 0029     rtc_reg4 = i2c_read(NACK);
	LDI  R26,LOW(0)
	CALL _i2c_read
	MOV  R18,R30
; 0006 002A     i2c_stop();
	CALL _i2c_stop
; 0006 002B     #asm("sei")
	sei
; 0006 002C 
; 0006 002D     z = rtc_reg4;
	MOV  R30,R18
	CLR  R31
	CLR  R22
	CLR  R23
	CALL SUBOPT_0x30
; 0006 002E     z <<= 8;
	CALL SUBOPT_0x31
	CALL SUBOPT_0x32
; 0006 002F     z += rtc_reg3;
	CALL SUBOPT_0x33
	CALL SUBOPT_0x34
; 0006 0030     z <<= 8;
; 0006 0031     z += rtc_reg2;
	CALL SUBOPT_0x35
	CALL SUBOPT_0x34
; 0006 0032     z <<= 8;
; 0006 0033     z += rtc_reg1;
	CALL SUBOPT_0x36
	CALL SUBOPT_0x31
	CALL SUBOPT_0x37
	CALL SUBOPT_0x38
; 0006 0034 
; 0006 0035     //printDebug("\r\nDS1672_read -> 0x%02X%02X%02X%02X\r\n",rtc_reg4,rtc_reg3,rtc_reg2,rtc_reg1);
; 0006 0036     //printDebug("rawtime [%ld]\r\n", z);
; 0006 0037 
; 0006 0038     return z;
	CALL __LOADLOCR4
	ADIW R28,8
	RET
; 0006 0039 }
;/*============================================================*/
;int binary_to_date(unsigned long x, struct rtc_structure *rtcCov) /* ------ convert binary time to date format ------ */
; 0006 003C {
_binary_to_date:
; 0006 003D     unsigned long yrs = 99, mon = 99, day = 99, tmp, jday, hrs, min, sec;
; 0006 003E     unsigned long j, n;
; 0006 003F     unsigned int dow;     // day of week
; 0006 0040 
; 0006 0041     j = x / 60;                             /* whole minutes since 1/1/70 */
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,40
	LDI  R24,12
	LDI  R26,LOW(28)
	LDI  R27,HIGH(28)
	LDI  R30,LOW(_0xC0003*2)
	LDI  R31,HIGH(_0xC0003*2)
	LDI  R22,BYTE3(_0xC0003*2)
	CALL __INITLOCB
	ST   -Y,R17
	ST   -Y,R16
;	x -> Y+44
;	*rtcCov -> Y+42
;	yrs -> Y+38
;	mon -> Y+34
;	day -> Y+30
;	tmp -> Y+26
;	jday -> Y+22
;	hrs -> Y+18
;	min -> Y+14
;	sec -> Y+10
;	j -> Y+6
;	n -> Y+2
;	dow -> R16,R17
	__GETD2S 44
	CALL SUBOPT_0x39
	CALL SUBOPT_0x3A
; 0006 0042     sec = x - (60 * j);                     /* leftover seconds */
	CALL SUBOPT_0x3B
	__GETD2S 44
	CALL __SUBD21
	__PUTD2S 10
; 0006 0043     n = j / 60;
	CALL SUBOPT_0x3C
	CALL SUBOPT_0x39
	CALL SUBOPT_0x3D
; 0006 0044     min = j - (60 * n);
	CALL SUBOPT_0x3E
	CALL SUBOPT_0x3B
	CALL SUBOPT_0x3C
	CALL __SUBD21
	__PUTD2S 14
; 0006 0045     j = n / 24;
	CALL SUBOPT_0x3F
	__GETD1N 0x18
	CALL __DIVD21U
	CALL SUBOPT_0x3A
; 0006 0046     hrs = n - (24 * j);
	__GETD2N 0x18
	CALL __MULD12U
	CALL SUBOPT_0x3F
	CALL __SUBD21
	__PUTD2S 18
; 0006 0047     j = j + (365 + 366);                    /* whole days since 1/1/68 */
	CALL SUBOPT_0x40
	__ADDD1N 731
	CALL SUBOPT_0x41
; 0006 0048 
; 0006 0049     dow = (j % 7)+1;                        /* since 1/1/68 is Monday */
	CALL SUBOPT_0x3C
	__GETD1N 0x7
	CALL __MODD21U
	ADIW R30,1
	MOVW R16,R30
; 0006 004A                                             /* 1-7 => Sun - Sat */
; 0006 004B     day = j / ((4 * 365) + 1);
	CALL SUBOPT_0x42
	CALL __DIVD21U
	CALL SUBOPT_0x43
; 0006 004C     tmp = j % ((4 * 365) + 1);
	CALL SUBOPT_0x42
	CALL __MODD21U
	CALL SUBOPT_0x44
; 0006 004D     if(tmp >= (31 + 29))                    /* if past 2/29 */
	CALL SUBOPT_0x45
	CALL SUBOPT_0x46
	BRLO _0xC0004
; 0006 004E     day++;                                  /* add a leap day */
	__GETD1S 30
	CALL SUBOPT_0x47
	CALL SUBOPT_0x43
; 0006 004F     yrs = (j - day) / 365;                  /* whole years since 1968 */
_0xC0004:
	CALL SUBOPT_0x48
	CALL SUBOPT_0x40
	CALL __SUBD12
	MOVW R26,R30
	MOVW R24,R22
	__GETD1N 0x16D
	CALL __DIVD21U
	__PUTD1S 38
; 0006 0050     jday = j - (yrs * 365) - day;           /* days since 1/1 of current year */
	CALL SUBOPT_0x49
	__GETD2N 0x16D
	CALL __MULD12U
	CALL SUBOPT_0x3C
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x48
	CALL __SUBD12
	CALL SUBOPT_0x4B
; 0006 0051     if(tmp <= 365 && tmp >= 60)             /* if past 2/29 and a leap year then */
	CALL SUBOPT_0x45
	__CPD2N 0x16E
	BRSH _0xC0006
	CALL SUBOPT_0x45
	CALL SUBOPT_0x46
	BRSH _0xC0007
_0xC0006:
	RJMP _0xC0005
_0xC0007:
; 0006 0052     jday++;                                 /* add a leap day */
	CALL SUBOPT_0x4C
	CALL SUBOPT_0x47
	CALL SUBOPT_0x4B
; 0006 0053     yrs += 1968;                            /* calculate year */
_0xC0005:
	CALL SUBOPT_0x49
	__ADDD1N 1968
	__PUTD1S 38
; 0006 0054     for(mon = 12; mon > 0; mon--)
	__GETD1N 0xC
	__PUTD1S 34
_0xC0009:
	__GETD2S 34
	CALL __CPD02
	BRLO PC+3
	JMP _0xC000A
; 0006 0055     {
; 0006 0056         switch(mon)
	CALL SUBOPT_0x4D
; 0006 0057         {
; 0006 0058             case 1:     tmp = 0;
	__CPD1N 0x1
	BRNE _0xC000E
	LDI  R30,LOW(0)
	__CLRD1S 26
; 0006 0059                         break;
	RJMP _0xC000D
; 0006 005A             case 2:     tmp = 31;
_0xC000E:
	__CPD1N 0x2
	BRNE _0xC000F
	__GETD1N 0x1F
	RJMP _0xC004D
; 0006 005B                         break;
; 0006 005C             case 3:     tmp = 59;
_0xC000F:
	__CPD1N 0x3
	BRNE _0xC0010
	__GETD1N 0x3B
	RJMP _0xC004D
; 0006 005D                         break;
; 0006 005E             case 4:     tmp = 90;
_0xC0010:
	__CPD1N 0x4
	BRNE _0xC0011
	__GETD1N 0x5A
	RJMP _0xC004D
; 0006 005F                         break;
; 0006 0060             case 5:     tmp = 120;
_0xC0011:
	__CPD1N 0x5
	BRNE _0xC0012
	__GETD1N 0x78
	RJMP _0xC004D
; 0006 0061                         break;
; 0006 0062             case 6:     tmp = 151;
_0xC0012:
	__CPD1N 0x6
	BRNE _0xC0013
	__GETD1N 0x97
	RJMP _0xC004D
; 0006 0063                         break;
; 0006 0064             case 7:     tmp = 181;
_0xC0013:
	__CPD1N 0x7
	BRNE _0xC0014
	__GETD1N 0xB5
	RJMP _0xC004D
; 0006 0065                         break;
; 0006 0066             case 8:     tmp = 212;
_0xC0014:
	__CPD1N 0x8
	BRNE _0xC0015
	__GETD1N 0xD4
	RJMP _0xC004D
; 0006 0067                         break;
; 0006 0068             case 9:     tmp = 243;
_0xC0015:
	__CPD1N 0x9
	BRNE _0xC0016
	__GETD1N 0xF3
	RJMP _0xC004D
; 0006 0069                         break;
; 0006 006A             case 10:    tmp = 273;
_0xC0016:
	__CPD1N 0xA
	BRNE _0xC0017
	__GETD1N 0x111
	RJMP _0xC004D
; 0006 006B                         break;
; 0006 006C             case 11:    tmp = 304;
_0xC0017:
	__CPD1N 0xB
	BRNE _0xC0018
	__GETD1N 0x130
	RJMP _0xC004D
; 0006 006D                         break;
; 0006 006E             case 12:    tmp = 334;
_0xC0018:
	__CPD1N 0xC
	BRNE _0xC000D
	__GETD1N 0x14E
_0xC004D:
	__PUTD1S 26
; 0006 006F                         break;
; 0006 0070         }
_0xC000D:
; 0006 0071         if((mon > 2) && !(yrs % 4))         /* adjust for leap year */
	__GETD2S 34
	__CPD2N 0x3
	BRLO _0xC001B
	CALL SUBOPT_0x49
	ANDI R30,LOW(0x3)
	BREQ _0xC001C
_0xC001B:
	RJMP _0xC001A
_0xC001C:
; 0006 0072         tmp++;
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x47
	CALL SUBOPT_0x44
; 0006 0073         if(jday >= tmp) break;
_0xC001A:
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x4F
	CALL __CPD21
	BRSH _0xC000A
; 0006 0074     }
	CALL SUBOPT_0x4D
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	__PUTD1S 34
	RJMP _0xC0009
_0xC000A:
; 0006 0075     day = jday - tmp + 1;                   /* calculate day in month */
	CALL SUBOPT_0x45
	CALL SUBOPT_0x4C
	CALL __SUBD12
	CALL SUBOPT_0x50
	CALL SUBOPT_0x43
; 0006 0076 
; 0006 0077     rtcCov->year    = yrs;
	CALL SUBOPT_0x49
	LDD  R26,Y+42
	LDD  R27,Y+42+1
	CALL __PUTDP1
; 0006 0078     rtcCov->month   = mon;
	CALL SUBOPT_0x4D
	__PUTD1SNS 42,4
; 0006 0079     rtcCov->date    = day;
	__GETD1S 30
	__PUTD1SNS 42,8
; 0006 007A     rtcCov->hour    = hrs;
	CALL SUBOPT_0x51
	__PUTD1SNS 42,12
; 0006 007B     rtcCov->min     = min;
	CALL SUBOPT_0x52
	__PUTD1SNS 42,16
; 0006 007C     rtcCov->sec     = sec;
	CALL SUBOPT_0x53
	__PUTD1SNS 42,20
; 0006 007D     rtcCov->day     = dow;
	MOVW R30,R16
	__PUTW1SNS 42,24
; 0006 007E 
; 0006 007F     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,48
	RET
; 0006 0080 }
;/*============================================================*/
;unsigned long int date_to_binary(struct rtc_structure rtcSrc)
; 0006 0083 {
; 0006 0084     /* ---- convert date to elapsed days in binary ---- */
; 0006 0085     unsigned long x;                                        // total second
; 0006 0086 
; 0006 0087     /* the following is broken down for clarity */
; 0006 0088     x = (unsigned long)365 * (rtcSrc.year - 1970);          /* calculate number of days for previous years */
;	rtcSrc -> Y+4
;	x -> Y+0
; 0006 0089     x += ((rtcSrc.year - 1969) >> 2);                       /* add a day for each leap year */
; 0006 008A     if((rtcSrc.month > 2) && (rtcSrc.year % 4 == 0))        /* add a day if current year is leap and past Feb 29th */
; 0006 008B         x++;
; 0006 008C 
; 0006 008D     switch(rtcSrc.month)
; 0006 008E     {
; 0006 008F         case 1:     x += 0;
; 0006 0090                     break;
; 0006 0091         case 2:     x += 31;
; 0006 0092                     break;
; 0006 0093         case 3:     x += 59;
; 0006 0094                     break;
; 0006 0095         case 4:     x += 90;
; 0006 0096                     break;
; 0006 0097         case 5:     x += 120;
; 0006 0098                     break;
; 0006 0099         case 6:     x += 151;
; 0006 009A                     break;
; 0006 009B         case 7:     x += 181;
; 0006 009C                     break;
; 0006 009D         case 8:     x += 212;
; 0006 009E                     break;
; 0006 009F         case 9:     x += 243;
; 0006 00A0                     break;
; 0006 00A1         case 10:    x += 273;
; 0006 00A2                     break;
; 0006 00A3         case 11:    x += 304;
; 0006 00A4                     break;
; 0006 00A5         case 12:    x += 334;
; 0006 00A6                     break;
; 0006 00A7     }
; 0006 00A8 
; 0006 00A9     x += rtcSrc.date - 1;                       /* finally, add the days into the current month */
; 0006 00AA     x = x * 86400;                              /* and calculate the number of seconds in all those days (1 day = 86400 second)*/
; 0006 00AB     x += (unsigned long)rtcSrc.hour * 1800;     /* add the number of seconds in the hours */
; 0006 00AC     x += (unsigned long)rtcSrc.hour * 1800;     /* add the number of seconds in the hours */
; 0006 00AD     x += (unsigned long)rtcSrc.min * 60;        /* ditto the minutes */
; 0006 00AE     x += rtcSrc.sec;                            /* finally, the seconds */
; 0006 00AF 
; 0006 00B0     return(x);
; 0006 00B1 }
;/*============================================================*/
;int RTC_setBinary(unsigned long int rtc_bin)
; 0006 00B4 {
_RTC_setBinary:
; 0006 00B5     unsigned long int rtc_current;
; 0006 00B6     unsigned long int rtc_diff;
; 0006 00B7     unsigned char a, b, c, d;
; 0006 00B8 
; 0006 00B9     rtc_current = DS1672_read();
	CALL __PUTPARD2
	SBIW R28,8
	CALL __SAVELOCR4
;	rtc_bin -> Y+12
;	rtc_current -> Y+8
;	rtc_diff -> Y+4
;	a -> R17
;	b -> R16
;	c -> R19
;	d -> R18
	RCALL _DS1672_read
	CALL SUBOPT_0x54
; 0006 00BA 
; 0006 00BB     if(rtc_current > rtc_bin){
	CALL SUBOPT_0x55
	CALL SUBOPT_0x56
	CALL __CPD12
	BRSH _0xC0030
; 0006 00BC         rtc_diff = (unsigned long int) (rtc_current - rtc_bin);
	CALL SUBOPT_0x57
	CALL SUBOPT_0x58
	CALL __SUBD12
	CALL SUBOPT_0x30
; 0006 00BD     }
; 0006 00BE     else if(rtc_bin > rtc_current){
	RJMP _0xC0031
_0xC0030:
	CALL SUBOPT_0x58
	CALL SUBOPT_0x57
	CALL __CPD12
	BRSH _0xC0032
; 0006 00BF         rtc_diff = (unsigned long int) (rtc_bin - rtc_current);
	CALL SUBOPT_0x56
	CALL SUBOPT_0x55
	CALL __SUBD12
	CALL SUBOPT_0x30
; 0006 00C0     }
; 0006 00C1     else{
	RJMP _0xC0033
_0xC0032:
; 0006 00C2         // set value and current value are equal
; 0006 00C3         //printDebug("\r\nset time and current time are equal\r\n");
; 0006 00C4         rtc_diff = 0;
	LDI  R30,LOW(0)
	__CLRD1S 4
; 0006 00C5     }
_0xC0033:
_0xC0031:
; 0006 00C6 
; 0006 00C7     if((rtc_diff >= 0) && (rtc_diff < 10)){
	CALL SUBOPT_0x31
	CALL __CPD20
	BRLO _0xC0035
	CALL SUBOPT_0x31
	__CPD2N 0xA
	BRLO _0xC0036
_0xC0035:
	RJMP _0xC0034
_0xC0036:
; 0006 00C8         //printDebug("\r\nset time is too close to current time, not set!!!\r\n");
; 0006 00C9         //printDebug("\r\nset time is too close to current time, not set!!! c[%ld] s[%ld]\r\n", rtc_current, rtc_bin);
; 0006 00CA         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E003C
; 0006 00CB     }
; 0006 00CC 
; 0006 00CD     printDebug("c_time[%ld] & s_time[%ld] => diff[%ld]\r\n",rtc_current,rtc_bin,rtc_diff);
_0xC0034:
	__POINTD1FN _0xC0000,0
	CALL SUBOPT_0x21
	CALL __PUTPARD1
	CALL SUBOPT_0x59
	CALL SUBOPT_0x5A
	CALL SUBOPT_0x22
; 0006 00CE 
; 0006 00CF     a = (rtc_bin & 0xff);
	LDD  R30,Y+12
	MOV  R17,R30
; 0006 00D0     b = ((rtc_bin >> 8) & 0xff);
	CALL SUBOPT_0x57
	LDI  R30,LOW(8)
	CALL __LSRD12
	MOV  R16,R30
; 0006 00D1     c = ((rtc_bin >> 16) & 0xff);
	CALL SUBOPT_0x5B
	MOV  R19,R30
; 0006 00D2     d = ((rtc_bin >> 24) & 0xff);
	CALL SUBOPT_0x57
	LDI  R30,LOW(24)
	CALL __LSRD12
	MOV  R18,R30
; 0006 00D3 
; 0006 00D4     #asm("cli")
	cli
; 0006 00D5     i2c_start();
	CALL SUBOPT_0x2D
; 0006 00D6     i2c_write(ADDRTC);          /* write slave address, write 1672 */
; 0006 00D7     i2c_write(0x00);            /* write register address, 1st clock register */
	LDI  R26,LOW(0)
	CALL _i2c_write
; 0006 00D8     i2c_write(a);
	MOV  R26,R17
	CALL _i2c_write
; 0006 00D9     i2c_write(b);
	MOV  R26,R16
	CALL _i2c_write
; 0006 00DA     i2c_write(c);
	MOV  R26,R19
	CALL _i2c_write
; 0006 00DB     i2c_write(d);
	MOV  R26,R18
	CALL SUBOPT_0x2E
; 0006 00DC     i2c_stop();
; 0006 00DD     #asm("sei")
	sei
; 0006 00DE 
; 0006 00DF     printDebug(">> RTC_setBinary RTC Sync.\r\n");
	__POINTD1FN _0xC0000,41
	CALL SUBOPT_0x0
; 0006 00E0 
; 0006 00E1     /* 10ms delay to complete the write operation */
; 0006 00E2     delay_ms(10);
	CALL SUBOPT_0x2F
; 0006 00E3 
; 0006 00E4     return 0;
_0x20E003C:
	CALL __LOADLOCR4
	ADIW R28,16
	RET
; 0006 00E5 }
;/*============================================================*/
;int RTC_setDateTime(struct rtc_structure rtcSrc,int timezone)
; 0006 00E8 {
; 0006 00E9     unsigned long int rtc_bin;
; 0006 00EA     unsigned long int rtc_current;
; 0006 00EB     unsigned long int rtc_diff;
; 0006 00EC     unsigned char a, b, c, d;
; 0006 00ED 
; 0006 00EE     if((timezone > 14) || (timezone < -12)){
;	rtcSrc -> Y+18
;	timezone -> Y+16
;	rtc_bin -> Y+12
;	rtc_current -> Y+8
;	rtc_diff -> Y+4
;	a -> R17
;	b -> R16
;	c -> R19
;	d -> R18
; 0006 00EF         printDebug("<RTC_setDateTime> Timezone out of range (%+d)\r\n",timezone);
; 0006 00F0         return -2;
; 0006 00F1     }
; 0006 00F2 
; 0006 00F3     rtc_bin = date_to_binary(rtcSrc);
; 0006 00F4 
; 0006 00F5     rtc_bin = rtc_bin + (int)(timezone * 60 * 60 * -1);
; 0006 00F6 
; 0006 00F7     raw_rtc = rtc_bin;
; 0006 00F8 
; 0006 00F9     rtc_current = DS1672_read();
; 0006 00FA 
; 0006 00FB     if(rtc_current > rtc_bin){
; 0006 00FC         rtc_diff = (unsigned long int) (rtc_current - rtc_bin);
; 0006 00FD     }
; 0006 00FE     else if(rtc_bin > rtc_current){
; 0006 00FF         rtc_diff = (unsigned long int) (rtc_bin - rtc_current);
; 0006 0100     }
; 0006 0101     else{
; 0006 0102         // set value and current value are equal
; 0006 0103         rtc_diff = 0;
; 0006 0104     }
; 0006 0105 
; 0006 0106     if((rtc_diff >= 0) && (rtc_diff < 10)){
; 0006 0107         //printDebug("\r\nset time is too close to current time, not set!!! c[%ld] s[%ld]\r\n", rtc_current, rtc_bin);
; 0006 0108         return -1;
; 0006 0109     }
; 0006 010A 
; 0006 010B     printDebug("c_time[%ld] & s_time[%ld] => diff[%ld]\r\n",rtc_current,rtc_bin,rtc_diff);
; 0006 010C 
; 0006 010D     a = (rtc_bin & 0xff);
; 0006 010E     b = ((rtc_bin >> 8) & 0xff);
; 0006 010F     c = ((rtc_bin >> 16) & 0xff);
; 0006 0110     d = ((rtc_bin >> 24) & 0xff);
; 0006 0111 
; 0006 0112     #asm("cli")
; 0006 0113     i2c_start();
; 0006 0114     i2c_write(ADDRTC);          /* write slave address, write 1672 */
; 0006 0115     i2c_write(0x00);            /* write register address, 1st clock register */
; 0006 0116     i2c_write(a);
; 0006 0117     i2c_write(b);
; 0006 0118     i2c_write(c);
; 0006 0119     i2c_write(d);
; 0006 011A     i2c_stop();
; 0006 011B     #asm("sei")
; 0006 011C 
; 0006 011D     /* 10ms delay to complete the write operation */
; 0006 011E     delay_ms(10);
; 0006 011F 
; 0006 0120     return 0;
; 0006 0121 }
;/*============================================================*/
;int RTC_getDateTime(struct rtc_structure *rtcPtr, int timezone)
; 0006 0124 {
_RTC_getDateTime:
; 0006 0125     unsigned long r_rtc;
; 0006 0126     int flag;
; 0006 0127 
; 0006 0128     r_rtc = DS1672_read();
	CALL SUBOPT_0x5C
	ST   -Y,R16
;	*rtcPtr -> Y+8
;	timezone -> Y+6
;	r_rtc -> Y+2
;	flag -> R16,R17
	RCALL _DS1672_read
	CALL SUBOPT_0x5D
; 0006 0129     if(r_rtc == 0xFFFFFFFF){
	CALL SUBOPT_0x5E
	BRNE _0xC0041
; 0006 012A         flag    = RTC_BACKUP;
	__GETWRN 16,17,1
; 0006 012B         r_rtc   = raw_rtc;
	LDS  R30,_raw_rtc
	LDS  R31,_raw_rtc+1
	LDS  R22,_raw_rtc+2
	LDS  R23,_raw_rtc+3
	CALL SUBOPT_0x3D
; 0006 012C     }
; 0006 012D     else{
	RJMP _0xC0042
_0xC0041:
; 0006 012E         flag    = RTC_REAL;
	__GETWRN 16,17,0
; 0006 012F         raw_rtc = r_rtc;
	CALL SUBOPT_0x3E
	STS  _raw_rtc,R30
	STS  _raw_rtc+1,R31
	STS  _raw_rtc+2,R22
	STS  _raw_rtc+3,R23
; 0006 0130     }
_0xC0042:
; 0006 0131 
; 0006 0132     r_rtc = r_rtc + (int)(timezone * 60 * 60);
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDI  R26,LOW(60)
	LDI  R27,HIGH(60)
	CALL __MULW12
	LDI  R26,LOW(60)
	LDI  R27,HIGH(60)
	CALL __MULW12
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x37
	CALL SUBOPT_0x3D
; 0006 0133 
; 0006 0134     binary_to_date(r_rtc,rtcPtr);
	CALL SUBOPT_0x3E
	CALL __PUTPARD1
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	RCALL _binary_to_date
; 0006 0135 
; 0006 0136     return flag;
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E003B:
	ADIW R28,10
	RET
; 0006 0137 }
;/*============================================================*/
;void printRTC(struct rtc_structure time)
; 0006 013A {
_printRTC:
; 0006 013B     switch(time.day){
;	time -> Y+0
	LDD  R30,Y+24
	LDD  R31,Y+24+1
; 0006 013C         case DAY_MON: printDebug("Mon. "); break;
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0xC0046
	__POINTD1FN _0xC0000,118
	RJMP _0xC004F
; 0006 013D         case DAY_TUE: printDebug("Tue. "); break;
_0xC0046:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0xC0047
	__POINTD1FN _0xC0000,124
	RJMP _0xC004F
; 0006 013E         case DAY_WED: printDebug("Wed. "); break;
_0xC0047:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0xC0048
	__POINTD1FN _0xC0000,130
	RJMP _0xC004F
; 0006 013F         case DAY_THU: printDebug("Thu. "); break;
_0xC0048:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0xC0049
	__POINTD1FN _0xC0000,136
	RJMP _0xC004F
; 0006 0140         case DAY_FRI: printDebug("Fri. "); break;
_0xC0049:
	CPI  R30,LOW(0x5)
	LDI  R26,HIGH(0x5)
	CPC  R31,R26
	BRNE _0xC004A
	__POINTD1FN _0xC0000,142
	RJMP _0xC004F
; 0006 0141         case DAY_SAT: printDebug("Sat. "); break;
_0xC004A:
	CPI  R30,LOW(0x6)
	LDI  R26,HIGH(0x6)
	CPC  R31,R26
	BRNE _0xC004B
	__POINTD1FN _0xC0000,148
	RJMP _0xC004F
; 0006 0142         case DAY_SUN: printDebug("Sun. "); break;
_0xC004B:
	CPI  R30,LOW(0x7)
	LDI  R26,HIGH(0x7)
	CPC  R31,R26
	BRNE _0xC0045
	__POINTD1FN _0xC0000,154
_0xC004F:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0006 0143     }
_0xC0045:
; 0006 0144 
; 0006 0145     printDebug(
; 0006 0146         "[%d]%04d-%02d-%02d %02d:%02d:%02d\r\n",
; 0006 0147         time.day,
; 0006 0148         time.year,
; 0006 0149         time.month,
; 0006 014A         time.date,
; 0006 014B         time.hour,
; 0006 014C         time.min,
; 0006 014D         time.sec
; 0006 014E     );
	__POINTD1FN _0xC0000,160
	CALL __PUTPARD1
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x58
	CALL SUBOPT_0x5A
	CALL __PUTPARD1
	__GETD1S 24
	CALL __PUTPARD1
	__GETD1S 32
	CALL __PUTPARD1
	__GETD1S 40
	CALL __PUTPARD1
	__GETD1S 48
	CALL __PUTPARD1
	LDI  R24,28
	CALL _printDebug
	ADIW R28,32
; 0006 014F     return;
	RJMP _0x20E003A
; 0006 0150 }
;/*============================================================*/
;void init_RTC(void)
; 0006 0153 {
_init_RTC:
; 0006 0154     struct rtc_structure rtcTest;
; 0006 0155 
; 0006 0156     raw_rtc = 0;            /* initial default time_value in RAM */
	SBIW R28,26
;	rtcTest -> Y+0
	LDI  R30,LOW(0)
	STS  _raw_rtc,R30
	STS  _raw_rtc+1,R30
	STS  _raw_rtc+2,R30
	STS  _raw_rtc+3,R30
; 0006 0157 
; 0006 0158     #asm("cli")
	cli
; 0006 0159     i2c_start();
	CALL SUBOPT_0x2D
; 0006 015A     i2c_write(ADDRTC);
; 0006 015B     i2c_write(0x04);
	LDI  R26,LOW(4)
	CALL _i2c_write
; 0006 015C     i2c_write(0x00);         /* enable the oscillator */
	LDI  R26,LOW(0)
	CALL SUBOPT_0x2E
; 0006 015D     i2c_stop();
; 0006 015E     #asm("sei")
	sei
; 0006 015F 
; 0006 0160     DS1672_trickerChargeEnable();
	RCALL _DS1672_trickerChargeEnable
; 0006 0161 
; 0006 0162     RTC_getDateTime(&rtcTest,7);
	MOVW R30,R28
	CALL SUBOPT_0x3
	RCALL _RTC_getDateTime
; 0006 0163 
; 0006 0164     printDebug("Running with System Clock @ ");
	__POINTD1FN _0xC0000,196
	CALL SUBOPT_0x0
; 0006 0165 
; 0006 0166     printRTC(rtcTest);
	CALL SUBOPT_0x60
; 0006 0167 }
_0x20E003A:
	ADIW R28,26
	RET
;#include "config.h"
;
;eeprom iDVConfig_t viDVConfigDefualt;
;eeprom iDVConfig_t viDVConfigUpdate;
;#include <stdlib.h>
;#include "configstructure.h"
;
;///**************************************************************/
;///**************** Configuration saved in EEPROM ***************/
;///**************************************************************/
;///*============================================================*/
;//eeprom struct prop_cnfg_st  config_prop                     =   {   "EndPoint",
;//                                                                    "COMM-ETH-0.01a",
;//                                                                    "TestEndPoint01",
;//                                                                    "00000000001",
;//                                                                    "iNTELENICs Company",
;//                                                                    "STRI-703",
;//                                                                    7
;//                                                                };
;//eeprom struct oper_cnfg_st  config_oper                     =   {   0x20,
;//                                                                    0x00,
;//                                                                    0x00,
;//                                                                    {0x00,0x00,0x00,0x00,0x00}
;//                                                                };
;//eeprom struct sens_cnfg_st  config_sens[MAX_SENS_CHANNEL]   =   {   {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   }
;//                                                                };
;//eeprom struct din_cnfg_st   config_din[MAX_DI_CHANNEL]      =   {   {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15}
;//                                                                };
;//eeprom struct dout_cnfg_st  config_dout[MAX_DO_CHANNEL]     =   {   {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    }
;//                                                                };
;////                                                                    ,{0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    }
;////                                                                };
;//eeprom struct ain_cnfg_st   config_ain[MAX_AI_CHANNEL]      =   {   {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5}
;//                                                                };
;//eeprom struct aout_cnfg_st  config_aout[MAX_AO_CHANNEL]     =   {   {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//
;//                                                                };
;//eeprom struct buzz_cnfg_st  config_buzz                     =   {   0x00,
;//                                                                    0x00,
;//                                                                    {   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                        0x00,0x00,0x00,0x00,0x00
;//                                                                    }
;//                                                                };
;//eeprom struct alm_cnfg_st   config_alm                      =   {   0x00000000,
;//                                                                    0x0000,
;//                                                                    0x00000000,
;//                                                                    0x00000000,
;//                                                                    0x0000,
;//                                                                    0x0000
;//                                                                };
;//eeprom struct stat_cnfg_st  config_stat                     =   {0x30,60};
;///*============================================================*/
;//
;///**************************************************************/
;///***************** EEPROM Configured indicator ****************/
;///**************************************************************/
;///*============================================================*/
;//eeprom char config_prop_flag                    =   0x00;
;//eeprom char config_oper_flag                    =   0x00;
;//eeprom char config_sens_flag[MAX_SENS_CHANNEL]  =   {0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_din_flag[MAX_DI_CHANNEL]     =   {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_dout_flag[MAX_DO_CHANNEL]    =   {0x00,0x00,0x00,0x00,0x00};//,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_ain_flag[MAX_AI_CHANNEL]     =   {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_aout_flag[MAX_AO_CHANNEL]    =   {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_buzz_flag                    =   0x00;
;//eeprom char config_alm_flag                     =   0x00;
;//eeprom char config_stat_flag                    =   0x00;
;///*============================================================*/
;#include <stdlib.h>
;#include <stdio.h>
;#include <string.h>
;#include <delay.h>
;#include "ethcomm.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "io.h"
;#include "log.h"
;#include "logqueue.h"
;#include "debug.h"
;
;//eeprom char     DEVICE_SERIAL[8]    = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
;eeprom char     DEVICE_SERIAL[8]    = {0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x22};
;/*bongkot edit default of serial number*/
;
;TIMER           commLostTimer       = 0;
;unsigned char   duplicateListClear  = 0;
;
;struct log_wait_st    logDataWait   = {0x00,0x00};
;struct log_wait_st    logEventWait  = {0x00,0x00};
;
;/**************************************************************/
;/***** Higher Level Communication Management (IMS_Protocol)****/
;/**************************************************************/
;/*============================================================*/
;//int ETH_sendNack(char frameID,char errCode)
;//{
;//    int     i=0,k=0;
;//    char    frameData[2+sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = PROTOERROR;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = errCode;
;//
;//    printDebug("<ETH_sendNack> sending..\r\n");
;//    //print_payload(frameData,i);
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendStatusRequestAck(char frameID,char accm,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[7+sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = STATREQA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accm;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendStatusRequestAck> sending..\r\n");
;//    //print_payload(frameData,i);
;//
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//
;//}
;///*============================================================*/
;//int ETH_sendStatusReportCmd(unsigned long int timestamp, unsigned char accm, unsigned char *paraResp, int paraLen)
;//{
;//    int     i=0,k=0;
;//    int     frameLen    = 0;
;//    char    *frameData;
;//
;//    frameLen            = 1 + sizeof(DEVICE_SERIAL) + sizeof(timestamp) + sizeof(accm) + paraLen;
;//    if(frameLen > 250){
;//        printDebug("<ETH_sendStatusReportCmd> frameLen too long (%d bytes)\r\n",frameLen);
;//        return -1;
;//    }
;//
;//    frameData           = (char *) malloc (frameLen);
;//    if(frameData == NULL){
;//        printDebug("<ETH_sendStatusReportCmd> malloc failed (%d bytes)\r\n",frameLen);
;//        return -1;
;//    }
;//
;//    frameData[i++]      = STATREPC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    memcpy(&frameData[i],&timestamp,sizeof(timestamp));
;//    i += sizeof(timestamp);
;//
;//    frameData[i++]      = accm;
;//
;//    memcpy(&frameData[i],paraResp,paraLen);
;//    i += paraLen;
;//
;//    ETH_send(frameData,i,0x00,CMD_TIMEOUT);
;//    free( frameData );
;//}
;///*============================================================*/
;//int ETH_sendEventReportCmd(char eventType, unsigned long int timestamp, char eventID, char statusCode)
;//{
;//    int     i=0,k=0,res=0;
;//    char    frameID;
;//    char    frameData[8 + sizeof(DEVICE_SERIAL)];
;//
;//    if((eventType != TYP_RLT) && (eventType != TYP_LOG) && (eventType != TYP_SAV))
;//    {
;//        printDebug("<ETH_sendEventReportCmd> Wrong eventType 0x%02X\r\n", eventType);
;//        return -1;
;//    }
;//
;//    frameData[i++]      =   EVENREPC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    memcpy(&frameData[i],&timestamp,sizeof(timestamp));
;//    i += sizeof(timestamp);
;//
;//    frameData[i++]      =   eventType;
;//    frameData[i++]      =   eventID;
;//    frameData[i++]      =   statusCode;
;//
;//    frameID             = ETH_generateId();
;//
;//    if(eventType == TYP_RLT)
;//    {
;//        res = addEventLogQueue(frameID,timestamp,eventID,statusCode);
;//        if(res < 0)
;//        {
;//            printDebug("<ETH_sendEventReportCmd> addEventLogQueue(0x%02X,%ld,0x%02X,0x%02X) failed\r\n",
;//                        frameID,timestamp,eventID,statusCode);
;//        }
;//    }
;//    else if(eventType == TYP_LOG)
;//    {
;//        logEventWait.frameID = frameID;
;//    }
;//
;//    printDebug("<ETH_sendEventReportCmd> sending..\r\n");
;//    print_payload(frameData,i);
;//
;//    res = ETH_send(frameData,i,frameID,CMD_TIMEOUT);
;//    if(res < 0){
;//        return -1;
;//    }
;//    else{
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int ETH_sendConfigManageNack(char frameID,char accd,char cnfg,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[4 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = CONFMANA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accd;
;//    frameData[i++]      = cnfg;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendConfigManageNack> sending..\r\n");
;//    //print_payload(frameData,i);
;//
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendConfigManageAck(char frameID,char accd,char cnfg,char status,char *cnfgData, int cnfgLen)
;//{
;//    int     i=0,k=0;
;//    int     frameLen    = 0;
;//    char    *frameData;
;//
;//
;//    frameLen            = 1 + sizeof(DEVICE_SERIAL) + sizeof(accd) + sizeof(cnfg) + sizeof(status) + cnfgLen;
;//    if(frameLen > 250){
;//        printDebug("<ETH_sendConfigManageAck> frameLen too long (%d bytes)\r\n",frameLen);
;//        ETH_sendConfigManageNack(frameID,accd,cnfg,ERROR);
;//        return -1;
;//    }
;//
;//    frameData           = (char *) malloc (frameLen);
;//    if(frameData == NULL){
;//        printDebug("<ETH_sendConfigManageAck> malloc failed (%d bytes)\r\n",frameLen);
;//        ETH_sendConfigManageNack(frameID,accd,cnfg,ERROR);
;//        return -1;
;//    }
;//
;//    frameData[i++]      = CONFMANA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accd;
;//    frameData[i++]      = cnfg;
;//    frameData[i++]      = status;
;//    if(cnfgLen > 0){
;//        memcpy(&frameData[i],cnfgData,cnfgLen);
;//        i += cnfgLen;
;//    }
;//
;//    printDebug("<ETH_sendConfigManageAck> sending..\r\n");
;//    print_payload(frameData,i);
;//
;//    ETH_send(frameData,i,frameID,0);
;//
;//    free( frameData );
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendDataReportCmd(char dataType, unsigned long int timestamp, unsigned int sensorID, float value)
;//{
;//    int     i=0,k=0,res=0;
;//    char    frameID;
;//    char    frameData[10 + sizeof(DEVICE_SERIAL)];
;//    char    did = 0x00;
;//
;//    if((dataType != TYP_RLT) && (dataType != TYP_LOG) && (dataType != TYP_SAV))
;//    {
;//        printDebug("<ETH_sendDataReportCmd> Wrong dataType 0x%02X\r\n", dataType);
;//        return -1;
;//    }
;//
;//    did     = ((sensorID+1) & 0xff) << 4;
;//    did    |= dataType;
;//
;//    frameData[i++]      =   DATAREPC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    memcpy(&frameData[i],&timestamp,sizeof(timestamp));
;//    i += sizeof(timestamp);
;//
;//    frameData[i++]      =   did;
;//
;//    memcpy(&frameData[i],&value,sizeof(value));
;//    i += sizeof(value);
;//
;//    frameID             = ETH_generateId();
;//
;//    if(dataType == TYP_RLT)
;//    {
;//        res = addDataLogQueue(frameID,timestamp,sensorID,value);
;//        if(res < 0)
;//        {
;//            printDebug("<ETH_sendDataReportCmd> addDataLogQueue(0x%02X,%ld,%u,%.2f) failed\r\n",frameID,timestamp,sensorID,value);
;//        }
;//    }
;//    else if(dataType == TYP_LOG)
;//    {
;//        logDataWait.frameID = frameID;
;//    }
;//
;//    printDebug("<ETH_sendDataReportCmd> sending..\r\n");
;//    //print_payload(frameData,i);
;//
;//    res = ETH_send(frameData,i,frameID,CMD_TIMEOUT);
;//    if(res < 0){
;//        return -1;
;//    }
;//    else{
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int ETH_sendLogManipulationAck(char frameID,char accd,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[3 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = LOGMANIA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accd;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendLogManipulationAck> sending..\r\n");
;//    //print_payload(frameData,i);
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendNetworkMaintenanceAck(char frameID,char cmd,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[3 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = NETMAINA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = cmd;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendNetworkMaintenanceAck> sending..\r\n");
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_remoteDeviceControlAck(char frameID,char cmd,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[3 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = RMDCTRLA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = cmd;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_remoteDeviceControlAck> sending..\r\n");
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_clearDuplicateRequestCmd(void)
;//{
;//    int     i=0,k=0;
;//    char    frameData[2 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]  = CLRLISTC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]  = CLR_DUPLIST;
;//
;//    printDebug("<ETH_clearDuplicateRequestCmd> sending..\r\n");
;//    ETH_send(frameData,i,0xFF,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//void ETH_checkPushLog(unsigned char id)
;//{
;//    FIL                 file;
;//    int                 res;
;//    unsigned long int   timestamp;
;//    unsigned int        channel;
;//    float               value;
;//    unsigned char       eventID;
;//    unsigned char       eventStatus;
;//
;//    // -- check if id is in dataLogQueue -- //
;//    res = readDataLogQueue(id,&timestamp,&channel,&value);
;//    if(res != -1)
;//    {
;//        // -- found in dataLogQueue -- //
;//        if( (timestamp == 0) || (timestamp == 0xFFFFFFFF) || (channel > (MAX_SENS_CHANNEL-1)) )
;//        {
;//            printDebug("\r\n<ETH_checkPushLog> === ERROR INFOMATION IN DATA LOG QUEUE ===\r\n");
;//        }
;//        else
;//        {
;//            printDebug("<ETH_checkPushLog> DataLog time[%ld],ch[%d],val[%.2f]\r\n",timestamp,channel,value);
;//            res = LOG_openFile(&file,LOGFILE_DATA);
;//            if(res < 0)
;//            {
;//                printDebug("<ETH_checkPushLog> LOG_openFile(%s) failed, couldn't save log\r\n",LOGFILE_DATA);
;//            }
;//            else
;//            {
;//                res = LOG_insertData(&file,timestamp,channel,value);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_insertData() failed\r\n");
;//                }
;//
;//                res = LOG_closeFile(&file);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_closeFile() failed\r\n");
;//                }
;//
;//                printDebug("<ETH_checkPushLog> Inserted Data Log\r\n");
;//            }
;//        }
;//
;//        //isDataLogEmpty = 0;
;//        removeDataLogQueue(id);
;//    }
;//
;//    // -- check if id is in eventLogQueue -- //
;//    res = readEventLogQueue(id,&timestamp,&eventID,&eventStatus);
;//    if(res != -1)
;//    {
;//        // -- found in eventLogQueue -- //
;//        if( (timestamp == 0) || (timestamp == 0xFFFFFFFF) )
;//        {
;//            printDebug("\r\n<ETH_checkPushLog> === ERROR INFOMATION IN EVENT LOG QUEUE ===\r\n");
;//        }
;//        else{
;//
;//            res = LOG_openFile(&file,LOGFILE_EVENT);
;//            if(res < 0)
;//            {
;//                printDebug("<ETH_checkPushLog> LOG_openFile(%s) failed, couldn't save log\r\n",LOGFILE_EVENT);
;//            }
;//            else
;//            {
;//                printDebug("<ETH_checkPushLog> EventLog time[%ld],id[0x%02X],stat[0x%02X]\r\n",timestamp,eventID,eventStatus);
;//                res = LOG_insertEvent(&file,timestamp,eventID,eventStatus);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_insertData() failed\r\n");
;//                }
;//
;//                res = LOG_closeFile(&file);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_closeFile() failed\r\n");
;//                }
;//
;//                printDebug("<ETH_checkPushLog> Inserted Event Log\r\n");
;//            }
;//
;//        }
;//
;//        //isEventLogEmpty    = 0;
;//        removeEventLogQueue(id);
;//    }
;//
;//    return;
;//}
;///*============================================================*/
;//void ETH_retransmit(void)
;//{
;//    int i;
;//
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++)
;//    {
;//        if( TIMER_checkTimerExceed(eth_waitQueue[i].retryTime) &&
;//            (eth_waitQueue[i].packetID != 0))
;//        {
;//            if(eth_waitQueue[i].retryCount >= ETH_MAX_RETRY)
;//            {
;//                printDebug("<ETH_retransmit> packet [0x%02X] Expired\r\n",eth_waitQueue[i].packetID);
;//
;//                if(eth_waitQueue[i].packetID == logDataWait.frameID){
;//                    printDebug("<ETH_retransmit> update logData timeout\r\n");
;//                    logDataWait.frameID = 0x00;
;//                }
;//                else if(eth_waitQueue[i].packetID == logEventWait.frameID){
;//                    printDebug("<ETH_retransmit> update logEvent timeout\r\n");
;//                    logEventWait.frameID = 0x00;
;//                }
;//                else{
;//                    // ---- Push in log here ---- //
;//                    ETH_checkPushLog(eth_waitQueue[i].packetID);
;//                    // -------------------------- //
;//                }
;//
;//                ETH_removeWaitQueue(eth_waitQueue[i].packetID);
;//
;//                printDebug("<ETH_retransmit> commLostTimer = %ld(%lX)\r\n",commLostTimer,commLostTimer);
;//                if((commLostTimer == 0xFFFFFFFF) || (commLostTimer == 0)){
;//                    TIMER_setTimer(&commLostTimer,30);
;//                    printDebug("<ETH_retransmit> LostTimer time left = %ld(%lX)\r\n",(commLostTimer-baseCounter),(commLostTimer-baseCounter));
;//                }
;//            }
;//            else
;//            {
;//                TIMER_setTimer(&(eth_waitQueue[i].retryTime), eth_waitQueue[i].timeout);
;//                eth_waitQueue[i].retryCount++;      // increase retry counter
;//
;//                printDebug("\r\n<ETH_retransmit> --Retransmitting-- [0x%02X]\r\n",eth_waitQueue[i].packetID);
;//
;//                write_uart0(    eth_waitQueue[i].packetData,
;//                                eth_waitQueue[i].packetLen);
;//            }
;//        }
;//    }
;//    return;
;//}
;///*============================================================*/
;//void ETH_processPacket(unsigned char *ptr2frame,int len)
;//{
;//    FIL             file;
;//    unsigned char   frameType;
;//    int             res=0;
;//    unsigned char   frameID;
;//    int             payload;            // -- pointer to payload data extracted from a frame -- //
;//
;//    int             cnfgRd;             // -- for keeping read configuration -- //
;//    char            *cnfgWr;
;//
;//    int             i;
;//
;////    printDebug("\r\n\r\n****** processPacket ******\r\n");
;////    print_payload(ptr2frame,len);
;////    printDebug("\r\n******************\r\n");
;//    frameID         = ptr2frame[0];
;//    frameType       = ptr2frame[1];
;//
;//    commLostTimer   = 0xFFFFFFFF;                     // -- cancel communication lost timer -- //
;//    //commLostTimer   = 0;                            // -- re-initial -- //
;//
;//    switch(frameType){
;//        case STATREQC  :     // -- Status Request COMMAND
;//            if( len < (2 + sizeof(struct stat_req_st) - (sizeof(unsigned int) + sizeof(unsigned char *)) ) ){
;//                printDebug("<ETH_processPacket> status request invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (len);
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc() failed\r\n");
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = statusRequestParser(ptr2frame+2,len-2,(struct stat_req_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> statusRequestParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--statusRequestParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("accessMethod    [0x%02X]\r\n",      ((struct stat_req_st *)payload)->accm);
;//            printDebug("interval        [0x%04X] = %d\r\n", ((struct stat_req_st *)payload)->intv,((struct stat_req_st *)payload)->intv);
;//            printDebug("statusList      |");
;//
;//            for( i=0 ; i<(((struct stat_req_st *)payload)->parLen) ; i++)
;//            {
;//                printDebug("%02X|",(((struct stat_req_st *)payload)->parlst)[i++]);
;//            }
;//            printDebug("\r\n-- ..Done.. --\r\n");
;//
;//            ETH_sendStatusRequestAck(frameID,((struct stat_req_st *)payload)->accm,0x00);
;//
;//            if( ((struct stat_req_st *)payload)->accm < 0x30){
;//                free_statusRequest((struct stat_req_st *)payload);
;//            }
;//
;//            free( (void *) payload );
;//            break;
;//        case STATREPA  :     // -- Status Report ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct stat_rep_st)) ){
;//                printDebug("<ETH_processPacket> status report invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            printDebug("\r\n--statusReportParser-- ACK [0x%02X]\r\n",frameID);
;//            printDebug("unixTime        [0x%02X][0x%02X][0x%02X][0x%02X]\r\n",
;//                                    ptr2frame[10],ptr2frame[11],ptr2frame[12],ptr2frame[13]);
;//            res = setTimeSyncSchema( &ptr2frame[10] );
;//            if(res < 0){
;//                //printDebug("<ETH_processPacket> setTimeSyncSchema() failed in STATREPA\r\n");
;//            }
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case EVENREPA  :     // -- Event Report ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct event_rep_st)) ){
;//                printDebug("<ETH_processPacket> event report invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            printDebug("\r\n--eventReportParser-- ACK [0x%02X]\r\n", frameID);
;//            if( (logEventWait.frameID != 0) && (frameID == logEventWait.frameID) )
;//            {
;//                printDebug("<ETH_processPacket> got event log ack\r\n");
;//
;//                res = LOG_openFile(&file,LOGFILE_EVENT);
;//                if(res < 0){        printDebug("<logReport> LOG_openFile(%s) failed\r\n",LOGFILE_EVENT);            }
;//                else
;//                {
;//                    res = LOG_setLastSend(&file,logEventWait.logID + 1);
;//                    if(res < 0){    printDebug("<LOG_readData> LOG_setLastSend() failed\r\n");                      }
;//                    else{           printDebug("<LOG_readData> LOG_setLastSend(%s,%ld)\r\n",LOGFILE_EVENT,logEventWait.logID + 1);   }
;//
;//                    res = LOG_closeFile(&file);
;//                    if(res < 0){    printDebug("<logReport> LOG_closeFile(%s) failed\r\n",LOGFILE_EVENT);           }
;//                }
;//
;//                logEventWait.frameID    = 0;
;//                logEventWait.logID      = 0;
;//            }
;//            removeEventLogQueue(frameID);
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case CONFMANC  :     // -- Configuration Management COMMAND
;//            printDebug("<ETH_processPacket> Config Manage\r\n");
;//            print_payload(ptr2frame, len);
;//
;//            if( len < (2 + sizeof(struct conf_man_st) - (sizeof(unsigned int) + sizeof(unsigned char *)) ) ){
;//                printDebug("<ETH_processPacket> configuration management invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct conf_man_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct conf_man_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = configManageParser(ptr2frame+2,len-2,(struct conf_man_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> configManageParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--configManageParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("accd            [0x%02X]\r\n",       ((struct conf_man_st *)payload)->accd);
;//            printDebug("cnfg            [0x%02X]\r\n",       ((struct conf_man_st *)payload)->cnfg);
;//
;//            switch( ((struct conf_man_st *)payload)->accd ){
;//                case CONF_RD_CMD    :   // -- Configration Read -- //
;//                                        res = getConfigLen(((struct conf_man_st *)payload)->cnfg);
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> getConfigLen() failed\r\n");
;//                                            ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            break;
;//                                        }
;//
;//                                        cnfgRd = (int) malloc (res);
;//                                        if(cnfgRd == NULL){
;//                                            printDebug("<ETH_processPacket> cnfgRd malloc() failed\r\n");
;//                                            ETH_sendNack(frameID,NOT_READY);
;//                                            break;
;//                                        }
;//
;//                                        res = configRead(((struct conf_man_st *)payload)->cnfg,(char *) cnfgRd);
;//                                        if(res <= 0){
;//                                            printDebug("<ETH_processPacket> configRead() failed\r\n");
;//                                            if(res == -1){
;//                                                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            }
;//                                            else if((res == -2) || (res == 0)){
;//                                                ETH_sendNack(frameID,NOT_READY);
;//                                            }
;//                                            else if(res == -3){
;//                                                ETH_sendConfigManageNack(   frameID,
;//                                                                            ((struct conf_man_st *)payload)->accd,
;//                                                                            ((struct conf_man_st *)payload)->cnfg,
;//                                                                            ERROR);
;//                                            }
;//                                            else{
;//                                                ETH_sendNack(frameID,UNKNOWN_ERROR);
;//                                            }
;//
;//                                            free((void *) cnfgRd);
;//                                            break;
;//                                        }
;//
;//                                        res = ETH_sendConfigManageAck(  frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        SUCCESS,
;//                                                                        (char *)cnfgRd,
;//                                                                        res  );
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> RD_CMD : ETH_sendConfigManageAck() failed\r\n");
;//                                        }
;//
;//                                        free( (void *) cnfgRd );
;//                                        break;
;//                case CONF_WR_CMD    :   // -- Configuration Write -- //
;//                                        cnfgWr = malloc(((struct conf_man_st *)payload)->confLen);
;//                                        if(cnfgWr == NULL){
;//                                            printDebug("<ETH_processPacket> cnfgWr malloc() failed\r\n");
;//                                            ETH_sendNack(frameID,NOT_READY);
;//                                            break;
;//                                        }
;//
;//                                        memcpy(cnfgWr,((struct conf_man_st *)payload)->confSpec,((struct conf_man_st *)payload)->confLen);
;//
;//                                        res = configWrite(  (unsigned char) (((struct conf_man_st *)payload)->cnfg),
;//                                                            cnfgWr,
;//                                                            (int) (((struct conf_man_st *)payload)->confLen) );
;//
;//                                        free(cnfgWr);
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> configWrite() failed\r\n");
;//                                            ETH_sendConfigManageNack(   frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        ERROR);
;//                                            break;
;//                                        }
;//
;//
;//                                        res = ETH_sendConfigManageAck(  frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        SUCCESS,
;//                                                                        NULL,
;//                                                                        0  );
;//                                        if(res < 0){
;//                                            printDebug("WARN : <ETH_processPacket> WR_CMD : ETH_sendConfigManageAck() failed\r\n");
;//                                        }
;//
;//                                        break;
;//                case CONF_CF_CMD    :   // -- Configuration Confirm -- //
;//                                        res = configConfirm();
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> configConfirm() failed\r\n");
;//                                            ETH_sendConfigManageNack(   frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        ERROR);
;//                                            break;
;//                                        }
;//
;//                                        res = ETH_sendConfigManageAck(  frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        SUCCESS,
;//                                                                        NULL,
;//                                                                        0  );
;//                                        if(res < 0){
;//                                            printDebug("WARN : <ETH_processPacket> WR_CMD : ETH_sendConfigManageAck() failed\r\n");
;//                                        }
;//
;//                                        break;
;//                default             :   // -- Shouldn't reach here -- //
;//                                        printDebug("<ETH_processPacket> unknown type for config->accd [0x%02X]\r\n",
;//                                                        ((struct conf_man_st *)payload)->accd );
;//                                        ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                        break;
;//            }
;//
;//            free_configManage((struct conf_man_st *)payload);
;//            free( (void *) payload );
;//
;//            break;
;//        case DATAREPA  :     // -- Data Report ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct data_rep_st)) ){
;//                printDebug("<ETH_processPacket> Data report invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            printDebug("\r\n--dataReportParser-- ACK [0x%02X]\r\n",frameID);
;//            if( (logDataWait.frameID != 0) && (frameID == logDataWait.frameID) )
;//            {
;//                printDebug("<ETH_processPacket> got data log ack\r\n");
;//
;//                res = LOG_openFile(&file,LOGFILE_DATA);
;//                if(res < 0){        printDebug("<logReport> LOG_openFile(%s) failed\r\n",LOGFILE_DATA);             }
;//                else
;//                {
;//                    res = LOG_setLastSend(&file,logDataWait.logID + 1);
;//                    if(res < 0){    printDebug("<LOG_readData> LOG_setLastSend() failed\r\n");                      }
;//                    else{           printDebug("<LOG_readData> LOG_setLastSend(%s,%ld)\r\n",LOGFILE_DATA,logDataWait.logID + 1);    }
;//
;//                    res = LOG_closeFile(&file);
;//                    if(res < 0){    printDebug("<logReport> LOG_closeFile(%s) failed\r\n",LOGFILE_DATA);            }
;//                }
;//
;//                logDataWait.frameID    = 0;
;//                logDataWait.logID      = 0;
;//            }
;//            removeDataLogQueue(frameID);
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case LOGMANIC  :     // -- Log Manipulation COMMAND
;//            if( len < (2 + sizeof(struct log_manic_st)) ){
;//                printDebug("<ETH_processPacket> log manipulation (CMD) invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct log_manic_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct log_manic_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = logManipulationCmdParser(ptr2frame+2,len-2,(struct log_manic_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> logManipulationCmdParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--logManipulationCmdParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("accd            [0x%02X]\r\n",  ((struct log_manic_st *)payload)->accd);
;//            printDebug("tStart          [%ld]\r\n",     ((struct log_manic_st *)payload)->tStart);
;//            printDebug("tStop           [%ld]\r\n",     ((struct log_manic_st *)payload)->tStop);
;//
;//            res = setLogManipulateSchema(   ((struct log_manic_st *)payload)->accd,
;//                                            ((struct log_manic_st *)payload)->tStart,
;//                                            ((struct log_manic_st *)payload)->tStop);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> setLogManipulateSchema() failed\r\n");
;//                ETH_sendLogManipulationAck(frameID,((struct log_manic_st *)payload)->accd,ERROR);
;//            }
;//
;//            ETH_sendLogManipulationAck(frameID,((struct log_manic_st *)payload)->accd,SUCCESS);
;//
;//            free( (void *) payload );
;//
;//            break;
;//        case LOGMANIA  :     // -- Log Manipulation ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct log_mania_st)) ){
;//                printDebug("<ETH_processPacket> log manipulation (ACK) invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct log_mania_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct log_mania_st));
;//                return;
;//            }
;//
;//            res = logManipulationAckParser(ptr2frame+2,(struct log_mania_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> logManipulationCmdParser() failed\r\n");
;//                free( (void *) payload );
;//                return;
;//            }
;//
;//            printDebug("\r\n--logManipulationAckParser-- ACK [0x%02X]\r\n",frameID);
;//            printDebug("accd            [0x%02X]\r\n",  ((struct log_mania_st *)payload)->accd);
;//            printDebug("status          [%ld]\r\n",     ((struct log_mania_st *)payload)->status);
;//
;//            free( (void *) payload );
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case NETMAINC  :     // -- Network Maintenance COMMAND
;//            if( len < (2 + sizeof(struct netw_man_st) - (sizeof(unsigned int) + sizeof(unsigned char *)) + 1 ) ){
;//                printDebug("<ETH_processPacket> network maintenance invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct netw_man_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct netw_man_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = networkMaintenanceParser(ptr2frame+2,len-2,(struct netw_man_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> networkMaintenanceParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--networkMaintenanceParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("cmd             [0x%02X]\r\n",  ((struct netw_man_st *)payload)->cmd);
;//            printDebug("dataLen         [%d]\r\n",      ((struct netw_man_st *)payload)->dataLen);
;//            if( ((struct netw_man_st *)payload)->dataLen > 0 ){
;//                printDebug("data ---        \r\n");
;//                print_payload(((struct netw_man_st *)payload)->data,((struct netw_man_st *)payload)->dataLen);
;//                printDebug("--------\r\n");
;//            }
;//
;//            switch(((struct netw_man_st *)payload)->cmd){
;//                case NETW_TIME_SYNC :   res = setTimeSyncSchema( ((struct netw_man_st *)payload)->data );
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> setTimeSyncSchema() failed\r\n");
;//                                            ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            free_networkMaintenance((struct netw_man_st *)payload);
;//                                            free( (void *) payload );
;//                                            return;
;//                                        }
;//
;//                                        res = ETH_sendNetworkMaintenanceAck(frameID,((struct netw_man_st *)payload)->cmd,SUCCESS);
;//
;//                                        if(res < 0){
;//                                            printDebug("WARN : <ETH_processPacket> NETW_TIME_SYNC : ETH_sendNetworkMaintenanceAck() failed\r\n");
;//                                        }
;//
;//                                        break;
;//                default :               // -- Shouldn't reach here -- //
;//                                        printDebug("<ETH_processPacket> unknown type for config->accd [0x%02X]\r\n",
;//                                                        ((struct netw_man_st *)payload)->cmd );
;//                                        ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                        break;
;//            }
;//
;//            if( ((struct netw_man_st *)payload)->dataLen > 0 ){
;//                free_networkMaintenance((struct netw_man_st *)payload);
;//            }
;//
;//            free( (void *) payload );
;//
;//            break;
;//        case RMDCTRLC  :     // -- Remote Device Control COMMAND
;//            if( len < (2 + sizeof(struct rem_dev_ctrl_st)) ){
;//                printDebug("<ETH_processPacket> remote device control invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct rem_dev_ctrl_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct rem_dev_ctrl_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = remoteDeviceControlParser(ptr2frame+2,(struct rem_dev_ctrl_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> remoteDeviceControlParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--remoteDeviceControlParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("cmd             [0x%02X]\r\n",  ((struct rem_dev_ctrl_st *)payload)->cmd);
;//            printDebug("value           [%ld]\r\n",      ((struct rem_dev_ctrl_st *)payload)->value);
;//
;//            switch(((struct rem_dev_ctrl_st *)payload)->cmd){
;//                case DEVCTRL_MUTE_ALARM :   res = setMuteAlarm( ((struct rem_dev_ctrl_st *)payload)->value );
;//                                            if(res < 0){
;//                                                printDebug("<ETH_processPacket> setTimeSyncSchema(%ld) failed\r\n",((struct rem_dev_ctrl_st *)payload)->value);
;//                                                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                                free( (void *) payload );
;//                                                return;
;//                                            }
;//
;//                                            res = ETH_remoteDeviceControlAck(frameID,((struct rem_dev_ctrl_st *)payload)->cmd,SUCCESS);
;//
;//                                            if(res < 0){
;//                                                printDebug("WARN : <ETH_processPacket> DEVCTRL_MUTE_ALARM : ETH_remoteDeviceControlAck() failed\r\n");
;//                                            }
;//                                            break;
;//                default :                   // -- Shouldn't reach here -- //
;//                                            printDebug("<ETH_processPacket> unknown type for config->accd [0x%02X]\r\n",
;//                                                            ((struct netw_man_st *)payload)->cmd );
;//                                            ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            break;
;//            }
;//
;//            free( (void *) payload );
;//            break;
;//        case CLRLISTA  :     // -- Clear List ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct clr_lst_st)) ){
;//                printDebug("<ETH_processPacket> clear list ACK invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct clr_lst_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct clr_lst_st));
;//                return;
;//            }
;//
;//            res = clearListParser(ptr2frame+2,(struct clr_lst_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> clearListParser() failed\r\n");
;//                free( (void *) payload );
;//                return;
;//            }
;//
;//            printDebug("\r\n--clearListParser-- ACK [0x%02X]\r\n",frameID);
;//            printDebug("cmd             [0x%02X]\r\n",  ((struct clr_lst_st *)payload)->cmd);
;//            printDebug("status          [0x%02X]\r\n",  ((struct clr_lst_st *)payload)->status);
;//
;//            switch(((struct clr_lst_st *)payload)->cmd){
;//                case CLR_DUPLIST :  if(((struct clr_lst_st *)payload)->status == 0x00)
;//                                    {
;//                                        printDebug("<ETH_processPacket> clear duplicate request (ACK) SUCCESS!!\r\n");
;//                                        duplicateListClear = 1;
;//                                        free( (void *) payload );
;//                                        return;
;//                                    }
;//                                    else
;//                                    {
;//                                        printDebug("<ETH_processPacket> clear duplicate request (ACK) FAILED[0x%02X]!!\r\n",
;//                                                    ((struct clr_lst_st *)payload)->status);
;//                                    }
;//                                    break;
;//                default         :   // -- Shouldn't reach here -- //
;//                                    printDebug("<ETH_processPacket> unknown type for clr_lst_st->cmd [0x%02X]\r\n",
;//                                                    ((struct clr_lst_st *)payload)->cmd );
;//                                    break;
;//            }
;//
;//            free( (void *) payload );
;//            break;
;//        case FMWUPLDC  :     // -- Firmware Upload COMMAND (Reserved)
;//            printDebug("<ETH_processPacket> firmware upload hasn't supported yet\r\n");
;//            break;
;//        default:
;//            printDebug("\r\n<ETH_processPacket> invalid frame type ( %02X )!!\r\n",frameType);
;//            break;
;//    }
;//
;//    return;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///************* Low level Communication Management *************/
;///**************************************************************/
;///*============================================================*/
;//void ETH_receive()
;//{
;//    unsigned char   *ptr;
;//    int             size=0;
;//
;//    // -- for packet validation -- //
;//    int     offset=0;
;//    int     len = 0x0000;
;//    int     total=0;
;//
;//    // --------------- Process Xbee Data ---------------- // UART0
;//    do{
;//        ptr = (char *) malloc (RX_BUFFER_SIZE0);
;//        if(ptr == NULL){
;//            printDebug("<ETH_receive> malloc..FAILED..\r\n");
;//        }
;//    }while(ptr == NULL);
;//    size = read_uart0(ptr,RX_BUFFER_SIZE0-1,10);
;//
;//    if(size <= 0){
;//        free( ptr );
;//        return;
;//    }
;//
;//    printDebug("\r\n\r\n+++++++ Raw buffer +++++++\r\n");
;//    print_payload(ptr,size);
;//
;//    do{
;//        //printDebug("<ETH_receive> ptr");
;//        offset += strcspn(&ptr[offset],"\x7e");                                   // seach for header
;//        if(offset == size){
;////            printDebug("<ETH_receive> invalid packet 0x7E not found\r\n");    // not found Start Delimiter 0x7E
;//            break;
;//        }
;//        len = (ptr[offset+1] & 0xffff) << 8;                                    // check packet length (MSB)
;//        len |= ptr[offset+2];                                                   // check packet length (LSB)
;////        printDebug("len = [0x%04X](%d)\r\n",len,len);
;//
;//        total += len;                                                           // update total analyse
;//        if (total > size){                                                      //check length validation
;//            offset++;
;//            total = offset;                                                     // roll back total analyse
;//            printDebug("\r\ninvalid length!!\r\n");
;//            continue;
;//        }
;//
;////        printDebug("\r\n****** packet checksum ******\r\n");
;////        print_payload(&ptr[offset+3],len);
;//        if(ETH_checksum(&ptr[offset+3],len) != ptr[offset+3+len]){              // checksum error detection
;//            printDebug("<ETH_receive> checksum error\r\n");
;//            offset++;
;//            total = offset;                                                     // roll back total analyse
;//        }
;//        else{                                                                   // got a valid packet
;////            printDebug("\r\n****** checksum correct ******\r\n");
;////            print_payload(&ptr[offset+3],len);
;////            printDebug("\r\n******************\r\n");
;//
;//            ETH_processPacket(&ptr[offset+3],len);                              // analyse API-specific Structure
;//            offset += 3+len;
;//        }
;//	}while( total < size);						                                // loop if still unread byte
;//
;//
;//
;//    free( ptr );
;//}
;///*============================================================*/
;//int ETH_send(char *frameData, int frameLen, char frameID, int timeout)
;//{
;//    int     res;
;//    char    *sendPacket;
;//    int     packetLen   = 0;
;//
;//    frameLen++;     // -- + frameID (1 Byte) -- //
;//
;//    packetLen   = frameLen + 2 + 1 + 1;       // length(2 bytes) + frameID(1 byte) + header(1 byte) + sum(1 byte)
;//
;//    if(packetLen > MAX_MTU){
;//        printDebug("<ETH_send> WARNING : Packet is too long(%d bytes)\r\n",packetLen);
;//        return -1;
;//    }
;//
;//    sendPacket  = (char *) malloc ( packetLen );
;//    if(sendPacket == NULL){
;//        printDebug("<ETH_send> WARNING : ETH_send malloc failed (%d)\r\n",packetLen);
;//        return -1;
;//    }
;//
;//    memset(sendPacket,'\0',packetLen);
;//
;//    sendPacket[0] = 0x7E;
;//    sendPacket[1] = (frameLen >> 8) & 0xFF;
;//    sendPacket[2] = frameLen & 0xFF;
;//
;//    if(frameID == 0x00){
;//        frameID         = ETH_generateId();
;//        //printDebug("<ETH_send> ETH_generateId() return 0x%02X\r\n",frameID);
;//    }
;//
;//    sendPacket[3] = frameID;
;//
;//    memcpy(&sendPacket[4],frameData,frameLen);
;//    sendPacket[packetLen-1] = ETH_checksum(&sendPacket[3],frameLen);
;//
;//    //printDebug("<ETH_send> checksum = 0x%02X\r\n",sendPacket[packetLen-1]);
;//
;//    if((timeout > 0) && (frameID != 0xFF)){
;//        res = ETH_addWaitQueue(frameID, &sendPacket[0], packetLen, timeout);
;//        if(res < 0){
;//            printDebug("<ETH_send> ETH_addWaitQueue() failed [id:0x%02X]\r\n",frameID);
;//            free(sendPacket);
;//            return -1;
;//        }
;//    }
;//
;//
;////    if((commLostTimer == 0xFFFFFFFF) || (commLostTimer == 0)){
;////        TIMER_setTimer(&commLostTimer,30);
;////    }
;//
;//    printDebug("\r\n--Transmitting [0x%02X]\r\n",frameID);
;//    print_payload(sendPacket,packetLen);
;//
;//    write_uart0(sendPacket,packetLen);
;//    free(sendPacket);
;//
;//    //printDebug("-- Completed --\r\n");
;//    delay_ms(7);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_checksum(char buf[],int len)
;//{
;//    int i;
;//    char sum = 0;
;//
;//    //printDebug("<checksum> \r\n");
;//    for (i=0;i<len;i++){
;//        sum += buf[i];
;//        //printDebug("<0x%02X> -> [0x%02X]\r\n",buf[i],sum);
;//    }
;//    return (0xff - (sum & 0xff));
;//
;//}
;///*============================================================*/
;//
;/**************************************************************/
;/***************** Ethernet Hardare Management ****************/
;/**************************************************************/
;/*============================================================*/
;char ETH_current_mode;
;char ETH_switchMode(char mode)
; 0009 049F {

	.CSEG
; 0009 04A0     if(mode == MODE_CONF){
;	mode -> Y+0
; 0009 04A1         printDebug("<ETH_switchMode> switch to Config mode\r\n");
; 0009 04A2         ETH_CONF;
; 0009 04A3     }
; 0009 04A4     else{
; 0009 04A5         printDebug("<ETH_switchMode> switch to Normal mode\r\n");
; 0009 04A6         ETH_NORM;
; 0009 04A7     }
; 0009 04A8 
; 0009 04A9     delay_ms(5);
; 0009 04AA 
; 0009 04AB     ETH_current_mode = mode;
; 0009 04AC 
; 0009 04AD     delay_ms(5);
; 0009 04AE     ETH_OFF;
; 0009 04AF     delay_ms(1500);
; 0009 04B0     ETH_ON;
; 0009 04B1     #asm("wdr")
; 0009 04B2     delay_ms(2000);
; 0009 04B3 
; 0009 04B4     return ETH_MODE;
; 0009 04B5 }
;///*============================================================*/
;//int ETH_getConfig(unsigned char *ptr, unsigned int *buflen)
;//{
;//    TIMER   timeout;
;//    char    getInfoCmd[] = ">R\r";
;//    int     i=0;
;//
;//    ETH_switchMode((unsigned char) MODE_CONF);
;//    /*
;//    if(mode != MODE_CONF){
;//        printDebug("<ETH_getConfig> ETH_switchMode(MODE_CONF) failed\r\n");
;//        return -1;
;//    }
;//    */
;//
;//    for(i=0;i<CONF_READ_BUFFER;i++){
;//        configRd[i] = 0x00;
;//    }
;//    configLen       = 0;
;//    config_start    = 0;
;//    config_ready    = 0;
;//    config_end      = 0;
;//    config_response = 0;
;//
;//    printDebug("<ETH_getConfig> Write to uart 0 :");
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar3(getInfoCmd[i]);
;//    }
;//    printDebug("\r\n");
;//
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar0(getInfoCmd[i]);
;//    }
;//
;//    TIMER_setTimer(&timeout, 7);
;//
;//    while( (!config_ready) && !TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//    }
;//
;//    memcpy(ptr,&configRd[0],configLen);
;//
;//    *buflen    = configLen;
;//
;//    ETH_switchMode(MODE_NORM);
;//
;//    /*
;//    if(mode != MODE_NORM){
;//        printDebug("<ETH_getConfig> ETH_switchMode(MODE_NORM) failed\r\n");
;//        return -1;
;//    }
;//    */
;//
;//    if(config_response == 'S'){
;//        return 0;
;//    }
;//    else{
;//        return -1;
;//    }
;//}
;///*============================================================*/
;//int ETH_setConfig(char *ip, char *mask, char *gw, char *server)
;//{
;//    TIMER   timeout;
;//    char    getInfoCmd[] = ">R\r";
;//    char    setInfoCmd[] = ">W";
;//    int     i=0;
;//    char    setStr[30];
;//    int     readLen=0;
;//    char    *ptr;
;//
;//    ptr = (unsigned char *) malloc( sizeof(char) * CONF_READ_BUFFER );
;//    if(ptr == NULL){
;//        printDebug("<ETH_setConfig> malloc(CONF_READ_BUFFER) failed\r\n");
;//        return -1;
;//    }
;//
;//    ETH_switchMode((unsigned char) MODE_CONF);
;//
;//    // ------------------------- Read Old Configuration --------------------------- //
;//    for(i=0;i<CONF_READ_BUFFER;i++){
;//        configRd[i] = 0x00;
;//    }
;//    configLen       = 0;
;//    config_start    = 0;
;//    config_ready    = 0;
;//    config_end      = 0;
;//    config_response = 0;
;//
;//    printDebug("<ETH_setConfig> Write to uart 0 :");
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar3(getInfoCmd[i]);
;//    }
;//    printDebug("\r\n");
;//
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar0(getInfoCmd[i]);
;//    }
;//
;//    TIMER_setTimer(&timeout, 7);
;//
;//    while( (!config_ready) && !TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//    }
;//
;//    memcpy(ptr,&configRd[0],configLen);
;//    readLen = configLen;
;//
;//    if(config_response != 'S'){
;//        printDebug("<ETH_setConfig> read config from ETH module failed\r\n");
;//        free( ptr );
;//        return -1;
;//    }
;//
;//    // ------------------------- Update Configuration --------------------------- //
;//    sprintf(setStr,"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
;//                (ip[0]    *100) + (ip[1]     *10) + ip[2],
;//                (ip[3]    *100) + (ip[4]     *10) + ip[5],
;//                (ip[6]    *100) + (ip[7]     *10) + ip[8],
;//                (ip[9]    *100) + (ip[10]    *10) + ip[11],
;//                (mask[0]  *100) + (mask[1]   *10) + mask[2],
;//                (mask[3]  *100) + (mask[4]   *10) + mask[5],
;//                (mask[6]  *100) + (mask[7]   *10) + mask[8],
;//                (mask[9]  *100) + (mask[10]  *10) + mask[11],
;//                (gw[0]    *100) + (gw[1]     *10) + gw[2],
;//                (gw[3]    *100) + (gw[4]     *10) + gw[5],
;//                (gw[6]    *100) + (gw[7]     *10) + gw[8],
;//                (gw[9]    *100) + (gw[10]    *10) + gw[11]);
;//
;//    printDebug("<ETH_setConfig> Set String [%s]\r\n",setStr);
;//
;//    memcpy((ptr+14),&setStr[0],24);
;//
;//    sprintf(setStr,"%02X%02X%02X%02X",
;//                (server[0]*100) + (server[1] *10) + server[2],
;//                (server[3]*100) + (server[4] *10) + server[5],
;//                (server[6]*100) + (server[7] *10) + server[8],
;//                (server[9]*100) + (server[10]*10) + server[11]);
;//
;//    printDebug("<ETH_setConfig> Set String [%s]\r\n",setStr);
;//
;//    memcpy((ptr+42),&setStr[0],8);
;//
;////    printDebug("<ETH_setConfig> Modified setting msg ---\r\n");
;////    for(i=0;i<configLen;i++){
;////        putchar3(ptr[i]);
;////    }
;////    printDebug("\r\n\---\r\n");
;//
;//    // ------------------------- Set New Configuration --------------------------- //
;//    for(i=0;i<CONF_READ_BUFFER;i++){
;//        configRd[i] = 0x00;
;//    }
;//    configLen       = 0;
;//    config_start    = 0;
;//    config_ready    = 0;
;//    config_end      = 0;
;//    config_response = 0;
;//
;//    printDebug("<ETH_setConfig> Setting msg ---\r\n");
;//    for(i=0;i<strlen(setInfoCmd);i++){
;//        putchar0(setInfoCmd[i]);
;//        putchar3(setInfoCmd[i]);
;//    }
;//    for(i=12;i<readLen;i++){
;//        putchar0(ptr[i]);
;//        putchar3(ptr[i]);
;//    }
;//    putchar0('\r');
;//    printDebug("\r\n\---\r\n");
;//
;//    TIMER_setTimer(&timeout, 10);
;//
;//    while( (!config_ready) && !TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//    }
;//
;//    ETH_switchMode(MODE_NORM);
;//
;//    free( ptr );
;//
;//    if(config_response == 'S'){
;//        return 0;
;//    }
;//    else{
;//        return -1;
;//    }
;//}
;///*============================================================*/
;//void ETH_reset(void)
;//{
;//    printDebug("<ETH_reset> Resetting Ethernet Module, please wait.");
;//    ETH_RESET   = 0;
;//    delay_ms(3000);
;//    ETH_RESET   = 1;
;//    delay_ms(1);
;//    printDebug("...Done\r\n");
;//}
;///*============================================================*/
;#include <stdlib.h>
;#include "ethparser.h"
;#include "debug.h"
;
;/*============================================================*/
;int statusRequestParser(unsigned char *pkt, int len, struct stat_req_st *st)
; 000A 0007 {

	.CSEG
; 000A 0008     int     i,k=0;
; 000A 0009 
; 000A 000A     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 000B         st->nid[0]  =   pkt[k++];
; 000A 000C     }
; 000A 000D 
; 000A 000E     st->accm        =   pkt[k++];
; 000A 000F 
; 000A 0010     st->intv        =   ((pkt[k++] & 0x00ff) << 8) |
; 000A 0011                         ((pkt[k++] & 0x00ff));
; 000A 0012 
; 000A 0013     if(st->accm >= 0x30){
; 000A 0014         return 0;
; 000A 0015     }
; 000A 0016 
; 000A 0017     st->parLen      =   len - k;
; 000A 0018 
; 000A 0019     st->parlst      =   malloc((st->parLen) * sizeof(char));
; 000A 001A     if(st->parlst == NULL)
; 000A 001B     {
; 000A 001C         printDebug("<statusRequestParser> malloc failed\r\n");
; 000A 001D         return -1;
; 000A 001E     }
; 000A 001F 
; 000A 0020     for( i=0 ; i<(st->parLen) ; i++ )
; 000A 0021     {
; 000A 0022         (st->parlst)[i]      = pkt[i+k];
; 000A 0023     }
; 000A 0024 
; 000A 0025     return 0;
; 000A 0026 }
;/*============================================================*/
;int statusReportParser(unsigned char *pkt, unsigned long int *time)
; 000A 0029 {
; 000A 002A     int i,k=0;
; 000A 002B 
; 000A 002C     k               +=  8;
;	*pkt -> Y+6
;	*time -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 002D 
; 000A 002E     *time           =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 002F                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 0030                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 0031                         (((long)pkt[k++] & 0x000000FF));
; 000A 0032 
; 000A 0033     return 0;
; 000A 0034 }
;/*============================================================*/
;int configManageParser(unsigned char *pkt, int len, struct conf_man_st *st)
; 000A 0037 {
; 000A 0038     int i,k=0;
; 000A 0039 
; 000A 003A     printDebug("<configManageParser>\r\n");
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 003B     print_payload(pkt,len);
; 000A 003C 
; 000A 003D     for(i=0;i<sizeof(st->nid);i++){
; 000A 003E         st->nid[0]  =   pkt[k++];
; 000A 003F     }
; 000A 0040 
; 000A 0041     st->accd        =   pkt[k++];
; 000A 0042 
; 000A 0043     st->cnfg        =   pkt[k++];
; 000A 0044 
; 000A 0045     if(st->accd == CONF_RD_CMD){
; 000A 0046         printDebug("<configManageParser> READING\r\n");
; 000A 0047         st->confLen     =   0;
; 000A 0048         st->confSpec    =   NULL;
; 000A 0049         return 0;
; 000A 004A     }
; 000A 004B     printDebug("<configManageParser> WRITING\r\n");
; 000A 004C 
; 000A 004D     st->confLen     =   len - k;
; 000A 004E 
; 000A 004F     printDebug("<configManageParser> confLen = %d\r\n",st->confLen);
; 000A 0050 
; 000A 0051 
; 000A 0052     st->confSpec    =   malloc((st->confLen) * sizeof(char));
; 000A 0053     if(st->confSpec == NULL)
; 000A 0054     {
; 000A 0055         printDebug("<configManageParser> malloc failed\r\n");
; 000A 0056         return -1;
; 000A 0057     }
; 000A 0058 
; 000A 0059     for( i=0 ; i<(st->confLen) ; i++ )
; 000A 005A     {
; 000A 005B         (st->confSpec)[i]      = pkt[i+k];
; 000A 005C     }
; 000A 005D 
; 000A 005E     return 0;
; 000A 005F 
; 000A 0060 }
;/*============================================================*/
;/*
;int dataReportParser(unsigned char *pkt, int len, unsigned char *frameID)
;{
;    *frameID        =   pkt[0];
;    return 0;
;}
;*/
;/*============================================================*/
;int logManipulationCmdParser(unsigned char *pkt, int len, struct log_manic_st *st)
; 000A 006B {
; 000A 006C     int i,k=0;
; 000A 006D 
; 000A 006E     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 006F         st->nid[0]  =   pkt[k++];
; 000A 0070     }
; 000A 0071 
; 000A 0072     st->accd        =   pkt[k++];
; 000A 0073 
; 000A 0074     if(len > 6){
; 000A 0075         st->tStart  =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 0076                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 0077                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 0078                         (((long)pkt[k++] & 0x000000FF));
; 000A 0079 
; 000A 007A         st->tStop   =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 007B                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 007C                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 007D                         (((long)pkt[k++] & 0x000000FF));
; 000A 007E     }
; 000A 007F 
; 000A 0080     return 0;
; 000A 0081 }
;/*============================================================*/
;int logManipulationAckParser(unsigned char *pkt, struct log_mania_st *st)
; 000A 0084 {
; 000A 0085     int i,k=0;
; 000A 0086 
; 000A 0087     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 0088         st->nid[0]  =   pkt[k++];
; 000A 0089     }
; 000A 008A 
; 000A 008B     st->accd        =   pkt[k++];
; 000A 008C     st->status      =   pkt[k++];
; 000A 008D 
; 000A 008E     return 0;
; 000A 008F }
;/*============================================================*/
;int networkMaintenanceParser(unsigned char *pkt, int len, struct netw_man_st *st)
; 000A 0092 {
; 000A 0093     int i,k=0;
; 000A 0094 
; 000A 0095     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 0096         st->nid[0]  =   pkt[k++];
; 000A 0097     }
; 000A 0098 
; 000A 0099     st->cmd         =   pkt[k++];
; 000A 009A 
; 000A 009B     st->dataLen     =   len - 2;
; 000A 009C 
; 000A 009D     if( st->dataLen > 0 ){
; 000A 009E 
; 000A 009F         st->data    =   malloc((st->dataLen) * sizeof(char));
; 000A 00A0         if(st->data == NULL)
; 000A 00A1         {
; 000A 00A2             printDebug("<networkMaintenanceParser> malloc failed (%d)\r\n",((st->dataLen) * sizeof(char)));
; 000A 00A3             return -1;
; 000A 00A4         }
; 000A 00A5 
; 000A 00A6         for( i=0 ; i<(st->dataLen) ; i++ )
; 000A 00A7         {
; 000A 00A8             (st->data)[i]      = pkt[i+k];
; 000A 00A9         }
; 000A 00AA 
; 000A 00AB     }
; 000A 00AC 
; 000A 00AD     return 0;
; 000A 00AE }
;/*============================================================*/
;int remoteDeviceControlParser(unsigned char *pkt, struct rem_dev_ctrl_st *st)
; 000A 00B1 {
; 000A 00B2     int i,k=0;
; 000A 00B3 
; 000A 00B4     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 00B5         st->nid[0]  =   pkt[k++];
; 000A 00B6     }
; 000A 00B7 
; 000A 00B8     st->cmd         =   pkt[k++];
; 000A 00B9 
; 000A 00BA     st->value       =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 00BB                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 00BC                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 00BD                         (((long)pkt[k++] & 0x000000FF));
; 000A 00BE 
; 000A 00BF     return 0;
; 000A 00C0 }
;/*============================================================*/
;int clearListParser(unsigned char *pkt, struct clr_lst_st *st)
; 000A 00C3 {
; 000A 00C4     int i,k=0;
; 000A 00C5 
; 000A 00C6     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 00C7         st->nid[0]  =   pkt[k++];
; 000A 00C8     }
; 000A 00C9 
; 000A 00CA     st->cmd         =   pkt[k++];
; 000A 00CB     st->status      =   pkt[k++];
; 000A 00CC 
; 000A 00CD     return 0;
; 000A 00CE }
;/*============================================================*/
;void free_statusRequest(struct stat_req_st *st)
; 000A 00D1 {
; 000A 00D2     free ( st->parlst );
;	*st -> Y+0
; 000A 00D3 }
;/*============================================================*/
;void free_configManage(struct conf_man_st *st)
; 000A 00D6 {
; 000A 00D7     free ( st->confSpec );
;	*st -> Y+0
; 000A 00D8 }
;/*============================================================*/
;void free_networkMaintenance(struct netw_man_st *st)
; 000A 00DB {
; 000A 00DC     free ( st->data );
;	*st -> Y+0
; 000A 00DD }
;/*============================================================*/
;
;#include <stdlib.h>
;#include <string.h>
;#include "ethservice.h"
;#include "ds1672.h"
;#include "alarm.h"
;#include "debug.h"
;
;///*============================================================*/
;//int getConfigLen(unsigned char cnfg)
;//{
;//    unsigned char   type = cnfg & 0xF0;;
;//
;//    switch( type ){
;//        case CONF_PROPERTIES    :   return sizeof(struct prop_cnfg_st);
;//        case CONF_OPERATE       :   return sizeof(struct oper_cnfg_st);
;//        case CONF_SENSOR        :   return sizeof(struct sens_cnfg_st);
;//        case CONF_AUXDI         :   return sizeof(struct din_cnfg_st);
;//        case CONF_AUXDO         :   return sizeof(struct dout_cnfg_st);
;//        case CONF_AUXAI         :   return sizeof(struct ain_cnfg_st);
;//        case CONF_AUXAO         :   return sizeof(struct aout_cnfg_st);
;//        case CONF_BUZZER        :   return sizeof(struct buzz_cnfg_st);
;//        case CONF_ENVALARM      :   return sizeof(struct alm_cnfg_st);
;//        default                 :   printDebug("<getConfigLen> unknown configuration type [0x%02X]\r\n",type);
;//                                    return -1;
;//    }
;//}
;///*============================================================*/
;//int configRead(unsigned char cnfg, unsigned char *ptr)
;//{
;//    int i = 0;
;//    int res = 0;
;//    unsigned char   type            = 0x00;
;//    int             channel         = 0;
;//    void            *cnfgStrc       = NULL;
;//
;//    type    =   cnfg & 0xF0;
;//
;//
;//    switch( type ){
;//        case CONF_PROPERTIES    :   cnfgStrc = malloc (sizeof(struct prop_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_PROPERTIES malloc1 failed (%d bytes)\r\n",sizeof(struct prop_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getPropertiesConfig((struct prop_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getPropertiesConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_PROPERTIES ---\r\n");
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->deviceType);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->firmwareVersion);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->deviceName);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->deviceID);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->hostName);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->hostID);
;//                                    printDebug("%d\r\n",(signed char) (((struct prop_cnfg_st *)cnfgStrc)->timeZone));
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct prop_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct prop_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct prop_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct prop_cnfg_st);
;//
;//        case CONF_OPERATE       :   cnfgStrc = malloc (sizeof(struct oper_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_OPERATE malloc1 failed (%d bytes)\r\n",sizeof(struct oper_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getOperatingConfig((struct oper_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getOperatingConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_OPERATE ---\r\n");
;//                                    printDebug("mode            [0x%02X]\r\n",((struct oper_cnfg_st *)cnfgStrc)->mode);
;//                                    printDebug("deviceEnable    [0x%02X]\r\n",((struct oper_cnfg_st *)cnfgStrc)->deviceEnable);
;//                                    printDebug("alarmEnable     [0x%02X]\r\n",((struct oper_cnfg_st *)cnfgStrc)->alarmEnable);
;//                                    printDebug("sensorEnable    ");
;//                                    for(i=0;i<MAX_SENS_CHANNEL;i++){
;//                                        printDebug("[0x%02X]",((struct oper_cnfg_st *)cnfgStrc)->sensorEnable[i]);
;//                                        if(i == (MAX_SENS_CHANNEL-1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct oper_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct oper_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct oper_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct oper_cnfg_st);
;//
;//        case CONF_SENSOR        :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct sens_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_SENSOR malloc1 failed (%d bytes)\r\n",sizeof(struct sens_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getSensorConfig(channel, (struct sens_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getSensorConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_SENSOR [%d]---\r\n",channel);
;//                                    printDebug("samplingRate    [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->samplingRate);
;//                                    printDebug("reOccurrence    [0x%04X]\r\n",  ((struct sens_cnfg_st *)cnfgStrc)->reOccurrence);
;//                                    printDebug("timeStartHour   [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStartHour);
;//                                    printDebug("timeStartMin    [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStartMin);
;//                                    printDebug("timeStopHour    [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStopHour);
;//                                    printDebug("timeStopMin     [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStopMin);
;//                                    printDebug("alarmEnable     [0x%02X]\r\n",  ((struct sens_cnfg_st *)cnfgStrc)->alarmEnable);
;//                                    printDebug("lowerLimit      [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->lowerLimit);
;//                                    printDebug("lowerDelay      [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->lowerDelay);
;//                                    printDebug("lowerExtreme    [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->lowerExtreme);
;//                                    printDebug("upperLimit      [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->upperLimit);
;//                                    printDebug("upperDelay      [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->upperDelay);
;//                                    printDebug("upperExtreme    [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->upperExtreme);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct sens_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct sens_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct sens_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct sens_cnfg_st);
;//
;//        case CONF_AUXDI         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct din_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXDI malloc1 failed (%d bytes)\r\n",sizeof(struct din_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxDinConfig(channel, (struct din_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxDinConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXDI [%d]---\r\n",channel);
;//                                    printDebug("channelEnable    [0x%02X]\r\n", ((struct din_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("alarmDelay       [%d]\r\n",     ((struct din_cnfg_st *)cnfgStrc)->alarmDelay);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct din_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct din_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct din_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct din_cnfg_st);
;//
;//        case CONF_AUXDO         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct dout_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXDO malloc1 failed (%d bytes)\r\n",sizeof(struct dout_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxDoutConfig(channel, (struct dout_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxDoutConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXDO [%d]---\r\n",channel);
;//                                    printDebug("channelEnable     [0x%02X]\r\n",    ((struct dout_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("stateOnEvent      [%d]\r\n",        ((struct dout_cnfg_st *)cnfgStrc)->stateOnEvent);
;//                                    printDebug("eventSourceNumber [%d]\r\n",        ((struct dout_cnfg_st *)cnfgStrc)->eventSourceNumber);
;//
;//                                    printDebug("eventSource       ");
;//                                    for(i=0;i<MAX_EVENT_SOURCE;i++){
;//                                        printDebug("[0x%02X]",((struct dout_cnfg_st *)cnfgStrc)->eventSource[i]);
;//                                        if(i == (MAX_EVENT_SOURCE-1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct dout_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct dout_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct dout_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct dout_cnfg_st);
;//
;//        case CONF_AUXAI         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct ain_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXAI malloc1 failed (%d bytes)\r\n",sizeof(struct ain_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxAinConfig(channel, (struct ain_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxAinConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXAI [%d]---\r\n",channel);
;//                                    printDebug("channelEnable    [0x%02X]\r\n", ((struct ain_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("alarmDelay       [%f]\r\n",     ((struct ain_cnfg_st *)cnfgStrc)->alarmLevel);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct ain_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct ain_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct ain_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct ain_cnfg_st);
;//
;//        case CONF_AUXAO         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct aout_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXAO malloc1 failed (%d bytes)\r\n",sizeof(struct aout_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxAoutConfig(channel, (struct aout_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxAoutConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXAO [%d]---\r\n",channel);
;//                                    printDebug("channelEnable     [0x%02X]\r\n",    ((struct aout_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("levelOnEvent      [%f]\r\n",        ((struct aout_cnfg_st *)cnfgStrc)->levelOnEvent);
;//                                    printDebug("eventSourceNumber [%d]\r\n",        ((struct aout_cnfg_st *)cnfgStrc)->eventSourceNumber);
;//
;//                                    printDebug("eventSource       ");
;//                                    for(i=0;i<MAX_EVENT_SOURCE;i++){
;//                                        printDebug("[0x%02X]",((struct aout_cnfg_st *)cnfgStrc)->eventSource[i]);
;//                                        if(i == (MAX_EVENT_SOURCE-1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct aout_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct aout_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct aout_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct aout_cnfg_st);
;//
;//        case CONF_BUZZER        :   cnfgStrc = malloc (sizeof(struct buzz_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_BUZZER malloc1 failed (%d bytes)\r\n",sizeof(struct buzz_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getBuzzerConfig((struct buzz_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getBuzzerConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_BUZZER ---\r\n");
;//                                    printDebug("enable            [0x%02X]\r\n",    ((struct buzz_cnfg_st *)cnfgStrc)->enable);
;//                                    printDebug("eventSourceNumber [%d]\r\n",        ((struct buzz_cnfg_st *)cnfgStrc)->eventSourceNumber);
;//
;//                                    printDebug("eventSource       ");
;//                                    for(i=0;i<MAX_EVENT_SOURCE;i++){
;//                                        printDebug("[0x%02X]",((struct buzz_cnfg_st *)cnfgStrc)->eventSource[i]);
;//                                        if(i == (MAX_EVENT_SOURCE - 1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct buzz_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct buzz_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct buzz_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct buzz_cnfg_st);
;//
;//        case CONF_ENVALARM      :   cnfgStrc = malloc (sizeof(struct alm_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_ENVALARM malloc1 failed (%d bytes)\r\n",sizeof(struct alm_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getEnvAlarmConfig((struct alm_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getEnvAlarmConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_ENVALARM ---\r\n");
;//                                    printDebug("gsmRSSILevel      [%f]\r\n",((struct alm_cnfg_st *)cnfgStrc)->gsmRSSILevel);
;//                                    printDebug("gsmCreditBalance  [%d]\r\n",((struct alm_cnfg_st *)cnfgStrc)->gsmCreditBalance);
;//                                    printDebug("batteryLevel      [%f]\r\n",((struct alm_cnfg_st *)cnfgStrc)->batteryLevel);
;//                                    printDebug("commSignalLevel   [%f]\r\n",((struct alm_cnfg_st *)cnfgStrc)->commSignalLevel);
;//                                    printDebug("commLostDelay     [%d]\r\n",((struct alm_cnfg_st *)cnfgStrc)->commLostDelay);
;//                                    printDebug("memoryMin         [%d]\r\n",((struct alm_cnfg_st *)cnfgStrc)->memoryMin);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct alm_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct alm_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct alm_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct alm_cnfg_st);
;//        case CONF_STATREPORT    :   cnfgStrc = malloc (sizeof(struct stat_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_STATREPORT malloc1 failed (%d bytes)\r\n",sizeof(struct stat_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getStatusReportConfig((struct stat_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getStatusReportConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_STATREPORT ---\r\n");
;//                                    printDebug("accm      [0x%02X]\r\n",((struct stat_cnfg_st *)cnfgStrc)->accm);
;//                                    printDebug("intv      [%d]\r\n",    ((struct stat_cnfg_st *)cnfgStrc)->intv);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct stat_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct stat_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct stat_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//        default                 :   printDebug("<configRead> unknown configuration type [0x%02X]\r\n",type);
;//                                    return -1;
;//    }
;//
;//    return 0;
;//
;//}
;///*============================================================*/
;//int configWrite(unsigned char cnfg, unsigned char *conf, int len)
;//{
;//    int res = 0;
;//    unsigned char   type            = 0x00;
;//    int             channel         = 0;
;//
;//    type    =   cnfg & 0xF0;
;//
;//    printDebug("\r\n --- WRITE CONFIG packet (%d)--- \r\n",len);
;//    print_payload(conf,len);
;//
;//    switch( type ){
;//        case CONF_PROPERTIES    :   printDebug("\r\n--- Write CONF_PROPERTIES ---");
;//
;//                                    res = setPropertiesConfig((struct prop_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setPropertiesConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_OPERATE       :   printDebug("\r\n--- Write CONF_OPERATE ---");
;//
;//                                    res = setOperatingConfig((struct oper_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setOperatingConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_SENSOR        :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_SENSOR (%d) ---",channel);
;//
;//                                    res = setSensorConfig(channel,(struct sens_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setSensorConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXDI         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXDI (%d) ---",channel);
;//
;//                                    res = setAuxDinConfig(channel,(struct din_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxDinConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXDO         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXDO (%d) ---",channel);
;//
;//                                    res = setAuxDoutConfig(channel,(struct dout_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxDoutConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXAI         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXAI (%d) ---",channel);
;//
;//                                    res = setAuxAinConfig(channel,(struct ain_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxAinConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXAO         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXAO (%d) ---",channel);
;//
;//                                    res = setAuxAoutConfig(channel,(struct aout_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxAoutConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_BUZZER        :   printDebug("\r\n--- Write CONF_BUZZER ---");
;//
;//                                    res = setBuzzerConfig((struct buzz_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setBuzzerConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_ENVALARM      :   printDebug("\r\n--- Write CONF_ENVALARM ---");
;//
;//                                    res = setEnvAlarmConfig((struct alm_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setEnvAlarmConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_STATREPORT    :   printDebug("\r\n--- Write CONF_STATREPORT ---");
;//
;//                                    res = setStatusReportConfig((struct stat_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setStatusReportConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//
;//        default                 :   printDebug("<configRead> unknown configuration type [0x%02X]\r\n",type);
;//                                    return -1;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int setLogManipulateSchema(unsigned char accd, unsigned long int tStart, unsigned long int tStop)
;//{
;//    if(tStop < tStart){
;//        printDebug("<setLogManipulateSchema> time period error start[%ld] - stop[%ld]\r\n",tStart,tStop);
;//        return -1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setTimeSyncSchema(unsigned char *timeData)
;//{
;//    int res;
;//    unsigned long int unixTime = 0x00000000;
;//
;//    memcpy(&unixTime,timeData,sizeof(unixTime));
;//
;//    if(unixTime == 0){
;//        printDebug("<setTimeSyncSchema> Got 0 Unix time stamp\r\n");
;//        return -1;
;//    }
;//
;//    printDebug("<setTimeSyncSchema> Received time sync. packet %ld\r\n",unixTime);
;//
;//    res = RTC_setBinary( unixTime );
;//    if( res < 0 ){
;//        printDebug("<setTimeSyncSchema> RTC_setBinary(%ld) failed\r\n", unixTime);
;//        return -1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setMuteAlarm(unsigned long int period)
;//{
;//    int res;
;//
;//    if(period == 0){
;//        printDebug("<setMuteAlarm> permanent mute alarm\r\n");
;//    }
;//    else if(((period < 300) || (period > 86400))){
;//        printDebug("<setMuteAlarm> invalid period (%ld)\r\n", period);
;//        return -1;
;//    }
;//    else{
;//        printDebug("<setMuteAlarm> mute alarm for %ld second\r\n",period);
;//    }
;//
;//    res = ALARM_mute( period );
;//    if( res < 0 ){
;//        printDebug("<setMuteAlarm> ALARM_mute(%ld) failed\r\n", period);
;//        return -1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int configConfirm(void)
;//{
;//    return 0;
;//}
;/*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "ethqueue.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "debug.h"
;
;#define MAX_SESS_LIST   100
;
;//struct ethqueue eth_waitQueue[ETH_MAX_WAIT_QUEUE];
;//char   ETH_waitQCount = 0;
;//
;//char   sess_list[MAX_SESS_LIST];
;//int    last_sess_id = 0;
;//
;///*============================================================*/
;//int ETH_addWaitQueue(char id, char *pktptr, int len, int timeout)
;//{
;//    int slot;
;//
;//    slot = ETH_findFreeSlotWaitQueue();
;//    if(slot < 0){
;//        printDebug("\r\n\r\n<ETH_addWaitQueue> WARNING : Wait queue FULL\r\n\r\n");
;//        return -1;
;//    }
;//
;//
;//    eth_waitQueue[slot].packetData = (char *) malloc(len);
;//    if(eth_waitQueue[slot].packetData == NULL)
;//    {
;//        printDebug("<ETH_addWaitQueue> malloc(%d) failed\r\n",len);
;//        return -1;
;//    }
;//
;//    memcpy( eth_waitQueue[slot].packetData, pktptr, len );
;//
;//    eth_waitQueue[slot].packetLen   = len;
;//    eth_waitQueue[slot].packetID    = id;
;//    eth_waitQueue[slot].retryCount  = 0;
;//    eth_waitQueue[slot].timeout     = timeout;
;//
;//    //eth_waitQueue[slot].retryTime   = 0;
;//    TIMER_setTimer(&(eth_waitQueue[slot].retryTime), eth_waitQueue[slot].timeout);
;//
;//    ETH_waitQCount++;
;//    printDebug("\r\n                                     Added (%02X) to eth_waitQueue[%d]\r\n", id, slot);
;//    //print_payload(eth_waitQueue[slot].packetData,eth_waitQueue[slot].packetLen);
;//    return ETH_waitQCount;
;//}
;///*============================================================*/
;//int ETH_removeWaitQueue(char id)
;//{
;//    char i;
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        if(id == eth_waitQueue[i].packetID){        // scan id in eth_waitQueue
;//            //printDebug("                                 Removing (%02X) from eth_waitQueue\r\n", id);
;//            //print_payload(eth_waitQueue[i].packetData,eth_waitQueue[i].packetLen);
;//            //memset( eth_waitQueue[i].packetData, '\0', ETH_MAX_PKT_LEN );
;//            free(eth_waitQueue[i].packetData);
;//            eth_waitQueue[i].packetData  = NULL;
;//            eth_waitQueue[i].packetLen   = 0;
;//            eth_waitQueue[i].packetID    = 0;
;//            eth_waitQueue[i].retryCount  = 0;
;//            eth_waitQueue[i].timeout     = 0;
;//            eth_waitQueue[i].retryTime   = 0;
;//            ETH_waitQCount--;
;//            //printDebug("Removed\r\n");
;//            printDebug("\r\n                                     Removed (%02X) to eth_waitQueue[%d]\r\n", id, i);
;//            return ETH_waitQCount;
;//        }
;//    }
;//    printDebug("\r\n\r\nWARNING : ETH_removeWaitQueue(%02X) not found!!\r\n\r\n",id);
;//    return -1;
;//}
;///*============================================================*/
;//void ETH_initWaitQueue(void)
;//{
;//    char i;
;//
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        //memset( eth_waitQueue[i].packetData, '\0', ETH_MAX_PKT_LEN );
;//        free(eth_waitQueue[i].packetData);
;//        eth_waitQueue[i].packetData  = NULL;
;//        eth_waitQueue[i].packetLen   = 0;
;//        eth_waitQueue[i].packetID    = 0;
;//        eth_waitQueue[i].retryCount  = 0;
;//        eth_waitQueue[i].timeout     = 0;
;//        eth_waitQueue[i].retryTime   = 0;
;//    }
;//    return;
;//}
;///*============================================================*/
;//char ETH_isIdExist(char id)
;//{
;//    char i;
;//
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        if(id == eth_waitQueue[i].packetID){
;//            return 1;                           // found id in eth_waitQueue
;//        }
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//char ETH_isIdUsed(char id)
;//{
;//    char i;
;//
;//    for(i=0;i<MAX_SESS_LIST;i++){
;//        if(id == sess_list[i]){
;//            return 1;                           // found id in eth_waitQueue
;//        }
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//char ETH_findFreeSlotWaitQueue(void)
;//{
;//    char i;
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        if(eth_waitQueue[i].packetLen == 0){
;//            return i;
;//        }
;//    }
;//    return -1;
;//}
;///*============================================================*/
;//char ETH_generateId(void)
;//{
;//    char id;
;//
;//    do{
;//        id = (rand() % 256) & 0xFF;
;//    }while(ETH_isIdExist(id) || (id == 0) || (id == 0xFF) || ETH_isIdUsed(id));
;//    sess_list[last_sess_id] = id;
;//    last_sess_id = (last_sess_id + 1) % MAX_SESS_LIST;
;//
;//    return id;
;//}
;///*============================================================*/
;#include <stdlib.h>
;#include <string.h>
;#include <stdio.h>
;#include <delay.h>
;#include "sensor.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "config.h"
;#include "timer.h"
;#include "debug.h"
;#include "dht11.h"
;#include "calibration.h"
;
;#define MAX(x, y) (((x) > (y)) ? (x) : (y))
;
;
;//extern eeprom ST_CAL sensorCalulate;
;struct sens_val_st      sensor[5];
;extern ST_DHT11 dhtDevice;
;ST_DHT11 dhtDevice;
;//eeprom float calS1[5];//standrad point 1
;//eeprom float calS2[5];//standrad point 2
;//eeprom float calS3[5];//standrad point 3
;//eeprom float calX1[5];//input sensor point 1
;//eeprom float calX2[5];//input sensor point 2
;//eeprom float calX3[5];//input sensor point 3
;
;float sensorGetValue(unsigned int channelID){
; 000D 001A float sensorGetValue(unsigned int channelID){

	.CSEG
; 000D 001B     printDebug("Sensor ch[%d] is a raw data[%0.2f] , calProcess[%0.2f]\r\n",channelID-1,adcData[channelID-1],calProcessValue(adcData[channelID-1],channelID));
;	channelID -> Y+0
; 000D 001C     return calProcessValue(adcData[channelID-1],channelID);
; 000D 001D }
;
;int sensorRead(int ch, struct sens_val_st *sensor){
; 000D 001F int sensorRead(int ch, struct sens_val_st *sensor){
; 000D 0020     int dhtRet = 0;
; 000D 0021 
; 000D 0022     updateSensorADC(ch);
;	ch -> Y+4
;	*sensor -> Y+2
;	dhtRet -> R16,R17
; 000D 0023     if(ch==0){
; 000D 0024        sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 0025        //sensor->value = adcData[ch];
; 000D 0026     }else if(ch==3){
; 000D 0027     sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 0028        //sensor->value = adcData[ch];
; 000D 0029     }else if(ch==4){
; 000D 002A        sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 002B        //sensor->value = adcData[ch];
; 000D 002C     }else if((ch==1) || (ch==2)){
; 000D 002D         dhtRet = dhtDevice.status;
; 000D 002E         if(dhtRet == DHT11_SUCCESS){
; 000D 002F            sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 0030            //sensor->value = adcData[ch];
; 000D 0031         }else if(dhtRet == DHT11_ERROR_TIMEOUT){
; 000D 0032            sensor->status  = SENS_ERROR;
; 000D 0033            //return -2;
; 000D 0034         }else if(dhtRet == DHT11_ERROR_CHECKSUM){
; 000D 0035            sensor->status  = SENS_ERROR;
; 000D 0036            //return -2;
; 000D 0037         }
; 000D 0038     }
; 000D 0039 
; 000D 003A     sensor->status  = SENS_NORMAL;
; 000D 003B     return 0;
; 000D 003C }
;
;void updateSensorADC(int ch)
; 000D 003F {
; 000D 0040     int adc_raw = 0;
; 000D 0041     int dhtRet = 0;
; 000D 0042     float voltCutOff = 0.0;
; 000D 0043     float ACS709offset = 18.5;
; 000D 0044     float buffAmpSensor[60];
; 000D 0045     float buffVoltSensor[50];
; 000D 0046     float buff420Sensor[10];
; 000D 0047     float bufferTemp[2] = {0,0};
; 000D 0048     float bufferHumi[2] = {0,0};
; 000D 0049     int i=0,j=0;
; 000D 004A     int dht11Reread=0;
; 000D 004B     float ampValue = 0.0;
; 000D 004C     float voltValue = 0.0;
; 000D 004D     float mA420Value = 0.0;
; 000D 004E 
; 000D 004F     adc_raw     = read_adc(8+ch);
;	ch -> Y+526
;	adc_raw -> R16,R17
;	dhtRet -> R18,R19
;	voltCutOff -> Y+522
;	ACS709offset -> Y+518
;	buffAmpSensor -> Y+278
;	buffVoltSensor -> Y+78
;	buff420Sensor -> Y+38
;	bufferTemp -> Y+30
;	bufferHumi -> Y+22
;	i -> R20,R21
;	j -> Y+20
;	dht11Reread -> Y+18
;	ampValue -> Y+14
;	voltValue -> Y+10
;	mA420Value -> Y+6
; 000D 0050     if(ch==0){
; 000D 0051         //adcData[ch] =   adc_raw;
; 000D 0052         //mA420Value = ((((adcData[ch]+5.0/1023.0)*3.30)/3.30)*20.0);
; 000D 0053 
; 000D 0054         for(i=0;i<10;i++){
; 000D 0055             buff420Sensor[i] = read_adc(8+ch);
; 000D 0056             delay_us(10);
; 000D 0057         }
; 000D 0058         mA420Value = ((average(buff420Sensor,10)+5.0)/1023.0)*20.0;
; 000D 0059         //mA420Value = (((adcData[ch]+5.0/1023.0)*3.30)/165.0);     //R=165 Ohm
; 000D 005A        //printDebug("[%d]ADC: %f, mA: %f \r\n", ch, adcData[ch], mA420Value);
; 000D 005B        //adcData[ch] = (adcData[ch]+5/1023.0)*3.30;
; 000D 005C        adcData[ch] = mA420Value;
; 000D 005D     }else if(ch==3){
; 000D 005E         //adcData[ch] =   adc_raw;
; 000D 005F         //voltValue = ((((adcData[ch]+5.0)/1023.0)*3.30)/3.30)*1000.0;
; 000D 0060         for(i=0;i<50;i++){
; 000D 0061             buffVoltSensor[i] = read_adc(8+ch);
; 000D 0062             delay_us(10);
; 000D 0063         }
; 000D 0064 
; 000D 0065 
; 000D 0066         voltValue = ((average(buffVoltSensor,50)+5.0)/1023.0)*1000.0;
; 000D 0067         //printDebug("[%d]ADC: %f, Volt(raw): %f, Volt(AC): %f \r\n", ch, adcData[ch], (adcData[ch]+5.0/1023.0)*3.30, voltValue);
; 000D 0068 
; 000D 0069        adcData[ch] = voltValue;
; 000D 006A        //adcData[ch] = (adcData[ch]+5/1023)*3.30;
; 000D 006B     }else if(ch==4){
; 000D 006C         memset(buffAmpSensor,0,sizeof(buffAmpSensor));
; 000D 006D         for(i=0;i<60;i++){
; 000D 006E           buffAmpSensor[i] =  read_adc(8+ch);
; 000D 006F           delay_ms(1);
; 000D 0070         }
; 000D 0071         //adcData[ch] = average(buffAmpSensor);
; 000D 0072        // voltCutOff = fabs(((((adcData[ch]+5.0)/1023.0)*3.30)-1.65));
; 000D 0073         voltCutOff = fabs(((((voltPeak(buffAmpSensor)+5.0)/1023.0)*3.30)-1.65));
; 000D 0074         ampValue = (voltCutOff*1000.0)/18.5;
; 000D 0075         //printDebug("[%d]ADC: %f, Volt(raw): %f, Amp: %f\r\n", ch, adcData[ch], (adcData[ch]-511.0), ampValue);
; 000D 0076 
; 000D 0077        adcData[ch] =  ampValue;
; 000D 0078     }else if((ch==1) || (ch==2)){
; 000D 0079 
; 000D 007A         //dhtRet = DHT11Read(&dhtDevice);
; 000D 007B 
; 000D 007C         dht11Reread = 0;
; 000D 007D         //memset(&dhtDevice,0,sizeof(dhtDevice));
; 000D 007E         for(i=0;i<20;i++){
; 000D 007F 
; 000D 0080             dhtRet = DHT11Read(&dhtDevice);
; 000D 0081             //delay_ms(4);
; 000D 0082             //printDebug("[%d]ADC:DHT11:Return (%d). \r\n", ch,dhtRet);
; 000D 0083             if(dhtRet == DHT11_SUCCESS){
; 000D 0084 //                if(ch==1){
; 000D 0085 //                  bufferTemp[dht11Reread] = dhtDevice.temp;
; 000D 0086 //                }else if(ch==2){
; 000D 0087 //                  bufferHumi[dht11Reread] = dhtDevice.humi;
; 000D 0088 //                }
; 000D 0089 
; 000D 008A                 bufferTemp[dht11Reread] = dhtDevice.temp;
; 000D 008B                 bufferHumi[dht11Reread] = dhtDevice.humi;
; 000D 008C 
; 000D 008D                 ++dht11Reread;
; 000D 008E             }
; 000D 008F             if(dht11Reread>=2){
; 000D 0090                break;
; 000D 0091             }
; 000D 0092         }
; 000D 0093 
; 000D 0094         if(dht11Reread>=2){
; 000D 0095             if(ch==1){
; 000D 0096                adcData[ch] = average(bufferTemp,2);
; 000D 0097             }else if(ch==2){
; 000D 0098                adcData[ch] = average(bufferHumi,2);
; 000D 0099             }
; 000D 009A         }else if(dht11Reread>=1){
; 000D 009B             if(ch==1){
; 000D 009C                adcData[ch] = average(bufferTemp,1);
; 000D 009D             }else if(ch==2){
; 000D 009E                adcData[ch] = average(bufferHumi,1);
; 000D 009F             }
; 000D 00A0         }
; 000D 00A1     }
; 000D 00A2     return;
; 000D 00A3 }
;
;float voltPeak(float data[]){       //Amp value
; 000D 00A5 float voltPeak(float data[]){
; 000D 00A6      int i = 0;
; 000D 00A7      float sum=0.0;
; 000D 00A8 
; 000D 00A9      for(i=0;i<60;i++){
;	data -> Y+6
;	i -> R16,R17
;	sum -> Y+2
; 000D 00AA        sum = MAX(sum,data[i]);
; 000D 00AB      }
; 000D 00AC      return sum;
; 000D 00AD }
;float average(float data[],int count){      //Volt value
; 000D 00AE float average(float data[],int count){
; 000D 00AF      int i = 0;
; 000D 00B0      float avg = 0.0, sum=0.0;
; 000D 00B1 
; 000D 00B2      //printDebug("raw data.\r\n");
; 000D 00B3      for(i=0;i<count;i++){
;	data -> Y+12
;	count -> Y+10
;	i -> R16,R17
;	avg -> Y+6
;	sum -> Y+2
; 000D 00B4        //printDebug("%.2f ", data[i]);
; 000D 00B5        sum += data[i];
; 000D 00B6      }
; 000D 00B7      //printDebug("\r\nMax(%.2f) ", sum);
; 000D 00B8      //printDebug("\r\n");
; 000D 00B9      //return sum;
; 000D 00BA 
; 000D 00BB 
; 000D 00BC      avg =(sum/count);
; 000D 00BD      return avg;
; 000D 00BE }
;
;
;
;#include <stdlib.h>
;#include <stdio.h>
;#include "dataqueue.h"
;#include "debug.h"
;
;struct data_record_st dataQ[MAX_DATA_QUEUE];
;int last_wr_dataQ = 0;
;int last_rd_dataQ = 0;
;int dataQ_len = 0;
;
;/*============================================================*/
;int addDataQueue(unsigned long int timestamp, unsigned int channel, float value)
; 000E 000D {

	.CSEG
; 000E 000E     if(dataQ_len == MAX_DATA_QUEUE){
;	timestamp -> Y+6
;	channel -> Y+4
;	value -> Y+0
; 000E 000F         return -1;
; 000E 0010     }
; 000E 0011 
; 000E 0012     dataQ[last_wr_dataQ].timestamp      = timestamp;
; 000E 0013     dataQ[last_wr_dataQ].channel        = channel;
; 000E 0014     dataQ[last_wr_dataQ].value          = value;
; 000E 0015 
; 000E 0016     last_wr_dataQ = (last_wr_dataQ + 1) % MAX_DATA_QUEUE;
; 000E 0017 
; 000E 0018     dataQ_len++;
; 000E 0019 
; 000E 001A     return 0;
; 000E 001B }
;/*============================================================*/
;int fetchDataQueue(unsigned long int *timestamp, unsigned int *channel, float *value)
; 000E 001E {
; 000E 001F     if(dataQ_len == 0){
;	*timestamp -> Y+4
;	*channel -> Y+2
;	*value -> Y+0
; 000E 0020         return -1;
; 000E 0021     }
; 000E 0022 
; 000E 0023     *timestamp  =   dataQ[last_rd_dataQ].timestamp;
; 000E 0024     *channel    =   dataQ[last_rd_dataQ].channel;
; 000E 0025     *value      =   dataQ[last_rd_dataQ].value;
; 000E 0026 
; 000E 0027     last_rd_dataQ = (last_rd_dataQ + 1) % MAX_DATA_QUEUE;
; 000E 0028 
; 000E 0029     dataQ_len--;
; 000E 002A     return 0;
; 000E 002B }
;/*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;//#include "status.h"
;//#include "config.h"
;//#include "timer.h"
;//#include "debug.h"
;//
;///*eeprom*/ char sensorStatus[MAX_SENS_CHANNEL]                  = {SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL};
;///*eeprom*/ char dataStatus[MAX_SENS_CHANNEL]                    = {DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL};
;//char mtncStatus                                             = MTNC_NORMAL;
;//char powerSrcStatus                                         = PWR_NORMAL;
;//char batteryStatus                                          = BATT_NORMAL;
;//char dinStatus[USE_DIN]                                     = {UNKNOWN,UNKNOWN};
;//char doutStatus[USE_DIN]                                    = {UNKNOWN,UNKNOWN};
;//char serverCommStatus                                       = UNKNOWN;
;//char lanStatus                                              = 0;
;//char memoryStatus                                           = MEM_NORMAL;
;//
;//float batteryVolt                                           = 0.0;
;//
;///*
;//char dataLowerStatus[MAX_SENS_CHANNEL]           = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataLowerDelayStatus[MAX_SENS_CHANNEL]      = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataLowerExtremeStatus[MAX_SENS_CHANNEL]    = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataUpperStatus[MAX_SENS_CHANNEL]           = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataUpperDelayStatus[MAX_SENS_CHANNEL]      = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataUpperExtremeStatus[MAX_SENS_CHANNEL]    = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//*/
;//
;///****
;//*  "sensor.h" -> struct sens_val_st sensor[]
;//*
;//****/
;///*============================================================*/
;//int updateMIPStatus(void)
;//{
;//    // -- depend on menu -- //
;//    return 0;
;//}
;///*============================================================*/
;//int updateBatteryStatus(void)
;//{
;//    static TIMER    t               = 0;
;//    static char     t_flag          = 0;
;//    static char     lastCheck       = 0;
;//    char            current_status  = 0;
;//
;//    if(MAIN_POWER_CONNECT){
;//        powerSrcStatus      =   PWR_NORMAL;
;//        batteryStatus       =   BATT_NORMAL;
;//        batteryVolt         =   4.2;
;//        return 0;
;//    }
;//    else{
;//        powerSrcStatus      =   PWR_DOWN;
;//        batteryVolt         =   readBattery();
;//
;//        if(env_config.batteryLevel == 0)    // -- battery alarm disable --> always BATT_NORMAL -- //
;//        {
;//            batteryStatus = BATT_NORMAL;
;//        }
;//        else
;//        {
;//            if(batteryVolt < env_config.batteryLevel)
;//            {
;//                current_status      = BATT_LOW;
;//            }
;//            else
;//            {
;//                current_status      = BATT_NORMAL;
;//            }
;//
;//            if(lastCheck != current_status)
;//            {
;//                t_flag              = 0;
;//                lastCheck           = current_status;
;//            }
;//
;//            if(!t_flag)
;//            {
;//                TIMER_setTimer(&t,10);
;//                t_flag              = 1;
;//            }
;//            else
;//            {
;//                if(TIMER_checkTimerExceed(t))
;//                {
;//                    batteryStatus   = current_status;
;//                    t_flag          = 0;
;//                }
;//            }
;//        }// -- battery alarm enable -- //
;//        return 1;
;//    }// -- main power disconnect -- //
;//
;//    return 0;
;//}
;///*============================================================*/
;//int updateCommStatus(void)
;//{
;//    int res;
;//
;//    if(!IO_LAN_CONNECT){
;//        lanStatus                       = COMM_LAN_DISCONNECT;
;//
;//        serverCommStatus                = UNKNOWN;
;//
;//        commLostTimer                   = 0;                // -- re-initial -- //
;//        return 1;
;//    }
;//    else{
;//        lanStatus                       = COMM_LAN_CONNECT;
;//
;//        if((commLostTimer != 0xFFFFFFFF) && (commLostTimer != 0)){
;//            printDebug("<updateCommStatus> LostTimer time left = %ld(%lX)\r\n",(commLostTimer-baseCounter),(commLostTimer-baseCounter));
;//        }
;//
;//        res = TIMER_checkTimerExceed(commLostTimer);
;//        if(res < 0){
;//            serverCommStatus            = UNKNOWN;              // -- unknown -- //
;//            return 0;
;//        }
;//        else{
;//            if(res){
;//                if(serverCommStatus != COMM_LOST){
;//                    printDebug("<updateCommStatus> Server Down!!!\r\n");
;//                }
;//                serverCommStatus        = COMM_LOST;            // -- disconnect -- //
;//                return 1;
;//            }
;//            else{
;//                if(serverCommStatus != COMM_NORMAL){
;//                    printDebug("<updateCommStatus> Server Up!!!\r\n");
;//                }
;//                serverCommStatus        = COMM_NORMAL;          // -- connect -- //
;//                return 0;
;//            }
;//        }
;//    }
;//}
;///*============================================================*/
;//int updateMemoryStatus(void)
;//{
;////    if(env_config.memoryMin == 0)    // -- memory alarm disable --> always MEM_NORMAL -- //
;////    {
;////            memoryStatus        = MEM_NORMAL;
;////    }
;////    else
;////    {
;//        if(sdFreeSpace == 0)
;//        {
;//            memoryStatus    = MEM_ERROR;
;//        }
;//        else if((int)(sdFreeSpace/1024) < env_config.memoryMin)
;//        {
;//            memoryStatus    = MEM_LOW;
;//        }
;//        else
;//        {
;//            memoryStatus    = MEM_NORMAL;
;//        }
;////    }// -- memory alarm enable -- //
;//
;//    if( memoryStatus != MEM_NORMAL ){
;//        return 1;
;//    }
;//    else{
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int updateSensorStatus(int ch)
;//{
;//    if((ch<0) || (ch>=MAX_SENS_CHANNEL)){
;//        printDebug("<checkProbeAlarm> sensor channel out of range (%d)\r\n",ch);
;//        return 0;
;//    }
;//
;//    sensorStatus[ch] = sensor[ch].status;
;//
;//    if(sensorStatus[ch] == SENS_ERR_UNKNOWN){
;//        return 0;
;//    }
;//    else if(sensorStatus[ch] != SENS_NORMAL){
;//        //printDebug("<checkProbeAlarm> Channel %d ERR\r\n",ch);
;//        return 1;
;//    }
;//    else{
;//        //printDebug("<checkProbeAlarm> Channel %d OK\r\n",ch);
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int updateDataStatus(int ch)
;//{
;//    static TIMER t[MAX_SENS_CHANNEL];
;//    static char flag_lower[MAX_SENS_CHANNEL] = {0,0,0,0,0};
;//    static char flag_upper[MAX_SENS_CHANNEL] = {0,0,0,0,0};
;//    int res = 0;
;//
;//    if((ch<0) || (ch>=MAX_SENS_CHANNEL)){
;//        printDebug("<updateDataStatus> ABORT: sensor channel out of range (%d)\r\n",ch);
;//        return 0;
;//    }
;//
;//    if(sensor[ch].status != SENS_NORMAL){
;//        //printDebug("<updateDataStatus> ABORT: sensor (%d) error\r\n",ch);
;//        return 0;
;//    }
;//
;//    if(sensor[ch].value < sensor_config[ch].lowerLimit){
;//
;//        if(!flag_lower[ch])
;//        {
;//            TIMER_setTimer(&t[ch],sensor_config[ch].lowerDelay);
;//            flag_lower[ch] = 1;
;//        }
;//        else
;//        {
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dataStatus[ch]              |=  DATA_LOWER_LIMIT;
;//                //printDebug("<updateDataStatus> Probe %d lowerDelayLimit[%02X]\r\n", ch+1, dataStatus[ch]);   /////
;//            }
;//        }
;//        //dataStatus[ch]                      |=  DATA_LOWER_LIMIT;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d lowerLimit[%02X] -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,dataStatus[ch],sensor[ch].value,sensor_config[ch].lowerLimit);
;//    }
;//    else{
;//        flag_lower[ch] = 0;
;//        dataStatus[ch]                      &=  ~DATA_LOWER_LIMIT;
;//        //dataStatus[ch]                      &=  ~DATA_LOWER_DELAY;
;//    }
;//
;//    if(sensor[ch].value < sensor_config[ch].lowerExtreme)
;//    {
;//        dataStatus[ch]                      |=  DATA_LOWER_EXTREME;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d lowerExtreme[%02X] -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,dataStatus[ch],sensor[ch].value,sensor_config[ch].lowerExtreme);
;//    }
;//    else
;//    {
;//        dataStatus[ch]                      &=  ~DATA_LOWER_EXTREME;
;//    }
;//
;//    if(sensor[ch].value > sensor_config[ch].upperLimit)
;//    {
;//        if(!flag_upper[ch])
;//        {
;//            TIMER_setTimer(&t[ch],sensor_config[ch].upperDelay);
;//            flag_upper[ch] = 1;
;//        }
;//        else
;//        {
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dataStatus[ch]              |=  DATA_UPPER_LIMIT;
;//            }
;//        }
;//        //dataStatus[ch]                      |=  DATA_UPPER_LIMIT;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d upperLimit -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,sensor[ch].value,sensor_config[ch].upperLimit);
;//    }
;//    else
;//    {
;//        flag_upper[ch] = 0;
;//        dataStatus[ch]                      &=  ~DATA_UPPER_LIMIT;
;//        //dataStatus[ch]                      &=  ~DATA_UPPER_DELAY;
;//    }
;//
;//    if(sensor[ch].value > sensor_config[ch].upperExtreme)
;//    {
;//        dataStatus[ch]                      |=  DATA_UPPER_EXTREME;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d upperExtreme -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,sensor[ch].value,sensor_config[ch].upperExtreme);
;//    }
;//    else
;//    {
;//        dataStatus[ch]                      &=  ~DATA_UPPER_EXTREME;
;//    }
;//
;//    return res;
;//}
;///*============================================================*/
;//int updateDinStatus(void)
;//{
;//    static TIMER    t[USE_DIN]                  = {0,0};
;//    static char     lastDinCheck[USE_DIN]       = {UNKNOWN,UNKNOWN};   // -- initial with unuse value -- //
;//    static char     steadyState[USE_DIN]        = {0,0};
;//    char            currentState                = UNKNOWN;
;//    int             ch                          = 0;
;//    int             ret                         = 0;
;//
;//    for(ch=0;ch<USE_DIN;ch++)
;//    {
;//        if(din_config[ch].channelEnable == 0x01)
;//        {
;//            switch(ch){
;//                case 0  : currentState = DIN1;  break;
;//                case 1  : currentState = DIN2;  break;
;//                default : printDebug("<updateDinStatus> channel[%d] out of range\r\n",ch); return 0;
;//            }
;//
;//            if(currentState != lastDinCheck[ch])
;//            {
;//                TIMER_setTimer(&t[ch],1);
;//                lastDinCheck[ch]    = currentState;
;//                steadyState[ch]     = 0;
;//            }
;//            else if(!steadyState[ch])
;//            {
;//                if(TIMER_checkTimerExceed(t[ch])){
;//
;//                    steadyState[ch] = 1;
;//
;//                    if(currentState){
;//                        dinStatus[ch]   = DIN_RISING;
;//                    }
;//                    else{
;//                        dinStatus[ch]   = DIN_FALLING;
;//                    }
;//
;//                    ret += 1;
;//                }
;//                else{
;//                    steadyState[ch] = 0;
;//                }
;//            }
;//        }
;//    }
;//
;//    return ret;
;//}
;///*============================================================*/
;//int updateDoutStatus(void)
;//{
;//    if(d_out[0]){   doutStatus[0]        = DOUT_HIGH; }
;//    else{           doutStatus[0]        = DOUT_LOW; }
;//
;//    if(d_out[1]){   doutStatus[1]        = DOUT_HIGH; }
;//    else{           doutStatus[1]        = DOUT_LOW; }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int getDeviceState(unsigned short *state)
;//{
;//    int     i   = 0;
;//
;//    *state      = 0x00;
;//
;//    if(isDeviceConfig()){
;//        *state |= (1 << 15);
;//    }
;//    else{
;//        *state &= ~(1 << 15);
;//    }
;//
;//    if(operating_config.deviceEnable){
;//        *state |= (1 << 14);
;//    }
;//    else{
;//        *state &= ~(1 << 14);
;//    }
;//
;//    if(operating_config.mode == MODE_REALTIME){
;//        *state |= (2 << 10);
;//    }
;//    else{
;//        *state |= (1 << 10);
;//    }
;//
;//    if(operating_config.alarmEnable){
;//        *state |= (2 << 8);
;//    }
;//    else{
;//        *state |= (1 << 8);
;//    }
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++)
;//    {
;//        if(operating_config.sensorEnable[i]){
;//            *state |= (1 << (4-i) );
;//        }
;//        else{
;//            *state &= ~(1 << (4-i) );
;//        }
;//    }
;//
;//    printDebug("<getDeviceState> state = [0x%04X]\r\n",*state);
;//
;//    return 0;
;//}
;/*============================================================*/
;#include <stdlib.h>
;#include <stdio.h>
;#include "eventqueue.h"
;#include "debug.h"
;
;struct event_record_st eventQ[MAX_EVENT_QUEUE];
;int last_wr_eventQ = 0;
;int last_rd_eventQ = 0;
;int eventQ_len = 0;
;
;/*============================================================*/
;int addEventQueue(unsigned long int timestamp, unsigned char eventID, unsigned char eventStatus)
; 0010 000D {

	.CSEG
; 0010 000E     if(eventQ_len == MAX_EVENT_QUEUE){
;	timestamp -> Y+2
;	eventID -> Y+1
;	eventStatus -> Y+0
; 0010 000F         return -1;
; 0010 0010     }
; 0010 0011 
; 0010 0012     eventQ[last_wr_eventQ].timestamp        = timestamp;
; 0010 0013     eventQ[last_wr_eventQ].eventID          = eventID;
; 0010 0014     eventQ[last_wr_eventQ].eventStatus      = eventStatus;
; 0010 0015 
; 0010 0016     last_wr_eventQ = (last_wr_eventQ + 1) % MAX_EVENT_QUEUE;
; 0010 0017 
; 0010 0018     eventQ_len++;
; 0010 0019 
; 0010 001A     return 0;
; 0010 001B }
;/*============================================================*/
;int fetchEventQueue(unsigned long int *timestamp, unsigned char *eventID, unsigned char *eventStatus)
; 0010 001E {
; 0010 001F     if(eventQ_len == 0){
;	*timestamp -> Y+4
;	*eventID -> Y+2
;	*eventStatus -> Y+0
; 0010 0020         return -1;
; 0010 0021     }
; 0010 0022 
; 0010 0023     *timestamp      =   eventQ[last_rd_eventQ].timestamp;
; 0010 0024     *eventID        =   eventQ[last_rd_eventQ].eventID;
; 0010 0025     *eventStatus    =   eventQ[last_rd_eventQ].eventStatus;
; 0010 0026 
; 0010 0027     last_rd_eventQ  = (last_rd_eventQ + 1) % MAX_EVENT_QUEUE;
; 0010 0028 
; 0010 0029     eventQ_len--;
; 0010 002A     return 0;
; 0010 002B }
;/*============================================================*/
;#include <stdlib.h>
;#include <stdio.h>
;//#include "alarm.h"
;//#include "config.h"
;//#include "debug.h"
;//
;///*eeprom*/ char sensorAlarm[MAX_SENS_CHANNEL]   = {SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL};        // -- oled -- //
;///*eeprom*/ char dataAlarm[MAX_SENS_CHANNEL]     = {DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL};        // -- oled -- //
;///*eeprom*/ char dinAlarm[MAX_DI_CHANNEL]        = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,     // -- oled -- //
;//                                               UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;///*eeprom*/ char ainAlarm[MAX_AI_CHANNEL]        = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,
;//                                               UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;///*eeprom*/ char muteAlarm                       = UNKNOWN;
;///*eeprom*/ char mtncAlarm                       = MTNC_NORMAL;
;///*eeprom*/ char powerSrcAlarm                   = PWR_NORMAL;
;///*eeprom*/ char batteryAlarm                    = BATT_NORMAL;                                                          // -- oled -- //
;///*eeprom*/ char communicationAlarm              = COMM_NORMAL;
;///*eeprom*/ char memoryAlarm                     = MEM_NORMAL;                                                           // -- oled -- //
;///*eeprom*/ char gsmAlarm                        = GSM_NORMAL;
;///*eeprom*/ char gsmBalanceAlarm                 = GBAL_NORMAL;
;//
;///*============================================================*/
;///**************************************************************/
;///**************** Alarm Indicating decision *******************/
;///**************************************************************/
;//int checkAlarm(char *srcList,int srcLen)
;//{
;//    int i=0, res=0, tmp=0;
;//
;//    for(i=0;i<srcLen;i++)
;//    {
;//        tmp  = checkAlarmFromSrc(srcList[i]);
;//        res |= tmp;
;//        //printDebug("<checkAlarm> SRC[0x%02X] -> %d\r\n",srcList[i],tmp);
;//    }
;//
;//    return res;
;//}
;///*============================================================*/
;//int checkAlarmFromSrc(char alarmSrc)
;//{
;//    int i   = 0;
;//    int res = 0;
;//
;//    switch(alarmSrc)
;//    {
;//        case SRC_SENS1_EVENT             :  if(((sensorStatus[0]!= SENS_NORMAL) && (sensorStatus[0] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[0]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS1_LOWER             :  if(dataStatus[0]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS1_LOWERDELAY        :  if(dataStatus[0]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS1_LOWEREXTREME      :  if(dataStatus[0]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS1_UPPER             :  if(dataStatus[0]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS1_UPPERDELAY        :  if(dataStatus[0]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS1_UPPEREXTREME      :  if(dataStatus[0]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS1_ERROR             :  if((sensorStatus[0] != SENS_NORMAL) &&
;//                                               (sensorStatus[0] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS2_EVENT             :  if(((sensorStatus[1]!= SENS_NORMAL) && (sensorStatus[1] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[1]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS2_LOWER             :  if(dataStatus[1]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS2_LOWERDELAY        :  if(dataStatus[1]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS2_LOWEREXTREME      :  if(dataStatus[1]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS2_UPPER             :  if(dataStatus[1]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS2_UPPERDELAY        :  if(dataStatus[1]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS2_UPPEREXTREME      :  if(dataStatus[1]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS2_ERROR             :  if((sensorStatus[1] != SENS_NORMAL) &&
;//                                               (sensorStatus[1] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS3_EVENT             :  if(((sensorStatus[2]!= SENS_NORMAL) && (sensorStatus[2] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[2]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS3_LOWER             :  if(dataStatus[2]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS3_LOWERDELAY        :  if(dataStatus[2]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS3_LOWEREXTREME      :  if(dataStatus[2]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS3_UPPER             :  if(dataStatus[2]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS3_UPPERDELAY        :  if(dataStatus[2]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS3_UPPEREXTREME      :  if(dataStatus[2]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS3_ERROR             :  if((sensorStatus[2] != SENS_NORMAL) &&
;//                                               (sensorStatus[2] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS4_EVENT             :  if(((sensorStatus[3]!= SENS_NORMAL) && (sensorStatus[3] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[3]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS4_LOWER             :  if(dataStatus[3]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS4_LOWERDELAY        :  if(dataStatus[3]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS4_LOWEREXTREME      :  if(dataStatus[3]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS4_UPPER             :  if(dataStatus[3]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS4_UPPERDELAY        :  if(dataStatus[3]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS4_UPPEREXTREME      :  if(dataStatus[3]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS4_ERROR             :  if((sensorStatus[3] != SENS_NORMAL) &&
;//                                               (sensorStatus[3] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS5_EVENT             :  if(((sensorStatus[4]!= SENS_NORMAL) && (sensorStatus[4] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[4]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS5_LOWER             :  if(dataStatus[4]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS5_LOWERDELAY        :  if(dataStatus[4]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS5_LOWEREXTREME      :  if(dataStatus[4]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS5_UPPER             :  if(dataStatus[4]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS5_UPPERDELAY        :  if(dataStatus[4]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS5_UPPEREXTREME      :  if(dataStatus[4]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS5_ERROR             :  if((sensorStatus[4] != SENS_NORMAL) &&
;//                                               (sensorStatus[4] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_DI_EVENT_ANY            :  break;
;//        case SRC_DI_RISING_ANY           :  for(i=0;i<USE_DIN;i++){
;//                                                if(dinStatus[i] == DIN_RISING)          res = 1;    break;
;//                                            }
;//                                            break;
;//        case SRC_DI_FALLING_ANY          :  for(i=0;i<USE_DIN;i++){
;//                                                if(dinStatus[i] == DIN_FALLING)         res = 1;    break;
;//                                            }
;//                                            break;
;//
;//        case SRC_DI_EVENT(0)             :  break;
;//        case SRC_DI_RISING(0)            :  if(dinStatus[0] == DIN_RISING) {
;//                                                res = 1;
;////                                                printDebug("DIN1 Rising Alarm \r\n");
;//                                            }
;//                                            break;
;//        case SRC_DI_FALLING(0)           :  if(dinStatus[0]     == DIN_FALLING)         res = 1;    break;
;//
;//        case SRC_DI_EVENT(1)             :  break;
;//        case SRC_DI_RISING(1)            :  if(dinStatus[1]     == DIN_RISING)          res = 1;    break;
;//        case SRC_DI_FALLING(1)           :  if(dinStatus[1]     == DIN_FALLING)         res = 1;    break;
;//
;//        case SRC_MUTE_ALARM              :  break;
;//        case SRC_MIP                     :  // --- wait for menu MIP --- //
;//                                            break;
;//        case SRC_POWER_DOWN              :  if(powerSrcStatus   == PWR_DOWN)            res = 1;    break;
;//        case SRC_LOW_BATTERY             :  if(batteryStatus    == BATT_LOW)            res = 1;    break;
;//        case SRC_LOW_COMM_SIGNAL         :  break;
;//        case SRC_LOW_MEMORY              :  if(memoryAlarm      == MEM_LOW)             res = 1;    break;
;//        case SRC_MEMORY_ERROR            :  if(memoryAlarm      == MEM_ERROR)           res = 1;    break;
;//        case SRC_LOST_OF_COMM            :  if(serverCommStatus == COMM_LOST) {
;//                                                res = 1;
;////                                                printDebug("Comm Lost Alarm \r\n");
;//                                            }
;////                                            printDebug("Check Comm Lost \r\n");
;//                                            break;
;//        case SRC_GSM_LOW_SIGNAL          :
;//        case SRC_GSM_DATE_EXPIRED        :
;//        case SRC_GSM_NO_OPERATOR         :
;//        case SRC_GSM_TOP_UP              :
;//        case SRC_GSM_LOW_BALANCE         :
;//        case SRC_GSM_UNKNOWN_FAILURE     :  printDebug("<checkAlarmFromSrc> GSM Not support yet [0x%02X]\r\n",alarmSrc);
;//                                            break;
;//
;//        default                          :  printDebug("<checkAlarmFromSrc> alarmSrc unknown [0x%02X]\r\n",alarmSrc);
;//                                            break;
;//    }
;//
;//    return res;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///****************** Send Alarm Detection **********************/
;///**************************************************************/
;///*============================================================*/
;//int checkSendMIPAlarm(unsigned char *code)
;//{
;//    if(mtncStatus != mtncAlarm)
;//    {
;//        mtncAlarm   = mtncStatus;
;//        *code       = mtncStatus;
;//        return 1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendPowerAlarm(unsigned char *code)
;//{
;//    static TIMER    t           = 0;
;//    static char     t_flag      = 0;
;//    static char     lastCheck   = 0x69;   // -- initial with any unuse value -- //
;//
;//    if(powerSrcStatus != powerSrcAlarm)
;//    {
;//        if(powerSrcStatus != lastCheck){
;//            t_flag      = 0;
;//            lastCheck   = powerSrcStatus;
;//        }
;//
;//        if(!t_flag){
;//            if(powerSrcStatus == PWR_DOWN){
;//                TIMER_setTimer(&t,30);
;//            }
;//            else{
;//                TIMER_setTimer(&t,3);
;//            }
;//            t_flag              = 1;
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t))
;//            {
;//                powerSrcAlarm   = powerSrcStatus;
;//
;//                *code           = powerSrcStatus;
;//
;//                t_flag          = 0;
;//                return 1;
;//            }
;//        }
;//    }
;//    else
;//    {
;//        t_flag = 0;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendBatteryAlarm(unsigned char *code)
;//{
;//    static TIMER    t           = 0;
;//    static char     t_flag      = 0;
;//    static char     lastCheck   = 0x69;   // -- initial with any unuse value -- //
;//
;//    if(env_config.batteryLevel > 0)
;//    {
;//        if(batteryStatus != batteryAlarm)
;//        {
;//            if(batteryStatus != lastCheck)
;//            {
;//                t_flag      = 0;
;//                lastCheck   = batteryStatus;
;//            }
;//
;//            if(!t_flag)
;//            {
;//                if(batteryStatus == BATT_LOW){
;//                    TIMER_setTimer(&t,10);
;//                }
;//                else{
;//                    TIMER_setTimer(&t,10);
;//                }
;//                t_flag              = 1;
;//            }
;//            else
;//            {
;//                if(TIMER_checkTimerExceed(t))
;//                {
;//                    batteryAlarm   = batteryStatus;
;//
;//                    *code           = batteryStatus;
;//
;//                    t_flag          = 0;
;//                    return 1;
;//                }
;//            }
;//        }
;//        else
;//        {
;//            t_flag = 0;
;//        }
;//    }
;//    else                                // -- battery alarm disable -- //
;//    {
;//        t           = 0;
;//        t_flag      = 0;
;//        lastCheck   = 0x69;
;//        if(batteryAlarm != BATT_NORMAL)
;//        {
;//            batteryAlarm    = BATT_NORMAL;
;//            *code           = BATT_NORMAL;
;//            return 1;
;//        }
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendMemoryAlarm(unsigned char *code)
;//{
;//    static TIMER    t      = 0;
;//    static char     t_flag = 0;
;//
;//    if(env_config.memoryMin > 0)
;//    {
;//        if(memoryStatus != memoryAlarm)
;//        {
;//            if(!t_flag){
;//                TIMER_setTimer(&t,15);
;//                t_flag          = 1;
;//            }
;//            else{
;//                if(TIMER_checkTimerExceed(t))
;//                {
;//                    memoryAlarm     = memoryStatus;
;//
;//                    *code           = memoryStatus;
;//
;//                    t_flag          = 0;
;//
;//                    return 1;
;//                }
;//            }
;//        }
;//        else{
;//            t_flag              = 0;
;//        }
;//    }
;//    else                                // -- battery alarm disable -- //
;//    {
;//        t           = 0;
;//        t_flag      = 0;
;//        if(batteryAlarm != MEM_NORMAL)
;//        {
;//            memoryAlarm     = MEM_NORMAL;
;//            *code           = MEM_NORMAL;
;//            return 1;
;//        }
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendDinAlarm(int ch, unsigned char *code)
;//{
;//    static TIMER    t[USE_DIN]         = {0,0};
;//    static char     t_flag[USE_DIN]    = {0,0};
;//    static char     lastCheck[USE_DIN] = {0x69,0x69};   // -- initial with any unuse value -- //
;//
;//    if((ch < 0) || (ch >= USE_DIN)){
;//        printDebug("<checkSendDinAlarm> channel out of range [%d]\r\n",ch);
;//        return 0;
;//    }
;//
;//    if(dinStatus[ch] != dinAlarm[ch])
;//    {
;//        if(dinStatus[ch] != lastCheck[ch]){
;//            t_flag[ch]          = 0;
;//            lastCheck[ch]       = dinStatus[ch];
;//        }
;//
;//        if(!t_flag[ch]){
;//            TIMER_setTimer(&t[ch],5);
;//            t_flag[ch]          = 1;
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dinAlarm[ch]    = dinStatus[ch];
;//                *code           = dinStatus[ch];
;//                t_flag[ch]      = 0;
;//                return 1;
;//            }
;//        }
;//    }
;//    else{
;//        t_flag[ch]              =   0;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendSensorAlarm(int ch, unsigned char *code)
;//{
;//    static TIMER    t[MAX_SENS_CHANNEL]         = {0,0,0,0,0};
;//    static char     t_flag[MAX_SENS_CHANNEL]    = {0,0,0,0,0};
;//    static char     lastCheck[MAX_SENS_CHANNEL] = {0x69,0x69,0x69,0x69,0x69};   // -- initial with any unuse value -- //
;//
;//    if(sensorStatus[ch] != sensorAlarm[ch])
;//    {
;//        if(sensorStatus[ch] != lastCheck[ch]){
;//            t_flag[ch]          = 0;
;//            lastCheck[ch]       = sensorStatus[ch];
;//        }
;//
;//        if(!t_flag[ch]){
;//            if(sensorStatus[ch] == SENS_ERR_UNKNOWN){
;//                TIMER_setTimer(&t[ch],30);
;//            }
;//            else{
;//                TIMER_setTimer(&t[ch],3);
;//            }
;//            t_flag[ch]          = 1;
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                sensorAlarm[ch] = sensorStatus[ch];
;//
;//                *code           = sensorStatus[ch];
;//
;//                t_flag[ch]      = 0;
;//                return 1;
;//            }
;//        }
;//    }
;//    else{
;//        t_flag[ch]              =   0;
;//    }
;//
;//    return 0;
;//
;//    /*
;//    if(sensorStatus[ch] != sensorAlarm[ch])
;//    {
;//        sensorAlarm[ch] = sensorStatus[ch];
;//
;//        *code           = sensorStatus[ch];
;//
;//        return 1;
;//    }
;//    */
;//
;//    /*
;//    // -- mask for an error and compare with reported alarm -- //
;//    if((sensorStatus[ch] & SENS_ERR_LOWER_BOUND) != (sensorAlarm[ch] & SENS_ERR_LOWER_BOUND))
;//    {
;//        // -- check if it's an error or recover -- //
;//        if( (sensorStatus[ch] & SENS_ERR_LOWER_BOUND) == SENS_ERR_LOWER_BOUND )     // -- error -- //
;//        {
;//
;//        }
;//        else                                                                        // -- recover -- //
;//        {
;//
;//        }
;//        sensorAlarm[ch] = sensorStatus[ch];
;//
;//        *code           = sensorStatus[ch];
;//
;//        return 1;
;//    }
;//
;//    return 0;
;//    */
;//}
;///*============================================================*/
;//int checkSendDataAlarm(int ch, unsigned char *code)
;//{
;//    static TIMER    t[MAX_SENS_CHANNEL]      = {0,0,0,0,0};
;//    static char     t_flag[MAX_SENS_CHANNEL] = {0,0,0,0,0};
;//
;//    if(dataStatus[ch] != dataAlarm[ch])
;//    {
;//        if(!t_flag[ch]){
;//            TIMER_setTimer(&t[ch],3);
;//            t_flag[ch]          = 1;
;////            printDebug("<checkSendDataAlarm> Probe %d dataAlarm[0x%02X] != dataStatus[0x%02X]\r\n",ch+1,dataAlarm[ch],dataStatus[ch]);
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dataAlarm[ch]   = dataStatus[ch];
;//
;//                *code           = dataStatus[ch];
;//
;//                t_flag[ch]      = 0;
;//
;//                printDebug("<checkSendDataAlarm> Probe %d dataAlarm[0x%02X]\r\n",ch+1,dataAlarm[ch]);
;//
;//                return 1;
;//            }
;//        }
;//    }
;//    else{
;//        t_flag[ch]              = 0;
;//    }
;//
;//    return 0;
;//
;//    /*
;//    if(dataStatus[ch] != dataAlarm[ch])
;//    {
;//        dataAlarm[ch]   = dataStatus[ch];
;//
;//        *code           = dataStatus[ch];
;//
;//        return 1;
;//    }
;//    */
;//
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///****************** Alarm Mute Management *********************/
;///**************************************************************/
;//char muteMode   = 0;
;//TIMER muteAlarmExpired  = 0xFFFFFFFF;       // -- initial with maximum TIMER value -- //
;///*============================================================*/
;//int ALARM_mute(unsigned long int period)
;//{
;//    if(period == 0){
;//        muteAlarmExpired    = 0xFFFFFFFF;
;//        muteMode            = MUTE_PERMAMENT;
;//    }
;//    else{
;//        TIMER_setTimer(&muteAlarmExpired,period);
;//        muteMode            = MUTE_TEMPORARY;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ALARM_checkMuteExpired(void)
;//{
;//    switch(muteMode){
;//        case MUTE_PERMAMENT :   return 0;
;//                                break;
;//        case MUTE_TEMPORARY :   if( TIMER_checkTimerExceed(muteAlarmExpired) ){
;//                                    return 1;
;//                                }
;//                                else{
;//                                    return 0;
;//                                }
;//                                break;
;//        default :               printDebug("<ALARM_checkMuteExpired> invalid muteMode (%d)\r\n", muteMode);
;//                                return 1;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///****************** Sevice Alarm Function *********************/
;///**************************************************************/
;///*============================================================*/
;//void resetAlarm(void)
;//{
;//    int i;
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++){
;//        sensorAlarm[i]      =   SENS_NORMAL;
;//        dataAlarm[i]        =   DATA_NORMAL;
;//    }
;//    for(i=0;i<MAX_DI_CHANNEL;i++){
;//        dinAlarm[i]         =   UNKNOWN;
;//    }
;//    for(i=0;i<MAX_AI_CHANNEL;i++){
;//        ainAlarm[i]         =   UNKNOWN;
;//    }
;//    muteAlarm                       = UNKNOWN;
;//    mtncAlarm                       = MTNC_NORMAL;
;//    powerSrcAlarm                   = PWR_NORMAL;
;//    batteryAlarm                    = BATT_NORMAL;
;//    communicationAlarm              = COMM_NORMAL;
;//    memoryAlarm                     = MEM_NORMAL;
;//    gsmAlarm                        = GSM_NORMAL;
;//    gsmBalanceAlarm                 = GBAL_NORMAL;
;//
;//}
;///*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <delay.h>
;#include "memcard.h"
;#include "debug.h"
;
;unsigned long int sdFreeSpace = 0;
;
;/*============================================================*/
;/* will hold the information for logical drive 0: */
;FATFS fat;
;/* pointer to the FATFS type structure */
;FATFS *pfat;
;/* root path */
;char root_path[] = "0:/";

	.DSEG
;/*============================================================*/        /* error message list */
;flash char * flash error_msg[]= {   "", /* not used */
;                                    "FR_DISK_ERR",
;                                    "FR_INT_ERR",
;                                    "FR_NOT_READY",
;                                    "FR_NO_FILE",
;                                    "FR_NO_PATH",
;                                    "FR_INVALID_NAME",
;                                    "FR_DENIED",
;                                    "FR_EXIST",
;                                    "FR_INVALID_OBJECT",
;                                    "FR_WRITE_PROTECTED",
;                                    "FR_INVALID_DRIVE",
;                                    "FR_NOT_ENABLED",
;                                    "FR_NO_FILESYSTEM",
;                                    "FR_MKFS_ABORTED",
;                                    "FR_TIMEOUT"  };
;/*============================================================*/        /* display error message and stop */
;void error(FRESULT res)
; 0012 0023 {

	.CSEG
_error:
; 0012 0024     if ((res>=FR_DISK_ERR) && (res<=FR_TIMEOUT))        printDebug("<ERR> %p.\r\n",error_msg[res]);     return;
	ST   -Y,R26
;	res -> Y+0
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRLO _0x240005
	CPI  R26,LOW(0x10)
	BRLO _0x240006
_0x240005:
	RJMP _0x240004
_0x240006:
	__POINTD1FN _0x240000,207
	CALL __PUTPARD1
	LDD  R30,Y+4
	LDI  R26,LOW(_error_msg*2)
	LDI  R27,HIGH(_error_msg*2)
	LDI  R24,BYTE3(_error_msg*2)
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __LSLD1
	CALL __LSLD1
	CALL __ADDD12
	CALL __GETD1PF
	CALL SUBOPT_0x61
_0x240004:
	ADIW R28,1
	RET
; 0012 0025 }
;/*============================================================*/
;int SD_writeData(FIL *file, unsigned long int start, unsigned char *data, unsigned int len)
; 0012 0028 {
; 0012 0029     FRESULT         res;
; 0012 002A     unsigned int    actual_write;
; 0012 002B 
; 0012 002C     if(sdFreeSpace == 0){ printDebug("<SD_writeData> SD Card not ready\r\n");       return -1;}
;	*file -> Y+12
;	start -> Y+8
;	*data -> Y+6
;	len -> Y+4
;	res -> R17
;	actual_write -> R18,R19
; 0012 002D 
; 0012 002E     res = f_lseek(file,start);
; 0012 002F     if(res != FR_OK){
; 0012 0030         printDebug("<SD_writeData> f_lseek(%u) failed!!\r\n", start);
; 0012 0031         error(res);
; 0012 0032         return -1;
; 0012 0033     }
; 0012 0034 
; 0012 0035     res = f_write(file,data,len,&actual_write);
; 0012 0036     if(res != FR_OK){
; 0012 0037         printDebug("<SD_writeData> f_write() failed\r\n");
; 0012 0038         print_payload(data,len);
; 0012 0039         error(res);
; 0012 003A         return -2;
; 0012 003B     }
; 0012 003C 
; 0012 003D     if(actual_write != len){
; 0012 003E         printDebug("<SD_writeData> actual_write[%u] != len[%u]\r\n",actual_write,len);
; 0012 003F         return -3; // -- the caller should roll back the last data -- //
; 0012 0040     }
; 0012 0041 
; 0012 0042     return 0;
; 0012 0043 }
;/*============================================================*/
;int SD_readData(FIL *file, unsigned long int start, unsigned char *data, unsigned int len)
; 0012 0046 {
; 0012 0047     FRESULT         res;
; 0012 0048     unsigned int    actual_read;
; 0012 0049 
; 0012 004A     if(sdFreeSpace == 0){ printDebug("<SD_readData> SD Card not ready\r\n");       return -1;}
;	*file -> Y+12
;	start -> Y+8
;	*data -> Y+6
;	len -> Y+4
;	res -> R17
;	actual_read -> R18,R19
; 0012 004B 
; 0012 004C     res = f_lseek(file,start);
; 0012 004D     if(res != FR_OK){
; 0012 004E         printDebug("<SD_readData> f_lseek(%u) failed!!\r\n", start);
; 0012 004F         error(res);
; 0012 0050         return -1;
; 0012 0051     }
; 0012 0052 
; 0012 0053     res = f_read(file,data,len,&actual_read);
; 0012 0054     if(res != FR_OK){
; 0012 0055         printDebug("<SD_readData> f_read() failed\r\n");
; 0012 0056         error(res);
; 0012 0057         return -2;
; 0012 0058     }
; 0012 0059 
; 0012 005A     if(actual_read != len){
; 0012 005B         printDebug("<SD_writeData> actual_read[%u] != len[%u]\r\n",actual_read,len);
; 0012 005C         return -3; // -- the caller should roll back the last data -- //
; 0012 005D     }
; 0012 005E 
; 0012 005F     return 0;
; 0012 0060 }
;/*============================================================*/
;int SD_readMemoryRemain(unsigned long *free_kbytes)
; 0012 0063 {
_SD_readMemoryRemain:
; 0012 0064     FRESULT         res;
; 0012 0065     unsigned long   free_clusters;
; 0012 0066 
; 0012 0067     // ------ read available memory space ------- //
; 0012 0068     // return as percentage!!! //
; 0012 0069 
; 0012 006A     /* get the number of free clusters */
; 0012 006B     res = f_getfree(root_path,&free_clusters,&pfat);
	CALL SUBOPT_0x5C
;	*free_kbytes -> Y+5
;	res -> R17
;	free_clusters -> Y+1
	LDI  R30,LOW(_root_path)
	LDI  R31,HIGH(_root_path)
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,3
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(_pfat)
	LDI  R27,HIGH(_pfat)
	CALL _f_getfree
	MOV  R17,R30
; 0012 006C     if ( res != FR_OK){
	CPI  R17,0
	BREQ _0x24000F
; 0012 006D        /* an error occured, display it and stop */
; 0012 006E        printDebug("<SD_readMemoryRemain> f_getfree(%s) error!!\r\n",root_path);
	__POINTD1FN _0x240000,518
	CALL SUBOPT_0x62
	CALL SUBOPT_0x63
; 0012 006F        error(res);
	MOV  R26,R17
	CALL SUBOPT_0x64
; 0012 0070        sdFreeSpace = 0;
; 0012 0071        return -1;
	RJMP _0x20E0039
; 0012 0072     }
; 0012 0073 
; 0012 0074     /* calculate the number of free bytes */
; 0012 0075     *free_kbytes = free_clusters * pfat->csize / 2;
_0x24000F:
	LDS  R30,_pfat
	LDS  R31,_pfat+1
	CALL SUBOPT_0x65
	CALL SUBOPT_0x66
	CALL SUBOPT_0x67
	CALL __LSRD1
	LDD  R26,Y+5
	LDD  R27,Y+5+1
	CALL __PUTDP1
; 0012 0076 
; 0012 0077     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0039:
	LDD  R17,Y+0
	ADIW R28,7
	RET
; 0012 0078 }
;/*============================================================*/
;int SD_mount(void)
; 0012 007B {
_SD_mount:
; 0012 007C     FRESULT         res;
; 0012 007D 
; 0012 007E     /* mount logical drive 0: */
; 0012 007F     res = f_mount(0,&fat);
	ST   -Y,R17
;	res -> R17
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R26,LOW(_fat)
	LDI  R27,HIGH(_fat)
	CALL _f_mount
	MOV  R17,R30
; 0012 0080     if( res != FR_OK ){
	CPI  R17,0
	BREQ _0x240010
; 0012 0081         printDebug("Logical drive 0: mounted ERROR\r\n");
	__POINTD1FN _0x240000,564
	CALL SUBOPT_0x0
; 0012 0082         error(res);
	MOV  R26,R17
	RCALL _error
; 0012 0083         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0038
; 0012 0084     }
; 0012 0085 
; 0012 0086     printDebug("Logical drive 0: mounted OK\r\n");
_0x240010:
	__POINTD1FN _0x240000,597
	CALL SUBOPT_0x0
; 0012 0087     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0038:
	LD   R17,Y+
	RET
; 0012 0088 }
;/*============================================================*/
;int SD_unmount(void)
; 0012 008B {
; 0012 008C     FRESULT         res;
; 0012 008D 
; 0012 008E     /* unmount logical drive 0: */
; 0012 008F     res = f_mount(0,NULL);
;	res -> R17
; 0012 0090     if( res != FR_OK ){
; 0012 0091         printDebug("Logical drive 0: unmounted ERROR\r\n");
; 0012 0092         error(res);
; 0012 0093         return -1;
; 0012 0094     }
; 0012 0095 
; 0012 0096     printDebug("Logical drive 0: unmounted OK\r\n");
; 0012 0097     return 0;
; 0012 0098 }
;/*============================================================*/
;int SD_remount(void)
; 0012 009B {
; 0012 009C     int res;
; 0012 009D 
; 0012 009E     res = SD_unmount();
;	res -> R16,R17
; 0012 009F     if(res < 0){
; 0012 00A0         printDebug("<SD_remount> SD_unmount() failed\r\n");
; 0012 00A1         return -1;
; 0012 00A2     }
; 0012 00A3     delay_ms(250);
; 0012 00A4     res = SD_mount();
; 0012 00A5     if(res < 0){
; 0012 00A6         printDebug("<SD_remount> SD_mount() failed\r\n");
; 0012 00A7         return -1;
; 0012 00A8     }
; 0012 00A9     delay_ms(250);
; 0012 00AA //
; 0012 00AB //    if(SD_createFile(LOG_PROTOCOL) < 0){
; 0012 00AC //        printDebug("Error creating new log file (Remount failed)\r\n");
; 0012 00AD //        return -1;
; 0012 00AE //    }
; 0012 00AF 
; 0012 00B0     return 0;
; 0012 00B1 }
;/*============================================================*/
;int SD_createFile(char *filename, unsigned char mode)
; 0012 00B4 {
; 0012 00B5     FIL          file;
; 0012 00B6     FRESULT      res;
; 0012 00B7     char         filepath[50];
; 0012 00B8 
; 0012 00B9     if(sdFreeSpace == 0){ printDebug("<SD_createFile> SD Card not ready\r\n");      return -1;}
;	*filename -> Y+596
;	mode -> Y+595
;	file -> Y+51
;	res -> R17
;	filepath -> Y+1
; 0012 00BA 
; 0012 00BB     sprintf(filepath,"%s%s",root_path,filename);
; 0012 00BC 
; 0012 00BD     if(mode == SD_FORCE)        // -- replace old file if exist -- //
; 0012 00BE     {
; 0012 00BF         //printDebug("<SD_createFile> Force re-creating file %s.\r\n",filename);
; 0012 00C0         res = f_open(   &file,
; 0012 00C1                         filepath,
; 0012 00C2                         FA_CREATE_ALWAYS | FA_WRITE );
; 0012 00C3     }
; 0012 00C4     else                        // -- keep old file if exist -- //
; 0012 00C5     {
; 0012 00C6         //printDebug("<SD_createFile> Try to creating file %s.\r\n",filename);
; 0012 00C7         res = f_open(   &file,
; 0012 00C8                         filepath,
; 0012 00C9                         FA_CREATE_NEW | FA_WRITE );
; 0012 00CA     }
; 0012 00CB 
; 0012 00CC     if( res == FR_EXIST){
; 0012 00CD         //printDebug("<SD_createFile> %s already exist\r\n", filename);
; 0012 00CE 
; 0012 00CF //        res = f_close( &file );
; 0012 00D0 //        if( res != FR_OK ){
; 0012 00D1 //            printDebug("<SD_createFile> f_close() failed\r\n");
; 0012 00D2 //            error(res);
; 0012 00D3 //            return -1;
; 0012 00D4 //        }
; 0012 00D5 
; 0012 00D6         return 0;       // -- return 0 indicated that a file is already exist -- //
; 0012 00D7     }
; 0012 00D8     else if( res != FR_OK){
; 0012 00D9         printDebug("<SD_createFile> f_open() failed\r\n");
; 0012 00DA         error(res);
; 0012 00DB         return -1;
; 0012 00DC     }
; 0012 00DD 
; 0012 00DE     //printDebug("<SD_createFile> '%s' created!!\r\n",filename);
; 0012 00DF 
; 0012 00E0     res = f_close( &file );
; 0012 00E1     if( res != FR_OK ){
; 0012 00E2         printDebug("<SD_createFile> f_close() failed\r\n");
; 0012 00E3         error(res);
; 0012 00E4         return -1;
; 0012 00E5     }
; 0012 00E6 
; 0012 00E7     return 1;   // -- return 1 indicated that it's a new file -- //
; 0012 00E8 }
;/*============================================================*/
;int SD_openFile(FIL *file, unsigned char *filename)
; 0012 00EB {
_SD_openFile:
; 0012 00EC     int     res;
; 0012 00ED     char    filepath[50];
; 0012 00EE 
; 0012 00EF     if(sdFreeSpace == 0){ printDebug("<SD_openFile> SD Card not ready\r\n");    return -1;}
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,50
	ST   -Y,R17
	ST   -Y,R16
;	*file -> Y+54
;	*filename -> Y+52
;	res -> R16,R17
;	filepath -> Y+2
	CALL SUBOPT_0x68
	BRNE _0x24001B
	__POINTD1FN _0x240000,872
	CALL SUBOPT_0x0
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0037
; 0012 00F0 
; 0012 00F1     sprintf(filepath,"%s%s",root_path,filename);
_0x24001B:
	CALL SUBOPT_0x69
	__POINTD1FN _0x240000,798
	CALL SUBOPT_0x62
	LDD  R30,Y+62
	LDD  R31,Y+62+1
	CALL SUBOPT_0x5F
	LDI  R24,8
	CALL _sprintf
	ADIW R28,14
; 0012 00F2 
; 0012 00F3     res = f_open( file, filepath, FA_WRITE | FA_READ | FA_OPEN_EXISTING);
	LDD  R30,Y+54
	LDD  R31,Y+54+1
	CALL SUBOPT_0x6A
	LDI  R26,LOW(3)
	CALL _f_open
	MOV  R16,R30
	CLR  R17
; 0012 00F4     if( res != FR_OK){
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x24001C
; 0012 00F5         printDebug("<SD_openFile> f_open() [%s] failed\r\n", filename);
	__POINTD1FN _0x240000,906
	CALL __PUTPARD1
	LDD  R30,Y+56
	LDD  R31,Y+56+1
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 0012 00F6         error(res);
	MOV  R26,R16
	CALL SUBOPT_0x64
; 0012 00F7         sdFreeSpace = 0;
; 0012 00F8         return -1;
	RJMP _0x20E0037
; 0012 00F9     }
; 0012 00FA 
; 0012 00FB     return 0;
_0x24001C:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0037:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,56
	RET
; 0012 00FC }
;/*============================================================*/
;int SD_closeFile(FIL *file)
; 0012 00FF {
_SD_closeFile:
; 0012 0100     int res;
; 0012 0101 
; 0012 0102     if(sdFreeSpace == 0){ printDebug("<SD_closeFile> SD Card not ready\r\n");       return -1;}
	CALL SUBOPT_0x13
;	*file -> Y+2
;	res -> R16,R17
	CALL SUBOPT_0x68
	BRNE _0x24001D
	__POINTD1FN _0x240000,943
	CALL SUBOPT_0x0
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0036
; 0012 0103 
; 0012 0104     res = f_close( file );
_0x24001D:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	CALL _f_close
	MOV  R16,R30
	CLR  R17
; 0012 0105     if( res != FR_OK ){
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x24001E
; 0012 0106         printDebug("<SD_closeFile> f_close() failed\r\n");
	__POINTD1FN _0x240000,978
	CALL SUBOPT_0x0
; 0012 0107         error(res);
	MOV  R26,R16
	RCALL _error
; 0012 0108         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0036
; 0012 0109     }
; 0012 010A 
; 0012 010B     return 0;
_0x24001E:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0036:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,4
	RET
; 0012 010C }
;/*============================================================*/
;int SD_init(void)
; 0012 010F {
_SD_init:
; 0012 0110     int                 err;
; 0012 0111 
; 0012 0112     printDebug("<SD_init> Start initial memory card\r\n");
	ST   -Y,R17
	ST   -Y,R16
;	err -> R16,R17
	__POINTD1FN _0x240000,1012
	CALL SUBOPT_0x0
; 0012 0113 
; 0012 0114     /* point to the FATFS structure that holds
; 0012 0115     information for the logical drive 0: */
; 0012 0116     pfat=&fat;
	LDI  R30,LOW(_fat)
	LDI  R31,HIGH(_fat)
	STS  _pfat,R30
	STS  _pfat+1,R31
; 0012 0117 
; 0012 0118     delay_ms(1000);
	CALL SUBOPT_0x6B
; 0012 0119     printDebug("\r\n<SD_init> Mounting SD Card...");
	__POINTD1FN _0x240000,1050
	CALL SUBOPT_0x0
; 0012 011A     err = SD_mount();
	RCALL _SD_mount
	MOVW R16,R30
; 0012 011B     if(err < 0){
	TST  R17
	BRPL _0x24001F
; 0012 011C         printDebug("<SD_init> SD_mount() failed\r\n");
	__POINTD1FN _0x240000,1082
	CALL SUBOPT_0x0
; 0012 011D         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	JMP  _0x20E0034
; 0012 011E     }
; 0012 011F 
; 0012 0120 
; 0012 0121     printDebug("\r\n<SD_init> Check Card Size...");
_0x24001F:
	__POINTD1FN _0x240000,1112
	CALL SUBOPT_0x0
; 0012 0122 
; 0012 0123     delay_ms(1000);
	CALL SUBOPT_0x6B
; 0012 0124 
; 0012 0125     err = SD_readMemoryRemain(&sdFreeSpace);
	LDI  R26,LOW(_sdFreeSpace)
	LDI  R27,HIGH(_sdFreeSpace)
	RCALL _SD_readMemoryRemain
	MOVW R16,R30
; 0012 0126     if(err < 0){
	TST  R17
	BRPL _0x240020
; 0012 0127         printDebug("<SD_init> SD_readMemoryRemain() failed\r\n");
	__POINTD1FN _0x240000,1143
	CALL SUBOPT_0x0
; 0012 0128         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	JMP  _0x20E0034
; 0012 0129     }
; 0012 012A 
; 0012 012B     /* display the number of free kbytes */
; 0012 012C     printDebug("<SD_init> Free space on logical drive 0: %lu kbytes\r\n",sdFreeSpace);
_0x240020:
	__POINTD1FN _0x240000,1184
	CALL __PUTPARD1
	LDS  R30,_sdFreeSpace
	LDS  R31,_sdFreeSpace+1
	LDS  R22,_sdFreeSpace+2
	LDS  R23,_sdFreeSpace+3
	CALL SUBOPT_0x61
; 0012 012D 
; 0012 012E     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	JMP  _0x20E0034
; 0012 012F }
;/*============================================================*/
;
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "log.h"
;#include "debug.h"
;
;unsigned char LOGFILE_DATA[]            = "data.log";           // -- data log file name -- //

	.DSEG
;unsigned char LOGFILE_EVENT[]           = "event.log";          // -- event log file name -- //
;unsigned char LOGFILE_ERROR[]           = "error.log";          // -- error log file name -- //
;unsigned char LOG_INIT_STR[SIZE_RECORD] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
;/*============================================================*/
;
;/**************************************************************/
;/************** Function Pointer to memcard.h *****************/
;/**************************************************************/
;/*============================================================*/
;int (*LOG_openFile)(FIL *, unsigned char *) = &SD_openFile;
;int (*LOG_closeFile)(FIL *)                 = &SD_closeFile;
;/*============================================================*/
;
;/**************************************************************/
;/******************* Data Log Management **********************/
;/**************************************************************/
;char isDataLogEmpty     = 0;
;/*============================================================*/
;int LOG_insertData(FIL *file, unsigned long int timestamp, unsigned int channel, float value)
; 0013 001B {

	.CSEG
; 0013 001C     int                 res;
; 0013 001D     unsigned long int   index;
; 0013 001E     unsigned long int   startAddr;
; 0013 001F     unsigned char       flag;
; 0013 0020 
; 0013 0021     res             = LOG_getLastInsert(file, &index);
;	*file -> Y+22
;	timestamp -> Y+18
;	channel -> Y+16
;	value -> Y+12
;	res -> R16,R17
;	index -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 0022     if(res < 0){    printDebug("<LOG_insertData> LOG_getLastInsert() failed\r\n");      return -1;  }
; 0013 0023 
; 0013 0024     flag            = 'P';
; 0013 0025 
; 0013 0026     startAddr       = index2Addr(index,SIZE_LOG_DATA);
; 0013 0027 
; 0013 0028     res             = SD_writeData(file, startAddr+OFFSET_FLAG,         (unsigned char *) &flag,        SIZE_FLAG);
; 0013 0029     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(flag) failed\r\n");       return -1;  }
; 0013 002A 
; 0013 002B     res             = SD_writeData(file, startAddr+OFFSET_TIMESTAMP,    (unsigned char *) &timestamp,   SIZE_TIMESTAMP);
; 0013 002C     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(timestamp) failed\r\n");  return -1;  }
; 0013 002D 
; 0013 002E     res             = SD_writeData(file, startAddr+OFFSET_DATA_CHANNEL, (unsigned char *) &channel,     SIZE_CHANNEL);
; 0013 002F     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(channel) failed\r\n");    return -1;  }
; 0013 0030 
; 0013 0031     res             = SD_writeData(file, startAddr+OFFSET_DATA_VALUE,   (unsigned char *) &value,       SIZE_VALUE);
; 0013 0032     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(value) failed\r\n");      return -1;  }
; 0013 0033 
; 0013 0034     res = LOG_setLastInsert(file,++index);
; 0013 0035     if(res < 0){    printDebug("<LOG_insertData> LOG_setLastInsert(%ld) failed\r\n",index);      return -1;  }
; 0013 0036 
; 0013 0037     isDataLogEmpty  = 0;
; 0013 0038     return index;
; 0013 0039 }
;/*============================================================*/
;int LOG_readData(FIL *file, unsigned long int *timestamp, unsigned int *channel, float *value, unsigned long int *index)
; 0013 003C {
; 0013 003D     int                 res;
; 0013 003E     unsigned long int   lastLogInsert;
; 0013 003F     unsigned long int   lastLogSend;
; 0013 0040     unsigned long int   startAddr;
; 0013 0041     unsigned char       flag;
; 0013 0042 
; 0013 0043 
; 0013 0044     res             = LOG_getLastInsert(file, &lastLogInsert);
;	*file -> Y+24
;	*timestamp -> Y+22
;	*channel -> Y+20
;	*value -> Y+18
;	*index -> Y+16
;	res -> R16,R17
;	lastLogInsert -> Y+12
;	lastLogSend -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 0045     if(res < 0){    printDebug("<LOG_readData> LOG_getLastInsert() failed\r\n");        return -1;  }
; 0013 0046     res             = LOG_getLastSend(file, &lastLogSend);
; 0013 0047     if(res < 0){    printDebug("<LOG_readData> LOG_getLastSend() failed\r\n");          return -1;  }
; 0013 0048 
; 0013 0049     printDebug("<LOG_readEvent> lastSend/lastInsert  --> %ld/%ld\r\n",lastLogSend,lastLogInsert);
; 0013 004A 
; 0013 004B     if(lastLogSend >= lastLogInsert)
; 0013 004C     {
; 0013 004D         printDebug("<LOG_readData> Log empty..!!\r\n");
; 0013 004E 
; 0013 004F         res = LOG_createFile(LOGFILE_DATA,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0013 0050         if(res < 0)
; 0013 0051         {
; 0013 0052             printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_DATA);
; 0013 0053         }
; 0013 0054 
; 0013 0055         isDataLogEmpty  = 1;
; 0013 0056         return 0;
; 0013 0057     }
; 0013 0058 
; 0013 0059     startAddr       = index2Addr(lastLogSend,SIZE_LOG_DATA);
; 0013 005A 
; 0013 005B     res             = SD_readData(file, startAddr+OFFSET_FLAG,          (unsigned char *) &flag,        SIZE_FLAG);
; 0013 005C     if(res < 0){    printDebug("<LOG_readData> SD_readData(flag) failed\r\n");          return -1;  }
; 0013 005D 
; 0013 005E     res             = SD_readData(file, startAddr+OFFSET_TIMESTAMP,     (unsigned char *) timestamp,    SIZE_TIMESTAMP);
; 0013 005F     if(res < 0){    printDebug("<LOG_readData> SD_readData(timestamp) failed\r\n");     return -1;  }
; 0013 0060 
; 0013 0061     res             = SD_readData(file, startAddr+OFFSET_DATA_CHANNEL, (unsigned char *) channel,       SIZE_CHANNEL);
; 0013 0062     if(res < 0){    printDebug("<LOG_readData> SD_readData(channel) failed\r\n");       return -1;  }
; 0013 0063 
; 0013 0064     res             = SD_readData(file, startAddr+OFFSET_DATA_VALUE,    (unsigned char *) value,        SIZE_VALUE);
; 0013 0065     if(res < 0){    printDebug("<LOG_readData> SD_readData(value) failed\r\n");         return -1;  }
; 0013 0066 
; 0013 0067     *index          = lastLogSend;
; 0013 0068 
; 0013 0069     return 1;
; 0013 006A }
;/*============================================================*/
;
;/**************************************************************/
;/******************* Event Log Management *********************/
;/**************************************************************/
;char isEventLogEmpty    = 0;
;/*============================================================*/
;int LOG_insertEvent(FIL *file, unsigned long int timestamp, unsigned char id, unsigned char status)
; 0013 0073 {
; 0013 0074     int                 res;
; 0013 0075     unsigned long int   index;
; 0013 0076     unsigned long int   startAddr;
; 0013 0077     unsigned char       flag;
; 0013 0078 
; 0013 0079     res = LOG_getLastInsert(file, &index);
;	*file -> Y+18
;	timestamp -> Y+14
;	id -> Y+13
;	status -> Y+12
;	res -> R16,R17
;	index -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 007A     if(res < 0){    printDebug("<LOG_insertEvent> LOG_getLastInsert() failed\r\n");     return -1;  }
; 0013 007B 
; 0013 007C     flag            = 'P';
; 0013 007D 
; 0013 007E     startAddr       = index2Addr(index,SIZE_LOG_EVENT);
; 0013 007F 
; 0013 0080     res             = SD_writeData(file, startAddr+OFFSET_FLAG,         (unsigned char *) &flag,        SIZE_FLAG);
; 0013 0081     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(flag) failed\r\n");      return -1;  }
; 0013 0082 
; 0013 0083     res             = SD_writeData(file, startAddr+OFFSET_TIMESTAMP,    (unsigned char *) &timestamp,   SIZE_TIMESTAMP);
; 0013 0084     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(timestamp) failed\r\n"); return -1;  }
; 0013 0085 
; 0013 0086     res             = SD_writeData(file, startAddr+OFFSET_EVENT_ID,     (unsigned char *) &id,          SIZE_ID);
; 0013 0087     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(id) failed\r\n");        return -1;  }
; 0013 0088 
; 0013 0089     res             = SD_writeData(file, startAddr+OFFSET_EVENT_STATUS, (unsigned char *) &status,      SIZE_STATUS);
; 0013 008A     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(status) failed\r\n");    return -1;  }
; 0013 008B 
; 0013 008C     res = LOG_setLastInsert(file,++index);
; 0013 008D     if(res < 0){    printDebug("<LOG_insertEvent> LOG_setLastInsert(%ld) failed\r\n",index);     return -1;  }
; 0013 008E 
; 0013 008F     isEventLogEmpty = 0;
; 0013 0090 
; 0013 0091     return index;
; 0013 0092 }
;/*============================================================*/
;int LOG_readEvent(FIL *file, unsigned long int *timestamp, unsigned char *id, unsigned char *status, unsigned long int *index)
; 0013 0095 {
; 0013 0096     int                 res;
; 0013 0097     unsigned long int   lastLogInsert;
; 0013 0098     unsigned long int   lastLogSend;
; 0013 0099     unsigned long int   startAddr;
; 0013 009A     unsigned char       flag;
; 0013 009B 
; 0013 009C 
; 0013 009D     res             = LOG_getLastInsert(file, &lastLogInsert);
;	*file -> Y+24
;	*timestamp -> Y+22
;	*id -> Y+20
;	*status -> Y+18
;	*index -> Y+16
;	res -> R16,R17
;	lastLogInsert -> Y+12
;	lastLogSend -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 009E     if(res < 0){    printDebug("<LOG_readEvent> LOG_getLastInsert() failed\r\n");       return -1;  }
; 0013 009F     res             = LOG_getLastSend(file, &lastLogSend);
; 0013 00A0     if(res < 0){    printDebug("<LOG_readEvent> LOG_getLastSend() failed\r\n");         return -1;  }
; 0013 00A1 
; 0013 00A2     printDebug("<LOG_readEvent> lastSend/lastInsert  --> %ld/%ld\r\n",lastLogSend,lastLogInsert);
; 0013 00A3 
; 0013 00A4     if(lastLogSend >= lastLogInsert)
; 0013 00A5     {
; 0013 00A6         printDebug("<LOG_readEvent> Log empty..!!\r\n");
; 0013 00A7 
; 0013 00A8         res = LOG_createFile(LOGFILE_EVENT,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0013 00A9         if(res < 0)
; 0013 00AA         {
; 0013 00AB             printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_EVENT);
; 0013 00AC         }
; 0013 00AD 
; 0013 00AE         isEventLogEmpty     = 1;
; 0013 00AF         return 0;
; 0013 00B0     }
; 0013 00B1 
; 0013 00B2     startAddr       = index2Addr(lastLogSend,SIZE_LOG_EVENT);
; 0013 00B3 
; 0013 00B4     res             = SD_readData(file, startAddr+OFFSET_FLAG,          (unsigned char *) &flag,        SIZE_FLAG);
; 0013 00B5     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(flag) failed\r\n");         return -1;  }
; 0013 00B6 
; 0013 00B7     res             = SD_readData(file, startAddr+OFFSET_TIMESTAMP,     (unsigned char *) timestamp,    SIZE_TIMESTAMP);
; 0013 00B8     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(timestamp) failed\r\n");    return -1;  }
; 0013 00B9 
; 0013 00BA     res             = SD_readData(file, startAddr+OFFSET_EVENT_ID,      (unsigned char *) id,           SIZE_ID);
; 0013 00BB     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(id) failed\r\n");           return -1;  }
; 0013 00BC 
; 0013 00BD     res             = SD_readData(file, startAddr+OFFSET_EVENT_STATUS,  (unsigned char *) status,       SIZE_STATUS);
; 0013 00BE     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(status) failed\r\n");       return -1;  }
; 0013 00BF 
; 0013 00C0     *index  = lastLogSend;
; 0013 00C1     return 1;
; 0013 00C2 }
;/*============================================================*/
;
;/**************************************************************/
;/******************* Log Indexing Function ********************/
;/**************************************************************/
;/*============================================================*/
;int LOG_getLastInsert(FIL *file, unsigned long int *index)
; 0013 00CA {
; 0013 00CB     int             res;
; 0013 00CC 
; 0013 00CD     res = SD_readData(file, 0, (unsigned char *) index, sizeof(unsigned long int));
;	*file -> Y+4
;	*index -> Y+2
;	res -> R16,R17
; 0013 00CE     if(res < 0)
; 0013 00CF     {
; 0013 00D0         printDebug("<LOG_getLastInsert> SD_readData() failed\r\n");
; 0013 00D1         return -1;
; 0013 00D2     }
; 0013 00D3 
; 0013 00D4     printDebug("<LOG_getLastInsert> got %ld\r\n", *index);
; 0013 00D5 
; 0013 00D6     return 0;
; 0013 00D7 }
;/*============================================================*/
;int LOG_setLastInsert(FIL *file, unsigned long int index)
; 0013 00DA {
; 0013 00DB     int             res;
; 0013 00DC 
; 0013 00DD     printDebug("<LOG_setLastInsert> writing %ld\r\n", index);
;	*file -> Y+6
;	index -> Y+2
;	res -> R16,R17
; 0013 00DE     print_payload((unsigned char *) &index, sizeof(unsigned long int));
; 0013 00DF 
; 0013 00E0     res = SD_writeData(file, 0, (unsigned char *) &index, sizeof(unsigned long int));
; 0013 00E1     if(res < 0)
; 0013 00E2     {
; 0013 00E3         printDebug("<LOG_setLastInsert> SD_readData() failed\r\n");
; 0013 00E4         return -1;
; 0013 00E5     }
; 0013 00E6 
; 0013 00E7     return 0;
; 0013 00E8 }
;/*============================================================*/
;int LOG_getLastSend(FIL *file, unsigned long int *index)
; 0013 00EB {
; 0013 00EC     int             res;
; 0013 00ED 
; 0013 00EE     res = SD_readData(file, 4, (unsigned char *) index, sizeof(unsigned long int));
;	*file -> Y+4
;	*index -> Y+2
;	res -> R16,R17
; 0013 00EF     if(res < 0)
; 0013 00F0     {
; 0013 00F1         printDebug("<LOG_getLastSend> SD_readData() failed\r\n");
; 0013 00F2         return -1;
; 0013 00F3     }
; 0013 00F4 
; 0013 00F5     printDebug("<LOG_getLastSend> got %ld\r\n", *index);
; 0013 00F6 
; 0013 00F7     return 0;
; 0013 00F8 }
;/*============================================================*/
;int LOG_setLastSend(FIL *file, unsigned long int index)
; 0013 00FB {
; 0013 00FC     int             res;
; 0013 00FD 
; 0013 00FE     printDebug("<LOG_setLastSend> writing %ld\r\n", index);
;	*file -> Y+6
;	index -> Y+2
;	res -> R16,R17
; 0013 00FF     print_payload((unsigned char *) &index, sizeof(unsigned long int));
; 0013 0100 
; 0013 0101     res = SD_writeData(file, 4, (unsigned char *) &index, sizeof(unsigned long int));
; 0013 0102     if(res < 0)
; 0013 0103     {
; 0013 0104         printDebug("<LOG_setLastSend> SD_readData() failed\r\n");
; 0013 0105         return -1;
; 0013 0106     }
; 0013 0107 
; 0013 0108     return 0;
; 0013 0109 }
;/*============================================================*/
;
;/**************************************************************/
;/********************* Support Function ***********************/
;/**************************************************************/
;/*============================================================*/
;unsigned long int index2Addr(unsigned long int index,int recordSize)
; 0013 0111 {
; 0013 0112     unsigned long int address=0;
; 0013 0113 
; 0013 0114     address = ( index * recordSize ) + SIZE_LAST_LOG_INDEX + SIZE_LAST_LOG_SENT + SIZE_PADDING;
;	index -> Y+6
;	recordSize -> Y+4
;	address -> Y+0
; 0013 0115 
; 0013 0116     return address;
; 0013 0117 }
;/*============================================================*/
;int LOG_createFile(unsigned char *filename, unsigned char mode, unsigned char *initString, unsigned int len)
; 0013 011A {
; 0013 011B     FIL         file;
; 0013 011C     int         res;
; 0013 011D 
; 0013 011E     res = SD_createFile(filename,mode);
;	*filename -> Y+551
;	mode -> Y+550
;	*initString -> Y+548
;	len -> Y+546
;	file -> Y+2
;	res -> R16,R17
; 0013 011F     if(res < 0){
; 0013 0120         printDebug("<LOG_createFile> SD_createFile(%s) failed\r\n",filename);
; 0013 0121         return -1;
; 0013 0122     }
; 0013 0123     else if(res == 0)
; 0013 0124     {
; 0013 0125         printDebug("<LOG_createFile> %s already exist\r\n", filename);
; 0013 0126         return 0;
; 0013 0127     }
; 0013 0128     else
; 0013 0129     {
; 0013 012A         printDebug("<LOG_createFile> %s created\r\n", filename);
; 0013 012B         if(len == 0) // -- no initial data -- //
; 0013 012C         {
; 0013 012D             printDebug("<LOG_createFile> %s contained no initial data\r\n");
; 0013 012E             return 1;
; 0013 012F         }
; 0013 0130 
; 0013 0131         // -- write the file initial data -- //
; 0013 0132         res = SD_openFile(&file,filename);
; 0013 0133         if(res < 0)
; 0013 0134         {
; 0013 0135             printDebug("<LOG_createFile> SD_openFile(%s) failed\r\n",filename);
; 0013 0136             return -1;
; 0013 0137         }
; 0013 0138         else
; 0013 0139         {
; 0013 013A             printDebug("<LOG_createFile> writing initial data\r\n");
; 0013 013B             print_payload(initString,len);
; 0013 013C             res = SD_writeData(&file,0,initString,len);
; 0013 013D             if(res < 0)
; 0013 013E             {
; 0013 013F                 printDebug("<LOG_createFile> SD_writeData() failed Writing.. \r\n");
; 0013 0140                 print_payload(initString,len);
; 0013 0141                 return -1;
; 0013 0142             }
; 0013 0143 
; 0013 0144             res = SD_closeFile(&file);
; 0013 0145             if(res < 0)
; 0013 0146             {
; 0013 0147                 printDebug("<LOG_createFile> SD_closeFile() failed\r\n");
; 0013 0148                 return -1;
; 0013 0149             }
; 0013 014A         }
; 0013 014B     }
; 0013 014C 
; 0013 014D 
; 0013 014E     return 1;
; 0013 014F }
;/*============================================================*/
;int LOG_init(void)
; 0013 0152 {
; 0013 0153     int         res,ret = 0;
; 0013 0154 
; 0013 0155     printDebug("<LOG_init> Initial log file\r\n");
;	res -> R16,R17
;	ret -> R18,R19
; 0013 0156 
; 0013 0157 
; 0013 0158     res = LOG_createFile(LOGFILE_DATA,0,LOG_INIT_STR,sizeof(LOG_INIT_STR));
; 0013 0159     if(res < 0)
; 0013 015A     {
; 0013 015B         printDebug("<LOG_init> LOG_createFile(%s) failed\r\n",LOGFILE_DATA);
; 0013 015C         ret = ret-1;
; 0013 015D     }
; 0013 015E 
; 0013 015F     res = LOG_createFile(LOGFILE_EVENT,0,LOG_INIT_STR,sizeof(LOG_INIT_STR));
; 0013 0160     if(res < 0)
; 0013 0161     {
; 0013 0162         printDebug("<LOG_init> LOG_createFile(%s) failed\r\n",LOGFILE_EVENT);
; 0013 0163         ret = ret-1;
; 0013 0164     }
; 0013 0165 
; 0013 0166     res = LOG_createFile(LOGFILE_ERROR,0,NULL,0);
; 0013 0167     if(res < 0)
; 0013 0168     {
; 0013 0169         printDebug("<LOG_init> LOG_createFile(%s) failed\r\n",LOGFILE_ERROR);
; 0013 016A         ret = ret-1;
; 0013 016B     }
; 0013 016C 
; 0013 016D     return ret;
; 0013 016E }
;/*============================================================*/
;
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "logqueue.h"
;#include "debug.h"
;
;struct event_log_st     eventLogQueue[MAX_EVENT_QUEUE];
;char                    eventLogQCount  = 0;
;
;struct data_log_st      dataLogQueue[MAX_DATA_QUEUE];
;char                    dataLogQCount   = 0;
;/*============================================================*/
;/* Data Log Queue */
;/*============================================================*/
;int addDataLogQueue(unsigned char id, unsigned long int timestamp, unsigned int channel, float value)
; 0014 0010 {

	.CSEG
; 0014 0011     int slot;
; 0014 0012 
; 0014 0013     slot = findFreeSlotDataLogQueue();
;	id -> Y+12
;	timestamp -> Y+8
;	channel -> Y+6
;	value -> Y+2
;	slot -> R16,R17
; 0014 0014     if(slot < 0)
; 0014 0015     {
; 0014 0016         printDebug("\r\n\r\n<addDataLogQueue> WARNING : dataLogQueue FULL\r\n\r\n");
; 0014 0017         return -1;
; 0014 0018     }
; 0014 0019 
; 0014 001A     dataLogQueue[slot].id                    = id;
; 0014 001B     dataLogQueue[slot].data.timestamp        = timestamp;
; 0014 001C     dataLogQueue[slot].data.channel          = channel;
; 0014 001D     dataLogQueue[slot].data.value            = value;
; 0014 001E 
; 0014 001F     dataLogQCount++;
; 0014 0020     printDebug("\r\n<addDataLogQueue>                           Added (%02X) to dataLogQueue[%d] Count = %d\r\n",id,slot,dataLogQCount);
; 0014 0021     return dataLogQCount;
; 0014 0022 }
;/*============================================================*/
;int readDataLogQueue(unsigned char id, unsigned long int *timestamp, unsigned int *channel, float *value)
; 0014 0025 {
; 0014 0026     int i;
; 0014 0027 
; 0014 0028     if(dataLogQCount == 0){
;	id -> Y+8
;	*timestamp -> Y+6
;	*channel -> Y+4
;	*value -> Y+2
;	i -> R16,R17
; 0014 0029         printDebug("<readDataLogQueue> WARN: dataLogQueue empty!!\r\n");
; 0014 002A         return -1;
; 0014 002B     }
; 0014 002C 
; 0014 002D     for(i=0;i<MAX_DATA_QUEUE;i++)
; 0014 002E     {
; 0014 002F         if(id == dataLogQueue[i].id)                       // -- scan id in dataLogQueue
; 0014 0030         {
; 0014 0031             *timestamp      =   dataLogQueue[i].data.timestamp;
; 0014 0032             *channel        =   dataLogQueue[i].data.channel;
; 0014 0033             *value          =   dataLogQueue[i].data.value;
; 0014 0034 
; 0014 0035             return i;
; 0014 0036         }
; 0014 0037     }
; 0014 0038 
; 0014 0039     printDebug("<readDataLogQueue> WARN: not found id[0x%02X] in dataLogQueue\r\n", id);
; 0014 003A     return -1;
; 0014 003B }
;/*============================================================*/
;int removeDataLogQueue(unsigned char id)
; 0014 003E {
; 0014 003F     char i;
; 0014 0040     for(i=0;i<MAX_DATA_QUEUE;i++)
;	id -> Y+1
;	i -> R17
; 0014 0041     {
; 0014 0042         if(id == dataLogQueue[i].id)                       // -- scan id in dataLogQueue
; 0014 0043         {
; 0014 0044             dataLogQueue[i].id                  = 0x00;
; 0014 0045             dataLogQueue[i].data.timestamp      = 0;
; 0014 0046             dataLogQueue[i].data.channel        = 0;
; 0014 0047             dataLogQueue[i].data.value          = 0;
; 0014 0048             dataLogQCount--;
; 0014 0049 
; 0014 004A             printDebug("\r\n<removeDataLogQueue>                        Removed (%02X) from dataLogQueue[%d]\r\n", id, i);
; 0014 004B             return dataLogQCount;
; 0014 004C         }
; 0014 004D     }
; 0014 004E     printDebug("<removeDataLogQueue> WARN: not found id[0x%02X] in dataLogQueue\r\n", id);
; 0014 004F     return -1;
; 0014 0050 }
;/*============================================================*/
;char findFreeSlotDataLogQueue(void)
; 0014 0053 {
; 0014 0054     char i;
; 0014 0055     for(i=0;i<MAX_DATA_QUEUE;i++){
;	i -> R17
; 0014 0056         if(dataLogQueue[i].id == 0x00){
; 0014 0057             return i;
; 0014 0058         }
; 0014 0059     }
; 0014 005A     return -1;
; 0014 005B }
;/*============================================================*/
;void initDataLogQueue(void)
; 0014 005E {
; 0014 005F     char i;
; 0014 0060 
; 0014 0061     for(i=0;i<MAX_DATA_QUEUE;i++){
;	i -> R17
; 0014 0062         dataLogQueue[i].id                  = 0x00;
; 0014 0063         dataLogQueue[i].data.timestamp      = 0;
; 0014 0064         dataLogQueue[i].data.channel        = 0;
; 0014 0065         dataLogQueue[i].data.value          = 0;
; 0014 0066     }
; 0014 0067     return;
; 0014 0068 }
;/*============================================================*/
;
;/*============================================================*/
;/* Event Log Queue */
;/*============================================================*/
;int addEventLogQueue(unsigned char id, unsigned long int timestamp, unsigned char eventID, unsigned char eventStatus)
; 0014 006F {
; 0014 0070     int slot;
; 0014 0071 
; 0014 0072     slot = findFreeSlotEventLogQueue();
;	id -> Y+8
;	timestamp -> Y+4
;	eventID -> Y+3
;	eventStatus -> Y+2
;	slot -> R16,R17
; 0014 0073     if(slot < 0)
; 0014 0074     {
; 0014 0075         printDebug("\r\n\r\n<addEventLogQueue> WARNING : eventLogQueue FULL\r\n\r\n");
; 0014 0076         return -1;
; 0014 0077     }
; 0014 0078 
; 0014 0079     eventLogQueue[slot].id                  = id;
; 0014 007A     eventLogQueue[slot].event.timestamp     = timestamp;
; 0014 007B     eventLogQueue[slot].event.eventID       = eventID;
; 0014 007C     eventLogQueue[slot].event.eventStatus   = eventStatus;
; 0014 007D 
; 0014 007E     eventLogQCount++;
; 0014 007F     printDebug("\r\n<addEventLogQueue>                         Added (%02X) to eventLogQueue[%d] Count = %d\r\n",id,slot,eventLogQCount);
; 0014 0080     return eventLogQCount;
; 0014 0081 }
;/*============================================================*/
;int readEventLogQueue(unsigned char id, unsigned long int *timestamp, unsigned char *eventID, unsigned char *eventStatus)
; 0014 0084 {
; 0014 0085     int i;
; 0014 0086 
; 0014 0087     if(eventLogQCount == 0){
;	id -> Y+8
;	*timestamp -> Y+6
;	*eventID -> Y+4
;	*eventStatus -> Y+2
;	i -> R16,R17
; 0014 0088         printDebug("<readEventLogQueue> WARN: eventLogQueue empty!!\r\n");
; 0014 0089         return -1;
; 0014 008A     }
; 0014 008B 
; 0014 008C     for(i=0;i<MAX_EVENT_QUEUE;i++)
; 0014 008D     {
; 0014 008E         if(id == eventLogQueue[i].id)                       // -- scan id in eventLogQueue
; 0014 008F         {
; 0014 0090             *timestamp      =   eventLogQueue[i].event.timestamp;
; 0014 0091             *eventID        =   eventLogQueue[i].event.eventID;
; 0014 0092             *eventStatus    =   eventLogQueue[i].event.eventStatus;
; 0014 0093 
; 0014 0094             return i;
; 0014 0095         }
; 0014 0096     }
; 0014 0097 
; 0014 0098     printDebug("<readEventLogQueue> WARN: not found id[0x%02X] in eventLogQueue\r\n", id);
; 0014 0099     return -1;
; 0014 009A }
;/*============================================================*/
;int removeEventLogQueue(unsigned char id)
; 0014 009D {
; 0014 009E     char i;
; 0014 009F     for(i=0;i<MAX_EVENT_QUEUE;i++)
;	id -> Y+1
;	i -> R17
; 0014 00A0     {
; 0014 00A1         if(id == eventLogQueue[i].id)                       // -- scan id in eventLogQueue
; 0014 00A2         {
; 0014 00A3             eventLogQueue[i].id                  = 0x00;
; 0014 00A4             eventLogQueue[i].event.timestamp     = 0;
; 0014 00A5             eventLogQueue[i].event.eventID       = 0;
; 0014 00A6             eventLogQueue[i].event.eventStatus   = 0;
; 0014 00A7             eventLogQCount--;
; 0014 00A8 
; 0014 00A9             printDebug("\r\n<removeEventLogQueue>                      Removed (%02X) from eventLogQueue[%d]\r\n", id, i);
; 0014 00AA             return eventLogQCount;
; 0014 00AB         }
; 0014 00AC     }
; 0014 00AD     printDebug("<removeEventLogQueue> WARN: not found id[0x%02X] in eventLogQueue\r\n", id);
; 0014 00AE     return -1;
; 0014 00AF }
;/*============================================================*/
;char findFreeSlotEventLogQueue(void)
; 0014 00B2 {
; 0014 00B3     char i;
; 0014 00B4     for(i=0;i<MAX_EVENT_QUEUE;i++){
;	i -> R17
; 0014 00B5         if(eventLogQueue[i].id == 0x00){
; 0014 00B6             return i;
; 0014 00B7         }
; 0014 00B8     }
; 0014 00B9     return -1;
; 0014 00BA }
;/*============================================================*/
;void initEventLogQueue(void)
; 0014 00BD {
; 0014 00BE     char i;
; 0014 00BF 
; 0014 00C0     for(i=0;i<MAX_EVENT_QUEUE;i++){
;	i -> R17
; 0014 00C1         eventLogQueue[i].id                  = 0x00;
; 0014 00C2         eventLogQueue[i].event.timestamp     = 0;
; 0014 00C3         eventLogQueue[i].event.eventID       = 0;
; 0014 00C4         eventLogQueue[i].event.eventStatus   = 0;
; 0014 00C5     }
; 0014 00C6     return;
; 0014 00C7 }
;/*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include <stdarg.h>
;#include <delay.h>
;#include <ctype.h>
;#include "debug.h"
;#include "adc.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "ds1672.h"
;#include "alarm.h"
;#include "log.h"
;#include "io.h"
;#include "ethcomm.h"
;#include "calibration.h"
;#include "sensor.h"
;//sensorGetValue(u int)
;extern ST_CAL_CONFIG sensorCalConfig;
;extern eeprom  ST_CAL sensorCalulate;          //improtance    extern from  calibration.h
;extern void (*pfCalibrate) (ST_CAL_CONFIG calConfig);   //pointer function of calibation set  extern from  calibration.h
;
;flash unsigned char cmdSetRTCDateTime[]     = "$CMDSDT";        // -- Set Date/Time -- //
;flash unsigned char cmdResetAlarmStatus[]   = "$CMDRAS";        // -- Re-initiate all alarm flag -- //
;flash unsigned char cmdClearLogFile[]       = "$CMDCLF";        // -- Re-initiate log file -- //
;flash unsigned char cmdSetVref[]            = "$CMDSVR";        // -- Set Vref measure from multimeter -- //
;flash unsigned char cmdSensorSelect[]       = "$CMDSNS";        // -- Select Sensor for Hardware Calibration [Disable mode require] -- //
;flash unsigned char cmdDeviceEnable[]       = "$CMDDEN";        // -- Enable Device -- //
;flash unsigned char cmdDeviceDisable[]      = "$CMDDDS";        // -- Disable Device -- //
;flash unsigned char cmdSetSerialNumber[]    = "$CMDSSN";        // -- Set Serial Number -- //
;flash unsigned char cmdReadSerialNumber[]   = "$CMDRSN";        // -- Read Serial Number -- //
;
;flash unsigned char cmdGetCal[]             = "$CMDGCL";         // -- Get calibrate value -- //      $CMDRCL,1#        ,chID(1)
;flash unsigned char cmdSetCal[]             = "$CMDSCL";         // -- Set calibrate value -- //      $CMDSCL,1,1,29.20     ,chID(1),pointID(1),std1Value(29.20)#
;flash unsigned char cmdConfirmCal[]         = "$CMDCCL";         // -- Confirm calibrate type -- //   ,chID(1),calType(1) 0:defualt-1:offset-2:linear-3:polynomail
;flash unsigned char cmdGetCurSensor[]       = "$CMDGCS";         // -- Get current sensor value -- //   ,chID(1)
;/*============================================================*/
;
;unsigned int hwCalId    = 9;

	.DSEG
;
;/**************************************************************/
;/************* Service Debug Command Function *****************/
;/**************************************************************/
;/*============================================================*/
;int debugGetCurSensor(){
; 0015 002B int debugGetCurSensor(){

	.CSEG
; 0015 002C     unsigned char i=0;
; 0015 002D     unsigned char buffer[2];
; 0015 002E     unsigned int channelID;
; 0015 002F 
; 0015 0030     printDebug("\r\n<Debug>GetCurSensor: \r\n");
;	i -> R17
;	buffer -> Y+4
;	channelID -> R18,R19
; 0015 0031     memset(buffer,0,sizeof(buffer));
; 0015 0032     for(i=0;i<1;i++){
; 0015 0033        buffer[i] = rxPackage3[i+8];
; 0015 0034     }
; 0015 0035     channelID = atoi(buffer);
; 0015 0036     printDebug("Channel ID:%d \r\n",channelID);
; 0015 0037     printDebug("\r\n");
; 0015 0038 
; 0015 0039     if( channelID>0 && channelID<6 ){           //max 5 ch
; 0015 003A        printDebug("current sensor ch[%d] , value:%0.2f\r\n",channelID,sensorGetValue(channelID));
; 0015 003B     }else{
; 0015 003C         printDebug("Channel ID is in range.\r\n");
; 0015 003D     }
; 0015 003E 
; 0015 003F     return 0;
; 0015 0040 }
;int debugGetCal(){
; 0015 0041 int debugGetCal(){
; 0015 0042     unsigned char i=0;
; 0015 0043     unsigned char buffer[4];
; 0015 0044     unsigned int channelID;
; 0015 0045 
; 0015 0046     printDebug("\r\n<Debug>GetCal: \r\n");
;	i -> R17
;	buffer -> Y+4
;	channelID -> R18,R19
; 0015 0047     memset(buffer,0,sizeof(buffer));
; 0015 0048     for(i=0;i<1;i++){
; 0015 0049        buffer[i] = rxPackage3[i+8];
; 0015 004A     }
; 0015 004B     channelID = atoi(buffer);
; 0015 004C     printDebug("Channel ID:%d \r\n",channelID);
; 0015 004D     printDebug("\r\n");
; 0015 004E 
; 0015 004F     if( channelID>0 && channelID<6 ){           //max 5 ch
; 0015 0050        for(i=0;i<3;i++){
; 0015 0051            printDebug("stdRef[%d] : %0.2f , ",i+1,sensorCalulate.sChennel[channelID-1].stdRef[i]);
; 0015 0052            printDebug("sensorRef[%d] : %0.2f\r\n",i+1,sensorCalulate.sChennel[channelID-1].sensorRef[i]);
; 0015 0053        }
; 0015 0054        switch(sensorCalulate.sChennel[channelID-1].calType){
; 0015 0055             case CAL_DEFAULT:{               //0
; 0015 0056                 printDebug("CalType : CAL_DEFAULT");
; 0015 0057                 break;
; 0015 0058             }
; 0015 0059             case CAL_EXTOFFSET:{             //1
; 0015 005A                 printDebug("CalType : CAL_EXTOFFSET");
; 0015 005B                 break;
; 0015 005C             }
; 0015 005D             case CAL_EXTLINEAR:{             //2
; 0015 005E                 printDebug("CalType : CAL_EXTLINEAR");
; 0015 005F                 break;
; 0015 0060             }
; 0015 0061             case CAL_EXTPOLYNOMIAL:{         //3
; 0015 0062                 printDebug("CalType : CAL_EXTPOLYNOMIAL");
; 0015 0063                 break;
; 0015 0064             }
; 0015 0065        }
; 0015 0066        printDebug("\r\n");
; 0015 0067     }else{
; 0015 0068         printDebug("Channel ID is in range.\r\n");
; 0015 0069     }
; 0015 006A 
; 0015 006B     return 0;
; 0015 006C }
;int debugSetCal(){
; 0015 006D int debugSetCal(){
; 0015 006E     unsigned char i=0;
; 0015 006F     unsigned char buffer[6];
; 0015 0070     unsigned int channelID;
; 0015 0071     unsigned int pointID;
; 0015 0072     float pointValue;         //std value
; 0015 0073 
; 0015 0074     //void (*pfnCalibrate) (ST_CAL_CONFIG calConfig);
; 0015 0075 
; 0015 0076     pfCalibrate = &calSet;
;	i -> R17
;	buffer -> Y+10
;	channelID -> R18,R19
;	pointID -> R20,R21
;	pointValue -> Y+6
; 0015 0077 
; 0015 0078     printDebug("\r\n<Debug>SetCal: \r\n");
; 0015 0079     memset(buffer,0,sizeof(buffer));
; 0015 007A     for(i=0;i<1;i++){
; 0015 007B        buffer[i] = rxPackage3[i+8];
; 0015 007C     }
; 0015 007D     channelID = atoi(buffer);
; 0015 007E     sensorCalConfig.channelID =  channelID;
; 0015 007F     printDebug("Channel ID:%d \r\n",channelID);
; 0015 0080 
; 0015 0081     memset(buffer,0,sizeof(buffer));
; 0015 0082     for(i=0;i<1;i++){
; 0015 0083        buffer[i] = rxPackage3[i+10];
; 0015 0084     }
; 0015 0085     pointID = atoi(buffer);
; 0015 0086     sensorCalConfig.pointID =  pointID;
; 0015 0087     printDebug("Point ID:%d \r\n",pointID);
; 0015 0088 
; 0015 0089     memset(buffer,0,sizeof(buffer));
; 0015 008A     for(i=0;i<5;i++){
; 0015 008B        buffer[i] = rxPackage3[i+12];
; 0015 008C     }
; 0015 008D     pointValue = atof(buffer);
; 0015 008E     sensorCalConfig.pointValue =  pointValue;     //std value for meter
; 0015 008F     printDebug("pointValue(meterRef) :%0.2f \r\n",pointValue);
; 0015 0090     printDebug("\r\n");
; 0015 0091 
; 0015 0092     pfCalibrate(sensorCalConfig);
; 0015 0093 
; 0015 0094     return 0;
; 0015 0095 }
;int debugConfirmCal(){
; 0015 0096 int debugConfirmCal(){
; 0015 0097     unsigned char i=0;
; 0015 0098     unsigned char buffer[6];
; 0015 0099     unsigned int channelID;
; 0015 009A     unsigned int calType;
; 0015 009B 
; 0015 009C     pfCalibrate = &calSetConfirm;
;	i -> R17
;	buffer -> Y+6
;	channelID -> R18,R19
;	calType -> R20,R21
; 0015 009D 
; 0015 009E     printDebug("\r\n<Debug>ConfirmCal: \r\n");
; 0015 009F     memset(buffer,0,sizeof(buffer));
; 0015 00A0     for(i=0;i<1;i++){
; 0015 00A1        buffer[i] = rxPackage3[i+8];
; 0015 00A2     }
; 0015 00A3     channelID = atoi(buffer);
; 0015 00A4     sensorCalConfig.channelID =  channelID;
; 0015 00A5     printDebug("Channel ID:%d \r\n",channelID);
; 0015 00A6 
; 0015 00A7     memset(buffer,0,sizeof(buffer));
; 0015 00A8     for(i=0;i<1;i++){
; 0015 00A9        buffer[i] = rxPackage3[i+10];
; 0015 00AA     }
; 0015 00AB     calType = atoi(buffer);
; 0015 00AC     sensorCalConfig.calType =  calType;
; 0015 00AD     //printDebug("calType :%d \r\n",calType);
; 0015 00AE     switch(sensorCalConfig.calType){
; 0015 00AF         case CAL_DEFAULT:{               //0
; 0015 00B0             printDebug("CalType : CAL_DEFAULT");
; 0015 00B1             break;
; 0015 00B2         }
; 0015 00B3         case CAL_EXTOFFSET:{             //2
; 0015 00B4             printDebug("CalType : CAL_EXTOFFSET");
; 0015 00B5             break;
; 0015 00B6         }
; 0015 00B7         case CAL_EXTLINEAR:{             //3
; 0015 00B8             printDebug("CalType : CAL_EXTLINEAR");
; 0015 00B9             break;
; 0015 00BA         }
; 0015 00BB         case CAL_EXTPOLYNOMIAL:{         //4
; 0015 00BC             printDebug("CalType : CAL_EXTPOLYNOMIAL");
; 0015 00BD             break;
; 0015 00BE         }
; 0015 00BF     }
; 0015 00C0     printDebug("\r\n");
; 0015 00C1 
; 0015 00C2     pfCalibrate(sensorCalConfig);
; 0015 00C3 
; 0015 00C4     return 0;
; 0015 00C5 }
;
;int DEBUG_setDateTime(void)
; 0015 00C8 {
; 0015 00C9     unsigned char   i;
; 0015 00CA     unsigned char   buffer[32];
; 0015 00CB     int             tz;
; 0015 00CC 
; 0015 00CD     struct rtc_structure rtcSet;
; 0015 00CE 
; 0015 00CF     for(i=0;i<4;i++)
;	i -> R17
;	buffer -> Y+30
;	tz -> R18,R19
;	rtcSet -> Y+4
; 0015 00D0     {
; 0015 00D1         buffer[i] = rxPackage3[i+8];
; 0015 00D2     }
; 0015 00D3     buffer[4] = 0;
; 0015 00D4 
; 0015 00D5     rtcSet.year = atol(buffer);
; 0015 00D6 
; 0015 00D7     printDebug("get year = %d\r\n",rtcSet.year);
; 0015 00D8 
; 0015 00D9     for(i=0;i<2;i++)
; 0015 00DA     {
; 0015 00DB         buffer[i] = rxPackage3[i+13];
; 0015 00DC     }
; 0015 00DD     buffer[2] = 0;
; 0015 00DE 
; 0015 00DF     rtcSet.month = atol(buffer);
; 0015 00E0 
; 0015 00E1     printDebug("get month = %d\r\n",rtcSet.month);
; 0015 00E2 
; 0015 00E3     for(i=0;i<2;i++)
; 0015 00E4     {
; 0015 00E5         buffer[i] = rxPackage3[i+16];
; 0015 00E6     }
; 0015 00E7     buffer[2] = 0;
; 0015 00E8 
; 0015 00E9     rtcSet.date = atol(buffer);
; 0015 00EA 
; 0015 00EB     printDebug("get date = %d\r\n",rtcSet.date);
; 0015 00EC 
; 0015 00ED     for(i=0;i<2;i++)
; 0015 00EE     {
; 0015 00EF         buffer[i] = rxPackage3[i+19];
; 0015 00F0     }
; 0015 00F1     buffer[2] = 0;
; 0015 00F2 
; 0015 00F3     rtcSet.hour = atol(buffer);
; 0015 00F4 
; 0015 00F5     printDebug("get hour = %d\r\n",rtcSet.hour);
; 0015 00F6 
; 0015 00F7     for(i=0;i<2;i++)
; 0015 00F8     {
; 0015 00F9         buffer[i] = rxPackage3[i+22];
; 0015 00FA     }
; 0015 00FB     buffer[2] = 0;
; 0015 00FC 
; 0015 00FD     rtcSet.min = atol(buffer);
; 0015 00FE 
; 0015 00FF     printDebug("get min = %d\r\n",rtcSet.min);
; 0015 0100 
; 0015 0101     for(i=0;i<2;i++)
; 0015 0102     {
; 0015 0103         buffer[i] = rxPackage3[i+25];
; 0015 0104     }
; 0015 0105     buffer[2] = 0;
; 0015 0106 
; 0015 0107     rtcSet.sec = atol(buffer);
; 0015 0108 
; 0015 0109     printDebug("get sec = %d\r\n",rtcSet.sec);
; 0015 010A 
; 0015 010B     for(i=0;i<3;i++)
; 0015 010C     {
; 0015 010D         buffer[i] = rxPackage3[i+28];
; 0015 010E     }
; 0015 010F     buffer[4] = 0;
; 0015 0110 
; 0015 0111     tz = atol(buffer);
; 0015 0112 
; 0015 0113     printDebug("get timezone = %+d\r\n",tz);
; 0015 0114 
; 0015 0115     RTC_setDateTime(rtcSet,tz);
; 0015 0116 
; 0015 0117     return 0;
; 0015 0118 }
;/*============================================================*/
;void DEBUG_resetAlarm(void)
; 0015 011B {
; 0015 011C //    resetAlarm();
; 0015 011D 
; 0015 011E     printDebug("\r\n<DEBUG> Alarm Status Reset..!!\r\n");
; 0015 011F }
;/*============================================================*/
;void DEBUG_ClearLogFile(void)
; 0015 0122 {
; 0015 0123     int         res;
; 0015 0124 
; 0015 0125     printDebug("<DEBUG_ClearLogFile> Re-initiate log file\r\n");
;	res -> R16,R17
; 0015 0126 
; 0015 0127     res = LOG_createFile(LOGFILE_DATA,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0015 0128     if(res < 0)
; 0015 0129     {
; 0015 012A         printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_DATA);
; 0015 012B     }
; 0015 012C 
; 0015 012D     res = LOG_createFile(LOGFILE_EVENT,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0015 012E     if(res < 0)
; 0015 012F     {
; 0015 0130         printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_EVENT);
; 0015 0131     }
; 0015 0132 
; 0015 0133     res = LOG_createFile(LOGFILE_ERROR,1,NULL,0);
; 0015 0134     if(res < 0)
; 0015 0135     {
; 0015 0136         printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_ERROR);
; 0015 0137     }
; 0015 0138 
; 0015 0139     return;
; 0015 013A }
;/*============================================================*/
;void DEBUG_setRealVref(void)
; 0015 013D {
; 0015 013E     unsigned char i;
; 0015 013F     unsigned char rxStrSetVREF[6];
; 0015 0140 
; 0015 0141     for(i=0;i<=5;i++)
;	i -> R17
;	rxStrSetVREF -> Y+1
; 0015 0142     {
; 0015 0143         rxStrSetVREF[i] = rxPackage3[i+8];
; 0015 0144     }
; 0015 0145     rxStrSetVREF[5] = '\0';
; 0015 0146     printDebug("<DEBUG_setRealVref> get set Vref<string> %s\r\n",rxStrSetVREF);
; 0015 0147     eep_vref_val = (atof(rxStrSetVREF));
; 0015 0148     printDebug("<DEBUG_setRealVref> After convert = %f\r\n",eep_vref_val);
; 0015 0149 }
;/*============================================================*/
;void DEBUG_sensorSelect(void)
; 0015 014C {
; 0015 014D     unsigned char ch[2];
; 0015 014E 
; 0015 014F     if(TEMP_SEL != TEMP_TYPE_K){
;	ch -> Y+0
; 0015 0150         printDebug("<DEBUG_sensorSelect> This TEMP_SEL not support\r\n\r\n");
; 0015 0151         return;
; 0015 0152     }
; 0015 0153 
; 0015 0154     if(rxPackage3[8] == 'N'){
; 0015 0155         hwCalId     = 9;
; 0015 0156         printDebug("<DEBUG_sensorSelect> Deselect sensor\r\n\r\n");
; 0015 0157     }
; 0015 0158     else if(isdigit(rxPackage3[8])){
; 0015 0159         ch[0]       = rxPackage3[8];
; 0015 015A         ch[1]       = '\0';
; 0015 015B         hwCalId     = atoi(ch);
; 0015 015C 
; 0015 015D         SENSOR_SELECT(hwCalId);
; 0015 015E         delay_ms(50);           // -- for multiplex stable -- //
; 0015 015F 
; 0015 0160         printDebug("<DEBUG_sensorSelect> Selected sensor %d\r\n\r\n",hwCalId);
; 0015 0161     }
; 0015 0162     else{
; 0015 0163         hwCalId     = 9;
; 0015 0164         printDebug("<DEBUG_sensorSelect> ERROR : Selecting sensor [%c][0x%02X]\r\n\r\n",rxPackage3[8],rxPackage3[8]);
; 0015 0165     }
; 0015 0166 
; 0015 0167     return;
; 0015 0168 }
;/*============================================================*/
;void DEBUG_setDeviceEnable(char flag)
; 0015 016B {
; 0015 016C //    if(flag){
; 0015 016D //        config_oper.deviceEnable        =   0x01;
; 0015 016E //    }
; 0015 016F //    else{
; 0015 0170 //        config_oper.deviceEnable        =   0x00;
; 0015 0171 //    }
; 0015 0172 //
; 0015 0173 //    config_oper_flag                    =   0x01;
; 0015 0174 //    is_operating_config_update          =   1;
; 0015 0175 //
; 0015 0176 //    return;
; 0015 0177 }
;/*============================================================*/
;void DEBUG_setSerialNumber(void)
; 0015 017A {
; 0015 017B     // -- assume input is "$CMDSSN,01,02,03,04,05,06,07,08#" -- //
; 0015 017C     unsigned char i;
; 0015 017D     unsigned char set_str[24];
; 0015 017E 
; 0015 017F     for(i=0;i<24;i++){
;	i -> R17
;	set_str -> Y+1
; 0015 0180         if( ( rxPackage3[i+7] != ',') && !isxdigit(rxPackage3[i+7])){
; 0015 0181             printDebug("<DEBUG_setSerialNumber> invalid setting string (%c)[0x%02]\r\n",rxPackage3[i+7],rxPackage3[i+7]);
; 0015 0182             return;
; 0015 0183         }
; 0015 0184         set_str[i] = tolower(rxPackage3[i+7]);           // -- copy only ",01,02,03,04,05,06,07,08" -- //
; 0015 0185     }
; 0015 0186 
; 0015 0187     printDebug("<DEBUG_setSerialNumber> Replacing DEVICE_SERIAL..\r\n");
; 0015 0188 
; 0015 0189     printDebug("<DEBUG_setSerialNumber> Set String --> ");
; 0015 018A     for(i=0;i<24;i++){
; 0015 018B         if((i%3) == 0)      {   continue;                       }
; 0015 018C         else if((i%3) == 1) {
; 0015 018D 
; 0015 018E             printDebug("[%c",set_str[i]);
; 0015 018F 
; 0015 0190             DEVICE_SERIAL[i/3]      = 0x00;
; 0015 0191 
; 0015 0192             if(isdigit(set_str[i])){
; 0015 0193                 DEVICE_SERIAL[i/3]  = (set_str[i] - 48) << 4;
; 0015 0194             }
; 0015 0195             else{
; 0015 0196                 DEVICE_SERIAL[i/3]  = (set_str[i] - 87) << 4;
; 0015 0197             }
; 0015 0198         }
; 0015 0199         else if((i%3) == 2) {
; 0015 019A 
; 0015 019B             printDebug("%c]",set_str[i]);
; 0015 019C 
; 0015 019D             if(isdigit(set_str[i])){
; 0015 019E                 DEVICE_SERIAL[i/3]  |= (set_str[i] - 48);
; 0015 019F             }
; 0015 01A0             else{
; 0015 01A1                 DEVICE_SERIAL[i/3]  |= (set_str[i] - 87);
; 0015 01A2             }
; 0015 01A3         }
; 0015 01A4     }
; 0015 01A5 
; 0015 01A6     printDebug("<DEBUG_setSerialNumber> Success!! DEV_SERIAL ==> ");
; 0015 01A7     for(i=0;i<8;i++){
; 0015 01A8         printDebug("[%02X]",DEVICE_SERIAL[i]);
; 0015 01A9     }
; 0015 01AA     printDebug("\r\n");
; 0015 01AB 
; 0015 01AC     return;
; 0015 01AD }
;/*============================================================*/
;void DEBUG_readSerialNumber(void)
; 0015 01B0 {
; 0015 01B1     unsigned char i;
; 0015 01B2 
; 0015 01B3     printDebug("<DEBUG_readSerialNumber> DEV_SERIAL ==> ");
;	i -> R17
; 0015 01B4     for(i=0;i<8;i++){
; 0015 01B5         printDebug("[%02X]",DEVICE_SERIAL[i]);
; 0015 01B6     }
; 0015 01B7     printDebug("\r\n");
; 0015 01B8 
; 0015 01B9     return;
; 0015 01BA }
;/*============================================================*/
;
;/**************************************************************/
;/****************** Debug Support Function ********************/
;/**************************************************************/
;/*============================================================*/
;void debug_req(void)
; 0015 01C2 {
; 0015 01C3     flag_PackageTerminate3 = 0;
; 0015 01C4 
; 0015 01C5     printDebug("Get Debug Req.:");
; 0015 01C6 
; 0015 01C7 
; 0015 01C8     if(!strncmpf(rxPackage3,cmdSetRTCDateTime,7)){
; 0015 01C9         DEBUG_setDateTime();
; 0015 01CA     }
; 0015 01CB     else if(!strncmpf(rxPackage3,cmdResetAlarmStatus,7)){
; 0015 01CC         DEBUG_resetAlarm();
; 0015 01CD     }
; 0015 01CE     else if(!strncmpf(rxPackage3,cmdClearLogFile,7)){
; 0015 01CF         DEBUG_ClearLogFile();
; 0015 01D0     }
; 0015 01D1     else if(!strncmpf(rxPackage3,cmdSetVref,7)){
; 0015 01D2         DEBUG_setRealVref();
; 0015 01D3     }
; 0015 01D4     else if(!strncmpf(rxPackage3,cmdSensorSelect,7)){
; 0015 01D5         DEBUG_sensorSelect();
; 0015 01D6     }
; 0015 01D7     else if(!strncmpf(rxPackage3,cmdDeviceEnable,7)){
; 0015 01D8         DEBUG_setDeviceEnable(1);
; 0015 01D9     }
; 0015 01DA     else if(!strncmpf(rxPackage3,cmdDeviceDisable,7)){
; 0015 01DB         DEBUG_setDeviceEnable(0);
; 0015 01DC     }
; 0015 01DD     else if(!strncmpf(rxPackage3,cmdSetSerialNumber,7)){
; 0015 01DE         DEBUG_setSerialNumber();
; 0015 01DF     }
; 0015 01E0     else if(!strncmpf(rxPackage3,cmdReadSerialNumber,7)){
; 0015 01E1         DEBUG_readSerialNumber();
; 0015 01E2     }else if(!strncmpf(rxPackage3,cmdGetCal,7)){
; 0015 01E3         debugGetCal();
; 0015 01E4     }else if(!strncmpf(rxPackage3,cmdSetCal,7)){
; 0015 01E5         debugSetCal();
; 0015 01E6     }else if(!strncmpf(rxPackage3,cmdConfirmCal,7)){
; 0015 01E7         debugConfirmCal();
; 0015 01E8     }else if(!strncmpf(rxPackage3,cmdGetCurSensor,7)){
; 0015 01E9         debugGetCurSensor();
; 0015 01EA     }
; 0015 01EB     return;
; 0015 01EC }
;/*============================================================*/
;void printDebug(flash char *fmtstr, ...)
; 0015 01EF {
_printDebug:
	PUSH R15
	MOV  R15,R24
; 0015 01F0     char textBuffer[256];
; 0015 01F1     va_list argptr;
; 0015 01F2 
; 0015 01F3     va_start(argptr, fmtstr);
	SUBI R29,1
	ST   -Y,R17
	ST   -Y,R16
;	*fmtstr -> Y+258
;	textBuffer -> Y+2
;	*argptr -> R16,R17
	MOVW R26,R28
	SUBI R26,LOW(-(254))
	SBCI R27,HIGH(-(254))
	CALL __ADDW2R15
	MOVW R16,R26
; 0015 01F4     vsprintf(textBuffer,fmtstr,argptr);
	CALL SUBOPT_0x69
	MOVW R26,R28
	SUBI R26,LOW(-(260))
	SBCI R27,HIGH(-(260))
	CALL SUBOPT_0x6C
	MOVW R26,R16
	CALL _vsprintf
; 0015 01F5     send_uart(3,textBuffer);
	LDI  R30,LOW(3)
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,3
	CALL _send_uart
; 0015 01F6     va_end(argptr);
; 0015 01F7 
; 0015 01F8     return;
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,2
	SUBI R29,-1
	POP  R15
	RET
; 0015 01F9 }
;/*============================================================*/
;void print_hex_ascii_line(const unsigned char *payload, int len, int offset)
; 0015 01FC {
_print_hex_ascii_line:
; 0015 01FD 
; 0015 01FE     int i;
; 0015 01FF     int gap;
; 0015 0200     const unsigned char *ch;
; 0015 0201 
; 0015 0202     // offset //
; 0015 0203     printDebug("%05d   ", offset);
	CALL SUBOPT_0x6D
;	*payload -> Y+10
;	len -> Y+8
;	offset -> Y+6
;	i -> R16,R17
;	gap -> R18,R19
;	*ch -> R20,R21
	__POINTD1FN _0x2A0000,1166
	CALL SUBOPT_0x6E
	CALL SUBOPT_0x6F
; 0015 0204 
; 0015 0205 
; 0015 0206     // hex //
; 0015 0207     ch = payload;
	__GETWRS 20,21,10
; 0015 0208     for(i = 0; i < len; i++) {
	__GETWRN 16,17,0
_0x2A0084:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CP   R16,R30
	CPC  R17,R31
	BRGE _0x2A0085
; 0015 0209         printDebug("%02x ", *ch);
	__POINTD1FN _0x2A0000,1174
	CALL SUBOPT_0x70
; 0015 020A 
; 0015 020B         ch++;
	__ADDWRN 20,21,1
; 0015 020C         // print extra space after 8th byte for visual aid //
; 0015 020D         if (i == 7){
	LDI  R30,LOW(7)
	LDI  R31,HIGH(7)
	CP   R30,R16
	CPC  R31,R17
	BRNE _0x2A0086
; 0015 020E             printDebug(" ");
	CALL SUBOPT_0x71
; 0015 020F 
; 0015 0210         }
; 0015 0211     }
_0x2A0086:
	__ADDWRN 16,17,1
	RJMP _0x2A0084
_0x2A0085:
; 0015 0212     // print space to handle line less than 8 bytes //
; 0015 0213     if (len < 8){
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,8
	BRGE _0x2A0087
; 0015 0214         printDebug(" ");
	CALL SUBOPT_0x71
; 0015 0215 
; 0015 0216     }
; 0015 0217 
; 0015 0218     // fill hex gap with spaces if not full line //
; 0015 0219     if (len < 16) {
_0x2A0087:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,16
	BRGE _0x2A0088
; 0015 021A         gap = 16 - len;
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(16)
	LDI  R31,HIGH(16)
	SUB  R30,R26
	SBC  R31,R27
	MOVW R18,R30
; 0015 021B         for (i = 0; i < gap; i++) {
	__GETWRN 16,17,0
_0x2A008A:
	__CPWRR 16,17,18,19
	BRGE _0x2A008B
; 0015 021C             printDebug("   ");
	CALL SUBOPT_0x72
; 0015 021D 
; 0015 021E         }
	__ADDWRN 16,17,1
	RJMP _0x2A008A
_0x2A008B:
; 0015 021F     }
; 0015 0220     printDebug("   ");
_0x2A0088:
	CALL SUBOPT_0x72
; 0015 0221 
; 0015 0222 
; 0015 0223     // ascii (if printable) //
; 0015 0224     ch = payload;
	__GETWRS 20,21,10
; 0015 0225     for(i = 0; i < len; i++) {
	__GETWRN 16,17,0
_0x2A008D:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CP   R16,R30
	CPC  R17,R31
	BRGE _0x2A008E
; 0015 0226         if (isprint(*ch)){
	MOVW R26,R20
	LD   R26,X
	CALL _isprint
	CPI  R30,0
	BREQ _0x2A008F
; 0015 0227             printDebug("%c", *ch);
	__POINTD1FN _0x2A0000,1045
	CALL SUBOPT_0x70
; 0015 0228 
; 0015 0229         }
; 0015 022A         else{
	RJMP _0x2A0090
_0x2A008F:
; 0015 022B             printDebug(".");
	__POINTD1FN _0x2A0000,1180
	CALL SUBOPT_0x0
; 0015 022C 
; 0015 022D         }
_0x2A0090:
; 0015 022E         ch++;
	__ADDWRN 20,21,1
; 0015 022F     }
	__ADDWRN 16,17,1
	RJMP _0x2A008D
_0x2A008E:
; 0015 0230 
; 0015 0231     printDebug("\r\n");
	__POINTD1FN _0x2A0000,23
	CALL SUBOPT_0x0
; 0015 0232 
; 0015 0233 
; 0015 0234 return;
	CALL __LOADLOCR6
	ADIW R28,12
	RET
; 0015 0235 }
;/*============================================================*/
;void print_payload(const unsigned char *payload, int len)
; 0015 0238 {
_print_payload:
; 0015 0239 
; 0015 023A     int len_rem = len;
; 0015 023B     int line_width = 16;            // number of bytes per line //
; 0015 023C     int line_len;
; 0015 023D     int offset = 0;                    // zero-based offset counter //
; 0015 023E     const unsigned char *ch = payload;
; 0015 023F 
; 0015 0240     if (len <= 0)
	CALL SUBOPT_0x73
	STD  Y+2,R30
	LDI  R30,LOW(0)
	STD  Y+3,R30
	CALL __SAVELOCR6
;	*payload -> Y+12
;	len -> Y+10
;	len_rem -> R16,R17
;	line_width -> R18,R19
;	line_len -> R20,R21
;	offset -> Y+8
;	*ch -> Y+6
	__GETWRS 16,17,10
	__GETWRN 18,19,16
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL __CPW02
	BRGE _0x20E0035
; 0015 0241         return;
; 0015 0242 
; 0015 0243     // data fits on one line //
; 0015 0244     if (len <= line_width) {
	CP   R18,R26
	CPC  R19,R27
	BRLT _0x2A0092
; 0015 0245         print_hex_ascii_line(ch, len, offset);
	CALL SUBOPT_0x74
	CALL SUBOPT_0x75
	CALL SUBOPT_0x76
; 0015 0246         return;
	RJMP _0x20E0035
; 0015 0247     }
; 0015 0248     // data spans multiple lines //
; 0015 0249     for ( ;; ) {
_0x2A0092:
_0x2A0094:
; 0015 024A         // compute current line length //
; 0015 024B         line_len = line_width % len_rem;
	MOVW R30,R16
	MOVW R26,R18
	CALL __MODW21
	MOVW R20,R30
; 0015 024C         // print line //
; 0015 024D         print_hex_ascii_line(ch, line_len, offset);
	CALL SUBOPT_0x74
	ST   -Y,R21
	ST   -Y,R20
	CALL SUBOPT_0x76
; 0015 024E         // compute total remaining //
; 0015 024F         len_rem = len_rem - line_len;
	__SUBWRR 16,17,20,21
; 0015 0250         // shift pointer to remaining bytes to print //
; 0015 0251         ch = ch + line_len;
	MOVW R30,R20
	CALL SUBOPT_0x77
	STD  Y+6,R30
	STD  Y+6+1,R31
; 0015 0252         // add offset //
; 0015 0253         offset = offset + line_width;
	MOVW R30,R18
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADD  R30,R26
	ADC  R31,R27
	STD  Y+8,R30
	STD  Y+8+1,R31
; 0015 0254         // check if we have line width chars or less //
; 0015 0255         if (len_rem <= line_width) {
	__CPWRR 18,19,16,17
	BRLT _0x2A0096
; 0015 0256             // print last line and get out //
; 0015 0257             print_hex_ascii_line(ch, len_rem, offset);
	CALL SUBOPT_0x74
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x76
; 0015 0258             break;
	RJMP _0x2A0095
; 0015 0259         }
; 0015 025A     }
_0x2A0096:
	RJMP _0x2A0094
_0x2A0095:
; 0015 025B 
; 0015 025C     return;
_0x20E0035:
	CALL __LOADLOCR6
	ADIW R28,14
	RET
; 0015 025D }
;/*============================================================*/
;void debugConfWiz100sr(){
; 0015 025F void debugConfWiz100sr(){
; 0015 0260 
; 0015 0261 }
;#include <stdlib.h>
;#include "debug.h"
;
;// -- for polynomial interpolation by gaussian elimination -- //
;int n = 3;

	.DSEG
;float a[3][4];
;
;/*============================================================*/
;void forwardSubstitution()
; 0016 000A {

	.CSEG
; 0016 000B     int i, j, k, max;
; 0016 000C     float t;
; 0016 000D     for (i = 0; i < n; ++i) {
;	i -> R16,R17
;	j -> R18,R19
;	k -> R20,R21
;	max -> Y+10
;	t -> Y+6
; 0016 000E 
; 0016 000F         max = i;
; 0016 0010         for (j = i + 1; j < n; ++j)
; 0016 0011             if (a[j][i] > a[max][i])
; 0016 0012                 max = j;
; 0016 0013 
; 0016 0014         for (j = 0; j < n + 1; ++j) {
; 0016 0015             t = a[max][j];
; 0016 0016             a[max][j] = a[i][j];
; 0016 0017             a[i][j] = t;
; 0016 0018         }
; 0016 0019 
; 0016 001A         /*
; 0016 001B         printDebug("\r\n-- fw_sub_swap(%d) --\r\n",i);
; 0016 001C         for (k = 0; k < n; ++k) {
; 0016 001D             printDebug("\t\t\t");
; 0016 001E             for (j = 0; j < n + 1; ++j)
; 0016 001F                 printDebug("%.2f\t", a[k][j]);
; 0016 0020             printDebug("\r\n");
; 0016 0021         }
; 0016 0022         printDebug("\r\n");
; 0016 0023         */
; 0016 0024 
; 0016 0025         //printDebug("\r\n-- fw_sub_calculate(%d) --\r\n",i);
; 0016 0026         for (j = n; j >= i; --j){
; 0016 0027             for (k = i + 1; k < n; ++k){
; 0016 0028                 a[k][j] -= a[k][i]/a[i][i] * a[i][j];
; 0016 0029                 //printDebug("\t\t\t\t\t\t%f (%f/%f * %f)\r\n",a[k][j],a[k][i],a[i][i],a[i][j]);
; 0016 002A             }
; 0016 002B         }
; 0016 002C         //printDebug("\r\n");
; 0016 002D 
; 0016 002E 
; 0016 002F         /*
; 0016 0030         printDebug("\r\n-- fw_sub_res(%d) --\r\n",i);
; 0016 0031         for (k = 0; k < n; ++k) {
; 0016 0032             printDebug("\t\t");
; 0016 0033             for (j = 0; j < n + 1; ++j)
; 0016 0034                 printDebug("%.2f\t", a[k][j]);
; 0016 0035             printDebug("\r\n");
; 0016 0036         }
; 0016 0037         printDebug("\r\n");
; 0016 0038         */
; 0016 0039     }
; 0016 003A }
;
;void reverseElimination()
; 0016 003D {
; 0016 003E     int i, j, k;
; 0016 003F     for (i = n - 1; i >= 0; --i) {
;	i -> R16,R17
;	j -> R18,R19
;	k -> R20,R21
; 0016 0040         a[i][n] = a[i][n] / a[i][i];
; 0016 0041         a[i][i] = 1;
; 0016 0042         for (j = i - 1; j >= 0; --j) {
; 0016 0043             a[j][n] -= a[j][i] * a[i][n];
; 0016 0044             a[j][i] = 0;
; 0016 0045         }
; 0016 0046 
; 0016 0047         /*
; 0016 0048         printDebug("\r\n-- rev_Eli(%d) --\r\n",i);
; 0016 0049         for (k = 0; k < n; ++k) {
; 0016 004A             printDebug("\t\t");
; 0016 004B             for (j = 0; j < n + 1; ++j)
; 0016 004C                 printDebug("%.2f\t", a[k][j]);
; 0016 004D             printDebug("\r\n");
; 0016 004E         }
; 0016 004F         printDebug("\r\n");
; 0016 0050         */
; 0016 0051     }
; 0016 0052 }
;
;void gaussian(float factor1, float factor2, float factor3, float ref1, float ref2, float ref3, float *resA, float *resB, float *resC)
; 0016 0055 {
; 0016 0056     int i, j;
; 0016 0057 
; 0016 0058     // -- form matrix -- //
; 0016 0059     a[0][0] = 1.0;      a[0][1] = factor1;     a[0][2] = factor1 * factor1;  a[0][3] = ref1;
;	factor1 -> Y+30
;	factor2 -> Y+26
;	factor3 -> Y+22
;	ref1 -> Y+18
;	ref2 -> Y+14
;	ref3 -> Y+10
;	*resA -> Y+8
;	*resB -> Y+6
;	*resC -> Y+4
;	i -> R16,R17
;	j -> R18,R19
; 0016 005A     a[1][0] = 1.0;      a[1][1] = factor2;     a[1][2] = factor2 * factor2;  a[1][3] = ref2;
; 0016 005B     a[2][0] = 1.0;      a[2][1] = factor3;     a[2][2] = factor3 * factor3;  a[2][3] = ref3;
; 0016 005C 
; 0016 005D 
; 0016 005E //    printDebug("\r\n<gaussian> --- start ---\r\n");
; 0016 005F //    for (i = 0; i < n; ++i) {
; 0016 0060 //        printDebug("\t\t");
; 0016 0061 //        for (j = 0; j < n + 1; ++j)
; 0016 0062 //            printDebug("%.2f\t", a[i][j]);
; 0016 0063 //        printDebug("\r\n");
; 0016 0064 //    }
; 0016 0065 
; 0016 0066     forwardSubstitution();
; 0016 0067     reverseElimination();
; 0016 0068 
; 0016 0069 //    printDebug("\r\n<gaussian> --- finish ---\r\n");
; 0016 006A //    for (i = 0; i < n; ++i) {
; 0016 006B //        printDebug("\t\t");
; 0016 006C //        for (j = 0; j < n + 1; ++j)
; 0016 006D //            printDebug("%.2f\t", a[i][j]);
; 0016 006E //        printDebug("\r\n");
; 0016 006F //    }
; 0016 0070 
; 0016 0071     *resA = a[2][3];
; 0016 0072     *resB = a[1][3];
; 0016 0073     *resC = a[0][3];
; 0016 0074 
; 0016 0075    // printDebug("\r\n<gaussian> y = %f(x^2) + %f(x) + %f\r\n",*resA,*resB,*resC);
; 0016 0076 
; 0016 0077     return;
; 0016 0078 }
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <delay.h>
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "dht11.h"
;#include "timer.h"
;#include "debug.h"
;
;/**
;*
;//Brif use timer5
;**/
;void MCUSignalOut(int status){
; 0017 000E void MCUSignalOut(int status){

	.CSEG
; 0017 000F //    DDRL.0  = 1;   //set output
; 0017 0010     char tempRegister = 0;
; 0017 0011     DDRJ |= 0x04;    //oboooo o10o
;	status -> Y+1
;	tempRegister -> R17
; 0017 0012     if(status==1){
; 0017 0013        PORTJ |= 0x04; //0b0000 0100
; 0017 0014     }else{
; 0017 0015         PORTJ &= 0xFB;//0b1111 1011
; 0017 0016     }
; 0017 0017 }
;int DHT11SignalIn(){
; 0017 0018 int DHT11SignalIn(){
; 0017 0019 //    DDRL.0   = 0;   //set input
; 0017 001A //    return DHT11_TO_MCU_PIN;
; 0017 001B     DDRJ &= 0xFB;
; 0017 001C     if((PINJ & 0x04)==0x04){
; 0017 001D        return 0x01;
; 0017 001E     }else{
; 0017 001F        return 0x00;
; 0017 0020     }
; 0017 0021 
; 0017 0022 }
;int DHT11Read(ST_DHT11 *dhtDevice){
; 0017 0023 int DHT11Read(ST_DHT11 *dhtDevice){
; 0017 0024     int i, j, temp;
; 0017 0025     int buffer = 0;
; 0017 0026     int count = 0;
; 0017 0027 	int data[5] = {0x00, 0x00, 0x00, 0x00, 0x00};
; 0017 0028 
; 0017 0029     /*start condition*/
; 0017 002A     dhtDevice->status = DHT11_ERROR_TIMEOUT;
;	*dhtDevice -> Y+20
;	i -> R16,R17
;	j -> R18,R19
;	temp -> R20,R21
;	buffer -> Y+18
;	count -> Y+16
;	data -> Y+6
; 0017 002B //    MCUSignalOut(MCU_SIGNAL_LOW);
; 0017 002C //    delay_ms(10);
; 0017 002D     MCUSignalOut(MCU_SIGNAL_HIGH);
; 0017 002E     delay_ms(4);
; 0017 002F 
; 0017 0030 //    TCCR5A=0x00;
; 0017 0031 //    TCCR5B=0x05;     //count = 128 microsec , 128 * 7812 = about 1sec
; 0017 0032 //
; 0017 0033 //    TCNT5H=0x00;     //timer count clearing
; 0017 0034 //    TCNT5L=0x00;
; 0017 0035 
; 0017 0036     MCUSignalOut(MCU_SIGNAL_LOW);
; 0017 0037     //while((TCNT5H <<8 | TCNT5L)<160);           //about 20 ms
; 0017 0038     delay_ms(20);
; 0017 0039 
; 0017 003A     /*set clk/8
; 0017 003B     *clk@8Mhz/prescaling 8
; 0017 003C     *get count every 1 us
; 0017 003D     */
; 0017 003E //    TCCR5A=0x00;
; 0017 003F //    TCCR5B=0x02;     //count = 1 microsec
; 0017 0040 //
; 0017 0041 //    TCNT5H=0x00;     //timer count clearing
; 0017 0042 //    TCNT5L=0x00;
; 0017 0043 
; 0017 0044     MCUSignalOut(MCU_SIGNAL_HIGH);
; 0017 0045     delay_us(40);
; 0017 0046     /*end start condition*/
; 0017 0047    // printDebug("DHT11: end Condition \r\n");
; 0017 0048 
; 0017 0049     TCCR5A=0x00;
; 0017 004A     TCCR5B=0x02;     //count = 1 microsec
; 0017 004B     TCNT5H=0x00;     //timer count clearing
; 0017 004C     TCNT5L=0x00;
; 0017 004D     while(DHT11SignalIn()==0){
; 0017 004E         if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us      //if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us
; 0017 004F             dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0050            return DHT11_ERROR_TIMEOUT;
; 0017 0051         }
; 0017 0052     }
; 0017 0053 
; 0017 0054     TCNT5H=0x00;     //timer count clearing
; 0017 0055     TCNT5L=0x00;
; 0017 0056     while(DHT11SignalIn()==1){
; 0017 0057         if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us        //if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us
; 0017 0058             dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0059            return DHT11_ERROR_TIMEOUT;
; 0017 005A         }
; 0017 005B     }
; 0017 005C 
; 0017 005D     //Read 40 bits (8*5)
; 0017 005E 	for(j = 0; j < 5; ++j) {
; 0017 005F 		for(i = 0; i < 8; ++i) {
; 0017 0060 
; 0017 0061 			//LOW for 50us
; 0017 0062 			TCNT5H=0x00;     //timer count clearing
; 0017 0063             TCNT5L=0x00;
; 0017 0064             while(DHT11SignalIn()==0){
; 0017 0065                 if((TCNT5H <<8 | TCNT5L)>70){       //about 50 us            //if((TCNT5H <<8 | TCNT5L)>70){
; 0017 0066                     dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0067                    return DHT11_ERROR_TIMEOUT;
; 0017 0068                 }
; 0017 0069             }
; 0017 006A 
; 0017 006B 			//Start counter
; 0017 006C 			//buffer = 0;
; 0017 006D 			//HIGH for 26-28us = 0 / 70us = 1
; 0017 006E 
; 0017 006F 			TCNT5H=0x00;     //timer count clearing
; 0017 0070             TCNT5L=0x00;
; 0017 0071             while(DHT11SignalIn()==1){
; 0017 0072                 count = (TCNT5H <<8 | TCNT5L);
; 0017 0073                 if(count>90){       //about 70 us                //if(count>90){
; 0017 0074                     dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0075                    return DHT11_ERROR_TIMEOUT;
; 0017 0076                 }
; 0017 0077 
; 0017 0078             }
; 0017 0079 
; 0017 007A //            if(count > 40){
; 0017 007B //               buffer = 1;
; 0017 007C //            }
; 0017 007D 			//Calc amount of time passed
; 0017 007E 			temp = count;
; 0017 007F 
; 0017 0080 			//shift 0
; 0017 0081 			data[j] = data[j] << 1;
; 0017 0082 
; 0017 0083 			//if > 30us it's 1
; 0017 0084 			if(temp > 40)
; 0017 0085 				data[j] = data[j]+1;
; 0017 0086 		}
; 0017 0087 	}
; 0017 0088 
; 0017 0089     //MCUSignalOut(MCU_SIGNAL_HIGH);
; 0017 008A 
; 0017 008B     //verify the Checksum
; 0017 008C 	if(data[4] != (data[0] + data[2])){
; 0017 008D         dhtDevice->status = DHT11_ERROR_CHECKSUM;
; 0017 008E         return DHT11_ERROR_CHECKSUM;
; 0017 008F     }
; 0017 0090 
; 0017 0091 
; 0017 0092 
; 0017 0093     dhtDevice->temp = (float)data[2];
; 0017 0094     dhtDevice->humi = (float)data[0];
; 0017 0095     dhtDevice->status = DHT11_SUCCESS;
; 0017 0096     return DHT11_SUCCESS;
; 0017 0097 }
;#include <stdlib.h>
;#include <string.h>
;#include <stdio.h>
;#include <delay.h>
;#include "calibration.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "timer.h"
;#include "gaussian.h"
;#include "debug.h"
;//#include "sensor.h"
;
;//typedef struct{
;//   ST_CAL_CHANNEL sChennel[5];
;//}ST_CAL;
;//
;
;ST_CAL_CONFIG sensorCalConfig;
;eeprom  ST_CAL sensorCalulate = {
;  {
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0}
;  }
;};          //improtance
;
;//eeprom float calOffset = 0.0;
;
;void (*pfCalibrate) (ST_CAL_CONFIG calConfig);   //pointer function of calibation set
;
;
;/**
;**@fn name   calGet
;**@header   name        type            des
;**@param    channelID   unsigned int    channel of sensor = 5(max)
;**@return   none        void
;**/
;void calGet(ST_CAL_CONFIG calConfig){
; 0018 0026 void calGet(ST_CAL_CONFIG calConfig){

	.CSEG
; 0018 0027     unsigned int i=0;
; 0018 0028     unsigned int offsetMember       = 1;     //use 1 point
; 0018 0029     unsigned int linearMember       = 2;     //use 2 point
; 0018 002A     unsigned int polynomailMember   = 3;     //use 3 point
; 0018 002B     if(calConfig.prop=CAL_GET){
;	calConfig -> Y+8
;	i -> R16,R17
;	offsetMember -> R18,R19
;	linearMember -> R20,R21
;	polynomailMember -> Y+6
; 0018 002C         printDebug("<Cal Std ref>ch[%d],formatType:%0.2f\r\n",calConfig.channelID,calConfig.calType);
; 0018 002D         switch(calConfig.calType){
; 0018 002E             case CAL_EXTOFFSET :{
; 0018 002F                 for(i=0;i<offsetMember;i++){
; 0018 0030                    printDebug("stdRef:%0.2f,sensorRef:%0.2f\r\n",sensorCalulate.sChennel[calConfig.channelID-1].stdRef[i],sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[i]);
; 0018 0031                 }
; 0018 0032                 break;
; 0018 0033             }
; 0018 0034             case CAL_EXTLINEAR :{
; 0018 0035                 for(i=0;i<linearMember;i++){
; 0018 0036                    printDebug("stdRef:%0.2f,sensorRef:%0.2f\r\n",sensorCalulate.sChennel[calConfig.channelID-1].stdRef[i],sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[i]);
; 0018 0037                 }
; 0018 0038                 break;
; 0018 0039             }
; 0018 003A             case CAL_EXTPOLYNOMIAL :{
; 0018 003B                 for(i=0;i<polynomailMember;i++){
; 0018 003C                    printDebug("stdRef:%0.2f,sensorRef:%0.2f\r\n",sensorCalulate.sChennel[calConfig.channelID-1].stdRef[i],sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[i]);
; 0018 003D                 }
; 0018 003E                 break;
; 0018 003F             }
; 0018 0040             defualt:{
; 0018 0041                 break;
; 0018 0042             }
; 0018 0043         }
; 0018 0044     }else{
; 0018 0045        printDebug("<calibration>Cal properties:set can not get value.");
; 0018 0046     }
; 0018 0047 }
;void calSet(ST_CAL_CONFIG calConfig){
; 0018 0048 void calSet(ST_CAL_CONFIG calConfig){
; 0018 0049     if(calConfig.prop=CAL_SET){
;	calConfig -> Y+0
; 0018 004A         sensorCalulate.sChennel[calConfig.channelID-1].stdRef[calConfig.pointID-1] =  calConfig.pointValue;
; 0018 004B         sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[calConfig.pointID-1] = adcData[calConfig.channelID-1];
; 0018 004C     }else{
; 0018 004D        printDebug("<calibration>Cal properties:get can not set value.");
; 0018 004E     }
; 0018 004F }
;void calSetConfirm(ST_CAL_CONFIG calConfig){
; 0018 0050 void calSetConfirm(ST_CAL_CONFIG calConfig){
; 0018 0051     if(calConfig.prop=CAL_SET){
;	calConfig -> Y+0
; 0018 0052         printDebug("<Cal Std ref>ch[%d],formatType:%d\r\n",calConfig.channelID,calConfig.calType);
; 0018 0053         switch(calConfig.calType){
; 0018 0054             case CAL_EXTOFFSET :{
; 0018 0055                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_EXTOFFSET;
; 0018 0056                 break;
; 0018 0057             }
; 0018 0058             case CAL_EXTLINEAR :{
; 0018 0059                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_EXTLINEAR;
; 0018 005A                 break;
; 0018 005B             }
; 0018 005C             case CAL_EXTPOLYNOMIAL :{
; 0018 005D                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_EXTPOLYNOMIAL;
; 0018 005E                 break;
; 0018 005F             }
; 0018 0060             case CAL_DEFAULT:{
; 0018 0061                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_DEFAULT;
; 0018 0062                 break;
; 0018 0063             }
; 0018 0064         }
; 0018 0065     }else{
; 0018 0066        printDebug("<calibration>Cal properties:get can not set value.");
; 0018 0067     }
; 0018 0068 }
;void calSetClearPoint(ST_CAL_CONFIG calConfig){
; 0018 0069 void calSetClearPoint(ST_CAL_CONFIG calConfig){
; 0018 006A    if(calConfig.prop=CAL_SET){
;	calConfig -> Y+0
; 0018 006B       sensorCalulate.sChennel[calConfig.channelID-1].stdRef[calConfig.pointID] =  0;
; 0018 006C       sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[calConfig.pointID] = 0;
; 0018 006D    }else{
; 0018 006E       printDebug("<calibration>Cal properties:get can not set value.");
; 0018 006F    }
; 0018 0070 }
;
;float calProcessValue(float sensorValue,unsigned int channelID){
; 0018 0072 float calProcessValue(float sensorValue,unsigned int channelID){
; 0018 0073     float offset = 0.0;
; 0018 0074     float sensorRef1 = 0.0,sensorRef2 = 0.0,sensorRef3 = 0.0;
; 0018 0075     float stdMeter1 = 0.0,stdMeter2 = 0.0,stdMeter3 = 0.0;        //standrad  meter
; 0018 0076     float lowRange = 0.0;
; 0018 0077     float stdMeterRange = 0.0;
; 0018 0078     float factorA = 0.0,factorB = 0.0,factorC = 0.0;
; 0018 0079 
; 0018 007A     switch(sensorCalulate.sChennel[channelID-1].calType){
;	sensorValue -> Y+50
;	channelID -> Y+48
;	offset -> Y+44
;	sensorRef1 -> Y+40
;	sensorRef2 -> Y+36
;	sensorRef3 -> Y+32
;	stdMeter1 -> Y+28
;	stdMeter2 -> Y+24
;	stdMeter3 -> Y+20
;	lowRange -> Y+16
;	stdMeterRange -> Y+12
;	factorA -> Y+8
;	factorB -> Y+4
;	factorC -> Y+0
; 0018 007B         case CAL_EXTOFFSET :{
; 0018 007C             offset =  sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT1] - sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT1];
; 0018 007D             sensorValue += offset;
; 0018 007E             break;
; 0018 007F         }
; 0018 0080         case CAL_EXTLINEAR :{
; 0018 0081             //sensorValue = (((H28-$B$28)*$E$28)/$F$28)+$A$28;
; 0018 0082             sensorRef1 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT1];
; 0018 0083             sensorRef2 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT2];
; 0018 0084             stdMeter1  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT1];
; 0018 0085             stdMeter2  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT2];
; 0018 0086             lowRange   =  sensorRef2 - sensorRef1;
; 0018 0087             stdMeterRange = stdMeter2 - stdMeter1;
; 0018 0088             sensorValue = (((sensorValue-sensorRef1)*stdMeterRange)/lowRange)+stdMeter1;
; 0018 0089             break;
; 0018 008A         }
; 0018 008B         case CAL_EXTPOLYNOMIAL :{
; 0018 008C             sensorRef1 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT1];
; 0018 008D             sensorRef2 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT2];
; 0018 008E             sensorRef3 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT3];
; 0018 008F             stdMeter1  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT1];
; 0018 0090             stdMeter2  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT2];
; 0018 0091             stdMeter3  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT3];
; 0018 0092 
; 0018 0093             gaussian(sensorRef1,  sensorRef2,  sensorRef3, stdMeter1, stdMeter2, stdMeter3, &factorA, &factorB, &factorC);
; 0018 0094             sensorValue = (factorA*sensorValue*sensorValue) + (factorB*sensorValue) + factorC;      //polynomail formula
; 0018 0095 
; 0018 0096             break;
; 0018 0097         }
; 0018 0098         case CAL_DEFAULT:{
; 0018 0099             break;
; 0018 009A         }
; 0018 009B     }
; 0018 009C     return sensorValue;
; 0018 009D }
;#include "io.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "ds1672.h"
;#include "smaProtocol.h"
;#include "debug.h"
;#include "dataAndStatusTask.h"
;
;extern iData_t viRXData;
;extern iData_t viTXData;
;
;iPTC_t iPTC_RX;
;iPTC_t iPTC_TX;
;
;//iChar_t * pviPTCData;
;
;iChar_t iPTCParser(iData_t *pviOutData_arg){
; 0019 000F iChar_t iPTCParser(iData_t *pviOutData_arg){

	.CSEG
_iPTCParser:
; 0019 0010      char *pviCheck;
; 0019 0011      iChar_t viReturn = PTC_INVALID;
; 0019 0012      iInt_t indexParser = 0;
; 0019 0013      iUInt_t viDataLen = 0;
; 0019 0014      iInt_t viCheckSD = 0;
; 0019 0015      iInt_t viCheckSum = 0;
; 0019 0016      iInt_t viCheckLen = 0;
; 0019 0017      int i = 0;
; 0019 0018 
; 0019 0019 
; 0019 001A      //Prepair data that correct
; 0019 001B      pviCheck = viRXData.value;
	CALL SUBOPT_0x78
	LDI  R30,LOW(_0x320003*2)
	LDI  R31,HIGH(_0x320003*2)
	LDI  R22,BYTE3(_0x320003*2)
	CALL __INITLOCB
	CALL __SAVELOCR6
;	*pviOutData_arg -> Y+16
;	*pviCheck -> R16,R17
;	viReturn -> R19
;	indexParser -> R20,R21
;	viDataLen -> Y+14
;	viCheckSD -> Y+12
;	viCheckSum -> Y+10
;	viCheckLen -> Y+8
;	i -> Y+6
	LDI  R19,0
	__GETWRN 20,21,0
	__POINTWRMN 16,17,_viRXData,2
; 0019 001C      if(*pviCheck == 0x7e){
	MOVW R26,R16
	LD   R26,X
	CPI  R26,LOW(0x7E)
	BRNE _0x320004
; 0019 001D         printDebug("[iPTCparser]Start Delimiter OK(%02x).\r\n",*pviCheck);
	__POINTD1FN _0x320000,0
	CALL __PUTPARD1
	MOVW R26,R16
	CALL SUBOPT_0x79
	CALL SUBOPT_0x61
; 0019 001E         viCheckSD = PTC_DS_SUCCESS;
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	STD  Y+12,R30
	STD  Y+12+1,R31
; 0019 001F      }else{
	RJMP _0x320005
_0x320004:
; 0019 0020         viCheckSD = PTC_DS_INVALID;
	LDI  R30,LOW(0)
	STD  Y+12,R30
	STD  Y+12+1,R30
; 0019 0021      }
_0x320005:
; 0019 0022 
; 0019 0023      viDataLen = (viRXData.value[1]<<8) | viRXData.value[2];
	__GETBRMN 27,_viRXData,3
	LDI  R26,LOW(0)
	__GETB1MN _viRXData,4
	LDI  R31,0
	OR   R30,R26
	OR   R31,R27
	STD  Y+14,R30
	STD  Y+14+1,R31
; 0019 0024      if(viDataLen>4 && viDataLen<512){
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	SBIW R26,5
	BRLO _0x320007
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	CPI  R26,LOW(0x200)
	LDI  R30,HIGH(0x200)
	CPC  R27,R30
	BRLO _0x320008
_0x320007:
	RJMP _0x320006
_0x320008:
; 0019 0025         viCheckLen = PTC_LEN_SUCCESS;
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	STD  Y+8,R30
	STD  Y+8+1,R31
; 0019 0026         printDebug("[iPTCparser]Length (%d).\r\n",viDataLen);
	__POINTD1FN _0x320000,40
	CALL __PUTPARD1
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 0019 0027      }else{
	RJMP _0x320009
_0x320006:
; 0019 0028         viCheckLen = PTC_LEN_INVALID;
	LDI  R30,LOW(0)
	STD  Y+8,R30
	STD  Y+8+1,R30
; 0019 0029      }
_0x320009:
; 0019 002A 
; 0019 002B 
; 0019 002C      pviCheck += (3 + viDataLen);         //3= SD(1)+Length(2)
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	ADIW R30,3
	__ADDWRR 16,17,30,31
; 0019 002D      viCheckSum = *pviCheck;
	MOVW R26,R16
	CALL SUBOPT_0x7A
	STD  Y+10,R30
	STD  Y+10+1,R31
; 0019 002E      printDebug("[iPTCparser]Check sum (%02x).\r\n",viCheckSum);
	__POINTD1FN _0x320000,67
	CALL SUBOPT_0x7B
; 0019 002F      viCheckSum = iCheckSum(&viRXData.value[3],(viRXData.length+1));
	__POINTW1MN _viRXData,5
	CALL SUBOPT_0x7C
	ADIW R26,1
	RCALL _iCheckSum
	CALL SUBOPT_0x7D
; 0019 0030      if(viCheckSum == 0){
	SBIW R30,0
	BRNE _0x32000A
; 0019 0031          printDebug("[iPTCparser]Check sum correct(%d).\r\n",viCheckSum);
	__POINTD1FN _0x320000,99
	CALL SUBOPT_0x7B
; 0019 0032          viCheckSum = PTC_CS_SUCCESS;
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	STD  Y+10,R30
	STD  Y+10+1,R31
; 0019 0033      }else{
	RJMP _0x32000B
_0x32000A:
; 0019 0034          printDebug("[iPTCparser]Check sum incorrect(%d).\r\n",viCheckSum);
	__POINTD1FN _0x320000,136
	CALL SUBOPT_0x7B
; 0019 0035          viCheckSum = PTC_CS_INVALID;
	LDI  R30,LOW(0)
	STD  Y+10,R30
	STD  Y+10+1,R30
; 0019 0036      }
_0x32000B:
; 0019 0037 
; 0019 0038      if((viCheckSD == PTC_DS_SUCCESS) && (viCheckLen == PTC_LEN_SUCCESS) && (viCheckSum == PTC_CS_SUCCESS)){
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	SBIW R26,1
	BRNE _0x32000D
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,1
	BRNE _0x32000D
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	SBIW R26,1
	BREQ _0x32000E
_0x32000D:
	RJMP _0x32000C
_0x32000E:
; 0019 0039          memcpy(&iPTC_RX.hd,&viRXData.value[1],sizeof(iPTC_RX.hd));
	LDI  R30,LOW(_iPTC_RX)
	LDI  R31,HIGH(_iPTC_RX)
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _viRXData,3
	CALL SUBOPT_0x1
	CALL _memcpy
; 0019 003A          indexParser += sizeof(iPTC_RX.hd);
	__ADDWRN 20,21,18
; 0019 003B          iPTC_RX.dat.value = &viRXData.value[19];        //sd(1),len(2),mti(2),tid(8),tim(4),fid(2)   = 1+2+2+8+4+2 = 19
	__POINTW1MN _viRXData,21
	__PUTW1MN _iPTC_RX,20
; 0019 003C          iPTC_RX.dat.len = (viDataLen + 3)-19;                               //(viDataLen) + sd(3) - 19
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	ADIW R26,3
	LDI  R30,LOW(19)
	LDI  R31,HIGH(19)
	CALL __SWAPW12
	SUB  R30,R26
	SBC  R31,R27
	__PUTW1MN _iPTC_RX,18
; 0019 003D          //printDebug("[iPTCParser]Data will process(%d).[\r\n",iPTC_RX.dat.len);
; 0019 003E          //print_payload(iPTC_RX.dat.value, iPTC_RX.dat.len);
; 0019 003F 
; 0019 0040          pviOutData_arg->length = iPTC_RX.dat.len;
	__GETW1MN _iPTC_RX,18
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ST   X+,R30
	ST   X,R31
; 0019 0041          memcpy(&pviOutData_arg->value[0],&viRXData.value[19],iPTC_RX.dat.len);
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _viRXData,21
	ST   -Y,R31
	ST   -Y,R30
	__GETW2MN _iPTC_RX,18
	CALL _memcpy
; 0019 0042 
; 0019 0043          viReturn = PTC_SUCCESS;
	LDI  R19,LOW(1)
; 0019 0044      }else{
	RJMP _0x32000F
_0x32000C:
; 0019 0045          viReturn = PTC_INVALID;
	LDI  R19,LOW(0)
; 0019 0046      }
_0x32000F:
; 0019 0047      return viReturn;
	MOV  R30,R19
	CALL __LOADLOCR6
	JMP  _0x20E0032
; 0019 0048 }
;
;
;
;iUChar_t iPTCCheckHostReq(iData_t *pviData_arg){
; 0019 004C iUChar_t iPTCCheckHostReq(iData_t *pviData_arg){
_iPTCCheckHostReq:
; 0019 004D    iUChar_t iReturn = PTC_HOST_NOT_REQ;
; 0019 004E    printDebug("[iPTCCheckHostReq]MTI(%02x%02x)",iPTC_RX.hd.mti[0],iPTC_RX.hd.mti[1]);
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
;	*pviData_arg -> Y+1
;	iReturn -> R17
	LDI  R17,0
	__POINTD1FN _0x320000,175
	CALL __PUTPARD1
	__GETB1MN _iPTC_RX,2
	CALL SUBOPT_0x7E
	__GETB1MN _iPTC_RX,3
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x7F
; 0019 004F    if((iPTC_RX.hd.mti[1] & 0x01) == 1){
	__GETB1MN _iPTC_RX,3
	ANDI R30,LOW(0x1)
	CPI  R30,LOW(0x1)
	BRNE _0x320010
; 0019 0050       printDebug("[iPTCCheckHostReq]Host Request.\r\n");
	__POINTD1FN _0x320000,207
	CALL SUBOPT_0x0
; 0019 0051       iReturn = PTC_HOST_REQ;
	LDI  R17,LOW(1)
; 0019 0052    }else{
	RJMP _0x320011
_0x320010:
; 0019 0053       printDebug("[iPTCCheckHostReq]Host is not Request.\r\n");
	__POINTD1FN _0x320000,241
	CALL SUBOPT_0x0
; 0019 0054    }
_0x320011:
; 0019 0055    return iReturn;
	MOV  R30,R17
	LDD  R17,Y+0
	ADIW R28,3
	RET
; 0019 0056 }
;
;iInt_t iCheckSum(iChar_t buf_ags[], iInt_t len_ags) {
; 0019 0058 iInt_t iCheckSum(iChar_t buf_ags[], iInt_t len_ags) {
_iCheckSum:
; 0019 0059     iUInt_t 	i = 0;
; 0019 005A     iUInt_t 	sum = 0;
; 0019 005B 
; 0019 005C     for (i = 0; i < len_ags; i++) {
	CALL SUBOPT_0x80
;	buf_ags -> Y+6
;	len_ags -> Y+4
;	i -> R16,R17
;	sum -> R18,R19
	__GETWRN 16,17,0
_0x320013:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CP   R16,R30
	CPC  R17,R31
	BRSH _0x320014
; 0019 005D         sum += buf_ags[i];
	MOVW R30,R16
	CALL SUBOPT_0x81
	CALL SUBOPT_0x7A
	__ADDWRR 18,19,30,31
; 0019 005E     }
	__ADDWRN 16,17,1
	RJMP _0x320013
_0x320014:
; 0019 005F     return (0xFF - (sum & 0xFF));
	MOVW R30,R18
	ANDI R31,HIGH(0xFF)
	LDI  R26,LOW(255)
	LDI  R27,HIGH(255)
	CALL __SWAPW12
	SUB  R30,R26
	SBC  R31,R27
	CALL __LOADLOCR4
	ADIW R28,8
	RET
; 0019 0060 }
;
;void iHostResponse(){}
; 0019 0062 void iHostResponse(){}
;
;iInt_t iGenFID(){
; 0019 0064 iInt_t iGenFID(){
_iGenFID:
; 0019 0065    iInt_t viFID = 0;
; 0019 0066    do{
	ST   -Y,R17
	ST   -Y,R16
;	viFID -> R16,R17
	__GETWRN 16,17,0
_0x320016:
; 0019 0067       viFID = rand();
	CALL _rand
	MOVW R16,R30
; 0019 0068    }while((viFID == 0) && (viFID == 0xffff));
	CLR  R0
	CP   R0,R16
	CPC  R0,R17
	BRNE _0x320018
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	CP   R30,R16
	CPC  R31,R17
	BREQ _0x320019
_0x320018:
	RJMP _0x320017
_0x320019:
	RJMP _0x320016
_0x320017:
; 0019 0069    return viFID;
	MOVW R30,R16
_0x20E0034:
	LD   R16,Y+
	LD   R17,Y+
	RET
; 0019 006A }
;
;
;void iAckHostReq(){
; 0019 006D void iAckHostReq(){
; 0019 006E     //7E0014080005050505050505055173C95524224B024A0010
; 0019 006F     //7E001008000505050505050505D072C95500006F
; 0019 0070 
; 0019 0071 //    iChat_t mit[2] = {0x80,0x00};
; 0019 0072 //    iInt_t viFrameID = 0;
; 0019 0073 //    viFrameID = iGenFID();
; 0019 0074 //    iPTCPack(iData_t *pviOutData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg)
; 0019 0075 }
;
;void iPTCPack(iData_t *pviOutData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg){
; 0019 0077 void iPTCPack(iData_t *pviOutData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg){
_iPTCPack:
; 0019 0078     //iChar_t * pviPTCData;
; 0019 0079     iUInt_t viIndexWrite = 0;
; 0019 007A     iUInt_t viLength = 0;
; 0019 007B     iUChar_t viCharLength[2];
; 0019 007C     iChar_t viCharMTI[2];
; 0019 007D     iChar_t viSD = 0x7e;
; 0019 007E     iUInt_t viCheckSum;
; 0019 007F     iUInt_t viFrameCSLen = 0;
; 0019 0080     iInt_t viFrameID = 0;
; 0019 0081     unsigned long int timestamp;
; 0019 0082 
; 0019 0083     viFrameCSLen = 2 + 8 + 4 + 2 + viLength_arg + 1;     //2(mti) + 8(tid) + 4(tim) + 2(fid) + ?(data) +1(cs)
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,14
	LDI  R30,LOW(0)
	STD  Y+4,R30
	STD  Y+5,R30
	STD  Y+6,R30
	STD  Y+7,R30
	CALL __SAVELOCR6
;	*pviOutData_arg -> Y+28
;	*pviData_arg -> Y+26
;	viLength_arg -> Y+24
;	*pviMTI_arg -> Y+22
;	*pviTID_arg -> Y+20
;	viIndexWrite -> R16,R17
;	viLength -> R18,R19
;	viCharLength -> Y+18
;	viCharMTI -> Y+16
;	viSD -> R21
;	viCheckSum -> Y+14
;	viFrameCSLen -> Y+12
;	viFrameID -> Y+10
;	timestamp -> Y+6
	__GETWRN 16,17,0
	__GETWRN 18,19,0
	LDI  R21,126
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	ADIW R30,17
	STD  Y+12,R30
	STD  Y+12+1,R31
; 0019 0084     //pviPTCData = (iChar_t *)malloc((viLength+20)); //sd(1),len(2),mti(2),tid(8),tim(4),fid(2),cs(1)
; 0019 0085 
; 0019 0086     //if(pviPTCData != NULL){
; 0019 0087         //sd
; 0019 0088         memcpy(&pviOutData_arg->value[viIndexWrite],&viSD,1);
	CALL SUBOPT_0x82
	IN   R30,SPL
	IN   R31,SPH
	ST   -Y,R31
	ST   -Y,R30
	PUSH R21
	LDI  R26,LOW(1)
	CALL SUBOPT_0x83
	POP  R21
; 0019 0089         viIndexWrite += 1;
	__ADDWRN 16,17,1
; 0019 008A 
; 0019 008B         //len
; 0019 008C         viLength = viLength_arg+16;
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	ADIW R30,16
	MOVW R18,R30
; 0019 008D         viCharLength[0] = (viLength<<8);
	MOV  R26,R18
	LDI  R30,LOW(8)
	CALL __LSLB12
	STD  Y+18,R30
; 0019 008E         viCharLength[1] = viLength;
	MOVW R30,R28
	ADIW R30,19
	ST   Z,R18
; 0019 008F         memcpy(&pviOutData_arg->value[viIndexWrite],&viCharLength[0],2);
	CALL SUBOPT_0x82
	MOVW R30,R28
	ADIW R30,20
	CALL SUBOPT_0x84
	CALL SUBOPT_0x85
; 0019 0090         viIndexWrite += 2;
; 0019 0091 
; 0019 0092         //mti
; 0019 0093         memcpy(&pviOutData_arg->value[viIndexWrite],&pviMTI_arg[0],2);
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	CALL SUBOPT_0x84
	CALL SUBOPT_0x85
; 0019 0094         viIndexWrite += 2;
; 0019 0095 
; 0019 0096         //tid
; 0019 0097         memcpy(&pviOutData_arg->value[viIndexWrite],&pviTID_arg[0],8);
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(8)
	CALL SUBOPT_0x83
; 0019 0098         viIndexWrite += 8;
	__ADDWRN 16,17,8
; 0019 0099 
; 0019 009A         //tim
; 0019 009B         timestamp = DS1672_read();
	CALL _DS1672_read
	CALL SUBOPT_0x41
; 0019 009C         memcpy(&pviOutData_arg->value[viIndexWrite],&timestamp,sizeof(timestamp));
	CALL SUBOPT_0x82
	CALL SUBOPT_0x86
	LDI  R26,LOW(4)
	CALL SUBOPT_0x83
; 0019 009D         viIndexWrite += sizeof(timestamp);
	__ADDWRN 16,17,4
; 0019 009E 
; 0019 009F         memcpy(&viCharMTI[0],&pviMTI_arg[0],2);
	CALL SUBOPT_0x87
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	CALL SUBOPT_0x84
	CALL _memcpy
; 0019 00A0         if((viCharMTI[0] == 0x08) && (viCharMTI[1] == 0x00)){
	LDD  R26,Y+16
	CPI  R26,LOW(0x8)
	BRNE _0x32001B
	LDD  R26,Y+17
	CPI  R26,LOW(0x0)
	BREQ _0x32001C
_0x32001B:
	RJMP _0x32001A
_0x32001C:
; 0019 00A1             //fid
; 0019 00A2             if(viLength_arg==0){
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	SBIW R30,0
	BRNE _0x32001D
; 0019 00A3                 viFrameID = 0;
	LDI  R30,LOW(0)
	STD  Y+10,R30
	STD  Y+10+1,R30
; 0019 00A4                 memcpy(&pviOutData_arg->value[viIndexWrite],&viFrameID,2);
	RJMP _0x320021
; 0019 00A5                 viIndexWrite += 2;
; 0019 00A6             }else{
_0x32001D:
; 0019 00A7                 //fid
; 0019 00A8                 viFrameID = iGenFID();
	RCALL _iGenFID
	STD  Y+10,R30
	STD  Y+10+1,R31
; 0019 00A9                 memcpy(&pviOutData_arg->value[viIndexWrite],&viFrameID,2);
_0x320021:
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	ADIW R30,2
	CALL SUBOPT_0x88
	MOVW R30,R28
	ADIW R30,12
	CALL SUBOPT_0x84
	CALL _memcpy
; 0019 00AA                 viIndexWrite += 2;
	__ADDWRN 16,17,2
; 0019 00AB             }
; 0019 00AC         }else{
	RJMP _0x32001F
_0x32001A:
; 0019 00AD             //fid
; 0019 00AE             viFrameID = iGenFID();
	RCALL _iGenFID
	STD  Y+10,R30
	STD  Y+10+1,R31
; 0019 00AF             memcpy(&pviOutData_arg->value[viIndexWrite],&viFrameID,2);
	CALL SUBOPT_0x82
	MOVW R30,R28
	ADIW R30,12
	CALL SUBOPT_0x84
	CALL _memcpy
; 0019 00B0             viIndexWrite += 2;
	__ADDWRN 16,17,2
; 0019 00B1         }
_0x32001F:
; 0019 00B2 
; 0019 00B3 
; 0019 00B4 
; 0019 00B5         if(viLength_arg != 0 ){
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	SBIW R30,0
	BREQ _0x320020
; 0019 00B6             //data
; 0019 00B7             memcpy(&pviOutData_arg->value[viIndexWrite],&pviData_arg[0],viLength_arg);
	CALL SUBOPT_0x82
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+28
	LDD  R27,Y+28+1
	CALL _memcpy
; 0019 00B8             viIndexWrite += viLength_arg;
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	__ADDWRR 16,17,30,31
; 0019 00B9         }
; 0019 00BA 
; 0019 00BB 
; 0019 00BC         //cs
; 0019 00BD         viCheckSum = iCheckSum(&pviOutData_arg->value[3],viFrameCSLen);
_0x320020:
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	ADIW R30,5
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	RCALL _iCheckSum
	STD  Y+14,R30
	STD  Y+14+1,R31
; 0019 00BE         memcpy(&pviOutData_arg->value[viIndexWrite],&viCheckSum,1);
	CALL SUBOPT_0x82
	MOVW R30,R28
	ADIW R30,16
	CALL SUBOPT_0x4
	CALL _memcpy
; 0019 00BF         viIndexWrite += 1;
	__ADDWRN 16,17,1
; 0019 00C0 
; 0019 00C1         pviOutData_arg->length = viLength_arg+20;
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	ADIW R30,20
	LDD  R26,Y+28
	LDD  R27,Y+28+1
	ST   X+,R30
	ST   X,R31
; 0019 00C2 
; 0019 00C3         //printDebug("[iPTCPack]Print:\r\n");
; 0019 00C4         //print_payload(pviOutData_arg->value, (viLength_arg+20));
; 0019 00C5 
; 0019 00C6 //    }else{
; 0019 00C7 //        printDebug("[iPTCPack]can 't allocate mem.\r\n");
; 0019 00C8 //        //pviPTCData = 0;
; 0019 00C9 //    }
; 0019 00CA     //free(pviPTCData);
; 0019 00CB     //return pviPTCData;
; 0019 00CC }
	CALL __LOADLOCR6
	ADIW R28,30
	RET
;
;//iChar_t * iPTCPack(iData_t *pviData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg){
;//    //iChar_t * pviPTCData;
;//    iUInt_t viIndexWrite = 0;
;//    iUInt_t viLength = 0;
;//    iUChar_t viCharLength[2];
;//    iChar_t viSD = 0x7e;
;//    iUInt_t viCheckSum;
;//    iUInt_t viFrameCSLen = 0;
;//    iInt_t viFrameID = 0;
;//    unsigned long int timestamp;
;//
;//    viFrameCSLen = 2 + 8 + 4 + 2 + viLength_arg + 1;     //2(mti) + 8(tid) + 4(tim) + 2(fid) + ?(data) +1(cs)
;//    pviPTCData = (iChar_t *)malloc((viLength+20)); //sd(1),len(2),mti(2),tid(8),tim(4),fid(2),cs(1)
;//
;//    if(pviPTCData != NULL){
;//        //sd
;//        memcpy(&pviPTCData[viIndexWrite],&viSD,1);
;//        viIndexWrite += 1;
;//
;//        //len
;//        viLength = viLength_arg+16;
;//        viCharLength[0] = (viLength<<8);
;//        viCharLength[1] = viLength;
;//        memcpy(&pviPTCData[viIndexWrite],&viCharLength[0],2);
;//        viIndexWrite += 2;
;//
;//        //mti
;//        memcpy(&pviPTCData[viIndexWrite],&pviMTI_arg[0],2);
;//        viIndexWrite += 2;
;//
;//        //tid
;//        memcpy(&pviPTCData[viIndexWrite],&pviTID_arg[0],8);
;//        viIndexWrite += 8;
;//
;//        //tim
;//        timestamp = DS1672_read();
;//        memcpy(&pviPTCData[viIndexWrite],&timestamp,sizeof(timestamp));
;//        viIndexWrite += sizeof(timestamp);
;//
;//        //fid
;//        viFrameID = iGenFID();
;//        memcpy(&pviPTCData[viIndexWrite],&viFrameID,2);
;//        viIndexWrite += 2;
;//
;//        //data
;//        memcpy(&pviPTCData[viIndexWrite],&pviData_arg[0],viLength_arg);
;//        viIndexWrite += viLength_arg;
;//
;//        //cs
;//        viCheckSum = iCheckSum(&pviPTCData[3],viFrameCSLen);
;//        memcpy(&pviPTCData[viIndexWrite],&viCheckSum,1);
;//        viIndexWrite += 1;
;//
;//        pviData_arg.length = viLength_arg+20;
;//
;//        printDebug("[iPTCPack]Print:\r\n");
;//        print_payload(pviPTCData, (viLength_arg+20));
;//
;//    }else{
;//        printDebug("[iPTCPack]can 't allocate mem.\r\n");
;//        pviPTCData = 0;
;//    }
;//    //free(pviPTCData);
;//    return pviPTCData;
;//}
;
;//void iDataReportPack(iChar_t *pviOutData,iDataReport_t *pviInData){
;//
;//}
;#include "io.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "timer.h"
;#include "ds1672.h"
;#include "managerTask.h"
;#include "dataAndStatusTask.h"
;#include "smaProtocol.h"
;#include "lan.h"
;#include "database.h"
;
;extern piQueueHandle_t pviQueueTaskAToTaskB;
;extern piQueueHandle_t pviQueueSensorToMang;
;extern piQueueHandle_t pviQueueDeviceToMang;
;
;extern eeprom iUChar_t viFlagTerInit;           //Terminal initial frist
;
;extern iDataMini_t viDataReport;
;extern iDataMini_t viStatusReport;
;
;iMangQueue_t viMangQueue[MANG_QUEUE_MAX];
;
;iSensorData_t pviRXReceiveSensor;
;//iUChar_t de
;
;//iData_t viTXDataBuff;
;//iData_t viRXDataBuff;
;
;void managerTask(void *pviParameter){
; 001A 001B void managerTask(void *pviParameter){

	.CSEG
_managerTask:
; 001A 001C      int i;
; 001A 001D      iData_t    viTXDataBuff;
; 001A 001E      iData_t    viRXDataBuff;
; 001A 001F      iUChar_t   viHostRetransmit = 3;
; 001A 0020      iChar_t *  pviDatAndStatBuff;
; 001A 0021      iUInt_t    viDatAndStatLength = 0;
; 001A 0022      unsigned long int viUniTime = 0;
; 001A 0023      iUInt_t viRecordID = 0;
; 001A 0024 
; 001A 0025 //     char viGenDataElem[80] = {
; 001A 0026 //         0x7e,
; 001A 0027 //         0x00,0x4c,
; 001A 0028 //         0x02,0x00,
; 001A 0029 //         0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
; 001A 002A //         0x50,0x72,0xC9,0x55,
; 001A 002B //         0x00,0x01,
; 001A 002C //         0x2A,0x06,0x11,0x04,0xCD,0xCC,0xC7,0x42,
; 001A 002D //         0x2A,0x06,0x12,0x04,0x00,0x00,0x00,0x00,
; 001A 002E //         0x2A,0x06,0x13,0x04,0x00,0x00,0xE0,0x41,
; 001A 002F //         0x5A,0x07,0x31,0x0c,0x0d,0x00,0x00,0x00,0x00,
; 001A 0030 //         0x5A,0x07,0x32,0x0d,0x0d,0x01,0x0f,0xf0,0x3b,
; 001A 0031 //         0x5A,0x07,0x41,0x0a,0x09,0x00,0x0f,0xe0,0x41,
; 001A 0032 //         0x5A,0x07,0x42,0x0a,0x0b,0x00,0x0f,0x08,0x42,
; 001A 0033 //         0x70
; 001A 0034 //    } ;
; 001A 0035 
; 001A 0036     char viGenDataElem[60] = {
; 001A 0037          0x2A,0x06,0x11,0x04,0xCD,0xCC,0xC7,0x42,
; 001A 0038          0x2A,0x06,0x12,0x04,0x00,0x00,0x00,0x00,
; 001A 0039          0x2A,0x06,0x13,0x04,0x00,0x00,0xE0,0x41,
; 001A 003A          0x5A,0x07,0x31,0x0c,0x0d,0x00,0x00,0x00,0x00,
; 001A 003B          0x5A,0x07,0x32,0x0d,0x0d,0x01,0x0f,0xf0,0x3b,
; 001A 003C          0x5A,0x07,0x41,0x0a,0x09,0x00,0x0f,0xe0,0x41,
; 001A 003D          0x5A,0x07,0x42,0x0a,0x0b,0x00,0x0f,0x08,0x42
; 001A 003E     } ;
; 001A 003F      char mti[2] = {0x02,0x00};
; 001A 0040      char tid[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
; 001A 0041      TIMER   viDelay_s;
; 001A 0042      TIMER   viTEver1min;
; 001A 0043      iUChar_t viCommuInterface = 0;
; 001A 0044      iUChar_t modeOperate = REALTIME_MODE;
; 001A 0045      iUChar_t deviceStatus = DEVICE_ENABLE;
; 001A 0046 
; 001A 0047 
; 001A 0048 
; 001A 0049     TIMER_setTimer(&viTEver1min, 60);
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,63
	SBIW R28,63
	SBIW R28,54
	SUBI R29,2
	LDI  R24,88
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x340003*2)
	LDI  R31,HIGH(_0x340003*2)
	LDI  R22,BYTE3(_0x340003*2)
	CALL __INITLOCB
	CALL __SAVELOCR6
;	*pviParameter -> Y+698
;	i -> R16,R17
;	viTXDataBuff -> Y+396
;	viRXDataBuff -> Y+94
;	viHostRetransmit -> R19
;	*pviDatAndStatBuff -> R20,R21
;	viDatAndStatLength -> Y+92
;	viUniTime -> Y+88
;	viRecordID -> Y+86
;	viGenDataElem -> Y+26
;	mti -> Y+24
;	tid -> Y+16
;	viDelay_s -> Y+12
;	viTEver1min -> Y+8
;	viCommuInterface -> R18
;	modeOperate -> Y+7
;	deviceStatus -> Y+6
	LDI  R19,3
	LDI  R18,0
	CALL SUBOPT_0x86
	__GETD2N 0x3C
	CALL _TIMER_setTimer
; 001A 004A     //TIMER_setTimer(&viTEver1min, 30);
; 001A 004B     while(!TIMER_checkTimerExceed(viTEver1min)){
_0x340004:
	CALL SUBOPT_0x56
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	BRNE _0x340006
; 001A 004C        #asm("wdr")
	wdr
; 001A 004D     }
	RJMP _0x340004
_0x340006:
; 001A 004E 
; 001A 004F     #asm("wdr")
	wdr
; 001A 0050 
; 001A 0051      printDebug("[managerTask]Task Running...\r\n");
	__POINTD1FN _0x340000,0
	CALL SUBOPT_0x0
; 001A 0052 
; 001A 0053 
; 001A 0054 //    if(iQueueReceive(pviQueueSensorToMang,&pviRXReceiveSensor)==1){
; 001A 0055 //        printDebug("<managerTask>ACD");
; 001A 0056 //        for(i=0;i<SENSER_ADC_MAX_SIZE;i++){
; 001A 0057 //            printDebug("[%d]:%d | ",(i+1),pviRXReceiveSensor.adc[i]);
; 001A 0058 //        }
; 001A 0059 //        printDebug("\r\n");
; 001A 005A //        printDebug("<managerTask>DHT11 Temp-c(%f), Humidity(%f)\r\n",pviRXReceiveSensor.dht11Temp,pviRXReceiveSensor.dht11Humi);
; 001A 005B //	}else{
; 001A 005C //		printDebug("<managerTask>data can not sent a data to pviQueueSensorToMang.\r\n");
; 001A 005D //	}
; 001A 005E 
; 001A 005F //
; 001A 0060 //    if(iQueueReceive(pviQueueDeviceToMang,&pviRXReceiveSensor)==1){
; 001A 0061 //        printDebug("<managerTask>ACD");
; 001A 0062 //        for(i=0;i<SENSER_ADC_MAX_SIZE;i++){
; 001A 0063 //            printDebug("[%d]:%d | ",(i+1),pviRXReceiveSensor.adc[i]);
; 001A 0064 //        }
; 001A 0065 //        printDebug("\r\n");
; 001A 0066 //        printDebug("<managerTask>DHT11 Temp-c(%f), Humidity(%f)\r\n",pviRXReceiveSensor.dht11Temp,pviRXReceiveSensor.dht11Humi);
; 001A 0067 //	}else{
; 001A 0068 //		printDebug("<managerTask>data can not sent a data to pviQueueSensorToMang.\r\n");
; 001A 0069 //	}
; 001A 006A     iDataSelect('N');
	LDI  R26,LOW(78)
	CALL _iDataSelect
; 001A 006B     //Terminal frist initial//
; 001A 006C     if(viFlagTerInit==0){
	LDI  R26,LOW(_viFlagTerInit)
	LDI  R27,HIGH(_viFlagTerInit)
	CALL __EEPROMRDB
	CPI  R30,0
	BRNE _0x340007
; 001A 006D         mti[0] = 0x08;
	CALL SUBOPT_0x89
; 001A 006E         mti[1] = 0x00;
; 001A 006F         iPTCPack(&viTXDataBuff,(char *)"",0,mti,tid);
; 001A 0070         if(iLanWriteData(&viTXDataBuff)){
	CALL SUBOPT_0x8A
	BREQ _0x340008
; 001A 0071             if(iLanReadData(&viRXDataBuff)){
	CALL SUBOPT_0x8B
	BREQ _0x340009
; 001A 0072                 memcpy(&viUniTime,&viRXDataBuff.value[13],4);
	CALL SUBOPT_0x8C
; 001A 0073                 iSyncUniTime(&viUniTime);
	MOVW R26,R28
	SUBI R26,LOW(-(88))
	SBCI R27,HIGH(-(88))
	RCALL _iSyncUniTime
; 001A 0074                 if(iPTCParser(&viRXDataBuff)){
	CALL SUBOPT_0x8D
	BREQ _0x34000A
; 001A 0075                     viFlagTerInit = 1;
	LDI  R26,LOW(_viFlagTerInit)
	LDI  R27,HIGH(_viFlagTerInit)
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 001A 0076                     iTagParser(&viRXDataBuff);      //tag process  othor do..
	CALL SUBOPT_0x8E
; 001A 0077                     if(iPTCCheckHostReq(&viRXDataBuff)){
; 001A 0078 
; 001A 0079                     }
; 001A 007A                 }
; 001A 007B                 //iHostReqProcess(&viTXDataBuff,&viRXDataBuff);
; 001A 007C             }
_0x34000A:
; 001A 007D         }
_0x340009:
; 001A 007E     }else{
_0x340008:
	RJMP _0x34000C
_0x340007:
; 001A 007F 
; 001A 0080         //deviceStatus = DEVICE_DISABLE;
; 001A 0081         deviceStatus = DEVICE_ENABLE;
	LDI  R30,LOW(1)
	STD  Y+6,R30
; 001A 0082 
; 001A 0083         if(deviceStatus == DEVICE_ENABLE){
	LDD  R26,Y+6
	CPI  R26,LOW(0x1)
	BREQ PC+3
	JMP _0x34000D
; 001A 0084             TIMER_setTimer(&viDelay_s, 5);
	MOVW R30,R28
	ADIW R30,12
	ST   -Y,R31
	ST   -Y,R30
	__GETD2N 0x5
	CALL _TIMER_setTimer
; 001A 0085             while(!TIMER_checkTimerExceed(viDelay_s)){
_0x34000E:
	CALL SUBOPT_0x57
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	BRNE _0x340010
; 001A 0086                #asm("wdr")
	wdr
; 001A 0087             }
	RJMP _0x34000E
_0x340010:
; 001A 0088 
; 001A 0089             viDatAndStatLength = (viDataReport.length + viStatusReport.length);
	LDS  R30,_viStatusReport
	LDS  R31,_viStatusReport+1
	LDS  R26,_viDataReport
	LDS  R27,_viDataReport+1
	ADD  R30,R26
	ADC  R31,R27
	__PUTW1SX 92
; 001A 008A             if(viDatAndStatLength<=0){
	CALL SUBOPT_0x8F
	SBIW R26,0
	BRNE _0x340011
; 001A 008B                modeOperate = LOGGER_MODE;
	LDI  R30,LOW(1)
	STD  Y+7,R30
; 001A 008C                if(1){   //if SD record file empty then to return
; 001A 008D                   return;
	RJMP _0x20E0033
; 001A 008E                }
; 001A 008F             }else{
_0x340011:
; 001A 0090                pviDatAndStatBuff = (iChar_t*)malloc(viDatAndStatLength);
	CALL SUBOPT_0x8F
	CALL _malloc
	MOVW R20,R30
; 001A 0091                if(pviDatAndStatBuff!=NULL){
	MOV  R0,R20
	OR   R0,R21
	BREQ _0x340014
; 001A 0092                   memcpy(&pviDatAndStatBuff[0],viDataReport.value,viDataReport.length);
	ST   -Y,R21
	ST   -Y,R20
	__POINTW1MN _viDataReport,2
	ST   -Y,R31
	ST   -Y,R30
	LDS  R26,_viDataReport
	LDS  R27,_viDataReport+1
	CALL _memcpy
; 001A 0093                   memcpy(&pviDatAndStatBuff[viDataReport.length],viStatusReport.value,viStatusReport.length);
	LDS  R30,_viDataReport
	LDS  R31,_viDataReport+1
	ADD  R30,R20
	ADC  R31,R21
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _viStatusReport,2
	ST   -Y,R31
	ST   -Y,R30
	LDS  R26,_viStatusReport
	LDS  R27,_viStatusReport+1
	CALL _memcpy
; 001A 0094                }else{
	RJMP _0x340015
_0x340014:
; 001A 0095                   free(pviDatAndStatBuff);
	MOVW R26,R20
	CALL _free
; 001A 0096                   printDebug("[managerTask]data and ststus can't allocate mem.\r\n");
	__POINTD1FN _0x340000,31
	CALL SUBOPT_0x0
; 001A 0097                   return;
	RJMP _0x20E0033
; 001A 0098                }
_0x340015:
; 001A 0099                modeOperate = REALTIME_MODE;
	LDI  R30,LOW(0)
	STD  Y+7,R30
; 001A 009A             }
; 001A 009B 
; 001A 009C 
; 001A 009D             if(modeOperate == REALTIME_MODE){
	CPI  R30,0
	BRNE _0x340016
; 001A 009E                  mti[0] = 0x02;
	LDI  R30,LOW(2)
	RJMP _0x340083
; 001A 009F                  mti[1] = 0x00;
; 001A 00A0             }else if(modeOperate == LOGGER_MODE){
_0x340016:
	LDD  R26,Y+7
	CPI  R26,LOW(0x1)
	BRNE _0x340018
; 001A 00A1                  mti[0] = 0x03;
	LDI  R30,LOW(3)
_0x340083:
	STD  Y+24,R30
; 001A 00A2                  mti[1] = 0x00;
	LDI  R30,LOW(0)
	STD  Y+25,R30
; 001A 00A3             }
; 001A 00A4 
; 001A 00A5             //iPTCPack(&viTXDataBuff,viGenDataElem,sizeof(viGenDataElem),mti,tid);
; 001A 00A6             iPTCPack(&viTXDataBuff,(const char*) pviDatAndStatBuff,viDatAndStatLength,mti,tid);
_0x340018:
	MOVW R30,R28
	SUBI R30,LOW(-(396))
	SBCI R31,HIGH(-(396))
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R21
	ST   -Y,R20
	CALL SUBOPT_0x90
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,30
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,24
	RCALL _iPTCPack
; 001A 00A7             free(pviDatAndStatBuff);
	MOVW R26,R20
	CALL _free
; 001A 00A8 
; 001A 00A9             viRecordID = iDataInsert(viTXDataBuff.value,viTXDataBuff.length);
	MOVW R30,R28
	SUBI R30,LOW(-(396))
	SBCI R31,HIGH(-(396))
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	__GETW2SX 398
	CALL _iDataInsert
	__PUTW1SX 86
; 001A 00AA             if(viRecordID>0){
	__GETW2SX 86
	CALL __CPW02
	BRSH _0x340019
; 001A 00AB                 printDebug("[managerTask]Record ID(%04ld)\r\n",viRecordID);
	__POINTD1FN _0x340000,82
	CALL __PUTPARD1
	CALL SUBOPT_0x91
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 001A 00AC             }
; 001A 00AD 
; 001A 00AE             iMangQueueAddItem(viRecordID,&viTXDataBuff,&viTXDataBuff.value[17]); //add protocol in mang queue
_0x340019:
	__GETW1SX 86
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	SUBI R30,LOW(-(398))
	SBCI R31,HIGH(-(398))
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	SUBI R30,LOW(-(400))
	SBCI R31,HIGH(-(400))
	ADIW R30,19
	MOVW R26,R30
	RCALL _iMangQueueAddItem
; 001A 00AF             iMangQueueDisplay();//display mang queue
	RCALL _iMangQueueDisplay
; 001A 00B0             delay_ms(1000);
	CALL SUBOPT_0x6B
; 001A 00B1             //iDataInsert(viTXDataBuff.value,viTXDataBuff.length);
; 001A 00B2             #asm("wdr")
	wdr
; 001A 00B3 
; 001A 00B4             //print_payload(viTXDataBuff.value, (sizeof(viGenDataElem)+20));               //20 = header + check sum
; 001A 00B5             while(iMangCheckRetransmit(&viTXDataBuff.value[17])!=0){
_0x34001A:
	CALL SUBOPT_0x92
	BRNE PC+3
	JMP _0x34001C
; 001A 00B6                 if(iLanWriteData(&viTXDataBuff)){
	CALL SUBOPT_0x8A
	BREQ _0x34001D
; 001A 00B7                       if(iLanReadData(&viRXDataBuff)){
	CALL SUBOPT_0x8B
	BREQ _0x34001E
; 001A 00B8                             memcpy(&viUniTime,&viRXDataBuff.value[13],4);
	CALL SUBOPT_0x8C
; 001A 00B9                             iSyncUniTime(&viUniTime);
	MOVW R26,R28
	SUBI R26,LOW(-(88))
	SBCI R27,HIGH(-(88))
	RCALL _iSyncUniTime
; 001A 00BA                             iMangQueueDelItem(&viRXDataBuff.value[17]);       //del queue with fid
	MOVW R30,R28
	SUBI R30,LOW(-(94))
	SBCI R31,HIGH(-(94))
	ADIW R30,19
	MOVW R26,R30
	RCALL _iMangQueueDelItem
; 001A 00BB                             if(iPTCParser(&viRXDataBuff)){    //report success
	CALL SUBOPT_0x8D
	BREQ _0x34001F
; 001A 00BC                                   printDebug("[managerTask]Print.[\r\n");
	__POINTD1FN _0x340000,114
	CALL SUBOPT_0x0
; 001A 00BD                                   print_payload(viRXDataBuff.value,viRXDataBuff.length);
	MOVW R30,R28
	SUBI R30,LOW(-(94))
	SBCI R31,HIGH(-(94))
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x93
	CALL SUBOPT_0x94
; 001A 00BE                                   printDebug("]\r\n");
; 001A 00BF 
; 001A 00C0                                   iTagParser(&viRXDataBuff);      //tag process  othor do..
	CALL SUBOPT_0x8E
; 001A 00C1 
; 001A 00C2 
; 001A 00C3                                   if(iPTCCheckHostReq(&viRXDataBuff)){
	CPI  R30,0
	BREQ _0x340020
; 001A 00C4                                      mti[0] = 0x08;
	CALL SUBOPT_0x89
; 001A 00C5                                      mti[1] = 0x00;
; 001A 00C6                                      iPTCPack(&viTXDataBuff,(char *)"",0,mti,tid);
; 001A 00C7                                      while(viHostRetransmit!=0){
_0x340021:
	CPI  R19,0
	BREQ _0x340023
; 001A 00C8                                         if(iLanWriteData(&viTXDataBuff)){
	CALL SUBOPT_0x8A
	BREQ _0x340024
; 001A 00C9                                             if(iLanReadData(&viRXDataBuff)){
	CALL SUBOPT_0x8B
	BREQ _0x340025
; 001A 00CA                                                 iHostReqProcess(&viTXDataBuff,&viRXDataBuff);
	MOVW R30,R28
	SUBI R30,LOW(-(396))
	SBCI R31,HIGH(-(396))
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	SUBI R26,LOW(-(96))
	SBCI R27,HIGH(-(96))
	RCALL _iHostReqProcess
; 001A 00CB                                             }
; 001A 00CC                                             break;
_0x340025:
	RJMP _0x340023
; 001A 00CD                                         }
; 001A 00CE                                         viHostRetransmit--;
_0x340024:
	SUBI R19,1
; 001A 00CF                                      }
	RJMP _0x340021
_0x340023:
; 001A 00D0                                   }
; 001A 00D1                             }
_0x340020:
; 001A 00D2                             break;
_0x34001F:
	RJMP _0x34001C
; 001A 00D3                        }else{
_0x34001E:
; 001A 00D4                             //iMangQueueDelItem(&viRXDataBuff.value[17]);       //del queue with fid
; 001A 00D5                        }
; 001A 00D6                 }
; 001A 00D7                 if(iMangCheckRetransmit(&viTXDataBuff.value[17])==0){
_0x34001D:
	CALL SUBOPT_0x92
	BRNE _0x340027
; 001A 00D8                      //iDataLogInsert(viTXDataBuff.value,viTXDataBuff.length);
; 001A 00D9                      iMangQueueDelItem(&viTXDataBuff.value[17]);       //del queue with fid  due over retransmit
	MOVW R30,R28
	SUBI R30,LOW(-(396))
	SBCI R31,HIGH(-(396))
	ADIW R30,19
	MOVW R26,R30
	RCALL _iMangQueueDelItem
; 001A 00DA                 }
; 001A 00DB             }
_0x340027:
	RJMP _0x34001A
_0x34001C:
; 001A 00DC 
; 001A 00DD 
; 001A 00DE         }
; 001A 00DF 
; 001A 00E0     }
_0x34000D:
_0x34000C:
; 001A 00E1 
; 001A 00E2 
; 001A 00E3 
; 001A 00E4 }
_0x20E0033:
	CALL __LOADLOCR6
	ADIW R28,63
	ADIW R28,63
	ADIW R28,62
	SUBI R29,-2
	RET
;
;iUInt_t iHostReqProcess(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
; 001A 00E6 iUInt_t iHostReqProcess(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
_iHostReqProcess:
; 001A 00E7     char mti[2] = {0x08,0x00};
; 001A 00E8     char tid[8] = {0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};
; 001A 00E9     iUInt_t viReturn = 0;
; 001A 00EA     iUChar_t viRetransmit = 1;
; 001A 00EB     iChar_t viHostNeedFlag = 0;
; 001A 00EC 
; 001A 00ED //    iPTCPack(pviTXDataBuff_arg,(char *)"",0,mti,tid);
; 001A 00EE //    iMangQueueAddItem(pviTXDataBuff_arg,&pviTXDataBuff_arg->value[17]); //add protocol in mang queue
; 001A 00EF //    iMangQueueDisplay();//display mang queue
; 001A 00F0 //    iDataInsert(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 00F1     printDebug("[iHostReqProcess]TX Print 1.[\r\n");
	CALL SUBOPT_0x78
	LDI  R30,LOW(_0x340028*2)
	LDI  R31,HIGH(_0x340028*2)
	LDI  R22,BYTE3(_0x340028*2)
	CALL __INITLOCB
	CALL __SAVELOCR4
;	*pviTXDataBuff_arg -> Y+16
;	*pviRXDataBuff_arg -> Y+14
;	mti -> Y+12
;	tid -> Y+4
;	viReturn -> R16,R17
;	viRetransmit -> R19
;	viHostNeedFlag -> R18
	__GETWRN 16,17,0
	LDI  R19,1
	LDI  R18,0
	__POINTD1FN _0x340000,141
	CALL SUBOPT_0x0
; 001A 00F2     print_payload(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL SUBOPT_0x95
; 001A 00F3     printDebug("]\r\n");
; 001A 00F4 
; 001A 00F5     printDebug("[iHostReqProcess]RX Print 2.[\r\n");
	__POINTD1FN _0x340000,173
	CALL SUBOPT_0x0
; 001A 00F6     print_payload(pviRXDataBuff_arg->value,pviRXDataBuff_arg->length);
	CALL SUBOPT_0x96
; 001A 00F7     printDebug("]\r\n");
; 001A 00F8 
; 001A 00F9     if(iPTCParser(pviRXDataBuff_arg)){    //report success
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	CALL _iPTCParser
	CPI  R30,0
	BREQ _0x340029
; 001A 00FA         printDebug("[iHostReqProcess]Print.[\r\n");
	__POINTD1FN _0x340000,205
	CALL SUBOPT_0x0
; 001A 00FB         print_payload(pviRXDataBuff_arg->value,pviRXDataBuff_arg->length);
	CALL SUBOPT_0x96
; 001A 00FC         printDebug("]\r\n");
; 001A 00FD 
; 001A 00FE         iTagParser(pviRXDataBuff_arg);      //tag process  othor do..
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	RCALL _iTagParser
; 001A 00FF     }
; 001A 0100 //
; 001A 0101 //    printDebug("[iHostReqProcess]FID(%02x%02x).\r\n",*(pviTXDataBuff_arg->value+17),*(pviTXDataBuff_arg->value+18));
; 001A 0102 
; 001A 0103 //        if(iLanReadData(pviRXDataBuff_arg)){
; 001A 0104 //            iMangQueueDelItem((pviTXDataBuff_arg->value+17));       //del queue with fid
; 001A 0105 //            if(iPTCParser(pviRXDataBuff_arg)){    report success
; 001A 0106 //                printDebug("[iHostReqProcess]Print 1-1.[\r\n");
; 001A 0107 //                print_payload(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 0108 //                printDebug("]\r\n");
; 001A 0109 //            }
; 001A 010A //        }
; 001A 010B //
; 001A 010C //    while(iMangCheckRetransmit((pviTXDataBuff_arg->value+17))!=0){
; 001A 010D //        if(iLanWriteData(pviTXDataBuff_arg)){
; 001A 010E //            if(iLanReadData(pviRXDataBuff_arg)){
; 001A 010F //                iMangQueueDelItem((pviTXDataBuff_arg->value+17));       //del queue with fid
; 001A 0110 //                if(iPTCParser(pviRXDataBuff_arg)){    report success
; 001A 0111 //                    printDebug("[iHostReqProcess]Print 1-1.[\r\n");
; 001A 0112 //                    print_payload(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 0113 //                    printDebug("]\r\n");
; 001A 0114 //                }
; 001A 0115 //            }
; 001A 0116 //        }
; 001A 0117 //        if(iMangCheckRetransmit((pviTXDataBuff_arg->value+17))==0){
; 001A 0118 //             iDataLogInsert(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 0119 //             iMangQueueDelItem((pviTXDataBuff_arg->value+17));       //del queue with fid  due over retransmit
; 001A 011A //        }
; 001A 011B //    }
; 001A 011C 
; 001A 011D 
; 001A 011E     return viReturn;
_0x340029:
	MOVW R30,R16
	CALL __LOADLOCR4
_0x20E0032:
	ADIW R28,18
	RET
; 001A 011F }
;
;void iDataReportTX(){
; 001A 0121 void iDataReportTX(){
; 001A 0122 
; 001A 0123 }
;
;void iStatusReportTX(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
; 001A 0125 void iStatusReportTX(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
; 001A 0126 
; 001A 0127 }
;
;void iEventReportTX(){
; 001A 0129 void iEventReportTX(){
; 001A 012A 
; 001A 012B }
;
;void iTerAckByTagB(iChar_t viTagName, iChar_t viPropNumber){              //host requst = A , terminal ack = B
; 001A 012D void iTerAckByTagB(iChar_t viTagName, iChar_t viPropNumber){
_iTerAckByTagB:
; 001A 012E      iChar_t viMTI[2] = {0x08,0x00};
; 001A 012F      iChar_t viTID[8];
; 001A 0130      iChar_t viAckData[4] = {0x4b,0x02,0x10,0x00};
; 001A 0131      iData_t * pviDataTX;
; 001A 0132      iData_t * pviDataRX;
; 001A 0133 
; 001A 0134      pviDataTX = (iData_t*)malloc(sizeof(iData_t));
	ST   -Y,R26
	SBIW R28,14
	LDI  R24,14
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x34002A*2)
	LDI  R31,HIGH(_0x34002A*2)
	LDI  R22,BYTE3(_0x34002A*2)
	CALL __INITLOCB
	CALL __SAVELOCR4
;	viTagName -> Y+19
;	viPropNumber -> Y+18
;	viMTI -> Y+16
;	viTID -> Y+8
;	viAckData -> Y+4
;	*pviDataTX -> R16,R17
;	*pviDataRX -> R18,R19
	LDI  R26,LOW(302)
	LDI  R27,HIGH(302)
	CALL _malloc
	MOVW R16,R30
; 001A 0135      pviDataRX = (iData_t*)malloc(sizeof(iData_t));
	LDI  R26,LOW(302)
	LDI  R27,HIGH(302)
	CALL _malloc
	MOVW R18,R30
; 001A 0136      if(pviDataTX!=NULL && pviDataRX!=NULL){
	CLR  R0
	CP   R0,R16
	CPC  R0,R17
	BREQ _0x34002C
	CLR  R0
	CP   R0,R18
	CPC  R0,R19
	BRNE _0x34002D
_0x34002C:
	RJMP _0x34002B
_0x34002D:
; 001A 0137          //memcpy(viTID,&viDVConfigUpdate.viProperties.viDeviceID[0],8);
; 001A 0138          printConfig(&viDVConfigUpdate.viProperties.viDeviceID[0],sizeof(viDVConfigUpdate.viProperties.viDeviceID));
	__POINTW1MN _viDVConfigUpdate,80
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x2B
	RCALL _printConfig
; 001A 0139          memcpyd(viTID,(char eeprom  *)&viDVConfigUpdate.viProperties.viDeviceID[0],8);
	CALL SUBOPT_0x86
	__POINTW1MN _viDVConfigUpdate,80
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(8)
	LDI  R27,0
	RCALL _memcpyd
; 001A 013A          print_payload(viTID,8);
	CALL SUBOPT_0x86
	LDI  R26,LOW(8)
	LDI  R27,0
	CALL _print_payload
; 001A 013B          if(viTagName==TAG_4A){
	LDD  R26,Y+19
	CPI  R26,LOW(0x4A)
	BRNE _0x34002E
; 001A 013C             if(viPropNumber==CONF_PROPERTIES){
	LDD  R26,Y+18
	CPI  R26,LOW(0x10)
	BRNE _0x34002F
; 001A 013D                 iPTCPack(pviDataTX,viAckData,sizeof(viAckData),viMTI,viTID);
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x97
	LDI  R30,LOW(4)
	LDI  R31,HIGH(4)
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,22
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,16
	CALL _iPTCPack
; 001A 013E                 if(iLanWriteData(pviDataTX)){
	MOVW R26,R16
	CALL _iLanWriteData
	CPI  R30,0
	BREQ _0x340030
; 001A 013F                     if(iLanReadData(pviDataRX)){
	MOVW R26,R18
	CALL _iLanReadData
	CPI  R30,0
	BREQ _0x340031
; 001A 0140                         if(iPTCParser(pviDataRX)){
	MOVW R26,R18
	CALL _iPTCParser
	CPI  R30,0
	BREQ _0x340032
; 001A 0141                             viFlagTerInit = 1;
	LDI  R26,LOW(_viFlagTerInit)
	LDI  R27,HIGH(_viFlagTerInit)
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 001A 0142                             iTagParser(pviDataRX);      //tag process  othor do..
	MOVW R26,R18
	RCALL _iTagParser
; 001A 0143                             if(iPTCCheckHostReq(pviDataRX)){
	MOVW R26,R18
	CALL _iPTCCheckHostReq
; 001A 0144 
; 001A 0145                             }
; 001A 0146                         }
; 001A 0147                     }
_0x340032:
; 001A 0148                 }
_0x340031:
; 001A 0149             }
_0x340030:
; 001A 014A 
; 001A 014B          }
_0x34002F:
; 001A 014C          free(pviDataTX);
_0x34002E:
	MOVW R26,R16
	CALL _free
; 001A 014D          free(pviDataRX);
	MOVW R26,R18
	CALL _free
; 001A 014E      }else{
	RJMP _0x340034
_0x34002B:
; 001A 014F         printDebug("[iTerAckByTagB]Not allocate memory.\r\n");
	__POINTD1FN _0x340000,232
	CALL SUBOPT_0x0
; 001A 0150      }
_0x340034:
; 001A 0151 }
	CALL __LOADLOCR4
	ADIW R28,20
	RET
;
;void iTagParser(iData_t *pviData_arg){
; 001A 0153 void iTagParser(iData_t *pviData_arg){
_iTagParser:
; 001A 0154     int i,j;
; 001A 0155     iUInt_t viDataLen = 0;
; 001A 0156 
; 001A 0157     printDebug("[iTagParser]Host response\r\n");
	CALL SUBOPT_0x6D
;	*pviData_arg -> Y+6
;	i -> R16,R17
;	j -> R18,R19
;	viDataLen -> R20,R21
	__GETWRN 20,21,0
	__POINTD1FN _0x340000,270
	CALL SUBOPT_0x0
; 001A 0158     viDataLen = pviData_arg->value[1];
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R20,Z+3
	CLR  R21
; 001A 0159     printDebug("[iTagParser]Len(%d)\r\n",viDataLen);
	__POINTD1FN _0x340000,298
	CALL SUBOPT_0x98
	CALL SUBOPT_0x63
; 001A 015A 
; 001A 015B     if(pviData_arg->value[0] == 0x00){
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R30,Z+2
	CPI  R30,0
	BREQ PC+3
	JMP _0x340035
; 001A 015C         for(i=2;i<(viDataLen);i+=2){
	__GETWRN 16,17,2
_0x340037:
	__CPWRR 16,17,20,21
	BRLO PC+3
	JMP _0x340038
; 001A 015D              //printDebug("[iTagParser]Loop:%02x(%d)",iPTC_RX.dat.value[i],iPTC_RX.dat.value[(i+1)]);
; 001A 015E              switch(pviData_arg->value[i]){
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x99
	LDI  R31,0
; 001A 015F                 case TAG_2A:{
	CPI  R30,LOW(0x2A)
	LDI  R26,HIGH(0x2A)
	CPC  R31,R26
	BRNE _0x34003C
; 001A 0160                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	CALL SUBOPT_0x99
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x9B
	RJMP _0x340084
; 001A 0161                    break;
; 001A 0162                 }
; 001A 0163                 case TAG_3A:{
_0x34003C:
	CPI  R30,LOW(0x3A)
	LDI  R26,HIGH(0x3A)
	CPC  R31,R26
	BRNE _0x34003D
; 001A 0164                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	CALL SUBOPT_0x99
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x9B
	RJMP _0x340084
; 001A 0165                    break;
; 001A 0166                 }
; 001A 0167                 case TAG_4A:{
_0x34003D:
	CPI  R30,LOW(0x4A)
	LDI  R26,HIGH(0x4A)
	CPC  R31,R26
	BRNE _0x34003E
; 001A 0168                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	CALL SUBOPT_0x99
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x9B
	RJMP _0x340084
; 001A 0169                    break;
; 001A 016A                 }
; 001A 016B                 case TAG_5A:{
_0x34003E:
	CPI  R30,LOW(0x5A)
	LDI  R26,HIGH(0x5A)
	CPC  R31,R26
	BRNE _0x34003F
; 001A 016C                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	CALL SUBOPT_0x99
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x9B
	RJMP _0x340084
; 001A 016D                    break;
; 001A 016E                 }
; 001A 016F                 case TAG_6A:{
_0x34003F:
	CPI  R30,LOW(0x6A)
	LDI  R26,HIGH(0x6A)
	CPC  R31,R26
	BRNE _0x340040
; 001A 0170                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	CALL SUBOPT_0x99
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x9B
	RJMP _0x340084
; 001A 0171                    break;
; 001A 0172                 }
; 001A 0173                 case TAG_7A:{
_0x340040:
	CPI  R30,LOW(0x7A)
	LDI  R26,HIGH(0x7A)
	CPC  R31,R26
	BRNE _0x340041
; 001A 0174                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	CALL SUBOPT_0x99
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x9B
	RJMP _0x340084
; 001A 0175                    break;
; 001A 0176                 }
; 001A 0177                 case TAG_8A:{
_0x340041:
	CPI  R30,LOW(0x8A)
	LDI  R26,HIGH(0x8A)
	CPC  R31,R26
	BRNE _0x340042
; 001A 0178                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	CALL SUBOPT_0x99
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x9B
	RJMP _0x340084
; 001A 0179                    break;
; 001A 017A                 }
; 001A 017B                 case TAG_9A:{
_0x340042:
	CPI  R30,LOW(0x9A)
	LDI  R26,HIGH(0x9A)
	CPC  R31,R26
	BRNE _0x34003B
; 001A 017C                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",&pviData_arg->value[i],&pviData_arg->value[(i+1)]);
	CALL SUBOPT_0x9A
	ADIW R30,2
	ADD  R30,R16
	ADC  R31,R17
	CALL SUBOPT_0x5F
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	ADIW R26,2
	MOVW R30,R16
	ADIW R30,1
	ADD  R30,R26
	ADC  R31,R27
	CLR  R22
	CLR  R23
_0x340084:
	CALL __PUTPARD1
	CALL SUBOPT_0x7F
; 001A 017D                    break;
; 001A 017E                 }
; 001A 017F              }
_0x34003B:
; 001A 0180         }
	__ADDWRN 16,17,2
	RJMP _0x340037
_0x340038:
; 001A 0181     }else if(pviData_arg->value[0] == TAG_4A){
	RJMP _0x340044
_0x340035:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+2
	CPI  R26,LOW(0x4A)
	BREQ PC+3
	JMP _0x340045
; 001A 0182         switch(pviData_arg->value[2]){
	LDD  R30,Z+4
	LDI  R31,0
; 001A 0183              case CONF_PROPERTIES:{      //config properties
	CPI  R30,LOW(0x10)
	LDI  R26,HIGH(0x10)
	CPC  R31,R26
	BRNE _0x340049
; 001A 0184                 printDebug("[iTagParser]Host need to config(Properties)\r\n");
	__POINTD1FN _0x340000,347
	CALL SUBOPT_0x0
; 001A 0185                 memcpye((char eeprom *)&viDVConfigUpdate.viProperties,&pviData_arg->value[3],viDataLen);
	LDI  R30,LOW(_viDVConfigUpdate)
	LDI  R31,HIGH(_viDVConfigUpdate)
	CALL SUBOPT_0x9C
; 001A 0186                 printConfig((char eeprom *)&viDVConfigUpdate.viProperties,sizeof(viDVConfigUpdate.viProperties));
	LDI  R30,LOW(_viDVConfigUpdate)
	LDI  R31,HIGH(_viDVConfigUpdate)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(161)
	LDI  R27,0
	RCALL _printConfig
; 001A 0187                 iTerAckByTagB(TAG_4A,CONF_PROPERTIES);
	LDI  R30,LOW(74)
	ST   -Y,R30
	LDI  R26,LOW(16)
	RCALL _iTerAckByTagB
; 001A 0188                 break;
	RJMP _0x340048
; 001A 0189              }
; 001A 018A              case CONF_OPERATEING:{      //config properties
_0x340049:
	CPI  R30,LOW(0x20)
	LDI  R26,HIGH(0x20)
	CPC  R31,R26
	BRNE _0x34004A
; 001A 018B                 printDebug("[iTagParser]Host need to config(Operating)\r\n");
	__POINTD1FN _0x340000,393
	CALL SUBOPT_0x0
; 001A 018C                 memcpye((char eeprom *)&viDVConfigUpdate.viOperate,&pviData_arg->value[3],viDataLen);
	__POINTW1MN _viDVConfigUpdate,161
	CALL SUBOPT_0x9C
; 001A 018D                 printConfig((char eeprom *)&viDVConfigUpdate.viOperate,sizeof(viDVConfigUpdate.viOperate));
	__POINTW1MN _viDVConfigUpdate,161
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(9)
	LDI  R27,0
	RCALL _printConfig
; 001A 018E                 break;
	RJMP _0x340048
; 001A 018F              }
; 001A 0190              case CONF_BUZZER:{      //config properties
_0x34004A:
	CPI  R30,LOW(0x80)
	LDI  R26,HIGH(0x80)
	CPC  R31,R26
	BRNE _0x34004B
; 001A 0191                 printDebug("[iTagParser]Host need to config(Buzzer)\r\n");
	__POINTD1FN _0x340000,438
	RJMP _0x340085
; 001A 0192                 break;
; 001A 0193              }
; 001A 0194              case CONF_ENVIRON_COND:{      //config properties
_0x34004B:
	CPI  R30,LOW(0x90)
	LDI  R26,HIGH(0x90)
	CPC  R31,R26
	BRNE _0x340048
; 001A 0195                 printDebug("[iTagParser]Host need to config(Environment Alarm Condition)\r\n");
	__POINTD1FN _0x340000,480
_0x340085:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 001A 0196                 break;
; 001A 0197              }
; 001A 0198         }
_0x340048:
; 001A 0199 
; 001A 019A         if((pviData_arg->value[2]&0xf0) == CONF_DIGI_IN){
	CALL SUBOPT_0x9D
	CPI  R30,LOW(0x40)
	BRNE _0x34004D
; 001A 019B              printDebug("[iTagParser]Host need to config(Digital Input)\r\n");
	__POINTD1FN _0x340000,543
	RJMP _0x340086
; 001A 019C         }else if((pviData_arg->value[2]&0xf0) == CONF_DIGI_OUT){
_0x34004D:
	CALL SUBOPT_0x9D
	CPI  R30,LOW(0x50)
	BRNE _0x34004F
; 001A 019D              printDebug("[iTagParser]Host need to config(Digital Output)\r\n");
	__POINTD1FN _0x340000,592
	RJMP _0x340086
; 001A 019E         }else if((pviData_arg->value[2]&0xf0) == CONF_ANA_IN){
_0x34004F:
	CALL SUBOPT_0x9D
	CPI  R30,LOW(0x60)
	BRNE _0x340051
; 001A 019F              printDebug("[iTagParser]Host need to config(Analog Input)\r\n");
	__POINTD1FN _0x340000,642
	RJMP _0x340086
; 001A 01A0         }else if((pviData_arg->value[2]&0xf0) == CONF_ANA_OUT){
_0x340051:
	CALL SUBOPT_0x9D
	CPI  R30,LOW(0x70)
	BRNE _0x340053
; 001A 01A1              printDebug("[iTagParser]Host need to config(Analog Output)\r\n");
	__POINTD1FN _0x340000,690
_0x340086:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 001A 01A2         }
; 001A 01A3 
; 001A 01A4     }else{
_0x340053:
	RJMP _0x340054
_0x340045:
; 001A 01A5        printDebug("[iTagParser]Host response unknow(%02x).\r\n",pviData_arg->value[0]);
	__POINTD1FN _0x340000,739
	CALL SUBOPT_0x6E
	LDD  R30,Z+2
	CALL SUBOPT_0x9E
; 001A 01A6     }
_0x340054:
_0x340044:
; 001A 01A7 
; 001A 01A8 
; 001A 01A9 }
	CALL __LOADLOCR6
	JMP  _0x20E0030
;
;
;iInt_t iMangQueueAddItem(iUInt_t viRecordID_arg,iData_t *pviDataItem_arg,iChar_t *pviFid_arg){
; 001A 01AC iInt_t iMangQueueAddItem(iUInt_t viRecordID_arg,iData_t *pviDataItem_arg,iChar_t *pviFid_arg){
_iMangQueueAddItem:
; 001A 01AD     iInt_t viReturn = -1;
; 001A 01AE     iInt_t i;
; 001A 01AF     iChar_t viFid[2];
; 001A 01B0 
; 001A 01B1     memcpy(viFid,&pviFid_arg[0],2);
	CALL SUBOPT_0x9F
;	viRecordID_arg -> Y+10
;	*pviDataItem_arg -> Y+8
;	*pviFid_arg -> Y+6
;	viReturn -> R16,R17
;	i -> R18,R19
;	viFid -> Y+4
	CALL _memcpy
; 001A 01B2     for(i=0;i<MANG_QUEUE_MAX;i++){
	__GETWRN 18,19,0
_0x340056:
	__CPWRN 18,19,2
	BRLT PC+3
	JMP _0x340057
; 001A 01B3         if(viMangQueue[i].value == NULL){
	CALL SUBOPT_0xA0
	CALL SUBOPT_0xA1
	BREQ PC+3
	JMP _0x340058
; 001A 01B4             viMangQueue[i].value = (iChar_t * const)malloc(pviDataItem_arg->length);
	CALL SUBOPT_0xA0
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xA2
	MOVW R26,R30
	CALL _malloc
	POP  R26
	POP  R27
	ST   X+,R30
	ST   X,R31
; 001A 01B5             if(viMangQueue[i].value != NULL){
	CALL SUBOPT_0xA0
	CALL SUBOPT_0xA1
	BREQ _0x340059
; 001A 01B6                 viMangQueue[i].length = pviDataItem_arg->length;
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,5
	MOVW R0,R30
	CALL SUBOPT_0xA2
	MOVW R26,R0
	ST   X+,R30
	ST   X,R31
; 001A 01B7                 viMangQueue[i].recordID = viRecordID_arg;
	CALL SUBOPT_0xA3
	SUBI R30,LOW(-_viMangQueue)
	SBCI R31,HIGH(-_viMangQueue)
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	STD  Z+0,R26
	STD  Z+1,R27
; 001A 01B8                 memcpy(viMangQueue[i].value,&pviDataItem_arg->value[0],pviDataItem_arg->length);
	CALL SUBOPT_0xA0
	MOVW R26,R30
	CALL SUBOPT_0xA4
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	CALL __GETW1P
	MOVW R26,R30
	CALL _memcpy
; 001A 01B9                 memcpy(&viMangQueue[i].fid[0],&viFid[0],2);
	CALL SUBOPT_0xA3
	CALL SUBOPT_0xA5
	CALL _memcpy
; 001A 01BA                 viMangQueue[i].reTransmit = MANG_RETRANSMIT;
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,4
	LDI  R26,LOW(3)
	STD  Z+0,R26
; 001A 01BB                 printDebug("[iMangQueueAddItem]Add by FID(%02x%02x).\r\n",viFid[0],viFid[1]);
	__POINTD1FN _0x340000,781
	CALL SUBOPT_0xA6
	LDD  R30,Y+13
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x7F
; 001A 01BC                 viReturn = 1;
	__GETWRN 16,17,1
; 001A 01BD                 break;
	RJMP _0x340057
; 001A 01BE             }else{
_0x340059:
; 001A 01BF                printDebug("[iMangQueueAddItem]can't allocate mem.\r\n");
	__POINTD1FN _0x340000,824
	CALL SUBOPT_0x0
; 001A 01C0                viReturn = -1;
	__GETWRN 16,17,-1
; 001A 01C1             }
; 001A 01C2         }else{
	RJMP _0x34005B
_0x340058:
; 001A 01C3            viReturn = 0;
	__GETWRN 16,17,0
; 001A 01C4         }
_0x34005B:
; 001A 01C5     }
	__ADDWRN 18,19,1
	RJMP _0x340056
_0x340057:
; 001A 01C6     if(viReturn == 0){
	MOV  R0,R16
	OR   R0,R17
	BRNE _0x34005C
; 001A 01C7         printDebug("[iMangQueueAddItem]MangQueue Full.\r\n");
	__POINTD1FN _0x340000,865
	CALL SUBOPT_0x0
; 001A 01C8     }
; 001A 01C9     return viReturn;
_0x34005C:
	MOVW R30,R16
	CALL __LOADLOCR4
	ADIW R28,12
	RET
; 001A 01CA }
;iInt_t iMangQueueDelItem(iChar_t *pviFid_arg){
; 001A 01CB iInt_t iMangQueueDelItem(iChar_t *pviFid_arg){
_iMangQueueDelItem:
; 001A 01CC     iInt_t viReturn = -1;
; 001A 01CD     iInt_t i;
; 001A 01CE     iChar_t viFid[2];
; 001A 01CF 
; 001A 01D0     memcpy(viFid,&pviFid_arg[0],2);
	CALL SUBOPT_0x9F
;	*pviFid_arg -> Y+6
;	viReturn -> R16,R17
;	i -> R18,R19
;	viFid -> Y+4
	CALL _memcpy
; 001A 01D1     printDebug("[iMangQueueDelItem]Del by FID(%02x%02x).\r\n",viFid[0],viFid[1]);
	__POINTD1FN _0x340000,902
	CALL SUBOPT_0xA6
	LDD  R30,Y+13
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x7F
; 001A 01D2     for(i=0;i<MANG_QUEUE_MAX;i++){
	__GETWRN 18,19,0
_0x34005E:
	__CPWRN 18,19,2
	BRGE _0x34005F
; 001A 01D3         if(viMangQueue[i].value != NULL){
	CALL SUBOPT_0xA0
	CALL SUBOPT_0xA1
	BREQ _0x340060
; 001A 01D4             if(memcmp(viMangQueue[i].fid,&viFid[0],2)==0){
	CALL SUBOPT_0xA3
	CALL SUBOPT_0xA5
	CALL _memcmp
	CPI  R30,0
	BRNE _0x340061
; 001A 01D5                 free(viMangQueue[i].value);
	CALL SUBOPT_0xA0
	MOVW R26,R30
	CALL __GETW1P
	MOVW R26,R30
	CALL _free
; 001A 01D6                 viMangQueue[i].value = NULL;
	CALL SUBOPT_0xA0
	CALL SUBOPT_0xA7
; 001A 01D7                 memset(viMangQueue[i].fid,0,2);
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,2
	CALL SUBOPT_0xA8
	CALL SUBOPT_0x7
	CALL _memset
; 001A 01D8                 viMangQueue[i].length = 0;
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,5
	CALL SUBOPT_0xA7
; 001A 01D9                 viReturn = 1;
	__GETWRN 16,17,1
; 001A 01DA                 break;
	RJMP _0x34005F
; 001A 01DB             }else{
_0x340061:
; 001A 01DC                 viReturn = -1;
	__GETWRN 16,17,-1
; 001A 01DD             }
; 001A 01DE         }else{
	RJMP _0x340063
_0x340060:
; 001A 01DF             viReturn = 0;
	__GETWRN 16,17,0
; 001A 01E0         }
_0x340063:
; 001A 01E1     }
	__ADDWRN 18,19,1
	RJMP _0x34005E
_0x34005F:
; 001A 01E2     if(viReturn == 0){
	MOV  R0,R16
	OR   R0,R17
	BRNE _0x340064
; 001A 01E3         printDebug("[iMangQueueDelItem]Queue is empty.\r\n");
	__POINTD1FN _0x340000,945
	RJMP _0x340087
; 001A 01E4     }else if(viReturn == -1){
_0x340064:
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	CP   R30,R16
	CPC  R31,R17
	BRNE _0x340066
; 001A 01E5         printDebug("[iMangQueueDelItem]FID invalid.\r\n");
	__POINTD1FN _0x340000,982
_0x340087:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 001A 01E6     }
; 001A 01E7     return viReturn;
_0x340066:
	MOVW R30,R16
	CALL __LOADLOCR4
	JMP  _0x20E0030
; 001A 01E8 }
;
;void iMangQueueDisplay(){
; 001A 01EA void iMangQueueDisplay(){
_iMangQueueDisplay:
; 001A 01EB     iInt_t viReturn = -1;
; 001A 01EC     iInt_t i;
; 001A 01ED 
; 001A 01EE     for(i=0;i<MANG_QUEUE_MAX;i++){
	CALL __SAVELOCR4
;	viReturn -> R16,R17
;	i -> R18,R19
	__GETWRN 16,17,-1
	__GETWRN 18,19,0
_0x340068:
	__CPWRN 18,19,2
	BRGE _0x340069
; 001A 01EF         printDebug("[iMangQueueDisplay]Queue %d.[\r\n",i+1);
	__POINTD1FN _0x340000,1016
	CALL __PUTPARD1
	MOVW R30,R18
	ADIW R30,1
	CALL SUBOPT_0x6F
; 001A 01F0         if(viMangQueue[i].value != NULL){
	CALL SUBOPT_0xA0
	CALL SUBOPT_0xA1
	BREQ _0x34006A
; 001A 01F1            print_payload(viMangQueue[i].value,viMangQueue[i].length);
	CALL SUBOPT_0xA0
	MOVW R26,R30
	CALL SUBOPT_0xA4
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,5
	MOVW R26,R30
	CALL __GETW1P
	MOVW R26,R30
	CALL _print_payload
; 001A 01F2         }else{
	RJMP _0x34006B
_0x34006A:
; 001A 01F3            printDebug("Empty\r\n");
	__POINTD1FN _0x340000,1048
	CALL SUBOPT_0x0
; 001A 01F4         }
_0x34006B:
; 001A 01F5         printDebug("]\r\n");
	CALL SUBOPT_0xA9
; 001A 01F6     }
	__ADDWRN 18,19,1
	RJMP _0x340068
_0x340069:
; 001A 01F7 }
	CALL __LOADLOCR4
	ADIW R28,4
	RET
;
;iChar_t iMangCheckRetransmit(iChar_t *pviFid_arg){
; 001A 01F9 iChar_t iMangCheckRetransmit(iChar_t *pviFid_arg){
_iMangCheckRetransmit:
; 001A 01FA     iInt_t viReturn = -1;
; 001A 01FB     iInt_t i;
; 001A 01FC     iChar_t viFid[2];
; 001A 01FD 
; 001A 01FE     memcpy(viFid,&pviFid_arg[0],2);
	CALL SUBOPT_0x9F
;	*pviFid_arg -> Y+6
;	viReturn -> R16,R17
;	i -> R18,R19
;	viFid -> Y+4
	CALL _memcpy
; 001A 01FF     for(i=0;i<MANG_QUEUE_MAX;i++){
	__GETWRN 18,19,0
_0x34006D:
	__CPWRN 18,19,2
	BRLT PC+3
	JMP _0x34006E
; 001A 0200         if(viMangQueue[i].value != NULL){
	CALL SUBOPT_0xA0
	CALL SUBOPT_0xA1
	BREQ _0x34006F
; 001A 0201            if(memcmp(viMangQueue[i].fid,&viFid[0],2)==0){
	CALL SUBOPT_0xA3
	CALL SUBOPT_0xA5
	CALL _memcmp
	CPI  R30,0
	BRNE _0x340070
; 001A 0202                 printDebug("[iMangCheckRetransmit]Retransmit remain %d.\r\n",viMangQueue[i].reTransmit);
	__POINTD1FN _0x340000,1056
	CALL __PUTPARD1
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,4
	LD   R30,Z
	CALL SUBOPT_0x9E
; 001A 0203                 viMangQueue[i].reTransmit--;
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,4
	MOVW R26,R30
	LD   R30,X
	SUBI R30,LOW(1)
	ST   X,R30
; 001A 0204                 viReturn = viMangQueue[i].reTransmit;
	CALL SUBOPT_0xA3
	__ADDW1MN _viMangQueue,4
	LD   R16,Z
	CLR  R17
; 001A 0205                 if(viReturn<0){
	TST  R17
	BRPL _0x340071
; 001A 0206                    viReturn = 0;
	__GETWRN 16,17,0
; 001A 0207                 }
; 001A 0208                 break;
_0x340071:
	RJMP _0x34006E
; 001A 0209             }else{
_0x340070:
; 001A 020A                 viReturn = -1;
	__GETWRN 16,17,-1
; 001A 020B             }
; 001A 020C         }else{
	RJMP _0x340073
_0x34006F:
; 001A 020D            printDebug("There is no FID(%02x%02x) in queue.\r\n",viFid[0],viFid[1]);
	__POINTD1FN _0x340000,1102
	CALL SUBOPT_0xA6
	LDD  R30,Y+13
	CALL SUBOPT_0x7E
	CALL SUBOPT_0x7F
; 001A 020E         }
_0x340073:
; 001A 020F         printDebug("]\r\n");
	CALL SUBOPT_0xA9
; 001A 0210     }
	__ADDWRN 18,19,1
	RJMP _0x34006D
_0x34006E:
; 001A 0211     return viReturn;
	MOV  R30,R16
	CALL __LOADLOCR4
	JMP  _0x20E0030
; 001A 0212 }
;
;iChar_t mangInitDevice(){
; 001A 0214 iChar_t mangInitDevice(){
; 001A 0215 
; 001A 0216 }
;
;void memcpye(char eeprom *eptr, char *dptr, int len)
; 001A 0219 {
_memcpye:
; 001A 021A    int i=0;
; 001A 021B    for(i=0;i<len;i++) {
	CALL SUBOPT_0x13
;	*eptr -> Y+6
;	*dptr -> Y+4
;	len -> Y+2
;	i -> R16,R17
	__GETWRN 16,17,0
	__GETWRN 16,17,0
_0x340075:
	CALL SUBOPT_0x14
	BRGE _0x340076
; 001A 021C       *eptr++ = *dptr;
	CALL SUBOPT_0xAA
	LD   R30,X
	MOVW R26,R0
	CALL __EEPROMWRB
; 001A 021D       dptr++;
	CALL SUBOPT_0xAB
; 001A 021E    }
	__ADDWRN 16,17,1
	RJMP _0x340075
_0x340076:
; 001A 021F    return;
	JMP  _0x20E0031
; 001A 0220 }
;
;void memcpyd(char *dptr, char eeprom *eptr,  int len)
; 001A 0223 {
_memcpyd:
; 001A 0224    int i=0;
; 001A 0225    for(i=0;i<len;i++) {
	CALL SUBOPT_0x13
;	*dptr -> Y+6
;	*eptr -> Y+4
;	len -> Y+2
;	i -> R16,R17
	__GETWRN 16,17,0
	__GETWRN 16,17,0
_0x340078:
	CALL SUBOPT_0x14
	BRGE _0x340079
; 001A 0226       *dptr++ = *eptr;
	CALL SUBOPT_0xAA
	CALL __EEPROMRDB
	MOVW R26,R0
	ST   X,R30
; 001A 0227       eptr++;
	CALL SUBOPT_0xAB
; 001A 0228    }
	__ADDWRN 16,17,1
	RJMP _0x340078
_0x340079:
; 001A 0229    return;
	JMP  _0x20E0031
; 001A 022A }
;
;void printConfig(char eeprom *eptr,unsigned int len)
; 001A 022D {
_printConfig:
; 001A 022E    int i=0,j=0;
; 001A 022F    printDebug("[printConfig]Data:[\r\n");
	CALL SUBOPT_0x80
;	*eptr -> Y+6
;	len -> Y+4
;	i -> R16,R17
;	j -> R18,R19
	__POINTD1FN _0x340000,1140
	CALL SUBOPT_0x0
; 001A 0230    printDebug("%04d\t\t",0);
	CALL SUBOPT_0xAC
	CALL SUBOPT_0x23
	CALL SUBOPT_0x61
; 001A 0231    for(i=0,j=1;i<len;i++,j++) {
	__GETWRN 16,17,0
	__GETWRN 18,19,1
_0x34007B:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CP   R16,R30
	CPC  R17,R31
	BRSH _0x34007C
; 001A 0232       printDebug("%02x",*(eptr++));
	__POINTD1FN _0x340000,1169
	CALL __PUTPARD1
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	ADIW R26,1
	STD  Y+10,R26
	STD  Y+10+1,R27
	SBIW R26,1
	CALL __EEPROMRDB
	CALL SUBOPT_0x9E
; 001A 0233       if(j==8){
	LDI  R30,LOW(8)
	LDI  R31,HIGH(8)
	CP   R30,R18
	CPC  R31,R19
	BRNE _0x34007D
; 001A 0234          printDebug("\t\t");
	__POINTD1FN _0x340000,1166
	CALL SUBOPT_0x0
; 001A 0235       }else if(j==16){
	RJMP _0x34007E
_0x34007D:
	LDI  R30,LOW(16)
	LDI  R31,HIGH(16)
	CP   R30,R18
	CPC  R31,R19
	BRNE _0x34007F
; 001A 0236          printDebug("\r\n");
	__POINTD1FN _0x340000,28
	CALL SUBOPT_0x0
; 001A 0237          printDebug("%04d\t\t",i+1);
	CALL SUBOPT_0xAC
	MOVW R30,R16
	ADIW R30,1
	CALL SUBOPT_0x6F
; 001A 0238          j=0;
	__GETWRN 18,19,0
; 001A 0239       }
; 001A 023A    }
_0x34007F:
_0x34007E:
	__ADDWRN 16,17,1
	__ADDWRN 18,19,1
	RJMP _0x34007B
_0x34007C:
; 001A 023B    printDebug("\r\n]\r\n");
	__POINTD1FN _0x340000,1174
	CALL SUBOPT_0x0
; 001A 023C    return;
	CALL __LOADLOCR4
	JMP  _0x20E0030
; 001A 023D }
;
;void iSyncUniTime(unsigned long int *viUniTime_arg){
; 001A 023F void iSyncUniTime(unsigned long int *viUniTime_arg){
_iSyncUniTime:
; 001A 0240      unsigned long int viUniTimeTerminal;
; 001A 0241      unsigned long int viUniTimeServer;
; 001A 0242      struct rtc_structure rtcTest;
; 001A 0243 
; 001A 0244      //tim
; 001A 0245      viUniTimeTerminal = DS1672_read();
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,34
;	*viUniTime_arg -> Y+34
;	viUniTimeTerminal -> Y+30
;	viUniTimeServer -> Y+26
;	rtcTest -> Y+0
	CALL _DS1672_read
	CALL SUBOPT_0x43
; 001A 0246      viUniTimeServer = *viUniTime_arg;
	LDD  R26,Y+34
	LDD  R27,Y+34+1
	CALL __GETD1P
	CALL SUBOPT_0x44
; 001A 0247 
; 001A 0248      if((viUniTimeServer-viUniTimeTerminal)>40){
	CALL SUBOPT_0xAD
	__CPD1N 0x29
	BRSH _0x340088
; 001A 0249 //         printDebug("[iSyncUniTime]Terminal %ld\r\n",viUniTimeTerminal);
; 001A 024A //         printDebug("[iSyncUniTime]Server %ld\r\n",viUniTimeServer);
; 001A 024B //         printDebug("[iSyncUniTime]Time Diff %ld\r\n",(viUniTimeServer-viUniTimeTerminal));
; 001A 024C //
; 001A 024D //         printDebug("[iSyncUniTime]Update Time.\r\n");
; 001A 024E          RTC_setBinary(viUniTimeServer);
; 001A 024F //         RTC_getDateTime(&rtcTest,0);
; 001A 0250 //         printRTC(rtcTest);
; 001A 0251      }else if((viUniTimeServer-viUniTimeTerminal)>(-40)){
	CALL SUBOPT_0xAD
	__CPD1N 0xFFFFFFD9
	BRLO _0x340082
; 001A 0252 //         printDebug("[iSyncUniTime]Terminal %ld\r\n",viUniTimeTerminal);
; 001A 0253 //         printDebug("[iSyncUniTime]Server %ld\r\n",viUniTimeServer);
; 001A 0254 //         printDebug("[iSyncUniTime]Time Diff %ld\r\n",(viUniTimeServer-viUniTimeTerminal));
; 001A 0255 //
; 001A 0256 //         printDebug("[iSyncUniTime]Update Time.\r\n");
; 001A 0257          RTC_setBinary(viUniTimeServer);
_0x340088:
	__GETD2S 26
	CALL _RTC_setBinary
; 001A 0258 //         RTC_getDateTime(&rtcTest,0);
; 001A 0259 //         printRTC(rtcTest);
; 001A 025A      }
; 001A 025B 
; 001A 025C 
; 001A 025D }
_0x340082:
	ADIW R28,36
	RET
;#include "queue.h"
;
;piQueueHandle_t iQueueCreate(const unsigned int iItemQuantity_p,const unsigned int iItemLength_p){
; 001B 0003 piQueueHandle_t iQueueCreate(const unsigned int iItemQuantity_p,const unsigned int iItemLength_p){

	.CSEG
_iQueueCreate:
; 001B 0004 	iQueue_t * pviQueue;
; 001B 0005 
; 001B 0006 	piQueueHandle_t ipvReturnQueueHandle = NULL;
; 001B 0007 	pviQueue = (iQueue_t *)malloc(sizeof(iQueue_t));
	ST   -Y,R27
	ST   -Y,R26
	CALL SUBOPT_0xD
;	iItemQuantity_p -> Y+6
;	iItemLength_p -> Y+4
;	*pviQueue -> R16,R17
;	*ipvReturnQueueHandle -> R18,R19
	LDI  R26,LOW(16)
	CALL SUBOPT_0xAE
	MOVW R16,R30
; 001B 0008     if(pviQueue != NULL){
	MOV  R0,R16
	OR   R0,R17
	BRNE PC+3
	JMP _0x360003
; 001B 0009         pviQueue->head = (void *)malloc((iItemQuantity_p*iItemLength_p));
	CALL SUBOPT_0xAF
	MOVW R26,R30
	CALL _malloc
	__PUTW1RNS 16,8
; 001B 000A         if(pviQueue->head != NULL){
	CALL SUBOPT_0xB0
	SBIW R30,0
	BREQ _0x360004
; 001B 000B             pviQueue->itemCount = 0;  //Empty
	MOVW R26,R16
	ADIW R26,2
	CALL SUBOPT_0xB1
; 001B 000C             pviQueue->writeTo = pviQueue->head;
	CALL SUBOPT_0xB0
	__PUTW1RNS 16,12
; 001B 000D             pviQueue->readDataFrom = pviQueue->head;
	CALL SUBOPT_0xB0
	__PUTW1RNS 16,14
; 001B 000E             pviQueue->tail = pviQueue->head+((iItemQuantity_p*iItemLength_p)-iItemLength_p);
	MOVW R30,R16
	__GETWRZ 22,23,8
	CALL SUBOPT_0xAF
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	SUB  R30,R26
	SBC  R31,R27
	MOVW R26,R22
	CALL SUBOPT_0xB2
	__PUTW1RNS 16,10
; 001B 000F             pviQueue->itemLength = iItemLength_p;  //size of type
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	__PUTW1RNS 16,4
; 001B 0010             pviQueue->itemQuantity = iItemQuantity_p; //Quantity of item
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	MOVW R26,R16
	ST   X+,R30
	ST   X,R31
; 001B 0011             ipvReturnQueueHandle = pviQueue;
	MOVW R18,R16
; 001B 0012             printDebug("[iQueueCreate],itemCount(%d)\r\n",pviQueue->itemCount);
	__POINTD1FN _0x360000,0
	CALL __PUTPARD1
	CALL SUBOPT_0xB3
	CALL SUBOPT_0x6F
; 001B 0013             //printDebug("[iQueueCreate],itemCount2(%d)\r\n",((iQueue_t *)ipvReturnQueueHandle)->itemCount);
; 001B 0014         }else{
	RJMP _0x360005
_0x360004:
; 001B 0015             ipvReturnQueueHandle = (int *)(-1); //fail malloc
	__GETWRN 18,19,-1
; 001B 0016             printDebug("[iQueueCreate],Queue(Elen size) is not created!.\r\n");
	__POINTD1FN _0x360000,31
	CALL SUBOPT_0x0
; 001B 0017         }
_0x360005:
; 001B 0018     }else{
	RJMP _0x360006
_0x360003:
; 001B 0019        ipvReturnQueueHandle = (int *)(-1); //fail malloc
	__GETWRN 18,19,-1
; 001B 001A        printDebug("[iQueueCreate],Queue is not created!.\r\n");
	__POINTD1FN _0x360000,82
	CALL SUBOPT_0x0
; 001B 001B     }
_0x360006:
; 001B 001C     return ipvReturnQueueHandle;
	MOVW R30,R18
	CALL __LOADLOCR4
	JMP  _0x20E0030
; 001B 001D }
;
;int iQueueSend(piQueueHandle_t const iQueue_p,const void* const piItem_p){
; 001B 001F int iQueueSend(piQueueHandle_t const iQueue_p,const void* const piItem_p){
; 001B 0020     int ivReturn;
; 001B 0021     //int buffTest;
; 001B 0022     //iSTData_t idata;
; 001B 0023     iQueue_t * const piQueue = (iQueue_t *)iQueue_p;
; 001B 0024     //printDebug("[iQueueSend],itemCount(%d)\r\n",((iQueue_t * const)iQueue_p)->itemCount);
; 001B 0025     if(piQueue != NULL){
;	*iQueue_p -> Y+6
;	*piItem_p -> Y+4
;	ivReturn -> R16,R17
;	*piQueue -> R18,R19
; 001B 0026         if(piQueue->itemCount == 0){
; 001B 0027             printDebug("<iQueueSend>status(empty)\r\n");
; 001B 0028             piQueue->writeTo = piQueue->head;
; 001B 0029             piQueue->readDataFrom = piQueue->head;
; 001B 002A 
; 001B 002B             piQueue->itemCount++;
; 001B 002C             memcpy((void*)piQueue->writeTo,piItem_p,piQueue->itemLength);
; 001B 002D 
; 001B 002E 
; 001B 002F             //test read
; 001B 0030 //            memcpy(&buffTest,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 0031 //            printf("<iQueueSend>data = %d\r\n",buffTest);
; 001B 0032 //            memcpy(&idata,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 0033 //            printf("<iQueueSend>data len(%d)\r\n",idata.length);
; 001B 0034 
; 001B 0035             piQueue->writeTo += piQueue->itemLength; //address will write data a next.
; 001B 0036             ivReturn = 1;
; 001B 0037         }else if((piQueue->itemCount > 0) && (piQueue->itemCount < piQueue->itemQuantity) ){
; 001B 0038             piQueue->itemCount++;
; 001B 0039             memcpy((void*)piQueue->writeTo,piItem_p,piQueue->itemLength);
; 001B 003A 
; 001B 003B             //test read
; 001B 003C //            memcpy(&buffTest,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 003D //            printf("<iQueueSend>data = %d\r\n",buffTest);
; 001B 003E //            memcpy(&idata,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 003F //            printf("<iQueueSend>data len(%d)\r\n",idata.length);
; 001B 0040 
; 001B 0041             piQueue->writeTo += piQueue->itemLength; //address will write data a next.
; 001B 0042             ivReturn = 1;
; 001B 0043         }else if((piQueue->itemCount) < 0 || (piQueue->itemCount > piQueue->itemQuantity)){
; 001B 0044             printDebug("<iQueueSend>status(item count is not range)\r\n)");
; 001B 0045             ivReturn = -1;
; 001B 0046             //while(1); //reset wdt
; 001B 0047         }else if(piQueue->itemCount == piQueue->itemQuantity){
; 001B 0048             piQueue->writeTo = piQueue->head;
; 001B 0049             printDebug("<iQueueSend>status(full and wait)\r\n");
; 001B 004A             ivReturn = -1;
; 001B 004B         }
; 001B 004C         //printf("<iQueueSend>item count(%d)\r\n",piQueue->itemCount);
; 001B 004D     }else{
; 001B 004E         ivReturn = -1; //fail malloc ref = NULL
; 001B 004F     }
; 001B 0050     //printf("<iQueueSend>count(%d)\r\n",piQueue->itemCount);
; 001B 0051     printDebug("<iQueueSend>count(%d)\r\n",piQueue->itemCount);
; 001B 0052     return ivReturn;
; 001B 0053 }
;
;int iQueueReceive(piQueueHandle_t iQueue_p,void* const piItem_p){
; 001B 0055 int iQueueReceive(piQueueHandle_t iQueue_p,void* const piItem_p){
; 001B 0056     int ivReturn;
; 001B 0057     //int buffTest;
; 001B 0058     iQueue_t * const piQueue = (iQueue_t *)iQueue_p;
; 001B 0059 
; 001B 005A     if(piQueue != NULL){
;	*iQueue_p -> Y+6
;	*piItem_p -> Y+4
;	ivReturn -> R16,R17
;	*piQueue -> R18,R19
; 001B 005B         if(piQueue->itemCount == 0){
; 001B 005C             //printf("<iQueueReceive>QueueItem is empty it can not read.\r\n");
; 001B 005D             printDebug("<iQueueReceive>QueueItem is empty it can not read.\r\n");
; 001B 005E             ivReturn = -1;
; 001B 005F         }else if(piQueue->itemCount > 0){
; 001B 0060             //printf("<iQueueReceive>QueueItem is exist.\r\n");
; 001B 0061             printDebug("<iQueueReceive>QueueItem is exist.\r\n");
; 001B 0062             if(piQueue->readDataFrom < piQueue->tail){
; 001B 0063 
; 001B 0064                 piQueue->itemCount--;
; 001B 0065                 memcpy(piItem_p,(void*)piQueue->readDataFrom,piQueue->itemLength);
; 001B 0066                 //memcpy((void*)piQueue->writeTo,piItem_p,piQueue->itemLength);
; 001B 0067 
; 001B 0068 //                memcpy(&buffTest,(void*)piQueue->readDataFrom,piQueue->itemLength);
; 001B 0069 //                printf("<iQueueReceive>data = %d\r\n",buffTest);
; 001B 006A 
; 001B 006B                 piQueue->readDataFrom += piQueue->itemLength;
; 001B 006C                 ivReturn = 1;
; 001B 006D             }else if(piQueue->readDataFrom == piQueue->tail){
; 001B 006E                 piQueue->itemCount--;
; 001B 006F                 piQueue->readDataFrom = piQueue->head;
; 001B 0070             }
; 001B 0071         }
; 001B 0072     }else{
; 001B 0073         ivReturn = -1; //fail malloc ref = NULL
; 001B 0074     }
; 001B 0075     //printf("<iQueueReceive>count(%d)\r\n",piQueue->itemCount);
; 001B 0076     printDebug("<iQueueReceive>count(%d)\r\n",piQueue->itemCount);
; 001B 0077     return ivReturn;
; 001B 0078 }
;#include "transmitInitial.h"
;
;
;#include "schedulerTask.h"
;
;int task_count_g = 0;
;
;iTask_t *pviTaskList[MAX_TASK];
;
;itaskHandel_t iTaskCreate(piTaskFunction piTaskCode_p,const char * const name_p,uint_t priority_p){
; 001D 0007 itaskHandel_t iTaskCreate(piTaskFunction piTaskCode_p,const char * const name_p,uint_t priority_p){

	.CSEG
_iTaskCreate:
; 001D 0008     itaskHandel_t pvTaskHandleReturn;
; 001D 0009     iTask_t *pviTaskNew;
; 001D 000A     void * vp;
; 001D 000B     int i = 0;
; 001D 000C     vp = &i;
	ST   -Y,R27
	ST   -Y,R26
	CALL SUBOPT_0xB4
;	*piTaskCode_p -> Y+12
;	*name_p -> Y+10
;	priority_p -> Y+8
;	*pvTaskHandleReturn -> R16,R17
;	*pviTaskNew -> R18,R19
;	*vp -> R20,R21
;	i -> Y+6
	MOVW R30,R28
	ADIW R30,6
	MOVW R20,R30
; 001D 000D 
; 001D 000E     if(task_count_g < MAX_TASK){
	LDS  R26,_task_count_g
	LDS  R27,_task_count_g+1
	SBIW R26,6
	BRGE _0x3A0003
; 001D 000F         pviTaskNew = (iTask_t *)malloc(sizeof(iTask_t));
	LDI  R26,LOW(24)
	CALL SUBOPT_0xAE
	MOVW R18,R30
; 001D 0010         if(pviTaskNew != NULL){
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x3A0004
; 001D 0011             printDebug("<iTaskCreate>Task can create.\r\n");
	__POINTD1FN _0x3A0000,0
	CALL SUBOPT_0x0
; 001D 0012             pviTaskNew->id = 0;
	MOVW R26,R18
	CALL SUBOPT_0xB1
; 001D 0013             pviTaskNew->hookFunction = piTaskCode_p;
	CALL SUBOPT_0x55
	__PUTD1RNS 18,2
; 001D 0014             memcpy(pviTaskNew->name,name_p,MAX_TASK_NAME);
	MOVW R30,R18
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x75
	LDI  R26,LOW(16)
	CALL SUBOPT_0x83
; 001D 0015             pviTaskNew->priority = priority_p;
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	__PUTW1RNS 18,22
; 001D 0016 
; 001D 0017             pviTaskList[task_count_g] = pviTaskNew;
	CALL SUBOPT_0xB5
	LDI  R26,LOW(_pviTaskList)
	LDI  R27,HIGH(_pviTaskList)
	CALL SUBOPT_0xB2
	ST   Z,R18
	STD  Z+1,R19
; 001D 0018             task_count_g++;
	LDI  R26,LOW(_task_count_g)
	LDI  R27,HIGH(_task_count_g)
	CALL SUBOPT_0x11
; 001D 0019 
; 001D 001A         }else{
	RJMP _0x3A0005
_0x3A0004:
; 001D 001B             printDebug("<iTaskCreate>Task can not create.\r\n");
	__POINTD1FN _0x3A0000,32
	CALL SUBOPT_0x0
; 001D 001C             pvTaskHandleReturn = (int *)(-1);
	__GETWRN 16,17,-1
; 001D 001D         }
_0x3A0005:
; 001D 001E     }else if(task_count_g == MAX_TASK){
	RJMP _0x3A0006
_0x3A0003:
	LDS  R26,_task_count_g
	LDS  R27,_task_count_g+1
	SBIW R26,6
	BRNE _0x3A0007
; 001D 001F         pvTaskHandleReturn = (void *)(-1);
	__GETWRN 16,17,-1
; 001D 0020     }
; 001D 0021 
; 001D 0022 
; 001D 0023 //    if(task_count_g == 0){
; 001D 0024 //        piTaskList_p->taskValue = pviTaskNew;
; 001D 0025 //        piTaskList_p->next = NULL;
; 001D 0026 //        task_count_g ++;
; 001D 0027 //        piTaskList_p->taskValue->hookFunction(vp);
; 001D 0028 //    }else if(task_count_g > 0){
; 001D 0029 ////        piTaskList_p->taskValue = pviTaskNew;
; 001D 002A ////        piTaskList_p->next = NULL;
; 001D 002B ////        task_count_g ++;
; 001D 002C //    }
; 001D 002D     //pviTaskNew->hookFunction(vp);
; 001D 002E     //piTaskCode_p(vp);
; 001D 002F     //free(pviTaskNew);
; 001D 0030     return pvTaskHandleReturn;
_0x3A0007:
_0x3A0006:
	MOVW R30,R16
	CALL __LOADLOCR6
	ADIW R28,16
	RET
; 001D 0031 }
;
;void startSchedulerTask(){
; 001D 0033 void startSchedulerTask(){
_startSchedulerTask:
; 001D 0034     itaskHandel_t pvTaskRunHandle;
; 001D 0035     void * vp;       //parameter
; 001D 0036     int i=0;
; 001D 0037     int j=0;
; 001D 0038     //pvTaskRunHandle = iTaskCreate(task_a_print,"TaskAP",5);
; 001D 0039     for(;;){
	CALL SUBOPT_0xB4
;	*pvTaskRunHandle -> R16,R17
;	*vp -> R18,R19
;	i -> R20,R21
;	j -> Y+6
	__GETWRN 20,21,0
_0x3A0009:
; 001D 003A         #asm("wdr")
	wdr
; 001D 003B         for(i=0;i<task_count_g;i++){
	__GETWRN 20,21,0
_0x3A000C:
	CALL SUBOPT_0xB5
	CP   R20,R30
	CPC  R21,R31
	BRLT PC+3
	JMP _0x3A000D
; 001D 003C             for(j=0;j<task_count_g;j++){
	LDI  R30,LOW(0)
	STD  Y+6,R30
	STD  Y+6+1,R30
_0x3A000F:
	CALL SUBOPT_0xB5
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R30
	CPC  R27,R31
	BRGE _0x3A0010
; 001D 003D                 if(pviTaskList[j]->priority == 10){
	CALL SUBOPT_0xB6
	ADIW R30,22
	MOVW R26,R30
	CALL __GETW1P
	CPI  R30,LOW(0xA)
	LDI  R26,HIGH(0xA)
	CPC  R31,R26
	BRNE _0x3A0011
; 001D 003E                     pviTaskList[j]->hookFunction(vp);
	CALL SUBOPT_0xB6
	ADIW R30,2
	MOVW R26,R30
	CALL __GETD1P
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R18
	POP  R30
	POP  R31
	POP  R22
	POP  R23
	OUT  EIND,R22
	EICALL
; 001D 003F                 }
; 001D 0040             }
_0x3A0011:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	RJMP _0x3A000F
_0x3A0010:
; 001D 0041             pviTaskList[i]->hookFunction(vp);
	MOVW R30,R20
	LDI  R26,LOW(_pviTaskList)
	LDI  R27,HIGH(_pviTaskList)
	CALL SUBOPT_0xB7
	ADIW R30,2
	MOVW R26,R30
	CALL __GETD1P
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R18
	POP  R30
	POP  R31
	POP  R22
	POP  R23
	OUT  EIND,R22
	EICALL
; 001D 0042         }
	__ADDWRN 20,21,1
	RJMP _0x3A000C
_0x3A000D:
; 001D 0043     }
	RJMP _0x3A0009
; 001D 0044 //    for(i=0;i<task_count_g;i++){
; 001D 0045 //        pviTaskList[i]->hookFunction(vp);
; 001D 0046 //    }
; 001D 0047 }
;#include "debugTask.h"
;
;
;void debugTask(void * pviParameter){
; 001E 0004 void debugTask(void * pviParameter){

	.CSEG
; 001E 0005     printDebug("<debugTask>Task Running...\r\n");
;	*pviParameter -> Y+0
; 001E 0006 }
;#include <delay.h>
;#include "communicateTask.h"
;#include "interruptTask.h"
;#include "wiz100rs.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;
;
;void communicateTask(void * pviParameter){
; 001F 0007 void communicateTask(void * pviParameter){

	.CSEG
; 001F 0008     printDebug("<communicateTask>Task Running...\r\n");
;	*pviParameter -> Y+0
; 001F 0009 //
; 001F 000A //    if(pviUart0TimeOut == 0){
; 001F 000B //        pviUart0TimeOut   = 1;
; 001F 000C //    }
; 001F 000D     //delay_ms(1000);
; 001F 000E     //iWizGetConf();
; 001F 000F 
; 001F 0010 }
;#include "lan.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "timer.h"
;#include "io.h"
;#include "debug.h"
;
;extern iData_t viRXData;
;extern iData_t viTXData;
;
;
;char AckHostData[20] = {
;    0x7E,
;    0x00,0x10,
;    0x08,0x00,
;    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
;    0x64,0x75,0xC9,0x55,
;    0x00,0x00,
;    0xD8
;};

	.DSEG
;
;iUChar_t iLanReadData(iData_t * pviData_agr){
; 0020 0014 iUChar_t iLanReadData(iData_t * pviData_agr){

	.CSEG
_iLanReadData:
; 0020 0015     iUChar_t viReturn;
; 0020 0016     TIMER   timeout;
; 0020 0017     iUChar_t viModeConnect = 0;     //0= no check connect  ,1 == check connect
; 0020 0018 
; 0020 0019    viReturn = LEN_DATA_EMPTY;
	CALL SUBOPT_0x5C
	ST   -Y,R16
;	*pviData_agr -> Y+6
;	viReturn -> R17
;	timeout -> Y+2
;	viModeConnect -> R16
	LDI  R16,0
	LDI  R17,LOW(0)
; 0020 001A    TIMER_setTimer(&timeout, 7);
	CALL SUBOPT_0x69
	__GETD2N 0x7
	CALL _TIMER_setTimer
; 0020 001B 
; 0020 001C    iWizRXMode = WIZ_RX_DATA_MODE;
	LDI  R30,LOW(2)
	STS  _iWizRXMode,R30
; 0020 001D   // delay_ms(1000);
; 0020 001E    while(!TIMER_checkTimerExceed(timeout)){
_0x400004:
	CALL SUBOPT_0x3F
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	BREQ PC+3
	JMP _0x400006
; 0020 001F       delay_ms(50);
	CALL SUBOPT_0xB
; 0020 0020       #asm("wdr")
	wdr
; 0020 0021       if(iWizRead()){
	RCALL _iWizRead
	SBIW R30,0
	BREQ _0x400007
; 0020 0022         printDebug("[iLanReadData]iWizRead:OK.\r\n");
	__POINTD1FN _0x400000,0
	CALL SUBOPT_0x0
; 0020 0023         viReturn = LEN_DATA_AVAILABLE;
	LDI  R17,LOW(1)
; 0020 0024         if(viRXData.length>0){
	LDS  R26,_viRXData
	LDS  R27,_viRXData+1
	CALL __CPW02
	BRGE _0x400008
; 0020 0025             pviData_agr->length = viRXData.length;
	LDS  R30,_viRXData
	LDS  R31,_viRXData+1
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ST   X+,R30
	ST   X,R31
; 0020 0026             memcpy(&pviData_agr->value[0],&viRXData.value[0],viRXData.length);
	CALL SUBOPT_0xB8
	__POINTW1MN _viRXData,2
	CALL SUBOPT_0x7C
	CALL _memcpy
; 0020 0027             printDebug("[iLanReadData]Data:OK[\r\n");
	__POINTD1FN _0x400000,29
	CALL SUBOPT_0x0
; 0020 0028             print_payload(&viRXData.value[0], viRXData.length);
	__POINTW1MN _viRXData,2
	CALL SUBOPT_0x7C
	CALL _print_payload
; 0020 0029             printDebug("]\r\n");
	__POINTD1FN _0x400000,54
	CALL SUBOPT_0x0
; 0020 002A         }else{
_0x400008:
; 0020 002B 
; 0020 002C         }
; 0020 002D         break;
	RJMP _0x400006
; 0020 002E       }else{
_0x400007:
; 0020 002F         printDebug("[iLanReadData]iWizRead:empty.\r\n");
	__POINTD1FN _0x400000,58
	CALL SUBOPT_0x0
; 0020 0030         viReturn = LEN_DATA_EMPTY;
	LDI  R17,LOW(0)
; 0020 0031       }
; 0020 0032    }
	RJMP _0x400004
_0x400006:
; 0020 0033     return viReturn;
	RJMP _0x20E002F
; 0020 0034 }
;
;//iUChar_t iLanWriteData(){
;//    iUChar_t viReturn;
;//    TIMER   timeout;
;//
;//    iWizRXMode = WIZ_RX_STAT_MODE;
;//    viReturn = LEN_DATA_WRITE_FAIL;
;//    TIMER_setTimer(&timeout, 20);
;//
;//    while(!TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//       if(iWizConnected()){
;//            printDebug("[iLanWriteData]Status:Connected.\r\n");
;//            iWizRXMode = WIZ_RX_DATA_MODE;
;//            iWizSend(viGenDataElem,sizeof(viGenDataElem));
;//            viReturn = LEN_DATA_WRITE_SUCCESS;
;//            break;
;//       } else{
;//            viReturn = LEN_DATA_WRITE_FAIL;
;//            printDebug("[iLanWriteData]Status:Close.\r\n");
;//       }
;//    }
;//    return viReturn;
;//}
;
;iUChar_t iLanWriteData(iData_t * pviData_agr){
; 0020 004F iUChar_t iLanWriteData(iData_t * pviData_agr){
_iLanWriteData:
; 0020 0050     iUChar_t viReturn;
; 0020 0051     TIMER   timeout;
; 0020 0052     iUChar_t viModeConnect = 0;     //0= no check connect  ,1 == check connect
; 0020 0053 
; 0020 0054     iWizRXMode = WIZ_RX_STAT_MODE;
	CALL SUBOPT_0x5C
	ST   -Y,R16
;	*pviData_agr -> Y+6
;	viReturn -> R17
;	timeout -> Y+2
;	viModeConnect -> R16
	LDI  R16,0
	LDI  R30,LOW(1)
	STS  _iWizRXMode,R30
; 0020 0055     viReturn = LEN_DATA_WRITE_FAIL;
	LDI  R17,LOW(0)
; 0020 0056     //TIMER_setTimer(&timeout, 20);
; 0020 0057 
; 0020 0058 //       if(iWizConnected()){
; 0020 0059 //            printDebug("[iLanWriteData]Status:Connected.\r\n");
; 0020 005A //            iWizRXMode = WIZ_RX_DATA_MODE;
; 0020 005B //            iWizSend(pviData_agr->value,pviData_agr->length);
; 0020 005C //            iWizRXMode = WIZ_RX_DATA_MODE;
; 0020 005D //            viReturn = LEN_DATA_WRITE_SUCCESS;
; 0020 005E //       } else{
; 0020 005F //            viReturn = LEN_DATA_WRITE_FAIL;
; 0020 0060 //            printDebug("[iLanWriteData]Status:Close.\r\n");
; 0020 0061 //       }
; 0020 0062 
; 0020 0063        if(viModeConnect==0){
	CPI  R16,0
	BRNE _0x40000B
; 0020 0064            iWizRXMode = WIZ_RX_DATA_MODE;
	LDI  R30,LOW(2)
	STS  _iWizRXMode,R30
; 0020 0065            iWizSend(pviData_agr->value,pviData_agr->length);
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xA2
	MOVW R26,R30
	RCALL _iWizSend
; 0020 0066            viReturn = LEN_DATA_WRITE_SUCCESS;
	LDI  R17,LOW(1)
; 0020 0067        }
; 0020 0068 
; 0020 0069 
; 0020 006A     return viReturn;
_0x40000B:
_0x20E002F:
	MOV  R30,R17
_0x20E0031:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E0030:
	ADIW R28,8
	RET
; 0020 006B }
;
;iChar_t iLanInit(){
; 0020 006D iChar_t iLanInit(){
_iLanInit:
; 0020 006E        iChar_t viReturn;
; 0020 006F 
; 0020 0070        iWizRXMode = WIZ_RX_STAT_MODE;
	ST   -Y,R17
;	viReturn -> R17
	LDI  R30,LOW(1)
	STS  _iWizRXMode,R30
; 0020 0071        if(iWizConnected()){
	RCALL _iWizConnected
	SBIW R30,0
	BREQ _0x40000C
; 0020 0072             printDebug("[iLanInit]Status:Connected.\r\n");
	__POINTD1FN _0x400000,90
	CALL SUBOPT_0x0
; 0020 0073             iWizRXMode = WIZ_RX_DATA_MODE;
	LDI  R30,LOW(2)
	STS  _iWizRXMode,R30
; 0020 0074             viReturn = LEN_DATA_WRITE_SUCCESS;
	LDI  R17,LOW(1)
; 0020 0075        } else{
	RJMP _0x40000D
_0x40000C:
; 0020 0076             viReturn = LEN_DATA_WRITE_FAIL;
	LDI  R17,LOW(0)
; 0020 0077             printDebug("[iLanInit]Status:Close.\r\n");
	__POINTD1FN _0x400000,120
	CALL SUBOPT_0x0
; 0020 0078        }
_0x40000D:
; 0020 0079        return viReturn;
	MOV  R30,R17
	LD   R17,Y+
	RET
; 0020 007A }
;#include <delay.h>
;#include "interruptTask.h"
;#include "wiz100rs.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "uart.h"
;#include "debug.h"
;#include "ethcomm.h"
;#include "io.h"
;#include "timer.h"
;
;int flagConnect = 0;
;
;iWiz100srConfig_t iWiz100srConfig;
;//char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nUser-Agent: AVR2560-LAN\r\nConnection: close\r\nContent-Length: ";
;//char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nX-CLIENT-UUID: 001100110011\r\nUser-Agent: AVR2560-LAN\r\nConnection: close\r\nContent-Length: ";
;
;
;//iWiz100srData_t iWiz100srData;
;
;void (*pfiWiz100rs)(void);
;int (*piWizCallBack)(char *,unsigned int);
;
;extern unsigned int rxBeginCount;
;extern piInterrupt_t pviUart0TimeOut;
;extern char rx0Buffer[];
;extern unsigned int index0Buffer;
;//char *pviValue;
;//char pviValue[RX_BUFFER_SIZE0];
;unsigned char iWizStatus = 0;
;unsigned char iWizRXMode = 0;
;//iWiz100srConnection iWizStatus;
;iWiz100srConnection iWizData;
;iHTTP_t iHTTPStatus;
;
;//iWizStatus.status = 0;
;
;void iWizGetConf(){
; 0021 0024 void iWizGetConf(){

	.CSEG
; 0021 0025     int i;
; 0021 0026     char    readCmd[] = ">R\r";
; 0021 0027     WIZ100RS_CONF_MODE;        //change to configure mode
;	i -> R16,R17
;	readCmd -> Y+2
; 0021 0028 
; 0021 0029 
; 0021 002A     ETH_CONF;
; 0021 002B 
; 0021 002C     //module off then on
; 0021 002D     WIZ100RS_OFF;
; 0021 002E     delay_ms(10);
; 0021 002F     WIZ100RS_ON;
; 0021 0030     delay_ms(1000);
; 0021 0031 
; 0021 0032     for(i=0;i<strlen(readCmd);i++){
; 0021 0033         putchar0(readCmd[i]);
; 0021 0034     }
; 0021 0035 }
;void iWizSetConf(){}
; 0021 0036 void iWizSetConf(){}
;
;
;void iWizTXdata(){}
; 0021 0039 void iWizTXdata(){}
;
;
;void iWizRXTimeOut(){
; 0021 003C void iWizRXTimeOut(){
; 0021 003D      rxBeginCount = 0;
; 0021 003E      pviUart0TimeOut = -1;
; 0021 003F      wiz100srSetTimer = -1;
; 0021 0040      printDebug("<iWizRXTimeOut>\r\n");
; 0021 0041 }
;
;int iWizCBCheckHTTPResCode(char *const data_p,unsigned int const len_p){
; 0021 0043 int iWizCBCheckHTTPResCode(char *const data_p,unsigned int const len_p){
; 0021 0044      char *iWizCheckHTTPResCode;
; 0021 0045      int i;
; 0021 0046      char * pch;
; 0021 0047      int iReturn = 0;
; 0021 0048      iWizCheckHTTPResCode = (char *)malloc(len_p);
;	*data_p -> Y+10
;	len_p -> Y+8
;	*iWizCheckHTTPResCode -> R16,R17
;	i -> R18,R19
;	*pch -> R20,R21
;	iReturn -> Y+6
; 0021 0049      if(iWizCheckHTTPResCode != NULL){
; 0021 004A         memcpy(&iWizCheckHTTPResCode[0],&data_p[0],len_p);
; 0021 004B         pch = strtok (iWizCheckHTTPResCode," ");
; 0021 004C         while(pch != NULL){
; 0021 004D             //printDebug("%s\r\n",pch);
; 0021 004E             if (strncmp (pch,"200",3) == 0)
; 0021 004F             {
; 0021 0050                 printDebug("[Res code: %s]\r\n",pch);
; 0021 0051                 iReturn = 1;
; 0021 0052                 break;
; 0021 0053             }
; 0021 0054             pch = strtok (NULL, " ");
; 0021 0055         }
; 0021 0056      }
; 0021 0057      free(iWizCheckHTTPResCode);
; 0021 0058      return iReturn;
; 0021 0059 }

	.DSEG
_0x42000B:
	.BYTE 0x4
;int iWizCBCheckHTTPContextLen(char *const data_p,unsigned int const len_p){
; 0021 005A int iWizCBCheckHTTPContextLen(char *const data_p,unsigned int const len_p){

	.CSEG
; 0021 005B      char *iWizCheckHTTPContextLen;
; 0021 005C      int i;
; 0021 005D      char * pch;
; 0021 005E      int iReturn = 0;
; 0021 005F      iWizCheckHTTPContextLen = (char *)malloc(len_p);
;	*data_p -> Y+10
;	len_p -> Y+8
;	*iWizCheckHTTPContextLen -> R16,R17
;	i -> R18,R19
;	*pch -> R20,R21
;	iReturn -> Y+6
; 0021 0060      if(iWizCheckHTTPContextLen != NULL){
; 0021 0061         memcpy(&iWizCheckHTTPContextLen[0],&data_p[0],len_p);
; 0021 0062         pch = strtok (iWizCheckHTTPContextLen," ");
; 0021 0063         while(pch != NULL){
; 0021 0064             if (strncmp (pch,"Content-Length",14) == 0)
; 0021 0065             {
; 0021 0066                 pch = strtok (NULL, " ");
; 0021 0067                 if(pch != NULL){
; 0021 0068                     //if (strncmp (pch,"Content-Length",14) == 0){
; 0021 0069                         printDebug("[Res len: %s]\r\n",pch);
; 0021 006A                         //iReturn = atoi(pch);
; 0021 006B                         iHTTPStatus.contentLength = atoi(pch);
; 0021 006C                         iReturn = 1;
; 0021 006D                         printDebug("[Res len: %d]\r\n",iReturn);
; 0021 006E                     //    if(iReturn <= 0){
; 0021 006F                     //         iReturn = WIZ_HTTP_CONTEXT_LEN_LESS;         //< 0
; 0021 0070                     //    }else if(iReturn > 400){
; 0021 0071                     //        iReturn = WIZ_HTTP_CONTEXT_LEN_OVER;          // > 400
; 0021 0072                     //    }
; 0021 0073                         break;
; 0021 0074                     //}
; 0021 0075                 }
; 0021 0076             }else{
; 0021 0077                 printDebug("[Notfound Res len]\r\n");
; 0021 0078                 break;
; 0021 0079             }
; 0021 007A             //pch = strtok (NULL, " ");
; 0021 007B         }
; 0021 007C      }else{
; 0021 007D         printDebug("[wizContentLen]can 't allocate mem.\r\n");
; 0021 007E      }
; 0021 007F      free(iWizCheckHTTPContextLen);
; 0021 0080      return iReturn;
; 0021 0081 }

	.DSEG
_0x420011:
	.BYTE 0xF
;
;int iWizCBChekStat(char *const data_p,unsigned int const len_p){
; 0021 0083 int iWizCBChekStat(char *const data_p,unsigned int const len_p){

	.CSEG
; 0021 0084      char *iWizCheckStat;
; 0021 0085      int i;
; 0021 0086      iWizCheckStat = (char *)malloc(len_p);
;	*data_p -> Y+6
;	len_p -> Y+4
;	*iWizCheckStat -> R16,R17
;	i -> R18,R19
; 0021 0087      if(iWizCheckStat != NULL){
; 0021 0088          memcpy(&iWizCheckStat[0],&data_p[0],len_p);
; 0021 0089          //printDebug("stat[%d](%s)\r\n",len_p,iWizCheckStat);
; 0021 008A //         printDebug("status[%d][",len_p);
; 0021 008B //         for(i=0;i<len_p;i++){
; 0021 008C //            printDebug("%c",*(iWizCheckStat++));
; 0021 008D //         }
; 0021 008E //         printDebug("]\r\n");
; 0021 008F          iWizData.status = WIZ_UNKNOW;
; 0021 0090          if (strncmp (iWizCheckStat,"> Connected",11) == 0)
; 0021 0091          {
; 0021 0092             iWizData.status = WIZ_CONNECTED;
; 0021 0093          }else if(strncmp (iWizCheckStat,"> Closed",8) == 0){
; 0021 0094             iWizData.status = WIZ_CLOSE;
; 0021 0095          }else{
; 0021 0096             iWizData.status = WIZ_UNKNOW;
; 0021 0097          }
; 0021 0098      }else{
; 0021 0099         printDebug("[wizStat]can 't allocate mem.\r\n");
; 0021 009A      }
; 0021 009B      free(iWizCheckStat);
; 0021 009C      return 0;
; 0021 009D }

	.DSEG
_0x420017:
	.BYTE 0x15
;int iWizCBReadData(char *const data_p,unsigned int const len_p){
; 0021 009E int iWizCBReadData(char *const data_p,unsigned int const len_p){

	.CSEG
; 0021 009F      char *iWizReadData;
; 0021 00A0      int i;
; 0021 00A1      iWizReadData = (char *)malloc(len_p);
;	*data_p -> Y+6
;	len_p -> Y+4
;	*iWizReadData -> R16,R17
;	i -> R18,R19
; 0021 00A2      if(iWizReadData != NULL){
; 0021 00A3          memcpy(&iWizReadData[0],&data_p[0],len_p);
; 0021 00A4          //printDebug("stat[%d](%s)\r\n",len_p,iWizCheckStat);
; 0021 00A5 //         printDebug("status[%d][",len_p);
; 0021 00A6 //         for(i=0;i<len_p;i++){
; 0021 00A7 //            printDebug("%c",*(iWizCheckStat++));
; 0021 00A8 //         }
; 0021 00A9 //         printDebug("]\r\n");
; 0021 00AA          //iWizData.status = WIZ_UNKNOW;
; 0021 00AB //         if (strncmp (iWizReadData,"> Connected",11) == 0)
; 0021 00AC //         {
; 0021 00AD //            iWizData.status = WIZ_CONNECTED;
; 0021 00AE //         }else if(strncmp (iWizReadData,"> Closed",8) == 0){
; 0021 00AF //            iWizData.status = WIZ_CLOSE;
; 0021 00B0 //         }else{
; 0021 00B1 //            iWizData.status = WIZ_UNKNOW;
; 0021 00B2 //         }
; 0021 00B3      }else{
; 0021 00B4         printDebug("[wizStat]can 't allocate mem.\r\n");
; 0021 00B5      }
; 0021 00B6      free(iWizReadData);
; 0021 00B7      return 0;
; 0021 00B8 }
;
;void iWizSend(const char * data_p,int len_p){
; 0021 00BA void iWizSend(const char * data_p,int len_p){
_iWizSend:
; 0021 00BB      //char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nUser-Agent: IMS_Test\r\nConnection: close\r\nContent-Length: ";
; 0021 00BC      //char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nUser-Agent: AVR2560-LAN\r\nConnection: close\r\nContent-Length: ";
; 0021 00BD      char *pviWizBuff;
; 0021 00BE      char lenData[10];
; 0021 00BF      int indexWrite = 0;
; 0021 00C0      char ivHTTPHeaderMethod[] = "POST /smasmartdevice HTTP/1.1";               //29
; 0021 00C1      char ivHTTPHeaderHost[]  = "\r\nHost: smasmartdevice.appspot.com";    //34
; 0021 00C2      char ivHTTPHeaderMac[]   = "\r\nX-CLIENT-UUID: ";                     //18
; 0021 00C3      //char ivHTTPHeaderUser[]  = "\r\nUser-Agent: AVR2560-LAN";             //23
; 0021 00C4      char ivHTTPHeaderConn[]  = "\r\nConnection: close";                   //17
; 0021 00C5      char ivHTTPHeaderLen[]   = "\r\nContent-Length: ";                    //16
; 0021 00C6 
; 0021 00C7      //char
; 0021 00C8 
; 0021 00C9 //     printDebug("[wizSend]Print-1.[\r\n");
; 0021 00CA //     print_payload(data_p, len_p);
; 0021 00CB //     printDebug("]\r\n");
; 0021 00CC 
; 0021 00CD      pviWizBuff = (char *)malloc(400);              //4(length unknow) = xx\r\n
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,63
	SBIW R28,63
	SBIW R28,6
	LDI  R24,122
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x42001E*2)
	LDI  R31,HIGH(_0x42001E*2)
	LDI  R22,BYTE3(_0x42001E*2)
	CALL __INITLOCB
	CALL SUBOPT_0xD
;	*data_p -> Y+138
;	len_p -> Y+136
;	*pviWizBuff -> R16,R17
;	lenData -> Y+126
;	indexWrite -> R18,R19
;	ivHTTPHeaderMethod -> Y+96
;	ivHTTPHeaderHost -> Y+61
;	ivHTTPHeaderMac -> Y+43
;	ivHTTPHeaderConn -> Y+23
;	ivHTTPHeaderLen -> Y+4
	LDI  R26,LOW(400)
	LDI  R27,HIGH(400)
	CALL SUBOPT_0xB9
; 0021 00CE //     printDebug("[wizSend]Print-2.[\r\n");
; 0021 00CF //     print_payload(data_p, len_p);
; 0021 00D0 //     printDebug("]\r\n");
; 0021 00D1 
; 0021 00D2      if(pviWizBuff != NULL){
	BRNE PC+3
	JMP _0x42001F
; 0021 00D3         sprintf(lenData,"%d\r\n\r\n",len_p);
	MOVW R30,R28
	SUBI R30,LOW(-(126))
	SBCI R31,HIGH(-(126))
	ST   -Y,R31
	ST   -Y,R30
	__POINTD1FN _0x420000,200
	CALL __PUTPARD1
	__GETW1SX 142
	CALL __CWD1
	CALL __PUTPARD1
	LDI  R24,4
	CALL _sprintf
	ADIW R28,10
; 0021 00D4 
; 0021 00D5 //        memcpy(&pviWizBuff[indexWrite],&httpPostHeader[0],strlen(httpPostHeader));
; 0021 00D6 //        indexWrite += strlen(httpPostHeader);
; 0021 00D7 //        memcpy(&pviWizBuff[indexWrite],&lenData[0],strlen(lenData));
; 0021 00D8 //        indexWrite += strlen(lenData);
; 0021 00D9 //        memcpy(&pviWizBuff[indexWrite],&data_p[0],len_p);
; 0021 00DA //        indexWrite += len_p;
; 0021 00DB         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderMethod[0],strlen(ivHTTPHeaderMethod));
	MOVW R30,R18
	CALL SUBOPT_0x88
	MOVW R30,R28
	SUBI R30,LOW(-(98))
	SBCI R31,HIGH(-(98))
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	SUBI R26,LOW(-(100))
	SBCI R27,HIGH(-(100))
	CALL SUBOPT_0xBA
; 0021 00DC         indexWrite += strlen(ivHTTPHeaderMethod);
	MOVW R26,R28
	SUBI R26,LOW(-(96))
	SBCI R27,HIGH(-(96))
	CALL SUBOPT_0xBB
; 0021 00DD 
; 0021 00DE         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderHost[0],strlen(ivHTTPHeaderHost));
	MOVW R30,R28
	ADIW R30,63
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	SUBI R26,LOW(-(65))
	SBCI R27,HIGH(-(65))
	CALL SUBOPT_0xBA
; 0021 00DF         indexWrite += strlen(ivHTTPHeaderHost);
	MOVW R26,R28
	ADIW R26,61
	CALL SUBOPT_0xBB
; 0021 00E0 
; 0021 00E1         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderMac[0],strlen(ivHTTPHeaderMac));
	MOVW R30,R28
	ADIW R30,45
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,47
	CALL SUBOPT_0xBA
; 0021 00E2         indexWrite += strlen(ivHTTPHeaderMac);
	MOVW R26,R28
	ADIW R26,43
	CALL SUBOPT_0xBB
; 0021 00E3         memcpy(&pviWizBuff[indexWrite],&iWiz100srConfig.macAddress[0],sizeof(iWiz100srConfig.macAddress));
	LDI  R30,LOW(_iWiz100srConfig)
	LDI  R31,HIGH(_iWiz100srConfig)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(12)
	CALL SUBOPT_0x83
; 0021 00E4         indexWrite += sizeof(iWiz100srConfig.macAddress);
	__ADDWRN 18,19,12
; 0021 00E5 
; 0021 00E6 //        memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderUser[0],strlen(ivHTTPHeaderUser));
; 0021 00E7 //        indexWrite += strlen(ivHTTPHeaderUser);
; 0021 00E8 
; 0021 00E9         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderConn[0],strlen(ivHTTPHeaderConn));
	MOVW R30,R18
	CALL SUBOPT_0x88
	MOVW R30,R28
	ADIW R30,25
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,27
	CALL SUBOPT_0xBA
; 0021 00EA         indexWrite += strlen(ivHTTPHeaderConn);
	MOVW R26,R28
	ADIW R26,23
	CALL SUBOPT_0xBB
; 0021 00EB 
; 0021 00EC         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderLen[0],strlen(ivHTTPHeaderLen));
	CALL SUBOPT_0x97
	MOVW R26,R28
	ADIW R26,8
	CALL SUBOPT_0xBA
; 0021 00ED         indexWrite += strlen(ivHTTPHeaderLen);
	MOVW R26,R28
	ADIW R26,4
	CALL SUBOPT_0xBB
; 0021 00EE         memcpy(&pviWizBuff[indexWrite],&lenData[0],strlen(lenData));
	MOVW R30,R28
	SUBI R30,LOW(-(128))
	SBCI R31,HIGH(-(128))
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	SUBI R26,LOW(-(130))
	SBCI R27,HIGH(-(130))
	CALL SUBOPT_0xBA
; 0021 00EF         indexWrite += strlen(lenData);
	MOVW R26,R28
	SUBI R26,LOW(-(126))
	SBCI R27,HIGH(-(126))
	CALL SUBOPT_0xBB
; 0021 00F0 
; 0021 00F1         memcpy(&pviWizBuff[indexWrite],&data_p[0],len_p);
	__GETW1SX 140
	ST   -Y,R31
	ST   -Y,R30
	__GETW2SX 140
	CALL _memcpy
; 0021 00F2         indexWrite += len_p;
	__GETW1SX 136
	__ADDWRR 18,19,30,31
; 0021 00F3 
; 0021 00F4         print_payload(pviWizBuff, indexWrite);
	ST   -Y,R17
	ST   -Y,R16
	MOVW R26,R18
	CALL _print_payload
; 0021 00F5         write_uart0(pviWizBuff, indexWrite);
	ST   -Y,R17
	ST   -Y,R16
	MOVW R26,R18
	CALL _write_uart0
; 0021 00F6         index0Buffer = 0;
	CALL SUBOPT_0xBC
; 0021 00F7         iWizRXMode = WIZ_RX_DATA_MODE;
	LDI  R30,LOW(2)
	STS  _iWizRXMode,R30
; 0021 00F8         free(pviWizBuff);
	MOVW R26,R16
	CALL _free
; 0021 00F9 
; 0021 00FA      }else{
	RJMP _0x420020
_0x42001F:
; 0021 00FB         printDebug("[wizSend]can 't allocate mem.\r\n");
	__POINTD1FN _0x420000,207
	CALL SUBOPT_0x0
; 0021 00FC      }
_0x420020:
; 0021 00FD      free(pviWizBuff);
	MOVW R26,R16
	CALL _free
; 0021 00FE 
; 0021 00FF }
	CALL __LOADLOCR4
	ADIW R28,63
	ADIW R28,63
	ADIW R28,14
	RET
;void iWizReceive(){
; 0021 0100 void iWizReceive(){
; 0021 0101      int i;
; 0021 0102      //free();
; 0021 0103 //     if(iHTTPStatus.connStatus == WIZ_HTTP_RES_CODE_OK && iHTTPStatus.contentLength >3){
; 0021 0104 //        print_payload(rx0Buffer, index0Buffer);
; 0021 0105 //     }
; 0021 0106 
; 0021 0107      printDebug("index0Buffer(%d)\r\n",index0Buffer);
;	i -> R16,R17
; 0021 0108      //printDebug("iHTTPStatusLen(%d)\r\n",iHTTPStatus.contentLength);
; 0021 0109      if(index0Buffer > 0){
; 0021 010A          for(i=0;i<index0Buffer;i++){
; 0021 010B               printDebug("%c",rx0Buffer[i]);
; 0021 010C          }
; 0021 010D      }
; 0021 010E 
; 0021 010F 
; 0021 0110      //print_payload(rx0Buffer, iHTTPStatus.contentLength);
; 0021 0111 }
;
;int iWizConnected(){
; 0021 0113 int iWizConnected(){
_iWizConnected:
; 0021 0114     //char *pviCheckWizConn;
; 0021 0115     int iReturn =  WIZ_CONN_FAIL;
; 0021 0116     char * pch;
; 0021 0117     TIMER   timeout;
; 0021 0118     char  pviCheckWizConn[200];
; 0021 0119 
; 0021 011A     TIMER_setTimer(&timeout, 20);
	SBIW R28,63
	SBIW R28,63
	SBIW R28,63
	SBIW R28,15
	CALL __SAVELOCR4
;	iReturn -> R16,R17
;	*pch -> R18,R19
;	timeout -> Y+204
;	pviCheckWizConn -> Y+4
	__GETWRN 16,17,0
	MOVW R30,R28
	SUBI R30,LOW(-(204))
	SBCI R31,HIGH(-(204))
	ST   -Y,R31
	ST   -Y,R30
	__GETD2N 0x14
	CALL _TIMER_setTimer
; 0021 011B     memset(pviCheckWizConn,0,sizeof(pviCheckWizConn));
	MOVW R30,R28
	ADIW R30,4
	CALL SUBOPT_0xA8
	LDI  R26,LOW(200)
	CALL SUBOPT_0xBD
; 0021 011C     index0Buffer = 0;
	CALL SUBOPT_0xBC
; 0021 011D #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 011E     printDebug("[iWizConnected]Function.\r\n");
; 0021 011F #endif
; 0021 0120     while(!TIMER_checkTimerExceed(timeout)){
_0x420025:
	__GETD2SX 204
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	BREQ PC+3
	JMP _0x420027
; 0021 0121         #asm("wdr")
	wdr
; 0021 0122         delay_ms(50);
	CALL SUBOPT_0xB
; 0021 0123         //printDebug("[iWizConnected len(%d)]\r\n",index0Buffer);
; 0021 0124 
; 0021 0125         if((index0Buffer >= 11) && (index0Buffer <200) && (iWizRXMode == WIZ_RX_STAT_MODE)){        //11= >  Connected
	CALL SUBOPT_0x12
	SBIW R26,11
	BRLO _0x420029
	CALL SUBOPT_0x12
	CPI  R26,LOW(0xC8)
	LDI  R30,HIGH(0xC8)
	CPC  R27,R30
	BRSH _0x420029
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x1)
	BREQ _0x42002A
_0x420029:
	RJMP _0x420028
_0x42002A:
; 0021 0126             //pviCheckWizConn = (char *)malloc(index0Buffer);
; 0021 0127             //pviCheckWizConn = (char *)malloc(400);
; 0021 0128             //if(pviCheckWizConn != NULL){
; 0021 0129                printDebug("[iWizConnected len(%d)]\r\n",index0Buffer);
	__POINTD1FN _0x420000,261
	CALL __PUTPARD1
	LDS  R30,_index0Buffer
	LDS  R31,_index0Buffer+1
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 0021 012A                memcpy(&pviCheckWizConn[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xBF
; 0021 012B                pch = strtok (pviCheckWizConn,">");
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xC0
; 0021 012C                //pch = strtok (pviCheckWizConn,"> ");
; 0021 012D                while(pch != NULL){
_0x42002B:
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x42002D
; 0021 012E                    //printDebug("[Data split]%s\r\n",pch);
; 0021 012F                    if(strncmp (pch," Connected",9)==0){
	ST   -Y,R19
	ST   -Y,R18
	__POINTW1MN _0x42002F,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(9)
	CALL _strncmp
	CPI  R30,0
	BRNE _0x42002E
; 0021 0130                         printDebug("[Data split]%s\r\n",pch);
	CALL SUBOPT_0xC1
	CALL SUBOPT_0x63
; 0021 0131                         iReturn =  WIZ_CONNECTED;
	__GETWRN 16,17,1
; 0021 0132                         break;
	RJMP _0x42002D
; 0021 0133                    }else if(strncmp (pch," Listen : OK",11)==0){
_0x42002E:
	ST   -Y,R19
	ST   -Y,R18
	__POINTW1MN _0x42002F,11
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(11)
	CALL _strncmp
	CPI  R30,0
	BRNE _0x420031
; 0021 0134                         printDebug("[Data split]%s\r\n",pch);
	CALL SUBOPT_0xC1
	CALL SUBOPT_0x63
; 0021 0135                         iReturn =  WIZ_CONNECTED;
	__GETWRN 16,17,1
; 0021 0136                         break;
	RJMP _0x42002D
; 0021 0137                    }
; 0021 0138                    pch = strtok (NULL, ">");
_0x420031:
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xC0
; 0021 0139                    //pch = strtok (NULL, "> ");
; 0021 013A                }
	RJMP _0x42002B
_0x42002D:
; 0021 013B 
; 0021 013C                //free(pviCheckWizConn);
; 0021 013D                if(iReturn ==  WIZ_CONNECTED){
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CP   R30,R16
	CPC  R31,R17
	BREQ _0x420027
; 0021 013E                    break;
; 0021 013F                }
; 0021 0140 //            }else{
; 0021 0141 //               printDebug("[iWizConnected]can 't allocate mem(%d).\r\n",index0Buffer);
; 0021 0142 //               iReturn =  WIZ_CONN_FAIL;
; 0021 0143 //            }
; 0021 0144         }else{
	RJMP _0x420033
_0x420028:
; 0021 0145            iReturn =  WIZ_CONN_FAIL;
	__GETWRN 16,17,0
; 0021 0146         }
_0x420033:
; 0021 0147     }
	RJMP _0x420025
_0x420027:
; 0021 0148     index0Buffer = 0;
	CALL SUBOPT_0xBC
; 0021 0149 
; 0021 014A     return iReturn;
	MOVW R30,R16
	CALL __LOADLOCR4
	ADIW R28,63
	ADIW R28,63
	ADIW R28,63
	ADIW R28,19
	RET
; 0021 014B }

	.DSEG
_0x42002F:
	.BYTE 0x18
;
;int iWizRead(){
; 0021 014D int iWizRead(){

	.CSEG
_iWizRead:
; 0021 014E     //char * pviWizRead;
; 0021 014F     int iReturn = WIZ_DATA_EMPTY;
; 0021 0150     char * pch;
; 0021 0151     char * pviHttpResCode;
; 0021 0152     char * pviHttpLen;
; 0021 0153     char * pviHttpData;
; 0021 0154     int i = 0;
; 0021 0155     char *pviReadLine;
; 0021 0156     unsigned int viHtteDetaLen = 0;
; 0021 0157     unsigned char viFlagHttpResCode;
; 0021 0158     unsigned char viFlagHttpLen;
; 0021 0159     char pviWizRead[400];
; 0021 015A 
; 0021 015B     TIMER   timeout;
; 0021 015C     TIMER_setTimer(&timeout, 3);
	SBIW R28,63
	SBIW R28,63
	SBIW R28,34
	SUBI R29,1
	LDI  R24,6
	LDI  R26,LOW(406)
	LDI  R27,HIGH(406)
	LDI  R30,LOW(_0x420034*2)
	LDI  R31,HIGH(_0x420034*2)
	LDI  R22,BYTE3(_0x420034*2)
	CALL __INITLOCB
	CALL __SAVELOCR6
;	iReturn -> R16,R17
;	*pch -> R18,R19
;	*pviHttpResCode -> R20,R21
;	*pviHttpLen -> Y+420
;	*pviHttpData -> Y+418
;	i -> Y+416
;	*pviReadLine -> Y+414
;	viHtteDetaLen -> Y+412
;	viFlagHttpResCode -> Y+411
;	viFlagHttpLen -> Y+410
;	pviWizRead -> Y+10
;	timeout -> Y+6
	__GETWRN 16,17,0
	CALL SUBOPT_0x97
	CALL SUBOPT_0xC3
; 0021 015D     while(!TIMER_checkTimerExceed(timeout)){
_0x420035:
	CALL SUBOPT_0x3C
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	BRNE _0x420037
; 0021 015E        #asm("wdr")
	wdr
; 0021 015F     }
	RJMP _0x420035
_0x420037:
; 0021 0160     //delay_ms(1000);
; 0021 0161 
; 0021 0162     memset(&pviWizRead,0,sizeof(pviWizRead));
	CALL SUBOPT_0xC4
	CALL SUBOPT_0xC5
; 0021 0163 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 0164     printDebug("[iWizRead]Function\r\n");
; 0021 0165 #endif
; 0021 0166     if((index0Buffer > 0) && (iWizRXMode == WIZ_RX_DATA_MODE)){
	CALL SUBOPT_0xC6
	BRSH _0x420039
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x2)
	BREQ _0x42003A
_0x420039:
	RJMP _0x420038
_0x42003A:
; 0021 0167         //pviWizRead = (char *)malloc(index0Buffer);
; 0021 0168         //if(pviWizRead != NULL){
; 0021 0169            memcpy(&pviWizRead[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0xC7
	CALL SUBOPT_0xBF
; 0021 016A //           for(i=0;i<index0Buffer;i++){
; 0021 016B //                printDebug("%c",*(pviReadDisplay++));
; 0021 016C //           }
; 0021 016D            //printDebug("[HTTP]Raw Data\r\n");
; 0021 016E            print_payload(pviWizRead, index0Buffer);
	CALL SUBOPT_0xC7
	CALL SUBOPT_0x12
	CALL _print_payload
; 0021 016F 
; 0021 0170 
; 0021 0171             pviReadLine = strtok(pviWizRead,"\r\n");
	CALL SUBOPT_0xC7
	CALL SUBOPT_0xC8
; 0021 0172 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 0173             printDebug("[HTTP]Check ResCode\r\n");
; 0021 0174 #endif
; 0021 0175             while(pviReadLine != NULL){
_0x42003B:
	CALL SUBOPT_0xC9
	SBIW R30,0
	BREQ _0x42003D
; 0021 0176                 #asm("wdr")
	wdr
; 0021 0177                 if(strncmp(pviReadLine,"HTTP/",5)==0){
	CALL SUBOPT_0xCA
	__POINTW1MN _0x42003F,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(5)
	CALL _strncmp
	CPI  R30,0
	BRNE _0x42003E
; 0021 0178                     pviHttpResCode = strtok (pviReadLine," ");
	CALL SUBOPT_0xCA
	CALL SUBOPT_0xCB
; 0021 0179                     while(pviHttpResCode != NULL){
_0x420040:
	MOV  R0,R20
	OR   R0,R21
	BREQ _0x420042
; 0021 017A                          #asm("wdr")
	wdr
; 0021 017B                          if(strncmp(pviHttpResCode,"200",3)==0){
	ST   -Y,R21
	ST   -Y,R20
	__POINTW1MN _0x42003F,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(3)
	CALL _strncmp
	CPI  R30,0
	BRNE _0x420043
; 0021 017C     #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 017D                               printDebug("[HTTP]200 OK\r\n");
; 0021 017E     #endif
; 0021 017F                               viFlagHttpResCode = WIZ_HTTP_RES_CODE_OK;
	LDI  R30,LOW(1)
	__PUTB1SX 411
; 0021 0180                               //free(pviHttpResCode);
; 0021 0181                               break;
	RJMP _0x420042
; 0021 0182                          }else{
_0x420043:
; 0021 0183                               viFlagHttpResCode = WIZ_HTTP_RES_CODE_ERROR;
	LDI  R30,LOW(0)
	__PUTB1SX 411
; 0021 0184                          }
; 0021 0185                          pviHttpResCode = strtok (NULL," ");
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xCB
; 0021 0186                     }
	RJMP _0x420040
_0x420042:
; 0021 0187                     if(viFlagHttpResCode == WIZ_HTTP_RES_CODE_OK){
	__GETB2SX 411
	CPI  R26,LOW(0x1)
	BREQ _0x42003D
; 0021 0188                          break;
; 0021 0189                     }
; 0021 018A                     //pviReadLine = strtok(NULL,"\r\n");
; 0021 018B                 }
; 0021 018C                 pviReadLine = strtok(NULL,"\r\n");
_0x42003E:
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xC8
; 0021 018D             }
	RJMP _0x42003B
_0x42003D:
; 0021 018E             //free(pviReadLine);
; 0021 018F 
; 0021 0190             memset(&pviWizRead,0,sizeof(pviWizRead));
	CALL SUBOPT_0xC4
	CALL SUBOPT_0xC5
; 0021 0191             memcpy(&pviWizRead[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0xC7
	CALL SUBOPT_0xBF
; 0021 0192 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 0193             printDebug("[HTTP]Check Length\r\n");
; 0021 0194 #endif
; 0021 0195             pviReadLine = strtok(pviWizRead,"\r\n");
	CALL SUBOPT_0xC7
	CALL SUBOPT_0xC8
; 0021 0196             while(pviReadLine != NULL){
_0x420046:
	CALL SUBOPT_0xC9
	SBIW R30,0
	BREQ _0x420048
; 0021 0197                #asm("wdr")
	wdr
; 0021 0198                if(strncmp(pviReadLine,"Content-Length",14)==0){
	CALL SUBOPT_0xCA
	__POINTW1MN _0x42003F,10
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(14)
	CALL _strncmp
	CPI  R30,0
	BRNE _0x420049
; 0021 0199                   pviHttpLen = strtok(pviReadLine," ");
	CALL SUBOPT_0xCA
	CALL SUBOPT_0xCC
; 0021 019A                   if(pviHttpLen != NULL){
	CALL SUBOPT_0xCD
	SBIW R30,0
	BREQ _0x42004A
; 0021 019B                       pviHttpLen = strtok(NULL," ");
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xCC
; 0021 019C #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 019D                       printDebug("[DataLen][%s]\r\n",pviHttpLen);
; 0021 019E #endif
; 0021 019F                       viHtteDetaLen = atoi(pviHttpLen);
	__GETW2SX 420
	CALL _atoi
	__PUTW1SX 412
; 0021 01A0                       viFlagHttpLen = WIZ_HTTP_CONTEXT_LEN_OK;
	LDI  R30,LOW(1)
	__PUTB1SX 410
; 0021 01A1                       break;
	RJMP _0x420048
; 0021 01A2                   }else{
_0x42004A:
; 0021 01A3                       viFlagHttpLen = WIZ_HTTP_CONTEXT_LEN_NOTFOUND;
	LDI  R30,LOW(0)
	__PUTB1SX 410
; 0021 01A4                   }
; 0021 01A5                }
; 0021 01A6                if(viFlagHttpLen == WIZ_HTTP_CONTEXT_LEN_OK){
_0x420049:
	__GETB2SX 410
	CPI  R26,LOW(0x1)
	BREQ _0x420048
; 0021 01A7                   break;
; 0021 01A8                }
; 0021 01A9                pviReadLine = strtok(NULL,"\r\n");
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xC8
; 0021 01AA             }
	RJMP _0x420046
_0x420048:
; 0021 01AB 
; 0021 01AC             memset(&pviWizRead,0,sizeof(pviWizRead));
	CALL SUBOPT_0xC4
	CALL SUBOPT_0xC5
; 0021 01AD             memcpy(&pviWizRead[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0xC7
	CALL SUBOPT_0xBF
; 0021 01AE #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 01AF             printDebug("[HTTP]Parser Data\r\n");
; 0021 01B0 #endif
; 0021 01B1             pviHttpData = strstr (pviWizRead,"\r\n\r\n");
	CALL SUBOPT_0xC7
	__POINTW2MN _0x42003F,25
	CALL _strstr
	__PUTW1SX 418
; 0021 01B2             if(pviHttpData){
	CALL SUBOPT_0xCE
	SBIW R30,0
	BREQ _0x42004D
; 0021 01B3 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 01B4                 printDebug("[Data][\r\n");
; 0021 01B5 #endif
; 0021 01B6 //                for(i=0;i<(pviHttpData+4);i++){
; 0021 01B7 //                    //printDebug("%c",*(pviHttpData++));
; 0021 01B8 //                    putchar3(*(pviHttpData++));
; 0021 01B9 //                }
; 0021 01BA 
; 0021 01BB                 //printDebug("[Data][%s]\r\n",pviHttpData);
; 0021 01BC                 print_payload(pviHttpData+4, viHtteDetaLen);
	CALL SUBOPT_0xCE
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	__GETW2SX 414
	CALL _print_payload
; 0021 01BD #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 01BE                 printDebug("]\r\n");
; 0021 01BF #endif
; 0021 01C0                 viRXData.length = viHtteDetaLen;
	__GETW1SX 412
	STS  _viRXData,R30
	STS  _viRXData+1,R31
; 0021 01C1                 memcpy(&viRXData.value[0],pviHttpData+4,viHtteDetaLen);
	__POINTW1MN _viRXData,2
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xCD
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	__GETW2SX 416
	CALL _memcpy
; 0021 01C2 
; 0021 01C3 //                memset(&pviWizRead,0,sizeof(pviWizRead));
; 0021 01C4 //                memcpy(&pviWizRead[0],pviHttpData+4,viHtteDetaLen);
; 0021 01C5             }
; 0021 01C6 
; 0021 01C7             if(viFlagHttpResCode==WIZ_HTTP_RES_CODE_OK && viFlagHttpLen == WIZ_HTTP_CONTEXT_LEN_OK){
_0x42004D:
	__GETB2SX 411
	CPI  R26,LOW(0x1)
	BRNE _0x42004F
	__GETB2SX 410
	CPI  R26,LOW(0x1)
	BREQ _0x420050
_0x42004F:
	RJMP _0x42004E
_0x420050:
; 0021 01C8 
; 0021 01C9                  iReturn =  WIZ_DATA_AVAILABLE;
	__GETWRN 16,17,1
; 0021 01CA             }
; 0021 01CB 
; 0021 01CC //        }else{
; 0021 01CD //           printDebug("[iWizRead]can 't allocate mem(%d).\r\n",index0Buffer);
; 0021 01CE //           iReturn =  WIZ_DATA_EMPTY;
; 0021 01CF //        }
; 0021 01D0     }else{
_0x42004E:
	RJMP _0x420051
_0x420038:
; 0021 01D1         iReturn =  WIZ_DATA_EMPTY;
	__GETWRN 16,17,0
; 0021 01D2     }
_0x420051:
; 0021 01D3     index0Buffer = 0;
	CALL SUBOPT_0xBC
; 0021 01D4     //free(pviWizRead);
; 0021 01D5     return iReturn;
	MOVW R30,R16
	CALL __LOADLOCR6
	ADIW R28,63
	ADIW R28,63
	ADIW R28,40
	SUBI R29,-1
	RET
; 0021 01D6 }

	.DSEG
_0x42003F:
	.BYTE 0x1E
;
;void iWizReadConfig(){
; 0021 01D8 void iWizReadConfig(){

	.CSEG
_iWizReadConfig:
; 0021 01D9     iChar_t viCmdModeChar[] = "+++";
; 0021 01DA 
; 0021 01DB     iChar_t viCmdMAC[] = "<RA>";                 //Get MAC Address
; 0021 01DC     iChar_t viCmdIP[] = "<RI>";                  //Get Local IP
; 0021 01DD     iChar_t viCmdSubnet[] = "<RS>";              //Get Subnet mask
; 0021 01DE     iChar_t viCmdGateWay[] = "<RG>";             //Get Gateway
; 0021 01DF     iChar_t viCmdLocalPort[] = "<RP>";           //Get Local IPs port number
; 0021 01E0     iChar_t viCmdIPMethod[] = "<RD>";            //Get the IP configuration method
; 0021 01E1     iChar_t viCmdOperMode[] = "<RM>";            //Get the operation mode
; 0021 01E2     iChar_t viCmdProtocal[] = "<RK>";            //Get the Protocol
; 0021 01E3     iChar_t viCmdBaudRate[] = "<RB>";            //Get the serial baud rate
; 0021 01E4     iChar_t viCmdCmdSerialMeth[] = "<RT>";       //Get the serial command method
; 0021 01E5     iChar_t viCmdCmdDomainName[] = "<RW>";       //Get the serial command method
; 0021 01E6 
; 0021 01E7     iChar_t viCmdRestart[] = "<WR>";       //Restart
; 0021 01E8 
; 0021 01E9     iChar_t viConfigMode;
; 0021 01EA     iChar_t * pviCheckResponse;
; 0021 01EB 
; 0021 01EC     iChar_t viWizReadBuffer[30];
; 0021 01ED     iChar_t viI = 0;
; 0021 01EE     TIMER   timeout;
; 0021 01EF 
; 0021 01F0     //Read configuration mode
; 0021 01F1     //viConfigMode = WIZ_CONFIG_READ_MODE;
; 0021 01F2     iWizRXMode = WIZ_CONFIG_READ_MODE;
	SBIW R28,63
	SBIW R28,35
	LDI  R24,64
	LDI  R26,LOW(34)
	LDI  R27,HIGH(34)
	LDI  R30,LOW(_0x420052*2)
	LDI  R31,HIGH(_0x420052*2)
	LDI  R22,BYTE3(_0x420052*2)
	CALL __INITLOCB
	CALL __SAVELOCR4
;	viCmdModeChar -> Y+98
;	viCmdMAC -> Y+93
;	viCmdIP -> Y+88
;	viCmdSubnet -> Y+83
;	viCmdGateWay -> Y+78
;	viCmdLocalPort -> Y+73
;	viCmdIPMethod -> Y+68
;	viCmdOperMode -> Y+63
;	viCmdProtocal -> Y+58
;	viCmdBaudRate -> Y+53
;	viCmdCmdSerialMeth -> Y+48
;	viCmdCmdDomainName -> Y+43
;	viCmdRestart -> Y+38
;	viConfigMode -> R17
;	*pviCheckResponse -> R18,R19
;	viWizReadBuffer -> Y+8
;	viI -> R16
;	timeout -> Y+4
	LDI  R16,0
	LDI  R30,LOW(4)
	STS  _iWizRXMode,R30
; 0021 01F3     //send +++
; 0021 01F4 
; 0021 01F5     index0Buffer = 0;
	CALL SUBOPT_0xBC
; 0021 01F6     for(viI=0;viI<strlen(viCmdModeChar);viI++){
	LDI  R16,LOW(0)
_0x420054:
	MOVW R26,R28
	SUBI R26,LOW(-(98))
	SBCI R27,HIGH(-(98))
	CALL SUBOPT_0xCF
	BRSH _0x420055
; 0021 01F7         putchar0(viCmdModeChar[viI]);
	CALL SUBOPT_0x35
	MOVW R26,R28
	SUBI R26,LOW(-(98))
	SBCI R27,HIGH(-(98))
	CALL SUBOPT_0x15
; 0021 01F8     }
	SUBI R16,-1
	RJMP _0x420054
_0x420055:
; 0021 01F9 
; 0021 01FA     //wait wiz module response
; 0021 01FB     TIMER_setTimer(&timeout, 1);
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xD0
; 0021 01FC     while(!TIMER_checkTimerExceed(timeout)){
_0x420056:
	CALL SUBOPT_0xD1
	BRNE _0x420058
; 0021 01FD        #asm("wdr")
	wdr
; 0021 01FE        if(index0Buffer>0){
	CALL SUBOPT_0xC6
	BRSH _0x420059
; 0021 01FF            delay_ms(100);
	CALL SUBOPT_0x8
; 0021 0200            memset(viWizReadBuffer,0,sizeof(viWizReadBuffer));
	CALL SUBOPT_0x86
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R26,LOW(30)
	CALL SUBOPT_0xBD
; 0021 0201            memcpy(&viWizReadBuffer[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0x86
	CALL SUBOPT_0xBF
; 0021 0202 
; 0021 0203            pviCheckResponse = strstr(viWizReadBuffer,"<E>");
	CALL SUBOPT_0x86
	__POINTW2MN _0x42005A,0
	CALL _strstr
	MOVW R18,R30
; 0021 0204            if(pviCheckResponse){
; 0021 0205 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 0206                printDebug("[iWizReadConfig]can config mode(Read).\r\n");
; 0021 0207 #endif
; 0021 0208            }else{
; 0021 0209 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 020A                printDebug("[iWizReadConfig]can config mode(Read).\r\n");
; 0021 020B #endif
; 0021 020C            }
; 0021 020D            break;
	RJMP _0x420058
; 0021 020E        }
; 0021 020F     }
_0x420059:
	RJMP _0x420056
_0x420058:
; 0021 0210     delay_ms(20);
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0021 0211     if(iWizConfigSend(viCmdMAC,viWizReadBuffer)==1){
	MOVW R30,R28
	SUBI R30,LOW(-(93))
	SBCI R31,HIGH(-(93))
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x42005D
; 0021 0212         iWizConfigMACParser(iWiz100srConfig.macAddress,viWizReadBuffer);
	LDI  R30,LOW(_iWiz100srConfig)
	LDI  R31,HIGH(_iWiz100srConfig)
	CALL SUBOPT_0xD2
	RCALL _iWizConfigMACParser
; 0021 0213         printDebug("[iWizReadConfig]MAC:");
	__POINTD1FN _0x420000,329
	CALL SUBOPT_0x0
; 0021 0214         for(viI=0;viI<sizeof(iWiz100srConfig.macAddress);viI++){
	LDI  R16,LOW(0)
_0x42005F:
	CPI  R16,12
	BRSH _0x420060
; 0021 0215             if(viI!=sizeof(iWiz100srConfig.macAddress)-1){
	CPI  R16,11
	BREQ _0x420061
; 0021 0216                 printDebug("%02x:",iWiz100srConfig.macAddress[viI]);
	__POINTD1FN _0x420000,350
	RJMP _0x4200AD
; 0021 0217             }else{
_0x420061:
; 0021 0218                 printDebug("%02x",iWiz100srConfig.macAddress[viI]);
	CALL SUBOPT_0xD3
_0x4200AD:
	CALL __PUTPARD1
	CALL SUBOPT_0x35
	SUBI R30,LOW(-_iWiz100srConfig)
	SBCI R31,HIGH(-_iWiz100srConfig)
	LD   R30,Z
	CALL SUBOPT_0x9E
; 0021 0219             }
; 0021 021A         }
	SUBI R16,-1
	RJMP _0x42005F
_0x420060:
; 0021 021B 
; 0021 021C         printDebug("\r\n");
	CALL SUBOPT_0xD4
; 0021 021D     }
; 0021 021E     delay_ms(20);
_0x42005D:
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0021 021F     if(iWizConfigSend(viCmdIP,viWizReadBuffer)==1){
	MOVW R30,R28
	SUBI R30,LOW(-(88))
	SBCI R31,HIGH(-(88))
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x420063
; 0021 0220         iWizConfigIPParser(iWiz100srConfig.ip,viWizReadBuffer);
	__POINTW1MN _iWiz100srConfig,13
	CALL SUBOPT_0xD2
	RCALL _iWizConfigIPParser
; 0021 0221         printDebug("[iWizReadConfig]IP:");
	__POINTD1FN _0x420000,361
	CALL SUBOPT_0x0
; 0021 0222         for(viI=0;viI<sizeof(iWiz100srConfig.ip);viI++){
	LDI  R16,LOW(0)
_0x420065:
	CPI  R16,4
	BRSH _0x420066
; 0021 0223             if(viI!=sizeof(iWiz100srConfig.ip)-1){
	CPI  R16,3
	BREQ _0x420067
; 0021 0224                 printDebug("%02x.",iWiz100srConfig.ip[viI]);
	CALL SUBOPT_0xD5
	RJMP _0x4200AE
; 0021 0225             }else{
_0x420067:
; 0021 0226                 printDebug("%02x",iWiz100srConfig.ip[viI]);
	CALL SUBOPT_0xD3
_0x4200AE:
	CALL __PUTPARD1
	__POINTW2MN _iWiz100srConfig,13
	CALL SUBOPT_0xD6
	CALL SUBOPT_0x61
; 0021 0227             }
; 0021 0228         }
	SUBI R16,-1
	RJMP _0x420065
_0x420066:
; 0021 0229         printDebug("\r\n");
	CALL SUBOPT_0xD4
; 0021 022A     }
; 0021 022B     delay_ms(20);
_0x420063:
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0021 022C     if(iWizConfigSend(viCmdSubnet,viWizReadBuffer)==1){
	MOVW R30,R28
	SUBI R30,LOW(-(83))
	SBCI R31,HIGH(-(83))
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x420069
; 0021 022D         iWizConfigIPParser(iWiz100srConfig.subnet,viWizReadBuffer);
	__POINTW1MN _iWiz100srConfig,17
	CALL SUBOPT_0xD2
	RCALL _iWizConfigIPParser
; 0021 022E         printDebug("[iWizReadConfig]Subnet mask:");
	__POINTD1FN _0x420000,387
	CALL SUBOPT_0x0
; 0021 022F         for(viI=0;viI<sizeof(iWiz100srConfig.subnet);viI++){
	LDI  R16,LOW(0)
_0x42006B:
	CPI  R16,4
	BRSH _0x42006C
; 0021 0230             if(viI!=sizeof(iWiz100srConfig.subnet)-1){
	CPI  R16,3
	BREQ _0x42006D
; 0021 0231                 printDebug("%02x.",iWiz100srConfig.subnet[viI]);
	CALL SUBOPT_0xD5
	RJMP _0x4200AF
; 0021 0232             }else{
_0x42006D:
; 0021 0233                 printDebug("%02x",iWiz100srConfig.subnet[viI]);
	CALL SUBOPT_0xD3
_0x4200AF:
	CALL __PUTPARD1
	__POINTW2MN _iWiz100srConfig,17
	CALL SUBOPT_0xD6
	CALL SUBOPT_0x61
; 0021 0234             }
; 0021 0235         }
	SUBI R16,-1
	RJMP _0x42006B
_0x42006C:
; 0021 0236         printDebug("\r\n");
	CALL SUBOPT_0xD4
; 0021 0237     }
; 0021 0238     delay_ms(20);
_0x420069:
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0021 0239     if(iWizConfigSend(viCmdGateWay,viWizReadBuffer)==1){
	MOVW R30,R28
	SUBI R30,LOW(-(78))
	SBCI R31,HIGH(-(78))
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x42006F
; 0021 023A         iWizConfigIPParser(iWiz100srConfig.gateWay,viWizReadBuffer);
	__POINTW1MN _iWiz100srConfig,21
	CALL SUBOPT_0xD2
	RCALL _iWizConfigIPParser
; 0021 023B         printDebug("[iWizReadConfig]Gateway:");
	__POINTD1FN _0x420000,416
	CALL SUBOPT_0x0
; 0021 023C         for(viI=0;viI<sizeof(iWiz100srConfig.gateWay);viI++){
	LDI  R16,LOW(0)
_0x420071:
	CPI  R16,4
	BRSH _0x420072
; 0021 023D             if(viI!=sizeof(iWiz100srConfig.gateWay)-1){
	CPI  R16,3
	BREQ _0x420073
; 0021 023E                 printDebug("%02x.",iWiz100srConfig.gateWay[viI]);
	CALL SUBOPT_0xD5
	RJMP _0x4200B0
; 0021 023F             }else{
_0x420073:
; 0021 0240                 printDebug("%02x",iWiz100srConfig.gateWay[viI]);
	CALL SUBOPT_0xD3
_0x4200B0:
	CALL __PUTPARD1
	__POINTW2MN _iWiz100srConfig,21
	CALL SUBOPT_0xD6
	CALL SUBOPT_0x61
; 0021 0241             }
; 0021 0242         }
	SUBI R16,-1
	RJMP _0x420071
_0x420072:
; 0021 0243         printDebug("\r\n");
	CALL SUBOPT_0xD4
; 0021 0244     }
; 0021 0245     delay_ms(20);
_0x42006F:
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0021 0246     iWizConfigSend(viCmdLocalPort,viWizReadBuffer);
	MOVW R30,R28
	SUBI R30,LOW(-(73))
	SBCI R31,HIGH(-(73))
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
; 0021 0247     iWizConfigSend(viCmdIPMethod,viWizReadBuffer);
	MOVW R30,R28
	SUBI R30,LOW(-(68))
	SBCI R31,HIGH(-(68))
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
; 0021 0248     iWizConfigSend(viCmdOperMode,viWizReadBuffer);
	MOVW R30,R28
	ADIW R30,63
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
; 0021 0249     delay_ms(20);
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0021 024A     if(iWizConfigSend(viCmdCmdDomainName,viWizReadBuffer)){
	MOVW R30,R28
	ADIW R30,43
	CALL SUBOPT_0xD2
	RCALL _iWizConfigSend
	CPI  R30,0
	BREQ _0x420075
; 0021 024B         memcpy(iWiz100srConfig.sdn,&viWizReadBuffer[2],sizeof(iWiz100srConfig.sdn));
	__POINTW1MN _iWiz100srConfig,56
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,12
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(32)
	CALL SUBOPT_0x83
; 0021 024C         printDebug("[iWizReadConfig]SDN:%s\r\n",iWiz100srConfig.sdn);
	__POINTD1FN _0x420000,441
	CALL __PUTPARD1
	__POINTW1MN _iWiz100srConfig,56
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 0021 024D     }
; 0021 024E 
; 0021 024F 
; 0021 0250 
; 0021 0251     index0Buffer = 0;
_0x420075:
	CALL SUBOPT_0xBC
; 0021 0252     for(viI=0;viI<strlen(viCmdRestart);viI++){
	LDI  R16,LOW(0)
_0x420077:
	MOVW R26,R28
	ADIW R26,38
	CALL SUBOPT_0xCF
	BRSH _0x420078
; 0021 0253         putchar0(viCmdRestart[viI]);
	CALL SUBOPT_0x35
	MOVW R26,R28
	ADIW R26,38
	CALL SUBOPT_0x15
; 0021 0254     }
	SUBI R16,-1
	RJMP _0x420077
_0x420078:
; 0021 0255     delay_ms(20);
	CALL SUBOPT_0x2B
	CALL _delay_ms
; 0021 0256     //wait wiz module response
; 0021 0257     TIMER_setTimer(&timeout, 3);
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xC3
; 0021 0258     while(!TIMER_checkTimerExceed(timeout)){
_0x420079:
	CALL SUBOPT_0xD1
	BRNE _0x42007B
; 0021 0259        #asm("wdr")
	wdr
; 0021 025A        if(index0Buffer>0){
	CALL SUBOPT_0xC6
	BRSH _0x42007C
; 0021 025B            delay_ms(100);
	CALL SUBOPT_0x8
; 0021 025C            memset(viWizReadBuffer,0,sizeof(viWizReadBuffer));
	CALL SUBOPT_0x86
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R26,LOW(30)
	CALL SUBOPT_0xBD
; 0021 025D            memcpy(&viWizReadBuffer[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0x86
	CALL SUBOPT_0xBF
; 0021 025E 
; 0021 025F            pviCheckResponse = strstr(viWizReadBuffer,"<S>");
	CALL SUBOPT_0x86
	__POINTW2MN _0x42005A,4
	CALL _strstr
	MOVW R18,R30
; 0021 0260            if(pviCheckResponse){
; 0021 0261 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 0262                printDebug("[iWizReadConfig]Restart Wiz100SR success.\r\n");
; 0021 0263 #endif
; 0021 0264            }else{
; 0021 0265 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 0266                printDebug("[iWizReadConfig]Restart Wiz100SR unsuccess.\r\n");
; 0021 0267 #endif
; 0021 0268            }
; 0021 0269            break;
	RJMP _0x42007B
; 0021 026A        }
; 0021 026B     }
_0x42007C:
	RJMP _0x420079
_0x42007B:
; 0021 026C 
; 0021 026D     index0Buffer = 0;
	CALL SUBOPT_0xBC
; 0021 026E     viConfigMode = WIZ_CONFIG_NORMAL_MODE;
	LDI  R17,LOW(6)
; 0021 026F }
	CALL __LOADLOCR4
	ADIW R28,63
	ADIW R28,39
	RET

	.DSEG
_0x42005A:
	.BYTE 0x8
;
;iChar_t iWizConfigSend(iChar_t * pviCmd_arg,iChar_t *pviDataBuff_arg){
; 0021 0271 iChar_t iWizConfigSend(iChar_t * pviCmd_arg,iChar_t *pviDataBuff_arg){

	.CSEG
_iWizConfigSend:
; 0021 0272     iChar_t viReturn = 0;
; 0021 0273     TIMER   timeout;
; 0021 0274     iChar_t viI = 0;
; 0021 0275     iChar_t * pviCheckResponse;
; 0021 0276 
; 0021 0277     index0Buffer = 0;
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
;	*pviCmd_arg -> Y+10
;	*pviDataBuff_arg -> Y+8
;	viReturn -> R17
;	timeout -> Y+4
;	viI -> R16
;	*pviCheckResponse -> R18,R19
	LDI  R17,0
	LDI  R16,0
	CALL SUBOPT_0xBC
; 0021 0278     for(viI=0;viI<strlen(pviCmd_arg);viI++){
	LDI  R16,LOW(0)
_0x420080:
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL SUBOPT_0xCF
	BRSH _0x420081
; 0021 0279         putchar0(*(pviCmd_arg+viI));
	CALL SUBOPT_0x35
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL SUBOPT_0x15
; 0021 027A     }
	SUBI R16,-1
	RJMP _0x420080
_0x420081:
; 0021 027B 
; 0021 027C     //wait wiz module response
; 0021 027D     TIMER_setTimer(&timeout, 1);
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xD0
; 0021 027E     while(!TIMER_checkTimerExceed(timeout)){
_0x420082:
	CALL SUBOPT_0xD1
	BRNE _0x420084
; 0021 027F        #asm("wdr")
	wdr
; 0021 0280        if(index0Buffer>0){
	CALL SUBOPT_0xC6
	BRSH _0x420085
; 0021 0281            delay_ms(100);
	CALL SUBOPT_0x8
; 0021 0282            memset(pviDataBuff_arg,0,sizeof(pviDataBuff_arg));
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CALL SUBOPT_0xA8
	CALL SUBOPT_0x7
	CALL _memset
; 0021 0283            memcpy(pviDataBuff_arg,&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0xD7
	CALL SUBOPT_0xBF
; 0021 0284 
; 0021 0285            pviCheckResponse = strstr(pviDataBuff_arg,"<S");
	CALL SUBOPT_0xD7
	__POINTW2MN _0x420086,0
	CALL _strstr
	MOVW R18,R30
; 0021 0286            if(pviCheckResponse){
; 0021 0287 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 0288                printDebug("[iWizReadConfig]response data[.\r\n");
; 0021 0289                print_payload(pviDataBuff_arg,strlen(pviDataBuff_arg));
; 0021 028A                printDebug("].\r\n");
; 0021 028B #endif
; 0021 028C            }else{
; 0021 028D #if (WIZ100SR_PRINT_DEBUG == 1)
; 0021 028E                printDebug("[iWizReadConfig]wiz is not response.\r\n");
; 0021 028F #endif
; 0021 0290            }
; 0021 0291            break;
	RJMP _0x420084
; 0021 0292        }
; 0021 0293     }
_0x420085:
	RJMP _0x420082
_0x420084:
; 0021 0294     viReturn = 1;
	LDI  R17,LOW(1)
; 0021 0295     return viReturn;
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,12
	RET
; 0021 0296 }

	.DSEG
_0x420086:
	.BYTE 0x3
;
;unsigned int* hex_decode(char *in, unsigned int len, unsigned int *out)
; 0021 0299 {

	.CSEG
; 0021 029A     unsigned int i, t, hn, ln;
; 0021 029B 
; 0021 029C     for (t = 0,i = 0; i < len; i+=2,++t) {
;	*in -> Y+12
;	len -> Y+10
;	*out -> Y+8
;	i -> R16,R17
;	t -> R18,R19
;	hn -> R20,R21
;	ln -> Y+6
; 0021 029D 
; 0021 029E             hn = in[i] > '9' ? (in[i]|32) - 'a' + 10 : in[i] - '0';
; 0021 029F             ln = in[i+1] > '9' ? (in[i+1]|32) - 'a' + 10 : in[i+1] - '0';
; 0021 02A0 
; 0021 02A1             out[t] = (hn << 4 ) | ln;
; 0021 02A2             printf("%s",out[t]);
; 0021 02A3     }
; 0021 02A4     return out;
; 0021 02A5 }
;
;iChar_t iWizConfigIPParser(iChar_t *pviOutData_arg,iChar_t *pviInData_arg){
; 0021 02A7 iChar_t iWizConfigIPParser(iChar_t *pviOutData_arg,iChar_t *pviInData_arg){
_iWizConfigIPParser:
; 0021 02A8     iChar_t *ptrCh;
; 0021 02A9     iChar_t viIP[4];   //ip,subnet,gateway
; 0021 02AA     iInt_t viNumber;
; 0021 02AB     iChar_t viReturn = 0;
; 0021 02AC     iChar_t viI=0;
; 0021 02AD 
; 0021 02AE     ptrCh = strtok((pviInData_arg+2),".");   //2= <S
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR6
;	*pviOutData_arg -> Y+12
;	*pviInData_arg -> Y+10
;	*ptrCh -> R16,R17
;	viIP -> Y+6
;	viNumber -> R18,R19
;	viReturn -> R21
;	viI -> R20
	LDI  R21,0
	LDI  R20,0
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL SUBOPT_0xD8
; 0021 02AF 
; 0021 02B0 	viI=0;
; 0021 02B1 	while(ptrCh != NULL) {
_0x420092:
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x420094
; 0021 02B2 		viIP[viI] = (unsigned char)(atoi(ptrCh));
	MOV  R30,R20
	LDI  R31,0
	MOVW R26,R28
	ADIW R26,6
	ADD  R30,R26
	ADC  R31,R27
	PUSH R31
	PUSH R30
	MOVW R26,R16
	CALL _atoi
	POP  R26
	POP  R27
	ST   X,R30
; 0021 02B3 		ptrCh = strtok(NULL,".");
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xD9
; 0021 02B4 		viI++;
	SUBI R20,-1
; 0021 02B5 	}
	RJMP _0x420092
_0x420094:
; 0021 02B6     memcpy(pviOutData_arg,viIP,4);
	CALL SUBOPT_0x75
	CALL SUBOPT_0x86
	LDI  R26,LOW(4)
	CALL SUBOPT_0x83
; 0021 02B7 //	printf("\r\n");
; 0021 02B8 //	for(i=0; i<4; i++) {
; 0021 02B9 //		printf("%02x ",ip[i]);
; 0021 02BA //	}
; 0021 02BB 
; 0021 02BC     viReturn = 1;
	LDI  R21,LOW(1)
; 0021 02BD     return viReturn;
	MOV  R30,R21
	CALL __LOADLOCR6
	ADIW R28,14
	RET
; 0021 02BE }
;
;//iChar_t iWizConfigMACParser(iUChar_t *pviOutData_arg,iChar_t *pviInData_arg){
;//    iChar_t *ptrCh;
;//    iChar_t viMAC[6];
;//    iInt_t viNumber;
;//    iChar_t viReturn = 0;
;//    iChar_t viI=0;
;//
;//    ptrCh = strtok((pviInData_arg+2),".");    //2= <S
;//	viI=0;
;//	while(ptrCh != NULL){
;//		viMAC[viI] = iMapAsciiHexToChar(ptrCh);
;//		ptrCh = strtok(NULL,".");
;//		viI++;
;//	}
;//    memcpy(pviOutData_arg,viMAC,6);
;//    //printDebug("[iWizConfigMACParser]MAC:%02x:%02x:%02x:%02x:%02x:%02x\r\n",*pviOutData_arg,*(pviOutData_arg+1),*(pviOutData_arg+2),*(pviOutData_arg+3),*(pviOutData_arg+4),*(pviOutData_arg+5));
;//
;//    viReturn = 1;
;//    return viReturn;
;//}
;iChar_t iWizConfigMACParser(iUChar_t *pviOutData_arg,iChar_t *pviInData_arg){
; 0021 02D4 iChar_t iWizConfigMACParser(iUChar_t *pviOutData_arg,iChar_t *pviInData_arg){
_iWizConfigMACParser:
; 0021 02D5     iChar_t *ptrCh;
; 0021 02D6     iChar_t viMAC[12];
; 0021 02D7     iInt_t viNumber;
; 0021 02D8     iChar_t viReturn = 0;
; 0021 02D9     iChar_t viI=0;
; 0021 02DA 
; 0021 02DB     ptrCh = strtok((pviInData_arg+2),".");    //2= <S
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,12
	CALL __SAVELOCR6
;	*pviOutData_arg -> Y+20
;	*pviInData_arg -> Y+18
;	*ptrCh -> R16,R17
;	viMAC -> Y+6
;	viNumber -> R18,R19
;	viReturn -> R21
;	viI -> R20
	LDI  R21,0
	LDI  R20,0
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CALL SUBOPT_0xD8
; 0021 02DC 	viI=0;
; 0021 02DD 	while(ptrCh != NULL){
_0x420095:
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x420097
; 0021 02DE 		//viMAC[viI] = iMapAsciiHexToChar(ptrCh);
; 0021 02DF         memcpy((pviOutData_arg+viI),ptrCh,2);
	MOV  R30,R20
	LDI  R31,0
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	CALL SUBOPT_0xDA
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x7
	CALL _memcpy
; 0021 02E0 		ptrCh = strtok(NULL,".");
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xD9
; 0021 02E1 		viI+=2;
	SUBI R20,-LOW(2)
; 0021 02E2 	}
	RJMP _0x420095
_0x420097:
; 0021 02E3     viReturn = 1;
	LDI  R21,LOW(1)
; 0021 02E4     return viReturn;
	MOV  R30,R21
	CALL __LOADLOCR6
	ADIW R28,22
	RET
; 0021 02E5 }
;
;iChar_t iMapAsciiHexToChar(iChar_t *chIn_arg){      //ascii hex 2 byte => char 1 byte
; 0021 02E7 iChar_t iMapAsciiHexToChar(iChar_t *chIn_arg){
; 0021 02E8 	iChar_t ivChar=0x00;
; 0021 02E9 	iChar_t *ptrCh;
; 0021 02EA 	iChar_t chReturn;
; 0021 02EB 	iChar_t i,j,k,l;
; 0021 02EC 
; 0021 02ED 	ptrCh = chIn_arg;
;	*chIn_arg -> Y+8
;	ivChar -> R17
;	*ptrCh -> R18,R19
;	chReturn -> R16
;	i -> R21
;	j -> R20
;	k -> Y+7
;	l -> Y+6
; 0021 02EE 
; 0021 02EF 	for(i=0,j=0x41,k=0x61,l=10; i<6; i++,j++,k++,l++) { //41='A' //61='a'
; 0021 02F0 		//printDebug("[hex1]%02x:%02x:%02x (%d) \r\n",i,j,k,l);
; 0021 02F1 		if((*(ptrCh) == j) || (*(ptrCh) == k)) {
; 0021 02F2 			ivChar = l;
; 0021 02F3 			break;
; 0021 02F4 		}
; 0021 02F5 	}
; 0021 02F6 	for(i=0,j=0x30; i<10; i++,j++) { //0-9 = 0x30-0x39
; 0021 02F7 		if(*(ptrCh) == j) {
; 0021 02F8 			ivChar = i;
; 0021 02F9 			break;
; 0021 02FA 		}
; 0021 02FB 	}
; 0021 02FC 	//printDebug("hex1:%02x \r\n",ivChar);
; 0021 02FD 	ptrCh++;
; 0021 02FE 
; 0021 02FF 	for(i=0,j=0x41,k=0x61,l=10; i<6; i++,j++,k++,l++) { //41='A' //61='a'
; 0021 0300 		//printDebug("[hex1]%02x:%02x:%02x (%d) \r\n",i,j,k,l);
; 0021 0301 		if((*(ptrCh) == j) || (*(ptrCh) == k)) {
; 0021 0302 			ivChar = (ivChar<<4)|l;
; 0021 0303 			break;
; 0021 0304 		}
; 0021 0305 	}
; 0021 0306 	for(i=0,j=0x30; i<10; i++,j++) { //0-9 = 0x30-0x39
; 0021 0307 		if(*(ptrCh) == j) {
; 0021 0308 			ivChar = (ivChar<<4)|i;
; 0021 0309 			break;
; 0021 030A 		}
; 0021 030B 	}
; 0021 030C 	//printDebug("hex2:%02x \r\n",ivChar);
; 0021 030D 	chReturn = ivChar;
; 0021 030E 	return chReturn;
; 0021 030F }
;#include "interruptTask.h"
;#include "timer.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "wiz100rs.h"
;int wiz100srSetTimer = -1;

	.DSEG
;//int viUart0TimeOutTemp = -1;
;piInterrupt_t pviUart0TimeOut = -1;
;extern void (*pfiWiz100rs)(void);
;
;void interruptTask(void *pviParameter){
; 0022 0009 void interruptTask(void *pviParameter){

	.CSEG
; 0022 000A 
; 0022 000B      printDebug("<interruptTask>Task Running...\r\n");
;	*pviParameter -> Y+0
; 0022 000C 
; 0022 000D //     if(pviUart0TimeOut == 1){    //start interrupt start timeout
; 0022 000E //        printf("<interruptTask>start count pviUart0TimeOut\r\n");
; 0022 000F //
; 0022 0010 //        if(wiz100srSetTimer == -1){
; 0022 0011 //           wiz100srSetTimer = countTimerIntpTask;
; 0022 0012 //        }else if((countTimerIntpTask - wiz100srSetTimer) > 2){                  //set timer = 1 sec
; 0022 0013 //             printDebug("<interruptTask>wiz100srSetTimer(timeout %d)\r\n",(countTimerIntpTask - wiz100srSetTimer));
; 0022 0014 //             wiz100srSetTimer = -1;
; 0022 0015 //             pviUart0TimeOut = 0;
; 0022 0016 //        }
; 0022 0017 //     }
; 0022 0018 
; 0022 0019      printDebug("<interruptTask>pviUart0TimeOut(%d),wiz100srSetTimer(%d)\r\n",pviUart0TimeOut,wiz100srSetTimer);
; 0022 001A      if(pviUart0TimeOut >= 0){    //start interrupt start timeout
; 0022 001B          printDebug("<interruptTask>start count pviUart0TimeOut\r\n");
; 0022 001C          if(wiz100srSetTimer == -1){
; 0022 001D              wiz100srSetTimer = countTimerIntpTask;
; 0022 001E              //viUart0TimeOutTemp = pviUart0TimeOut;
; 0022 001F          }else if((countTimerIntpTask - wiz100srSetTimer) > 2){                  //set timer = 1 sec
; 0022 0020              printDebug("<interruptTask>wiz100srSetTimer(timeout %d)\r\n",(countTimerIntpTask - wiz100srSetTimer));
; 0022 0021              pfiWiz100rs = &iWizRXTimeOut;
; 0022 0022              pfiWiz100rs();
; 0022 0023              wiz100srSetTimer = -1;
; 0022 0024              pviUart0TimeOut = -1;
; 0022 0025          }
; 0022 0026      }else if(pviUart0TimeOut == -1){
; 0022 0027          wiz100srSetTimer = -1;
; 0022 0028      }
; 0022 0029 
; 0022 002A 
; 0022 002B 
; 0022 002C }
;#include "deviceTask.h"
;#include "config.h"
;
;eeprom iUChar_t viFlagTerInit = 0;
;
;extern piQueueHandle_t pviQueueMangToConfig;
;
;iConfigFormat_t viDataConfig;
;
;void deviceTask(void *pviParameter){
; 0023 000A void deviceTask(void *pviParameter){

	.CSEG
; 0023 000B     printDebug("[deviceTask]Task Running...\r\n");
;	*pviParameter -> Y+0
; 0023 000C 
; 0023 000D     if(viFlagTerInit!=0){
; 0023 000E 
; 0023 000F     }else{
; 0023 0010 
; 0023 0011     }
; 0023 0012 
; 0023 0013     if(iQueueReceive(pviQueueMangToConfig,&viDataConfig)==1){
; 0023 0014         printDebug("[deviceTask]There is configuration.\r\n");
; 0023 0015 	}else{
; 0023 0016 		printDebug("[deviceTask]There is not config.\r\n");
; 0023 0017 	}
; 0023 0018 }
;#include "ad595.h"
;
;//iAD595 ad595Get(unsigned int adcValue_p){
;//     iAD595.tempCelsius = (3 * adcValue_p * 100.0)/1024;              //100.0 = 10 mV
;//     return iAD595;
;//}
;#include "logTask.h"
;#include "debug.h"
;#include "logManager.h"
;
;void logTask(void *pviParameter){
; 0025 0005 void logTask(void *pviParameter){

	.CSEG
_logTask:
; 0025 0006      printDebug("[logTask]Running...\r\n");
	ST   -Y,R27
	ST   -Y,R26
;	*pviParameter -> Y+0
	__POINTD1FN _0x4A0000,0
	CALL SUBOPT_0x0
; 0025 0007 
; 0025 0008      iGenFileDaily();
	CALL _iGenFileDaily
; 0025 0009 }
	ADIW R28,2
	RET
;#include "sdManager.h"
;
;// global variable
;//iChar_t viFolderDataName[] = "Data";
;iChar_t viFolderDataName[] = "Record";

	.DSEG
;//iChar_t viFolderDataLogName[] = "Data_Log";
;iChar_t viFolderDataLogName[] = "Log";
;iChar_t viFolderEventName[] = "Event";
;iChar_t viFolderStatusName[] = "Status";
;iChar_t viFolderErrorName[] = "Error";
;iChar_t viFolderConfigName[] = "Config";
;
;iChar_t viDirRootPath[] = "0:/";
;//iChar_t viDirDataPath[] = "0:/DATA";
;//iChar_t viDirDataPath[] = "0:/RECORD";
;iChar_t viDirDataPath[] = "0:/RECORD";
;//iChar_t viDirDataLogPath[] = "0:/DATA_LOG";
;iChar_t viDirDataLogPath[] = "0:/LOG";
;iChar_t viDirEventPath[] = "0:/EVENT";
;iChar_t viDirStatusPath[] = "0:/STATUS";
;iChar_t viDirErrorPath[] = "0:/ERROR";
;iChar_t viDirConfigPath[] = "0:/CONFIG";
;
;//iChar_t viDataFName[] = "0:./data1.nc";
;iChar_t viDataFName[] = "0:./00000000.nc";
;iChar_t viDataLogFName[] = "0:./dataLog1.nc";
;iChar_t viEventFName[] = "0:./event1.nc";
;iChar_t viStatusFName[] = "0:./status1.nc";
;iChar_t viErrorFName[] = "0:./error1.nc";
;iChar_t viConfigFName[] = "0:./config1.nc";
;
;/* will hold file/directory information returned by f_readdir*/
;FILINFO file_info;
;
;
;///* recursively scan directory entries and display them */
;//FRESULT directory_scan(char *path){
;//    /* will hold the directory information */
;//    DIR directory;
;//    /* FAT function result */
;//    FRESULT res;
;//    int i;
;//
;//
;//    if ((res=f_opendir(&directory,path))==FR_OK){
;//       while (((res=f_readdir(&directory,&file_info))==FR_OK) &&
;//             file_info.fname[0])
;//             {
;//             /* display file/directory name and associated information */
;//             printDebug("%c%c%c%c%c %02u/%02u/%u %02u:%02u:%02u %9lu"                 "  %s/%s\r\n",
;//                    (file_info.fattrib & AM_DIR) ? 'D' : '-',
;//                    (file_info.fattrib & AM_RDO) ? 'R' : '-',
;//                    (file_info.fattrib & AM_HID) ? 'H' : '-',
;//                    (file_info.fattrib & AM_SYS) ? 'S' : '-',
;//                    (file_info.fattrib & AM_ARC) ? 'A' : '-',
;//                    file_info.fdate & 0x1F,(file_info.fdate >> 5) & 0xF,
;//                    (file_info.fdate >> 9)+1980,
;//                    file_info.ftime >> 11,(file_info.ftime >> 5) & 0x3F,
;//                    (file_info.ftime & 0xF) << 1,
;//                    file_info.fsize,path,file_info.fname);
;//             if (file_info.fattrib & AM_DIR)
;//                {
;//                /* its a subdirectory */
;//                /* make sure to skip past "." and ".." when recursing */
;//                if (file_info.fname[0]!='.')
;//                   {
;//                   i=strlen(path);
;//                   /* append the subdirectory name to the path */
;//                   if (path[i-1]!='/') strcatf(path,"/");
;//                   strcat(path,file_info.fname);
;//                   /* scan subdirectory */
;//                   res=directory_scan(path);
;//                   /* restore the old path name */
;//                   path[i]=0;
;//                   /* remove any eventual '/' from the end of the path */
;//                   --i;
;//                   if (path[i]=='/') path[i]=0;
;//                   /* stop if an error occured */
;//                   if (res!=FR_OK) break;
;//                   }
;//                }
;//              }
;//    }
;//   return res;
;//}
;
;
;
;iInt_t iCreateFolder(iUChar_t viFolderName_arg){
; 0026 0059 iInt_t iCreateFolder(iUChar_t viFolderName_arg){

	.CSEG
; 0026 005A 
; 0026 005B }
;
;
;iInt_t iInitSDCard(){
; 0026 005E iInt_t iInitSDCard(){
_iInitSDCard:
; 0026 005F     //Check SD folder
; 0026 0060 //    char viFolderDataName[] = "Data";
; 0026 0061 //    char viFolderEventName[] = "Event";
; 0026 0062 //    char viFolderStatusName[] = "Status";
; 0026 0063 //    char viFolderErrorName[] = "Error";
; 0026 0064 //    char viFolderConfigName[] = "Config";
; 0026 0065 //    char viDirRootPath[] = "0:/";
; 0026 0066 //    char viDirDataPath[] = "0:/DATA";
; 0026 0067 //    char viDirEventPath[] = "0:/EVENT";
; 0026 0068 //    char viDirStatusPath[] = "0:/STATUS";
; 0026 0069 //    char viDirErrorPath[] = "0:/ERROR";
; 0026 006A //    char viDirConfigPath[] = "0:/CONFIG";
; 0026 006B     FRESULT viFReturn;
; 0026 006C     DIR viOutDir;
; 0026 006D 
; 0026 006E 
; 0026 006F     viFReturn = f_opendir(&viOutDir, viDirDataPath);
	SBIW R28,22
	ST   -Y,R17
;	viFReturn -> R17
;	viOutDir -> Y+1
	CALL SUBOPT_0xDB
	LDI  R26,LOW(_viDirDataPath)
	LDI  R27,HIGH(_viDirDataPath)
	CALL SUBOPT_0xDC
; 0026 0070     if(viFReturn == FR_OK){
	BRNE _0x4C0016
; 0026 0071         printDebug("[iInitSDCard]Record dir is exist.\r\n");
	__POINTD1FN _0x4C0000,0
	RJMP _0x4C0076
; 0026 0072     }else{
_0x4C0016:
; 0026 0073         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xDD
; 0026 0074         if(viFReturn == FR_NO_PATH){
	BRNE _0x4C0018
; 0026 0075             viFReturn = f_mkdir(viFolderDataName);
	LDI  R26,LOW(_viFolderDataName)
	LDI  R27,HIGH(_viFolderDataName)
	CALL SUBOPT_0xDE
; 0026 0076             if(viFReturn == FR_OK){
	BRNE _0x4C0019
; 0026 0077                printDebug("[iInitSDCard]mkdir Record success.\r\n");
	__POINTD1FN _0x4C0000,36
	RJMP _0x4C0076
; 0026 0078             }else{
_0x4C0019:
; 0026 0079                printDebug("[iInitSDCard]mkdir Record error.\r\n");
	__POINTD1FN _0x4C0000,73
_0x4C0076:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0026 007A             }
; 0026 007B         }
; 0026 007C     }
_0x4C0018:
; 0026 007D 
; 0026 007E     viFReturn = f_opendir(&viOutDir, viDirDataLogPath);
	CALL SUBOPT_0xDB
	LDI  R26,LOW(_viDirDataLogPath)
	LDI  R27,HIGH(_viDirDataLogPath)
	CALL SUBOPT_0xDC
; 0026 007F     if(viFReturn == FR_OK){
	BRNE _0x4C001B
; 0026 0080         printDebug("[iInitSDCard]DataLog dir is exist.\r\n");
	__POINTD1FN _0x4C0000,108
	RJMP _0x4C0077
; 0026 0081     }else{
_0x4C001B:
; 0026 0082         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xDD
; 0026 0083         if(viFReturn == FR_NO_PATH){
	BRNE _0x4C001D
; 0026 0084             viFReturn = f_mkdir(viFolderDataLogName);
	LDI  R26,LOW(_viFolderDataLogName)
	LDI  R27,HIGH(_viFolderDataLogName)
	CALL SUBOPT_0xDE
; 0026 0085             if(viFReturn == FR_OK){
	BRNE _0x4C001E
; 0026 0086                printDebug("[iInitSDCard]mkdir DataLog success.\r\n");
	__POINTD1FN _0x4C0000,145
	RJMP _0x4C0077
; 0026 0087             }else{
_0x4C001E:
; 0026 0088                printDebug("[iInitSDCard]mkdir DataLog error.\r\n");
	__POINTD1FN _0x4C0000,183
_0x4C0077:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0026 0089             }
; 0026 008A         }
; 0026 008B     }
_0x4C001D:
; 0026 008C 
; 0026 008D     viFReturn = f_opendir(&viOutDir, viDirEventPath);
	CALL SUBOPT_0xDB
	LDI  R26,LOW(_viDirEventPath)
	LDI  R27,HIGH(_viDirEventPath)
	CALL SUBOPT_0xDC
; 0026 008E     if(viFReturn == FR_OK){
	BRNE _0x4C0020
; 0026 008F         printDebug("[iInitSDCard]Event dir is exist.\r\n");
	__POINTD1FN _0x4C0000,219
	RJMP _0x4C0078
; 0026 0090     }else{
_0x4C0020:
; 0026 0091         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xDD
; 0026 0092         if(viFReturn == FR_NO_PATH){
	BRNE _0x4C0022
; 0026 0093             viFReturn = f_mkdir(viFolderEventName);
	LDI  R26,LOW(_viFolderEventName)
	LDI  R27,HIGH(_viFolderEventName)
	CALL SUBOPT_0xDE
; 0026 0094             if(viFReturn == FR_OK){
	BRNE _0x4C0023
; 0026 0095                printDebug("[iInitSDCard]mkdir Event success.\r\n");
	__POINTD1FN _0x4C0000,254
	RJMP _0x4C0078
; 0026 0096             }else{
_0x4C0023:
; 0026 0097                printDebug("[iInitSDCard]mkdir Event error.\r\n");
	__POINTD1FN _0x4C0000,290
_0x4C0078:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0026 0098             }
; 0026 0099         }
; 0026 009A     }
_0x4C0022:
; 0026 009B 
; 0026 009C     viFReturn = f_opendir(&viOutDir, viDirStatusPath);
	CALL SUBOPT_0xDB
	LDI  R26,LOW(_viDirStatusPath)
	LDI  R27,HIGH(_viDirStatusPath)
	CALL SUBOPT_0xDC
; 0026 009D     if(viFReturn == FR_OK){
	BRNE _0x4C0025
; 0026 009E         printDebug("[iInitSDCard]Status dir is exist.\r\n");
	__POINTD1FN _0x4C0000,324
	RJMP _0x4C0079
; 0026 009F     }else{
_0x4C0025:
; 0026 00A0         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xDD
; 0026 00A1         if(viFReturn == FR_NO_PATH){
	BRNE _0x4C0027
; 0026 00A2             viFReturn = f_mkdir(viFolderStatusName);
	LDI  R26,LOW(_viFolderStatusName)
	LDI  R27,HIGH(_viFolderStatusName)
	CALL SUBOPT_0xDE
; 0026 00A3             if(viFReturn == FR_OK){
	BRNE _0x4C0028
; 0026 00A4                printDebug("[iInitSDCard]mkdir Status success.\r\n");
	__POINTD1FN _0x4C0000,360
	RJMP _0x4C0079
; 0026 00A5             }else{
_0x4C0028:
; 0026 00A6                printDebug("[iInitSDCard]mkdir Status error.\r\n");
	__POINTD1FN _0x4C0000,397
_0x4C0079:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0026 00A7             }
; 0026 00A8         }
; 0026 00A9     }
_0x4C0027:
; 0026 00AA 
; 0026 00AB     viFReturn = f_opendir(&viOutDir, viDirErrorPath);
	CALL SUBOPT_0xDB
	LDI  R26,LOW(_viDirErrorPath)
	LDI  R27,HIGH(_viDirErrorPath)
	CALL SUBOPT_0xDC
; 0026 00AC     if(viFReturn == FR_OK){
	BRNE _0x4C002A
; 0026 00AD         printDebug("[iInitSDCard]Error dir is exist.\r\n");
	__POINTD1FN _0x4C0000,432
	RJMP _0x4C007A
; 0026 00AE     }else{
_0x4C002A:
; 0026 00AF         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xDD
; 0026 00B0         if(viFReturn == FR_NO_PATH){
	BRNE _0x4C002C
; 0026 00B1             viFReturn = f_mkdir(viFolderErrorName);
	LDI  R26,LOW(_viFolderErrorName)
	LDI  R27,HIGH(_viFolderErrorName)
	CALL SUBOPT_0xDE
; 0026 00B2             if(viFReturn == FR_OK){
	BRNE _0x4C002D
; 0026 00B3                printDebug("[iInitSDCard]mkdir Error success.\r\n");
	__POINTD1FN _0x4C0000,467
	RJMP _0x4C007A
; 0026 00B4             }else{
_0x4C002D:
; 0026 00B5                printDebug("[iInitSDCard]mkdir Error error.\r\n");
	__POINTD1FN _0x4C0000,503
_0x4C007A:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0026 00B6             }
; 0026 00B7         }
; 0026 00B8     }
_0x4C002C:
; 0026 00B9 
; 0026 00BA     viFReturn = f_opendir(&viOutDir, viDirConfigPath);
	CALL SUBOPT_0xDB
	LDI  R26,LOW(_viDirConfigPath)
	LDI  R27,HIGH(_viDirConfigPath)
	CALL SUBOPT_0xDC
; 0026 00BB     if(viFReturn == FR_OK){
	BRNE _0x4C002F
; 0026 00BC         printDebug("[iInitSDCard]Config dir is exist.\r\n");
	__POINTD1FN _0x4C0000,537
	RJMP _0x4C007B
; 0026 00BD     }else{
_0x4C002F:
; 0026 00BE         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xDD
; 0026 00BF         if(viFReturn == FR_NO_PATH){
	BRNE _0x4C0031
; 0026 00C0             viFReturn = f_mkdir(viFolderConfigName);
	LDI  R26,LOW(_viFolderConfigName)
	LDI  R27,HIGH(_viFolderConfigName)
	CALL SUBOPT_0xDE
; 0026 00C1             if(viFReturn == FR_OK){
	BRNE _0x4C0032
; 0026 00C2                printDebug("[iInitSDCard]mkdir Config success.\r\n");
	__POINTD1FN _0x4C0000,573
	RJMP _0x4C007B
; 0026 00C3             }else{
_0x4C0032:
; 0026 00C4                printDebug("[iInitSDCard]mkdir Config error.\r\n");
	__POINTD1FN _0x4C0000,610
_0x4C007B:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0026 00C5             }
; 0026 00C6         }
; 0026 00C7     }
_0x4C0031:
; 0026 00C8 }
	LDD  R17,Y+0
	ADIW R28,23
	RET
;
;
;void iFDisplayReturn(FRESULT viFResulyt_arg){
; 0026 00CB void iFDisplayReturn(FRESULT viFResulyt_arg){
_iFDisplayReturn:
; 0026 00CC     switch(viFResulyt_arg){
	ST   -Y,R26
;	viFResulyt_arg -> Y+0
	LD   R30,Y
	CALL SUBOPT_0x16
; 0026 00CD         case FR_OK:{
	BRNE _0x4C0037
; 0026 00CE             printDebug("success.\r\n");
	__POINTD1FN _0x4C0000,62
	RJMP _0x4C007C
; 0026 00CF             break;
; 0026 00D0         }
; 0026 00D1         case FR_NO_PATH:{
_0x4C0037:
	CPI  R30,LOW(0x5)
	LDI  R26,HIGH(0x5)
	CPC  R31,R26
	BRNE _0x4C0038
; 0026 00D2             printDebug("couldn't find the path.\r\n");
	__POINTD1FN _0x4C0000,645
	RJMP _0x4C007C
; 0026 00D3             break;
; 0026 00D4         }
; 0026 00D5         case FR_INVALID_NAME:{
_0x4C0038:
	CPI  R30,LOW(0x6)
	LDI  R26,HIGH(0x6)
	CPC  R31,R26
	BRNE _0x4C0039
; 0026 00D6             printDebug("the directory name is invalid.\r\n");
	__POINTD1FN _0x4C0000,671
	RJMP _0x4C007C
; 0026 00D7             break;
; 0026 00D8         }
; 0026 00D9         case FR_INVALID_DRIVE:{
_0x4C0039:
	CPI  R30,LOW(0xB)
	LDI  R26,HIGH(0xB)
	CPC  R31,R26
	BRNE _0x4C003A
; 0026 00DA             printDebug("the drive number is invalid.\r\n");
	__POINTD1FN _0x4C0000,704
	RJMP _0x4C007C
; 0026 00DB             break;
; 0026 00DC         }
; 0026 00DD         case FR_NOT_READY:{
_0x4C003A:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x4C003B
; 0026 00DE             printDebug("no disk access was possible due to missing media or other reason.\r\n");
	__POINTD1FN _0x4C0000,735
	RJMP _0x4C007C
; 0026 00DF             break;
; 0026 00E0         }
; 0026 00E1         case FR_DISK_ERR:{
_0x4C003B:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x4C003C
; 0026 00E2             printDebug("the function failed because of a physical disk access function failure.\r\n");
	__POINTD1FN _0x4C0000,803
	RJMP _0x4C007C
; 0026 00E3             break;
; 0026 00E4         }
; 0026 00E5         case FR_INT_ERR:{
_0x4C003C:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x4C003D
; 0026 00E6             printDebug("the function failed due to a wrong FAT structure or an internal error.\r\n");
	__POINTD1FN _0x4C0000,877
	RJMP _0x4C007C
; 0026 00E7             break;
; 0026 00E8         }
; 0026 00E9         case FR_NOT_ENABLED:{
_0x4C003D:
	CPI  R30,LOW(0xC)
	LDI  R26,HIGH(0xC)
	CPC  R31,R26
	BRNE _0x4C003E
; 0026 00EA             printDebug("the logical drive was not mounted with f_mount.\r\n");
	__POINTD1FN _0x4C0000,950
	RJMP _0x4C007C
; 0026 00EB             break;
; 0026 00EC         }
; 0026 00ED         case FR_NO_FILESYSTEM:{
_0x4C003E:
	CPI  R30,LOW(0xD)
	LDI  R26,HIGH(0xD)
	CPC  R31,R26
	BRNE _0x4C003F
; 0026 00EE             printDebug("there is no valid FAT partition on the disk.\r\n");
	__POINTD1FN _0x4C0000,1000
	RJMP _0x4C007C
; 0026 00EF             break;
; 0026 00F0         }
; 0026 00F1         case FR_DENIED:{
_0x4C003F:
	CPI  R30,LOW(0x7)
	LDI  R26,HIGH(0x7)
	CPC  R31,R26
	BRNE _0x4C0040
; 0026 00F2             printDebug("file access was denied because it was opened in read-only mode.\r\n");
	__POINTD1FN _0x4C0000,1047
	RJMP _0x4C007C
; 0026 00F3             break;
; 0026 00F4         }
; 0026 00F5         case FR_INVALID_OBJECT:{
_0x4C0040:
	CPI  R30,LOW(0x9)
	LDI  R26,HIGH(0x9)
	CPC  R31,R26
	BRNE _0x4C0041
; 0026 00F6             printDebug("the file was not opened with f_open.\r\n");
	__POINTD1FN _0x4C0000,1113
	RJMP _0x4C007C
; 0026 00F7             break;
; 0026 00F8         }
; 0026 00F9         case FR_NO_FILE:{
_0x4C0041:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x4C0042
; 0026 00FA             printDebug("couldn't find the file or directory.\r\n");
	__POINTD1FN _0x4C0000,1152
	RJMP _0x4C007C
; 0026 00FB             break;
; 0026 00FC         }
; 0026 00FD         case FR_WRITE_PROTECTED:{
_0x4C0042:
	CPI  R30,LOW(0xA)
	LDI  R26,HIGH(0xA)
	CPC  R31,R26
	BRNE _0x4C0036
; 0026 00FE             printDebug("the media in the drive is write protected.\r\n");
	__POINTD1FN _0x4C0000,1191
_0x4C007C:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0026 00FF             break;
; 0026 0100         }
; 0026 0101     }
_0x4C0036:
; 0026 0102 }
	ADIW R28,1
	RET
;
;
;void iFCreate(FIL *pviOutFilePtr_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0026 0105 void iFCreate(FIL *pviOutFilePtr_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0026 0106     FRESULT viFReturn;
; 0026 0107     //iUChar_t viReturn = 0;
; 0026 0108     DIR viOutDir;
; 0026 0109     FIL pviFilePtr;
; 0026 010A 
; 0026 010B     if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
;	*pviOutFilePtr_arg -> Y+571
;	*pviDirPath_arg -> Y+569
;	*pviFilename_arg -> Y+567
;	viFReturn -> R17
;	viOutDir -> Y+545
;	pviFilePtr -> Y+1
; 0026 010C        printDebug("[iFCreate]Current directory : %s.\r\n",pviDirPath_arg);
; 0026 010D        if((viFReturn=f_open(pviOutFilePtr_arg,pviFilename_arg,FA_CREATE_NEW))==FR_OK){
; 0026 010E            printDebug("[iFCreate]File %s is created.\r\n",pviFilename_arg);
; 0026 010F            if((viFReturn=f_close(pviOutFilePtr_arg))==FR_OK){
; 0026 0110            }else{
; 0026 0111               iFDisplayReturn(viFReturn);
; 0026 0112            }
; 0026 0113        }else{
; 0026 0114            printDebug("[iFCreate]File %s : %s.[\r\n",pviFilename_arg);
; 0026 0115            iFDisplayReturn(viFReturn);
; 0026 0116            printDebug("]\r\n");
; 0026 0117        }
; 0026 0118     }else{
; 0026 0119        printDebug("[iFCreate]directory : %s.[\r\n",pviDirPath_arg);
; 0026 011A        iFDisplayReturn(viFReturn);
; 0026 011B        printDebug("]\r\n");
; 0026 011C     }
; 0026 011D }
;
;void iFRwite(const iChar_t * const pviDataBuff,iUInt_t ivLength_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg,iUInt_t viBlockSize_arg){
; 0026 011F void iFRwite(const iChar_t * const pviDataBuff,iUInt_t ivLength_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg,iUInt_t viBlockSize_arg){
_iFRwite:
; 0026 0120     FIL *viFilePtr;
; 0026 0121     FRESULT viFReturn;
; 0026 0122     unsigned int nbytes;
; 0026 0123     const iChar_t * pviDataBuffRef = (iChar_t * const )pviDataBuff;
; 0026 0124 
; 0026 0125     //print_payload((const iChar_t *)pviDataBuff,ivLength_arg);
; 0026 0126     print_payload(pviDataBuffRef,ivLength_arg);
	CALL SUBOPT_0xDF
;	*pviDataBuff -> Y+16
;	ivLength_arg -> Y+14
;	*pviDirPath_arg -> Y+12
;	*pviFilename_arg -> Y+10
;	viBlockSize_arg -> Y+8
;	*viFilePtr -> R16,R17
;	viFReturn -> R19
;	nbytes -> R20,R21
;	*pviDataBuffRef -> Y+6
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	STD  Y+6,R30
	STD  Y+6+1,R31
	CALL SUBOPT_0x74
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	CALL _print_payload
; 0026 0127     viFilePtr = (FIL * const)malloc(sizeof(FIL));
	CALL SUBOPT_0xE0
; 0026 0128     if(viFilePtr!=NULL){
	BRNE PC+3
	JMP _0x4C004A
; 0026 0129         if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	CALL SUBOPT_0xE1
	BREQ PC+3
	JMP _0x4C004B
; 0026 012A            printDebug("[iFRwite]Current directory : %s.\r\n",pviDirPath_arg);
	__POINTD1FN _0x4C0000,1364
	CALL SUBOPT_0xE2
	CALL SUBOPT_0x63
; 0026 012B            if((viFReturn=f_open(viFilePtr,pviFilename_arg,FA_WRITE|FA_OPEN_ALWAYS))==FR_OK){
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x75
	LDI  R26,LOW(18)
	CALL SUBOPT_0xE3
	BREQ PC+3
	JMP _0x4C004C
; 0026 012C                printDebug("[iFRwite]File %s is openned.\r\n",pviFilename_arg);
	__POINTD1FN _0x4C0000,1399
	CALL SUBOPT_0xE4
	CALL SUBOPT_0x63
; 0026 012D 
; 0026 012E                /* Move to end of the file to append data */
; 0026 012F                printDebug("[iFRwite]File size(%ld).\r\n",viFilePtr->fsize);
	__POINTD1FN _0x4C0000,1430
	CALL SUBOPT_0xE5
; 0026 0130                if((viFReturn=f_lseek(viFilePtr, viFilePtr->fsize))==FR_OK){        //seek end of file in order append
	ST   -Y,R17
	ST   -Y,R16
	MOVW R30,R16
	CALL SUBOPT_0xE6
	CALL _f_lseek
	MOV  R19,R30
	CPI  R30,0
	BRNE _0x4C004D
; 0026 0131                    printDebug("[iFRwite]Pointer(seek) of File moved.\r\n");
	__POINTD1FN _0x4C0000,1457
	CALL SUBOPT_0x0
; 0026 0132                    //print_payload((const iChar_t *)pviDataBuff,ivLength_arg);
; 0026 0133                    print_payload(pviDataBuffRef,ivLength_arg);
	CALL SUBOPT_0x74
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	CALL _print_payload
; 0026 0134                    if((viFReturn=f_write(viFilePtr,(const iChar_t *)pviDataBuff,ivLength_arg,&nbytes))==FR_OK){    //viFReturn=f_write(viFilePtr,&pviDataBuff[0],strlen(pviDataBuff),&nbytes)
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0xE7
	CALL SUBOPT_0xE7
	IN   R26,SPL
	IN   R27,SPH
	SBIW R26,1
	PUSH R21
	PUSH R20
	CALL _f_write
	POP  R20
	POP  R21
	MOV  R19,R30
	CPI  R30,0
	BRNE _0x4C004E
; 0026 0135                        printDebug("[iFRwite]%d bytes written of %d\r\n",nbytes,ivLength_arg);
	__POINTD1FN _0x4C0000,1497
	CALL SUBOPT_0x98
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x7F
; 0026 0136                    }else{
	RJMP _0x4C004F
_0x4C004E:
; 0026 0137                        printDebug("[iFRwite]Write error(%d)\r\n",viFReturn);
	__POINTD1FN _0x4C0000,1531
	CALL __PUTPARD1
	MOV  R30,R19
	CALL SUBOPT_0x9E
; 0026 0138                        iFDisplayReturn(viFReturn);
	MOV  R26,R19
	RCALL _iFDisplayReturn
; 0026 0139                    }
_0x4C004F:
; 0026 013A                }else{
	RJMP _0x4C0050
_0x4C004D:
; 0026 013B                    iFDisplayReturn(viFReturn);
	MOV  R26,R19
	RCALL _iFDisplayReturn
; 0026 013C                }
_0x4C0050:
; 0026 013D 
; 0026 013E                if((viFReturn=f_close(viFilePtr))==FR_OK){
	CALL SUBOPT_0xE8
	BREQ _0x4C0052
; 0026 013F                }else{
; 0026 0140                   iFDisplayReturn(viFReturn);
	MOV  R26,R19
	RCALL _iFDisplayReturn
; 0026 0141                }
_0x4C0052:
; 0026 0142            }else{
	RJMP _0x4C0053
_0x4C004C:
; 0026 0143                printDebug("[iFRwite]File %s : %s.[\r\n",pviFilename_arg);
	__POINTD1FN _0x4C0000,1558
	CALL SUBOPT_0xE4
	CALL SUBOPT_0x63
; 0026 0144                iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xE9
; 0026 0145                printDebug("]\r\n");
; 0026 0146            }
_0x4C0053:
; 0026 0147         }else{
	RJMP _0x4C0054
_0x4C004B:
; 0026 0148            printDebug("[iFRwite]directory : %s.[\r\n",pviDirPath_arg);
	__POINTD1FN _0x4C0000,1584
	CALL SUBOPT_0xE2
	CALL SUBOPT_0x63
; 0026 0149            iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xE9
; 0026 014A            printDebug("]\r\n");
; 0026 014B         }
_0x4C0054:
; 0026 014C         free(viFilePtr);
	MOVW R26,R16
	CALL _free
; 0026 014D     }else{
	RJMP _0x4C0055
_0x4C004A:
; 0026 014E         printDebug("[iFRwite]can't allocate mem.\r\n");
	__POINTD1FN _0x4C0000,1612
	CALL SUBOPT_0x0
; 0026 014F     }
_0x4C0055:
; 0026 0150 
; 0026 0151 }
	CALL __LOADLOCR6
	ADIW R28,18
	RET
;
;void iFDelete(iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0026 0153 void iFDelete(iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0026 0154     FRESULT viFReturn;
; 0026 0155     if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
;	*pviDirPath_arg -> Y+3
;	*pviFilename_arg -> Y+1
;	viFReturn -> R17
; 0026 0156        printDebug("[iFDelete]Current directory : %s.\r\n",pviDirPath_arg);
; 0026 0157        if((viFReturn=f_unlink(pviFilename_arg))==FR_OK){
; 0026 0158            printDebug("[iFDelete]File %s is deleted.\r\n",pviFilename_arg);
; 0026 0159        }else{
; 0026 015A            printDebug("[iFDelete]File %s : %s. can't delete.[\r\n",pviFilename_arg);
; 0026 015B            iFDisplayReturn(viFReturn);
; 0026 015C            printDebug("]\r\n");
; 0026 015D        }
; 0026 015E     }else{
; 0026 015F        printDebug("[iFDelete]directory : %s.[\r\n",pviDirPath_arg);
; 0026 0160        iFDisplayReturn(viFReturn);
; 0026 0161        printDebug("]\r\n");
; 0026 0162     }
; 0026 0163 }
;
;iChar_t iFSize(iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg,unsigned long *pviOutFileSize_arg){
; 0026 0165 iChar_t iFSize(iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg,unsigned long *pviOutFileSize_arg){
_iFSize:
; 0026 0166     FIL *viFilePtr;
; 0026 0167     FRESULT viFReturn;
; 0026 0168     iChar_t viReturn = -1;
; 0026 0169 
; 0026 016A     viFilePtr = (FIL * const)malloc(sizeof(FIL));
	CALL SUBOPT_0xEA
;	*pviDirPath_arg -> Y+8
;	*pviFilename_arg -> Y+6
;	*pviOutFileSize_arg -> Y+4
;	*viFilePtr -> R16,R17
;	viFReturn -> R19
;	viReturn -> R18
	LDI  R18,255
	CALL SUBOPT_0xE0
; 0026 016B     if(viFilePtr!=NULL){
	BRNE PC+3
	JMP _0x4C005A
; 0026 016C        if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL SUBOPT_0xE1
	BRNE _0x4C005B
; 0026 016D            printDebug("[iFSize]Current directory : %s.\r\n",pviDirPath_arg);
	__POINTD1FN _0x4C0000,1781
	CALL SUBOPT_0xEB
	CALL SUBOPT_0x63
; 0026 016E            if((viFReturn=f_open(viFilePtr,pviFilename_arg,FA_WRITE|FA_OPEN_ALWAYS))==FR_OK){
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0xD7
	LDI  R26,LOW(18)
	CALL SUBOPT_0xE3
	BRNE _0x4C005C
; 0026 016F                printDebug("[iFSize]File %s is openned.\r\n",pviFilename_arg);
	__POINTD1FN _0x4C0000,1815
	CALL SUBOPT_0x6E
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 0026 0170 
; 0026 0171                /* Move to end of the file to append data */
; 0026 0172                printDebug("[iFSize]File size(%ld).\r\n",viFilePtr->fsize);
	__POINTD1FN _0x4C0000,1845
	CALL SUBOPT_0xE5
; 0026 0173                *pviOutFileSize_arg = viFilePtr->fsize;
	MOVW R26,R16
	ADIW R26,10
	CALL __GETD1P
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL __PUTDP1
; 0026 0174 
; 0026 0175                if((viFReturn=f_close(viFilePtr))==FR_OK){
	CALL SUBOPT_0xE8
	BREQ _0x4C005E
; 0026 0176                }else{
; 0026 0177                   iFDisplayReturn(viFReturn);
	MOV  R26,R19
	RCALL _iFDisplayReturn
; 0026 0178                }
_0x4C005E:
; 0026 0179                viReturn = 1;
	LDI  R18,LOW(1)
; 0026 017A            }else{
	RJMP _0x4C005F
_0x4C005C:
; 0026 017B                printDebug("[iFSize]File %s : %s.[\r\n",pviFilename_arg);
	__POINTD1FN _0x4C0000,1871
	CALL SUBOPT_0x6E
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 0026 017C                iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xE9
; 0026 017D                printDebug("]\r\n");
; 0026 017E            }
_0x4C005F:
; 0026 017F         }else{
	RJMP _0x4C0060
_0x4C005B:
; 0026 0180            printDebug("[iFSize]directory : %s.[\r\n",pviDirPath_arg);
	__POINTD1FN _0x4C0000,1896
	CALL SUBOPT_0xEB
	CALL SUBOPT_0x63
; 0026 0181            iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xE9
; 0026 0182            printDebug("]\r\n");
; 0026 0183         }
_0x4C0060:
; 0026 0184         free(viFilePtr);
	MOVW R26,R16
	CALL _free
; 0026 0185     }else{
	RJMP _0x4C0061
_0x4C005A:
; 0026 0186         printDebug("[iFSize]can't allocate mem.\r\n");
	__POINTD1FN _0x4C0000,1923
	CALL SUBOPT_0x0
; 0026 0187     }
_0x4C0061:
; 0026 0188     return viReturn;
	MOV  R30,R18
	CALL __LOADLOCR4
	ADIW R28,10
	RET
; 0026 0189 }
;
;void iFCreateFileDaily(iChar_t *pviFilename_arg){
; 0026 018B void iFCreateFileDaily(iChar_t *pviFilename_arg){
; 0026 018C     FRESULT viFReturn;
; 0026 018D     DIR viOutDir;
; 0026 018E     FIL *viFilePtr;
; 0026 018F 
; 0026 0190     if((viFReturn=f_chdir(viDirDataPath))==FR_OK){
;	*pviFilename_arg -> Y+26
;	viFReturn -> R17
;	viOutDir -> Y+4
;	*viFilePtr -> R18,R19
; 0026 0191         printDebug("[iFCreateFileDaily]Current directory : %s.\r\n",viDirDataPath);
; 0026 0192         if(viFReturn == FR_OK){
; 0026 0193             printDebug("[iFCreateFileDaily]Data dir is exist.\r\n");
; 0026 0194             if((viFReturn=f_open(viFilePtr,pviFilename_arg,FA_OPEN_ALWAYS))==FR_OK){
; 0026 0195                 printDebug("[iGenFileDaily]File %s is openned.\r\n",pviFilename_arg);
; 0026 0196                 if((viFReturn=f_close(viFilePtr))==FR_OK){
; 0026 0197                 }else{
; 0026 0198                    iFDisplayReturn(viFReturn);
; 0026 0199                 }
; 0026 019A             }else{
; 0026 019B                 iFDisplayReturn(viFReturn);
; 0026 019C                 printDebug("\r\n");
; 0026 019D             }
; 0026 019E         }else{
; 0026 019F             iFDisplayReturn(viFReturn);
; 0026 01A0         }
; 0026 01A1     }else{
; 0026 01A2        printDebug("[iFCreateFileDaily]directory : %s.[\r\n",viDirDataPath);
; 0026 01A3        iFDisplayReturn(viFReturn);
; 0026 01A4        printDebug("]\r\n");
; 0026 01A5     }
; 0026 01A6 }
;
;iChar_t iFRead(iChar_t * pviDataBuff,iUInt_t ivLength_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg,unsigned long *pviReadPtr_arg){
; 0026 01A8 iChar_t iFRead(iChar_t * pviDataBuff,iUInt_t ivLength_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg,unsigned long *pviReadPtr_arg){
_iFRead:
; 0026 01A9     FIL *viFilePtr;
; 0026 01AA     FRESULT viFReturn;
; 0026 01AB     unsigned int nbytes;
; 0026 01AC     iChar_t viReturn = -1;
; 0026 01AD 
; 0026 01AE     //print_payload(pviDataBuffRef,ivLength_arg);
; 0026 01AF     viFilePtr = (FIL * const)malloc(sizeof(FIL));
	CALL SUBOPT_0x6D
;	*pviDataBuff -> Y+14
;	ivLength_arg -> Y+12
;	*pviDirPath_arg -> Y+10
;	*pviFilename_arg -> Y+8
;	*pviReadPtr_arg -> Y+6
;	*viFilePtr -> R16,R17
;	viFReturn -> R19
;	nbytes -> R20,R21
;	viReturn -> R18
	LDI  R18,255
	CALL SUBOPT_0xE0
; 0026 01B0     if(viFilePtr!=NULL){
	BRNE PC+3
	JMP _0x4C006A
; 0026 01B1         if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL SUBOPT_0xE1
	BREQ PC+3
	JMP _0x4C006B
; 0026 01B2            printDebug("[iFRead]Current directory : %s.\r\n",pviDirPath_arg);
	__POINTD1FN _0x4C0000,2113
	CALL SUBOPT_0xE4
	CALL SUBOPT_0x63
; 0026 01B3            if((viFReturn=f_open(viFilePtr,pviFilename_arg,FA_READ))==FR_OK){
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(1)
	CALL SUBOPT_0xE3
	BREQ PC+3
	JMP _0x4C006C
; 0026 01B4                printDebug("[iFRead]File %s is openned.\r\n",pviFilename_arg);
	__POINTD1FN _0x4C0000,2147
	CALL SUBOPT_0xEB
	CALL SUBOPT_0x63
; 0026 01B5 
; 0026 01B6                /* Move to end of the file to append data */
; 0026 01B7                //printDebug("[iFRead]File size(%ld).\r\n",viFilePtr->fsize);
; 0026 01B8                if((viFReturn=f_lseek(viFilePtr, *pviReadPtr_arg))==FR_OK){        //seek end of file in order append
	ST   -Y,R17
	ST   -Y,R16
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL __GETD1P
	MOVW R26,R30
	MOVW R24,R22
	CALL _f_lseek
	MOV  R19,R30
	CPI  R30,0
	BRNE _0x4C006D
; 0026 01B9                    printDebug("[iFRead]Pointer(seek) of File moved(%ld).\r\n",pviReadPtr_arg);
	__POINTD1FN _0x4C0000,2177
	CALL SUBOPT_0x6E
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 0026 01BA                    //print_payload((const iChar_t *)pviDataBuff,ivLength_arg);
; 0026 01BB                   // print_payload(pviDataBuffRef,ivLength_arg);
; 0026 01BC                    if((viFReturn=f_read(viFilePtr,pviDataBuff,ivLength_arg,&nbytes))==FR_OK){    //viFReturn=f_write(viFilePtr,&pviDataBuff[0],strlen(pviDataBuff),&nbytes)
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	ST   -Y,R31
	ST   -Y,R30
	IN   R26,SPL
	IN   R27,SPH
	SBIW R26,1
	PUSH R21
	PUSH R20
	CALL _f_read
	POP  R20
	POP  R21
	MOV  R19,R30
	CPI  R30,0
	BRNE _0x4C006E
; 0026 01BD                        printDebug("[iFRead]%d bytes Reading of %d\r\n",nbytes,ivLength_arg);
	__POINTD1FN _0x4C0000,2221
	CALL SUBOPT_0x98
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x7F
; 0026 01BE                        viReturn = 1;
	LDI  R18,LOW(1)
; 0026 01BF                    }else{
	RJMP _0x4C006F
_0x4C006E:
; 0026 01C0                        printDebug("[iFRead]Read error(%d)\r\n",viFReturn);
	__POINTD1FN _0x4C0000,2254
	CALL __PUTPARD1
	MOV  R30,R19
	CALL SUBOPT_0x9E
; 0026 01C1                        iFDisplayReturn(viFReturn);
	MOV  R26,R19
	RCALL _iFDisplayReturn
; 0026 01C2                    }
_0x4C006F:
; 0026 01C3                }else{
	RJMP _0x4C0070
_0x4C006D:
; 0026 01C4                    iFDisplayReturn(viFReturn);
	MOV  R26,R19
	RCALL _iFDisplayReturn
; 0026 01C5                }
_0x4C0070:
; 0026 01C6 
; 0026 01C7                if((viFReturn=f_close(viFilePtr))==FR_OK){
	CALL SUBOPT_0xE8
	BREQ _0x4C0072
; 0026 01C8                }else{
; 0026 01C9                   iFDisplayReturn(viFReturn);
	MOV  R26,R19
	RCALL _iFDisplayReturn
; 0026 01CA                }
_0x4C0072:
; 0026 01CB            }else{
	RJMP _0x4C0073
_0x4C006C:
; 0026 01CC                printDebug("[iFRead]File %s : %s.[\r\n",pviFilename_arg);
	__POINTD1FN _0x4C0000,2279
	CALL SUBOPT_0xEB
	CALL SUBOPT_0x63
; 0026 01CD                iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xE9
; 0026 01CE                printDebug("]\r\n");
; 0026 01CF            }
_0x4C0073:
; 0026 01D0         }else{
	RJMP _0x4C0074
_0x4C006B:
; 0026 01D1            printDebug("[iFRead]directory : %s.[\r\n",pviDirPath_arg);
	__POINTD1FN _0x4C0000,2304
	CALL SUBOPT_0xE4
	CALL SUBOPT_0x63
; 0026 01D2            iFDisplayReturn(viFReturn);
	CALL SUBOPT_0xE9
; 0026 01D3            printDebug("]\r\n");
; 0026 01D4         }
_0x4C0074:
; 0026 01D5         free(viFilePtr);
	MOVW R26,R16
	CALL _free
; 0026 01D6     }else{
	RJMP _0x4C0075
_0x4C006A:
; 0026 01D7         printDebug("[iFRead]can't allocate mem.\r\n");
	__POINTD1FN _0x4C0000,2331
	CALL SUBOPT_0x0
; 0026 01D8     }
_0x4C0075:
; 0026 01D9     return viReturn;
	MOV  R30,R18
	CALL __LOADLOCR6
	ADIW R28,16
	RET
; 0026 01DA }
;#include "database.h"
;#include "sdManager.h"
;
;
;extern iChar_t viFolderDataName[];
;extern iChar_t viFolderDataLogName[];
;//extern iChar_t viFolderEventName[];
;//extern iChar_t viFolderStatusName[];
;//extern iChar_t viFolderErrorName[];
;//extern iChar_t viFolderConfigName[];
;
;extern iChar_t viDirRootPath[];
;extern iChar_t viDirDataPath[];
;//extern iChar_t viDirDataLogPath[];
;//extern iChar_t viDirEventPath[];
;//extern iChar_t viDirStatusPath[];
;//extern iChar_t viDirErrorPath[];
;//extern iChar_t viDirConfigPath[];
;
;extern iChar_t viDataFName[];
;//extern iChar_t viDataLogFName[];
;//extern iChar_t viEventFName[];
;//extern iChar_t viStatusFName[];
;//extern iChar_t viErrorFName[];
;//extern iChar_t viConfigFName[];
;
;piDataBaseHandle_t pviDataBaseHandle = NULL;
;eeprom unsigned int viLineID=0;
;
;
;
;iChar_t iDataLogUpdate(iChar_t *pviDataBuffer_arg,iUInt_t viLineID_arg){
; 0027 0020 iChar_t iDataLogUpdate(iChar_t *pviDataBuffer_arg,iUInt_t viLineID_arg){

	.CSEG
; 0027 0021     iDB_t *pviDBLogger;
; 0027 0022     iChar_t viReturn = 0;
; 0027 0023 
; 0027 0024     return viReturn;
;	*pviDataBuffer_arg -> Y+6
;	viLineID_arg -> Y+4
;	*pviDBLogger -> R16,R17
;	viReturn -> R19
; 0027 0025 }
;
;iUInt_t iDataInsert(iChar_t const * const pviDataBuffer_arg,iUInt_t viLength_arg){
; 0027 0027 iUInt_t iDataInsert(iChar_t const * const pviDataBuffer_arg,iUInt_t viLength_arg){
_iDataInsert:
; 0027 0028     iDB_t *pviDBLogger;
; 0027 0029     iUInt_t viReturnID = 0;
; 0027 002A     iChar_t *pviDataBuffInsert;
; 0027 002B     const iChar_t viStatusField = 'N';
; 0027 002C     iChar_t viDataBuff[255];
; 0027 002D     unsigned int viRecordID = 0;
; 0027 002E     unsigned int indexWrite = 0;
; 0027 002F     unsigned long viFileSize = 0;
; 0027 0030 
; 0027 0031     pviDBLogger = (iDB_t * const)malloc(sizeof(iDB_t));
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,8
	SUBI R29,1
	__GETWRN 24,25,264
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x4E0003*2)
	LDI  R31,HIGH(_0x4E0003*2)
	LDI  R22,BYTE3(_0x4E0003*2)
	CALL __INITLOCW
	CALL __SAVELOCR6
;	*pviDataBuffer_arg -> Y+272
;	viLength_arg -> Y+270
;	*pviDBLogger -> R16,R17
;	viReturnID -> R18,R19
;	*pviDataBuffInsert -> R20,R21
;	viStatusField -> Y+269
;	viDataBuff -> Y+14
;	viRecordID -> Y+12
;	indexWrite -> Y+10
;	viFileSize -> Y+6
	__GETWRN 18,19,0
	LDI  R26,LOW(7)
	CALL SUBOPT_0xAE
	MOVW R16,R30
; 0027 0032     if(pviDBLogger!=NULL){
	MOV  R0,R16
	OR   R0,R17
	BRNE PC+3
	JMP _0x4E0004
; 0027 0033         memset(viDataBuff,0,sizeof(viDataBuff));
	MOVW R30,R28
	ADIW R30,14
	CALL SUBOPT_0xA8
	LDI  R26,LOW(255)
	CALL SUBOPT_0xBD
; 0027 0034         if(iFSize((char const * const)viDirDataPath,(char const * const)viDataFName,&viFileSize)){
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xD2
	RCALL _iFSize
	CPI  R30,0
	BREQ _0x4E0005
; 0027 0035            if(viFileSize == 0){
	CALL SUBOPT_0xED
	BRNE _0x4E0006
; 0027 0036               viLineID = 0;
	LDI  R26,LOW(_viLineID)
	LDI  R27,HIGH(_viLineID)
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	CALL __EEPROMWRW
; 0027 0037            }
; 0027 0038         }
_0x4E0006:
; 0027 0039         viRecordID = ++viLineID;
_0x4E0005:
	LDI  R26,LOW(_viLineID)
	LDI  R27,HIGH(_viLineID)
	CALL __EEPROMRDW
	ADIW R30,1
	CALL __EEPROMWRW
	STD  Y+12,R30
	STD  Y+12+1,R31
; 0027 003A         indexWrite = 0;
	LDI  R30,LOW(0)
	STD  Y+10,R30
	STD  Y+10+1,R30
; 0027 003B         memcpy(&viDataBuff[indexWrite],&viRecordID,2);
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL SUBOPT_0xEE
	MOVW R30,R28
	ADIW R30,14
	CALL SUBOPT_0x84
	CALL SUBOPT_0xEF
; 0027 003C         indexWrite += 2;
	ADIW R30,2
	CALL SUBOPT_0x7D
; 0027 003D         memcpy(&viDataBuff[indexWrite],&viStatusField,1);
	CALL SUBOPT_0xEE
	MOVW R30,R28
	SUBI R30,LOW(-(271))
	SBCI R31,HIGH(-(271))
	CALL SUBOPT_0x4
	CALL SUBOPT_0xEF
; 0027 003E         indexWrite += 1;
	ADIW R30,1
	CALL SUBOPT_0x7D
; 0027 003F         memcpy(&viDataBuff[indexWrite],&viLength_arg,2);
	CALL SUBOPT_0xEE
	MOVW R30,R28
	SUBI R30,LOW(-(272))
	SBCI R31,HIGH(-(272))
	CALL SUBOPT_0x84
	CALL SUBOPT_0xEF
; 0027 0040         indexWrite += 2;
	ADIW R30,2
	CALL SUBOPT_0x7D
; 0027 0041         memcpy(&viDataBuff[indexWrite],&pviDataBuffer_arg[0],viLength_arg);
	CALL SUBOPT_0xEE
	__GETW1SX 274
	ST   -Y,R31
	ST   -Y,R30
	__GETW2SX 274
	CALL _memcpy
; 0027 0042         indexWrite += viLength_arg;
	__GETW1SX 270
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	ADD  R30,R26
	ADC  R31,R27
	CALL SUBOPT_0x7D
; 0027 0043 
; 0027 0044         pviDBLogger->viTable.length = indexWrite;
	__PUTW1RNS 16,3
; 0027 0045         pviDBLogger->viTable.value = viDataBuff;
	MOVW R30,R28
	ADIW R30,14
	__PUTW1RNS 16,5
; 0027 0046         iFRwite(pviDBLogger->viTable.value,sizeof(viDataBuff),(const char*)viDirDataPath,(const char*)viDataFName,DB_BLOCK_WRITE_def);
	MOVW R30,R16
	LDD  R26,Z+5
	LDD  R27,Z+6
	ST   -Y,R27
	ST   -Y,R26
	CALL SUBOPT_0xF0
	CALL SUBOPT_0xF1
	RCALL _iFRwite
; 0027 0047 
; 0027 0048         free(pviDBLogger);
	MOVW R26,R16
	CALL _free
; 0027 0049 
; 0027 004A         printDebug("[iDataInsert]Insert is success.\r\n");
	__POINTD1FN _0x4E0000,0
	CALL SUBOPT_0x0
; 0027 004B         viReturnID = viRecordID;
	__GETWRS 18,19,12
; 0027 004C     }else{
	RJMP _0x4E0007
_0x4E0004:
; 0027 004D         printDebug("[iDataInsert]Databuff_arg can't allocate mem.\r\n");
	__POINTD1FN _0x4E0000,34
	CALL SUBOPT_0x0
; 0027 004E     }
_0x4E0007:
; 0027 004F     return viReturnID;
	MOVW R30,R18
	RJMP _0x20E002E
; 0027 0050 }
;
;iChar_t iDataSelect(iUChar_t viStatus_arg){             //'N' log and not send data , 'Y' sent data ,'S' settlemented
; 0027 0052 iChar_t iDataSelect(iUChar_t viStatus_arg){
_iDataSelect:
; 0027 0053     iDB_t *pviDBLogger;
; 0027 0054     iChar_t viReturn = 0;
; 0027 0055     iChar_t *pviDataBuffInsert;
; 0027 0056     iChar_t viDataBuff[255];
; 0027 0057     unsigned int viRecordID = 0;
; 0027 0058     unsigned long indexRead = 0;
; 0027 0059     unsigned int viLenOfData = 0;
; 0027 005A     unsigned long viFileSize = 0;
; 0027 005B 
; 0027 005C     pviDBLogger = (iDB_t * const)malloc(sizeof(iDB_t));
	ST   -Y,R26
	SBIW R28,11
	SUBI R29,1
	LDI  R24,12
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x4E0008*2)
	LDI  R31,HIGH(_0x4E0008*2)
	LDI  R22,BYTE3(_0x4E0008*2)
	CALL __INITLOCB
	CALL __SAVELOCR6
;	viStatus_arg -> Y+273
;	*pviDBLogger -> R16,R17
;	viReturn -> R19
;	*pviDataBuffInsert -> R20,R21
;	viDataBuff -> Y+18
;	viRecordID -> Y+16
;	indexRead -> Y+12
;	viLenOfData -> Y+10
;	viFileSize -> Y+6
	LDI  R19,0
	LDI  R26,LOW(7)
	CALL SUBOPT_0xAE
	MOVW R16,R30
; 0027 005D     if(pviDBLogger!=NULL){
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x4E0009
; 0027 005E         memset(viDataBuff,0,sizeof(viDataBuff));
	MOVW R30,R28
	ADIW R30,18
	CALL SUBOPT_0xA8
	LDI  R26,LOW(255)
	CALL SUBOPT_0xBD
; 0027 005F         if(iFSize((char const * const)viDirDataPath,(char const * const)viDataFName,&viFileSize)==1){
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xD2
	RCALL _iFSize
	CPI  R30,LOW(0x1)
	BRNE _0x4E000A
; 0027 0060            if(viFileSize == 0){
	CALL SUBOPT_0xED
	BRNE _0x4E000B
; 0027 0061               printDebug("[iDataSelect]File is empty.\r\n");
	__POINTD1FN _0x4E0000,82
	CALL SUBOPT_0x0
; 0027 0062            }else{
	RJMP _0x4E000C
_0x4E000B:
; 0027 0063               printDebug("[iDataSelect]File size(%ld).\r\n",viFileSize);
	__POINTD1FN _0x4E0000,112
	CALL __PUTPARD1
	CALL SUBOPT_0x53
	CALL SUBOPT_0x61
; 0027 0064               iFRead(viDataBuff,(iUInt_t)DB_BLOCK_READ_def,(char const * const)viDirDataPath,(char const * const)viDataFName,&indexRead);
	CALL SUBOPT_0xF2
	CALL SUBOPT_0xF0
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,20
	RCALL _iFRead
; 0027 0065               print_payload(viDataBuff,255);
	MOVW R30,R28
	ADIW R30,18
	CALL SUBOPT_0xF1
	CALL _print_payload
; 0027 0066            }
_0x4E000C:
; 0027 0067         }
; 0027 0068         free(pviDBLogger);
_0x4E000A:
	MOVW R26,R16
	CALL _free
; 0027 0069         printDebug("[iDataSelect]iDataSelect is success.\r\n");
	__POINTD1FN _0x4E0000,143
	CALL SUBOPT_0x0
; 0027 006A         viReturn = 1;
	LDI  R19,LOW(1)
; 0027 006B     }else{
	RJMP _0x4E000D
_0x4E0009:
; 0027 006C         printDebug("[iDataSelect]Databuff_arg can't allocate mem.\r\n");
	__POINTD1FN _0x4E0000,182
	CALL SUBOPT_0x0
; 0027 006D     }
_0x4E000D:
; 0027 006E     return viReturn;
	MOV  R30,R19
_0x20E002E:
	CALL __LOADLOCR6
	ADIW R28,18
	SUBI R29,-1
	RET
; 0027 006F }
;#include "sensorManager.h"
;#include "config.h"
;#include "sensor.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "managerTask.h"
;extern eeprom iDVConfig_t viDVConfigUpdate;
;extern iDataReport_t viDataReportBuff[];
;
;extern iDataMini_t viDataReport;
;extern iDataMini_t viStatusReport;
;
;iChar_t iSensorRead(iDataMini_t *pviOutData_arg){
; 0028 000B iChar_t iSensorRead(iDataMini_t *pviOutData_arg){

	.CSEG
_iSensorRead:
; 0028 000C     iChar_t i;
; 0028 000D     iChar_t viReturn = 0;
; 0028 000E     const iChar_t viCMD[2] = {0x5a,0x07};
; 0028 000F     iUChar_t viIndexWrite = 0;
; 0028 0010 
; 0028 0011     /*test*/
; 0028 0012     viDVConfigUpdate.viOperate.viSensorEnable[0] = 1;
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	LDI  R30,LOW(90)
	ST   Y,R30
	LDI  R30,LOW(7)
	CALL SUBOPT_0xF3
;	*pviOutData_arg -> Y+6
;	i -> R17
;	viReturn -> R16
;	viCMD -> Y+4
;	viIndexWrite -> R19
	__POINTW2MN _viDVConfigUpdate,163
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 0028 0013     viDVConfigUpdate.viOperate.viSensorEnable[1] = 1;
	__POINTW2MN _viDVConfigUpdate,164
	CALL __EEPROMWRB
; 0028 0014     viDVConfigUpdate.viOperate.viSensorEnable[2] = 1;
	__POINTW2MN _viDVConfigUpdate,165
	CALL __EEPROMWRB
; 0028 0015     viDVConfigUpdate.viOperate.viSensorEnable[3] = 1;
	__POINTW2MN _viDVConfigUpdate,166
	CALL __EEPROMWRB
; 0028 0016     viDVConfigUpdate.viOperate.viSensorEnable[4] = 1;
	__POINTW2MN _viDVConfigUpdate,167
	CALL __EEPROMWRB
; 0028 0017     viDVConfigUpdate.viSensorConfig[0].viChannelID = 0;
	__POINTW2MN _viDVConfigUpdate,170
	LDI  R30,LOW(0)
	CALL __EEPROMWRB
; 0028 0018     viDVConfigUpdate.viSensorConfig[1].viChannelID = 1;
	__POINTW2MN _viDVConfigUpdate,198
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 0028 0019     viDVConfigUpdate.viSensorConfig[2].viChannelID = 2;
	__POINTW2MN _viDVConfigUpdate,226
	LDI  R30,LOW(2)
	CALL __EEPROMWRB
; 0028 001A     viDVConfigUpdate.viSensorConfig[3].viChannelID = 3;
	__POINTW2MN _viDVConfigUpdate,254
	LDI  R30,LOW(3)
	CALL __EEPROMWRB
; 0028 001B     viDVConfigUpdate.viSensorConfig[4].viChannelID = 4;
	__POINTW2MN _viDVConfigUpdate,282
	LDI  R30,LOW(4)
	CALL __EEPROMWRB
; 0028 001C     viDVConfigUpdate.viSensorConfig[0].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,171
	LDI  R30,LOW(17)
	CALL __EEPROMWRB
; 0028 001D     viDVConfigUpdate.viSensorConfig[1].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,199
	CALL __EEPROMWRB
; 0028 001E     viDVConfigUpdate.viSensorConfig[2].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,227
	CALL __EEPROMWRB
; 0028 001F     viDVConfigUpdate.viSensorConfig[3].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,255
	CALL __EEPROMWRB
; 0028 0020     viDVConfigUpdate.viSensorConfig[4].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,283
	CALL __EEPROMWRB
; 0028 0021     viDVConfigUpdate.viSensorConfig[0].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,172
	LDI  R30,LOW(49)
	CALL __EEPROMWRB
; 0028 0022     viDVConfigUpdate.viSensorConfig[1].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,200
	CALL __EEPROMWRB
; 0028 0023     viDVConfigUpdate.viSensorConfig[2].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,228
	CALL __EEPROMWRB
; 0028 0024     viDVConfigUpdate.viSensorConfig[3].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,256
	CALL __EEPROMWRB
; 0028 0025     viDVConfigUpdate.viSensorConfig[4].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,284
	CALL __EEPROMWRB
; 0028 0026 
; 0028 0027 #if (0)
; 0028 0028     printDebug("viOperate\r\n");
; 0028 0029     printConfig((char eeprom *)&viDVConfigUpdate.viOperate,sizeof(viDVConfigUpdate.viOperate));
; 0028 002A     printDebug("SensorConfig[0]\r\n");
; 0028 002B     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[0],sizeof(viDVConfigUpdate.viSensorConfig));
; 0028 002C     printDebug("SensorConfig[1]\r\n");
; 0028 002D     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[1],sizeof(viDVConfigUpdate.viSensorConfig));
; 0028 002E     printDebug("SensorConfig[2]\r\n");
; 0028 002F     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[2],sizeof(viDVConfigUpdate.viSensorConfig));
; 0028 0030     printDebug("SensorConfig[3]\r\n");
; 0028 0031     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[3],sizeof(viDVConfigUpdate.viSensorConfig));
; 0028 0032     printDebug("SensorConfig[4]\r\n");
; 0028 0033     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[4],sizeof(viDVConfigUpdate.viSensorConfig));
; 0028 0034     /////////
; 0028 0035 #endif
; 0028 0036 
; 0028 0037     viIndexWrite = 0;
	LDI  R19,LOW(0)
; 0028 0038     for(i=0;i<5;i++){
	LDI  R17,LOW(0)
_0x500004:
	CPI  R17,5
	BRLO PC+3
	JMP _0x500005
; 0028 0039         #asm("wdr")
	wdr
; 0028 003A        if(viDVConfigUpdate.viOperate.viSensorEnable[i]==1){
	__POINTW2MN _viDVConfigUpdate,163
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	CALL __EEPROMRDB
	CPI  R30,LOW(0x1)
	BREQ PC+3
	JMP _0x500006
; 0028 003B            viDataReportBuff[i].viChannelID = viDVConfigUpdate.viSensorConfig[i].viChannelID;
	CALL SUBOPT_0xF4
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	CALL __EEPROMRDB
	POP  R26
	POP  R27
	ST   X,R30
; 0028 003C            viDataReportBuff[i].viSensorID = viDVConfigUpdate.viSensorConfig[i].viSensorID;
	LDI  R26,LOW(7)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _viDataReportBuff,1
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,1
	CALL __EEPROMRDB
	POP  R26
	POP  R27
	ST   X,R30
; 0028 003D            viDataReportBuff[i].viUnitID =   viDVConfigUpdate.viSensorConfig[i].viUnitID;
	LDI  R26,LOW(7)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _viDataReportBuff,2
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,2
	CALL __EEPROMRDB
	POP  R26
	POP  R27
	ST   X,R30
; 0028 003E            iSensorReadByType(&viDataReportBuff[i]);
	CALL SUBOPT_0xF4
	MOVW R26,R30
	RCALL _iSensorReadByType
; 0028 003F            memcpy(&pviOutData_arg->value[viIndexWrite],viCMD,2);
	CALL SUBOPT_0xF7
	CALL SUBOPT_0xDA
	MOVW R30,R28
	ADIW R30,6
	CALL SUBOPT_0x84
	CALL _memcpy
; 0028 0040            viIndexWrite += 2;
	SUBI R19,-LOW(2)
; 0028 0041            memcpy(&pviOutData_arg->value[viIndexWrite],&viDataReportBuff[i],sizeof(viDataReportBuff[i]));
	CALL SUBOPT_0xF7
	CALL SUBOPT_0xDA
	CALL SUBOPT_0xF4
	CALL SUBOPT_0x3
	CALL _memcpy
; 0028 0042            viIndexWrite += sizeof(viDataReportBuff[i]);
	SUBI R19,-LOW(7)
; 0028 0043            pviOutData_arg->length = viIndexWrite;
	CALL SUBOPT_0xF8
; 0028 0044        }
; 0028 0045     }
_0x500006:
	SUBI R17,-1
	RJMP _0x500004
_0x500005:
; 0028 0046     printDebug("[iSensorRead]Data:[\r\n");
	__POINTD1FN _0x500000,0
	CALL SUBOPT_0x0
; 0028 0047     print_payload(&pviOutData_arg->value[0],pviOutData_arg->length);
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xA2
	MOVW R26,R30
	CALL _print_payload
; 0028 0048     printDebug("]\r\n");
	__POINTD1FN _0x500000,22
	CALL SUBOPT_0x0
; 0028 0049     viReturn = 1;
	LDI  R16,LOW(1)
; 0028 004A     return viReturn;
	MOV  R30,R16
	JMP  _0x20E002C
; 0028 004B }
;
;void iSensorReadByType(iDataReport_t *pviInOutData_arg){
; 0028 004D void iSensorReadByType(iDataReport_t *pviInOutData_arg){
_iSensorReadByType:
; 0028 004E     switch(pviInOutData_arg->viSensorID){
	CALL SUBOPT_0x28
;	*pviInOutData_arg -> Y+0
	LDD  R30,Z+1
	LDI  R31,0
; 0028 004F         case SEN_ADC_TYPE:{
	CPI  R30,LOW(0x11)
	LDI  R26,HIGH(0x11)
	CPC  R31,R26
	BRNE _0x500009
; 0028 0050             pviInOutData_arg->viData = read_adc(8+pviInOutData_arg->viChannelID);
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X
	SUBI R30,-LOW(8)
	MOV  R26,R30
	CALL _read_adc
	LD   R26,Y
	LDD  R27,Y+1
	ADIW R26,3
	CALL SUBOPT_0x2C
; 0028 0051             printDebug("[iSensorReadByType]Channel[%d] data : %f\r\n",pviInOutData_arg->viChannelID,pviInOutData_arg->viData);
	__POINTD1FN _0x500000,26
	CALL __PUTPARD1
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL SUBOPT_0x79
	CALL __PUTPARD1
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	__GETD2Z 3
	CALL __PUTPARD2
	CALL SUBOPT_0x7F
; 0028 0052             break;
; 0028 0053         }
; 0028 0054     }
_0x500009:
; 0028 0055 }
	JMP  _0x20E002D
;
;float iADCTypeCalculator(){
; 0028 0057 float iADCTypeCalculator(){
; 0028 0058     float viReturn = 0;
; 0028 0059     return viReturn;
;	viReturn -> Y+0
; 0028 005A }
;
;float iKTypeCalculator(){
; 0028 005C float iKTypeCalculator(){
; 0028 005D     float viReturn = 0;
; 0028 005E     return viReturn;
;	viReturn -> Y+0
; 0028 005F }
;
;float iTP100TypeCalculator(){
; 0028 0061 float iTP100TypeCalculator(){
; 0028 0062     float viReturn = 0;
; 0028 0063     return viReturn;
;	viReturn -> Y+0
; 0028 0064 }
;
;float iVoltTypeCalculator(){
; 0028 0066 float iVoltTypeCalculator(){
; 0028 0067     float viReturn = 0;
; 0028 0068     return viReturn;
;	viReturn -> Y+0
; 0028 0069 }
;
;float iAmpTypeCalculator(){
; 0028 006B float iAmpTypeCalculator(){
; 0028 006C     float viReturn = 0;
; 0028 006D     return viReturn;
;	viReturn -> Y+0
; 0028 006E }
;
;float i420TypeCalculator(){
; 0028 0070 float i420TypeCalculator(){
; 0028 0071     float viReturn = 0;
; 0028 0072     return viReturn;
;	viReturn -> Y+0
; 0028 0073 }
;
;float iDHT11TypeCalculator(){
; 0028 0075 float iDHT11TypeCalculator(){
; 0028 0076     float viReturn = 0;
; 0028 0077     return viReturn;
;	viReturn -> Y+0
; 0028 0078 }
;
;float iDHT22TypeCalculator(){
; 0028 007A float iDHT22TypeCalculator(){
; 0028 007B     float viReturn = 0;
; 0028 007C     return viReturn;
;	viReturn -> Y+0
; 0028 007D }
;
;float iDS1820TypeCalculator(){
; 0028 007F float iDS1820TypeCalculator(){
; 0028 0080     float viReturn = 0;
; 0028 0081     return viReturn;
;	viReturn -> Y+0
; 0028 0082 }
;
;float iDS18B20TypeCalculator(){
; 0028 0084 float iDS18B20TypeCalculator(){
; 0028 0085     float viReturn = 0;
; 0028 0086     return viReturn;
;	viReturn -> Y+0
; 0028 0087 }
;#include "statusManager.h"
;#include "adc.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;
;//extern eeprom iDVConfig_t viDVConfigUpdate;
;extern iStatusReport_t viStatusReportBuff;
;
;extern iDataMini_t viDataReport;
;extern iDataMini_t viStatusReport;
;
;iChar_t iStatusRead(iDataMini_t *pviOutData_arg){
; 0029 000A iChar_t iStatusRead(iDataMini_t *pviOutData_arg){

	.CSEG
_iStatusRead:
; 0029 000B     iChar_t i;
; 0029 000C     iChar_t viReturn = 0;
; 0029 000D     const iChar_t viCMD[2] = {0x2a,0x06};
; 0029 000E     iUChar_t viIndexWrite = 0;
; 0029 000F 
; 0029 0010     /*test*/
; 0029 0011     #asm("wdr")
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	LDI  R30,LOW(42)
	ST   Y,R30
	LDI  R30,LOW(6)
	CALL SUBOPT_0xF3
;	*pviOutData_arg -> Y+6
;	i -> R17
;	viReturn -> R16
;	viCMD -> Y+4
;	viIndexWrite -> R19
	wdr
; 0029 0012     viStatusReportBuff.viStatusType = STATUS_BATTERY_TYPE;
	LDI  R30,LOW(1)
	STS  _viStatusReportBuff,R30
; 0029 0013     viStatusReportBuff.viDataType =  STATUS_FLOAT;
	LDI  R30,LOW(4)
	__PUTB1MN _viStatusReportBuff,1
; 0029 0014     iStatusReadByType(&viStatusReportBuff);
	LDI  R26,LOW(_viStatusReportBuff)
	LDI  R27,HIGH(_viStatusReportBuff)
	RCALL _iStatusReadByType
; 0029 0015 
; 0029 0016     viIndexWrite = 0;
	LDI  R19,LOW(0)
; 0029 0017     memcpy(&pviOutData_arg->value[viIndexWrite],viCMD,2);
	CALL SUBOPT_0xF7
	CALL SUBOPT_0xDA
	MOVW R30,R28
	ADIW R30,6
	CALL SUBOPT_0x84
	CALL _memcpy
; 0029 0018     viIndexWrite += 2;
	SUBI R19,-LOW(2)
; 0029 0019     memcpy(&pviOutData_arg->value[viIndexWrite],&viStatusReportBuff,sizeof(viStatusReportBuff));
	CALL SUBOPT_0xF7
	CALL SUBOPT_0xDA
	LDI  R30,LOW(_viStatusReportBuff)
	LDI  R31,HIGH(_viStatusReportBuff)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(6)
	CALL SUBOPT_0x83
; 0029 001A     viIndexWrite += sizeof(viStatusReportBuff);
	SUBI R19,-LOW(6)
; 0029 001B     pviOutData_arg->length = viIndexWrite;
	CALL SUBOPT_0xF8
; 0029 001C 
; 0029 001D     printDebug("[iStatusRead]Data:[\r\n");
	__POINTD1FN _0x520000,0
	CALL SUBOPT_0x0
; 0029 001E     print_payload(&pviOutData_arg->value[0],pviOutData_arg->length);
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xA2
	MOVW R26,R30
	CALL _print_payload
; 0029 001F     printDebug("]\r\n");
	__POINTD1FN _0x520000,22
	CALL SUBOPT_0x0
; 0029 0020 
; 0029 0021 
; 0029 0022     viReturn = 1;
	LDI  R16,LOW(1)
; 0029 0023 
; 0029 0024     return viReturn;
	MOV  R30,R16
	JMP  _0x20E002C
; 0029 0025 }
;
;void iStatusReadByType(iStatusReport_t *pviInOutData_arg){
; 0029 0027 void iStatusReadByType(iStatusReport_t *pviInOutData_arg){
_iStatusReadByType:
; 0029 0028      //float viReturn = 0.0;
; 0029 0029      switch(pviInOutData_arg->viStatusType){
	ST   -Y,R27
	ST   -Y,R26
;	*pviInOutData_arg -> Y+0
	LD   R26,Y
	LDD  R27,Y+1
	CALL SUBOPT_0x7A
; 0029 002A           case STATUS_BATTERY_TYPE:{
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x520005
; 0029 002B             //pviInOutData_arg->viData = iStatusReadBattery();
; 0029 002C             pviInOutData_arg->viData = 2.56;
	LD   R26,Y
	LDD  R27,Y+1
	ADIW R26,2
	__GETD1N 0x4023D70A
	CALL __PUTDP1
; 0029 002D             break;
; 0029 002E           }
; 0029 002F      }
_0x520005:
; 0029 0030 //     viReturn = 1;
; 0029 0031 //     return viReturn;
; 0029 0032 }
	RJMP _0x20E002D
;
;//float iStatusReadBattery(){
;//    float  viBatt = 0.0;
;//    float  viADCDividerMax = 635.5;//2.05      // from voltage divider 120k & 150k
;//    float  viVoltMaxBatt = 3.7;
;//
;//    //viBatt = (float)((read_adc(14)/viADCDividerMax) * viVoltMaxBatt);                // Battery Read
;//    viBatt = 2.50;
;//    return viBatt;
;//}
;//
;//float iStatusReadMainPower(iChar_t viStatusType_arg){
;//     float viMainPwr = 0.0;
;//     if(MAIN_POWER_CONNECT){
;//         viMainPwr = 1.0;
;//     }else{
;//         viMainPwr = 0.0;
;//     }
;//     return viMainPwr;
;//}
;//
;//float iStatusReadSDCard(iChar_t viStatusType_arg){
;//     float viReturn = 0.0;
;//
;//     return viReturn;
;//}
;//
;//float iStatusReadLan(iChar_t viStatusType_arg){
;//     float viReturn = 0.0;
;//
;//     return viReturn;
;//}
;//
;//float iStatusReadWifi(iChar_t viStatusType_arg){
;//     float viReturn = 0.0;
;//
;//     return viReturn;
;//}
;//
;//float iStatusReadDI0(iChar_t viStatusType_arg){
;//     float viReturn = 0.0;
;//
;//     return viReturn;
;//}
;//
;//float iStatusReadDI1(iChar_t viStatusType_arg){
;//     float viReturn = 0.0;
;//
;//     return viReturn;
;//}
;#include <delay.h>
;#include "dataAndStatusTask.h"
;#include "sensorManager.h"
;#include "statusManager.h"
;#include "sensor.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "dht11.h"
;
;unsigned int viSwitchContextSensor;
;
;extern piQueueHandle_t pviQueueTaskAToTaskB;
;
;extern piQueueHandle_t pviQueueSensorToMang;
;extern piQueueHandle_t pviQueueMangToSensor;
;
;iDataReport_t viDataReportBuff[7];
;iStatusReport_t viStatusReportBuff;
;
;extern iDataMini_t viDataReport;
;extern iDataMini_t viStatusReport;
;
;iSensorData_t pviSensorData;
;
;void dataAndStatusTask(void *pviParameter){
; 002A 0017 void dataAndStatusTask(void *pviParameter){

	.CSEG
_dataAndStatusTask:
; 002A 0018     printDebug("[dataAndStatusTask]Task Running...\r\n");
	ST   -Y,R27
	ST   -Y,R26
;	*pviParameter -> Y+0
	__POINTD1FN _0x540000,0
	CALL SUBOPT_0x0
; 002A 0019 
; 002A 001A //    swContextSensor();
; 002A 001B //    swContextSensor();
; 002A 001C 
; 002A 001D     //printDebug("[sensorTask],Queue->Quantity(%d).\r\n",((iQueue_t *)pviQueueSensorToMang)->itemCount);
; 002A 001E //    if(iQueueSend(pviQueueSensorToMang,&pviSensorData)==1){
; 002A 001F //        printDebug("<sensorTask>pviQueueSensorToMang can sent a data.\r\n");
; 002A 0020 //    }else{
; 002A 0021 //        printDebug("<sensorTask>data can not sent a data to pviQueueSensorToMang.\r\n");
; 002A 0022 //    }
; 002A 0023     #asm("wdr")
	wdr
; 002A 0024     iSensorRead(&viDataReport);                        //the 5A packed
	LDI  R26,LOW(_viDataReport)
	LDI  R27,HIGH(_viDataReport)
	CALL _iSensorRead
; 002A 0025     #asm("wdr")
	wdr
; 002A 0026     iStatusRead(&viStatusReport);                      //the 2A packed
	LDI  R26,LOW(_viStatusReport)
	LDI  R27,HIGH(_viStatusReport)
	RCALL _iStatusRead
; 002A 0027     #asm("wdr")
	wdr
; 002A 0028     delay_ms(100);
	CALL SUBOPT_0x8
; 002A 0029 }
	RJMP _0x20E002D
;//
;//void swContextSensor(){
;//     unsigned int i;
;//     ST_DHT11 *dhtDevice;
;//     int viReturn;
;//     //pviSensorData_t  pviSensorData;
;//     #asm("wdr")
;//     if(viSwitchContextSensor == SENSER_MAX_TYPE){
;//          viSwitchContextSensor = 0;
;//     }
;//     switch(viSwitchContextSensor){
;//         case SENSOR_ADC:{
;//            for(i=0;i<SENSER_ADC_MAX_SIZE;i++){
;//                //printDebug("ACD[%d] : %d\r\n",(i+1),read_adc(8+i));
;//                pviSensorData.adc[i] =  read_adc(8+i);
;//            }
;//            break;
;//         }
;//         case SENSOR_DIGI:{
;//            delay_ms(300);
;//            viReturn =DHT11Read(dhtDevice);
;//            if(viReturn==DHT11_SUCCESS){
;//               //printDebug("DHT11 Temp-c(%f), Humidity(%f)\r\n",dhtDevice->temp,dhtDevice->humi);
;//               pviSensorData.dht11Temp = dhtDevice->temp;
;//               pviSensorData.dht11Humi = dhtDevice->humi;
;//            }else if(viReturn==DHT11_ERROR_CHECKSUM){
;//               printDebug("DHT11 errer(check sum).\r\n");
;//            }else if(viReturn==DHT11_ERROR_TIMEOUT){
;//               printDebug("DHT11 errer(time out).\r\n");
;//            }
;//            break;
;//         }
;//         default:{
;//            break;
;//         }
;//     }
;//     ++ viSwitchContextSensor;
;//}
;#include "eventTask.h"
;#include "eventManager.h"
;
;iEventReport_t viEventReportBuff;
;extern iDataMini_t viEventReport;
;
;void eventTask(void *pviParameter){
; 002B 0007 void eventTask(void *pviParameter){

	.CSEG
_eventTask:
; 002B 0008     #asm("wdr")
	ST   -Y,R27
	ST   -Y,R26
;	*pviParameter -> Y+0
	wdr
; 002B 0009     printDebug("[dataAndStatusTask]Task Running...\r\n");
	__POINTD1FN _0x560000,0
	CALL SUBOPT_0x0
; 002B 000A     iEventRead(&viEventReport);
	LDI  R26,LOW(_viEventReport)
	LDI  R27,HIGH(_viEventReport)
	RCALL _iEventRead
; 002B 000B }
_0x20E002D:
	ADIW R28,2
	RET
;#include "eventManager.h"
;#include "config.h"
;#include "eventTask.h"
;#include "dataAndStatusTask.h"
;
;extern eeprom iDVConfig_t viDVConfigUpdate;
;
;extern iDataReport_t viDataReportBuff[];
;
;extern iDataMini_t viStatusReport;
;
;extern iEventReport_t viEventReportBuff;
;
;iChar_t iEventRead(iDataMini_t *pviOutData_arg){
; 002C 000E iChar_t iEventRead(iDataMini_t *pviOutData_arg){

	.CSEG
_iEventRead:
; 002C 000F     iChar_t i;
; 002C 0010     iChar_t viReturn = 0;
; 002C 0011     const iChar_t viCMD[2] = {0x3a,0x05};
; 002C 0012     iUChar_t viIndexWrite = 0;
; 002C 0013 
; 002C 0014     iTestSetValueSensorConfig();
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	LDI  R30,LOW(58)
	ST   Y,R30
	LDI  R30,LOW(5)
	CALL SUBOPT_0xF3
;	*pviOutData_arg -> Y+6
;	i -> R17
;	viReturn -> R16
;	viCMD -> Y+4
;	viIndexWrite -> R19
	RCALL _iTestSetValueSensorConfig
; 002C 0015     //check sensor event
; 002C 0016     viIndexWrite = 0;
	LDI  R19,LOW(0)
; 002C 0017     for(i=0;i<5;i++){
	LDI  R17,LOW(0)
_0x580004:
	CPI  R17,5
	BRLO PC+3
	JMP _0x580005
; 002C 0018         #asm("wdr")
	wdr
; 002C 0019         if(viDVConfigUpdate.viSensorConfig[i].viAlarmEnable == SENSOR_ENABLE_def){
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,3
	CALL __EEPROMRDB
	CPI  R30,LOW(0x1)
	BREQ PC+3
	JMP _0x580006
; 002C 001A             //check lower case
; 002C 001B             if((viDataReportBuff[i].viData < viDVConfigUpdate.viSensorConfig[i].viAlarmLowerExtreme) && (viDataReportBuff[i].viData > viDVConfigUpdate.viSensorConfig[i].viAlarmLower)){
	CALL SUBOPT_0xF9
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,12
	CALL __EEPROMRDD
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CMPF12
	BRSH _0x580008
	CALL SUBOPT_0xF9
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,4
	CALL __EEPROMRDD
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CMPF12
	BREQ PC+2
	BRCC PC+3
	JMP  _0x580008
	RJMP _0x580009
_0x580008:
	RJMP _0x580007
_0x580009:
; 002C 001C                 switch(i){
	MOV  R30,R17
	CALL SUBOPT_0x16
; 002C 001D                     case 0:{
	BRNE _0x58000D
; 002C 001E                         iPrintEventByCase(SENSOR1_LOWER_EXTREME_EVENT_def);
	LDI  R26,LOW(18)
	RJMP _0x580031
; 002C 001F                         break;
; 002C 0020                     }
; 002C 0021                     case 1:{
_0x58000D:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x58000E
; 002C 0022                         iPrintEventByCase(SENSOR2_LOWER_EXTREME_EVENT_def);
	LDI  R26,LOW(34)
	RJMP _0x580031
; 002C 0023                         break;
; 002C 0024                     }
; 002C 0025                     case 2:{
_0x58000E:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x58000F
; 002C 0026                         iPrintEventByCase(SENSOR3_LOWER_EXTREME_EVENT_def);
	LDI  R26,LOW(50)
	RJMP _0x580031
; 002C 0027                         break;
; 002C 0028                     }
; 002C 0029                     case 3:{
_0x58000F:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x580010
; 002C 002A                         iPrintEventByCase(SENSOR4_LOWER_EXTREME_EVENT_def);
	LDI  R26,LOW(66)
	RJMP _0x580031
; 002C 002B                         break;
; 002C 002C                     }
; 002C 002D                     case 4:{
_0x580010:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x58000C
; 002C 002E                         iPrintEventByCase(SENSOR5_LOWER_EXTREME_EVENT_def);
	LDI  R26,LOW(82)
_0x580031:
	RCALL _iPrintEventByCase
; 002C 002F                         break;
; 002C 0030                     }
; 002C 0031                 }
_0x58000C:
; 002C 0032             }else if(viDataReportBuff[i].viData < viDVConfigUpdate.viSensorConfig[i].viAlarmLower){
	RJMP _0x580012
_0x580007:
	CALL SUBOPT_0xF9
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,4
	CALL __EEPROMRDD
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CMPF12
	BRSH _0x580013
; 002C 0033                 switch(i){
	MOV  R30,R17
	CALL SUBOPT_0x16
; 002C 0034                     case 0:{
	BRNE _0x580017
; 002C 0035                         iPrintEventByCase(SENSOR1_LOWER_EVENT_def);
	LDI  R26,LOW(17)
	RJMP _0x580032
; 002C 0036                         break;
; 002C 0037                     }
; 002C 0038                     case 1:{
_0x580017:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x580018
; 002C 0039                         iPrintEventByCase(SENSOR2_LOWER_EVENT_def);
	LDI  R26,LOW(33)
	RJMP _0x580032
; 002C 003A                         break;
; 002C 003B                     }
; 002C 003C                     case 2:{
_0x580018:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x580019
; 002C 003D                         iPrintEventByCase(SENSOR3_LOWER_EVENT_def);
	LDI  R26,LOW(49)
	RJMP _0x580032
; 002C 003E                         break;
; 002C 003F                     }
; 002C 0040                     case 3:{
_0x580019:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x58001A
; 002C 0041                         iPrintEventByCase(SENSOR4_LOWER_EVENT_def);
	LDI  R26,LOW(65)
	RJMP _0x580032
; 002C 0042                         break;
; 002C 0043                     }
; 002C 0044                     case 4:{
_0x58001A:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x580016
; 002C 0045                         iPrintEventByCase(SENSOR5_LOWER_EVENT_def);
	LDI  R26,LOW(81)
_0x580032:
	RCALL _iPrintEventByCase
; 002C 0046                         break;
; 002C 0047                     }
; 002C 0048                 }
_0x580016:
; 002C 0049             }
; 002C 004A 
; 002C 004B             //check upper case
; 002C 004C             if((viDataReportBuff[i].viData > viDVConfigUpdate.viSensorConfig[i].viAlarmUpperExtreme) && (viDataReportBuff[i].viData < viDVConfigUpdate.viSensorConfig[i].viAlarmUpper)){
_0x580013:
_0x580012:
	CALL SUBOPT_0xF9
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,24
	CALL __EEPROMRDD
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CMPF12
	BREQ PC+2
	BRCC PC+3
	JMP  _0x58001D
	CALL SUBOPT_0xF9
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,16
	CALL __EEPROMRDD
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CMPF12
	BRLO _0x58001E
_0x58001D:
	RJMP _0x58001C
_0x58001E:
; 002C 004D                 switch(i){
	MOV  R30,R17
	CALL SUBOPT_0x16
; 002C 004E                     case 0:{
	BRNE _0x580022
; 002C 004F                         iPrintEventByCase(SENSOR1_UPPERY_EXTREME_EVENT_def);
	LDI  R26,LOW(20)
	RJMP _0x580033
; 002C 0050                         break;
; 002C 0051                     }
; 002C 0052                     case 1:{
_0x580022:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x580023
; 002C 0053                         iPrintEventByCase(SENSOR2_UPPERY_EXTREME_EVENT_def);
	LDI  R26,LOW(36)
	RJMP _0x580033
; 002C 0054                         break;
; 002C 0055                     }
; 002C 0056                     case 2:{
_0x580023:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x580024
; 002C 0057                         iPrintEventByCase(SENSOR3_UPPERY_EXTREME_EVENT_def);
	LDI  R26,LOW(52)
	RJMP _0x580033
; 002C 0058                         break;
; 002C 0059                     }
; 002C 005A                     case 3:{
_0x580024:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x580025
; 002C 005B                         iPrintEventByCase(SENSOR4_UPPERY_EXTREME_EVENT_def);
	LDI  R26,LOW(68)
	RJMP _0x580033
; 002C 005C                         break;
; 002C 005D                     }
; 002C 005E                     case 4:{
_0x580025:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x580021
; 002C 005F                         iPrintEventByCase(SENSOR5_UPPERY_EXTREME_EVENT_def);
	LDI  R26,LOW(84)
_0x580033:
	RCALL _iPrintEventByCase
; 002C 0060                         break;
; 002C 0061                     }
; 002C 0062                 }
_0x580021:
; 002C 0063             }else if(viDataReportBuff[i].viData > viDVConfigUpdate.viSensorConfig[i].viAlarmUpper){
	RJMP _0x580027
_0x58001C:
	CALL SUBOPT_0xF9
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xF5
	CALL SUBOPT_0xF6
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,16
	CALL __EEPROMRDD
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CMPF12
	BREQ PC+2
	BRCC PC+3
	JMP  _0x580028
; 002C 0064                 switch(i){
	MOV  R30,R17
	CALL SUBOPT_0x16
; 002C 0065                     case 0:{
	BRNE _0x58002C
; 002C 0066                         iPrintEventByCase(SENSOR1_UPPER_EVENT_def);
	LDI  R26,LOW(19)
	RJMP _0x580034
; 002C 0067                         break;
; 002C 0068                     }
; 002C 0069                     case 1:{
_0x58002C:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x58002D
; 002C 006A                         iPrintEventByCase(SENSOR2_UPPER_EVENT_def);
	LDI  R26,LOW(35)
	RJMP _0x580034
; 002C 006B                         break;
; 002C 006C                     }
; 002C 006D                     case 2:{
_0x58002D:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x58002E
; 002C 006E                         iPrintEventByCase(SENSOR3_UPPER_EVENT_def);
	LDI  R26,LOW(51)
	RJMP _0x580034
; 002C 006F                         break;
; 002C 0070                     }
; 002C 0071                     case 3:{
_0x58002E:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x58002F
; 002C 0072                         iPrintEventByCase(SENSOR4_UPPER_EVENT_def);
	LDI  R26,LOW(67)
	RJMP _0x580034
; 002C 0073                         break;
; 002C 0074                     }
; 002C 0075                     case 4:{
_0x58002F:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x58002B
; 002C 0076                         iPrintEventByCase(SENSOR5_UPPER_EVENT_def);
	LDI  R26,LOW(83)
_0x580034:
	RCALL _iPrintEventByCase
; 002C 0077                         break;
; 002C 0078                     }
; 002C 0079                 }
_0x58002B:
; 002C 007A             }
; 002C 007B         }
_0x580028:
_0x580027:
; 002C 007C     }
_0x580006:
	SUBI R17,-1
	RJMP _0x580004
_0x580005:
; 002C 007D }
_0x20E002C:
	CALL __LOADLOCR4
	ADIW R28,8
	RET
;
;
;
;void iPrintEventByCase(iChar_t viEventID_arg){
; 002C 0081 void iPrintEventByCase(iChar_t viEventID_arg){
_iPrintEventByCase:
; 002C 0082     printDebug("[iPrintEventByCase]id(%02X)\r\n",viEventID_arg);
	ST   -Y,R26
;	viEventID_arg -> Y+0
	__POINTD1FN _0x580000,0
	CALL __PUTPARD1
	LDD  R30,Y+4
	CALL SUBOPT_0x9E
; 002C 0083 }
	JMP  _0x20E0029
;
;void iTestSetValueSensorConfig(){
; 002C 0085 void iTestSetValueSensorConfig(){
_iTestSetValueSensorConfig:
; 002C 0086     /*test*/
; 002C 0087     viDVConfigUpdate.viSensorConfig[0].viAlarmEnable = 0x01;
	__POINTW2MN _viDVConfigUpdate,173
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002C 0088     viDVConfigUpdate.viSensorConfig[0].viAlarmLower = 0.0;
	__POINTW2MN _viDVConfigUpdate,174
	CALL SUBOPT_0xFA
; 002C 0089     viDVConfigUpdate.viSensorConfig[0].viAlarmLowerDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,178
	CALL SUBOPT_0xFA
; 002C 008A     viDVConfigUpdate.viSensorConfig[0].viAlarmLowerExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,182
	CALL SUBOPT_0xFA
; 002C 008B     viDVConfigUpdate.viSensorConfig[0].viAlarmUpper = 0.0;
	__POINTW2MN _viDVConfigUpdate,186
	CALL SUBOPT_0xFA
; 002C 008C     viDVConfigUpdate.viSensorConfig[0].viAlarmUpperDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,190
	CALL SUBOPT_0xFA
; 002C 008D     viDVConfigUpdate.viSensorConfig[0].viAlarmUpperExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,194
	CALL SUBOPT_0xFA
; 002C 008E 
; 002C 008F     viDVConfigUpdate.viSensorConfig[1].viAlarmEnable = 0x01;
	__POINTW2MN _viDVConfigUpdate,201
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002C 0090     viDVConfigUpdate.viSensorConfig[1].viAlarmLower = 0.0;
	__POINTW2MN _viDVConfigUpdate,202
	CALL SUBOPT_0xFA
; 002C 0091     viDVConfigUpdate.viSensorConfig[1].viAlarmLowerDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,206
	CALL SUBOPT_0xFA
; 002C 0092     viDVConfigUpdate.viSensorConfig[1].viAlarmLowerExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,210
	CALL SUBOPT_0xFA
; 002C 0093     viDVConfigUpdate.viSensorConfig[1].viAlarmUpper = 0.0;
	__POINTW2MN _viDVConfigUpdate,214
	CALL SUBOPT_0xFA
; 002C 0094     viDVConfigUpdate.viSensorConfig[1].viAlarmUpperDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,218
	CALL SUBOPT_0xFA
; 002C 0095     viDVConfigUpdate.viSensorConfig[1].viAlarmUpperExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,222
	CALL SUBOPT_0xFA
; 002C 0096 
; 002C 0097     viDVConfigUpdate.viSensorConfig[2].viAlarmEnable = 0x01;
	__POINTW2MN _viDVConfigUpdate,229
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002C 0098     viDVConfigUpdate.viSensorConfig[2].viAlarmLower = 0.0;
	__POINTW2MN _viDVConfigUpdate,230
	CALL SUBOPT_0xFA
; 002C 0099     viDVConfigUpdate.viSensorConfig[2].viAlarmLowerDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,234
	CALL SUBOPT_0xFA
; 002C 009A     viDVConfigUpdate.viSensorConfig[2].viAlarmLowerExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,238
	CALL SUBOPT_0xFA
; 002C 009B     viDVConfigUpdate.viSensorConfig[2].viAlarmUpper = 0.0;
	__POINTW2MN _viDVConfigUpdate,242
	CALL SUBOPT_0xFA
; 002C 009C     viDVConfigUpdate.viSensorConfig[2].viAlarmUpperDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,246
	CALL SUBOPT_0xFA
; 002C 009D     viDVConfigUpdate.viSensorConfig[2].viAlarmUpperExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,250
	CALL SUBOPT_0xFA
; 002C 009E 
; 002C 009F     viDVConfigUpdate.viSensorConfig[3].viAlarmEnable = 0x01;
	__POINTW2MN _viDVConfigUpdate,257
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002C 00A0     viDVConfigUpdate.viSensorConfig[3].viAlarmLower = 0.0;
	__POINTW2MN _viDVConfigUpdate,258
	CALL SUBOPT_0xFA
; 002C 00A1     viDVConfigUpdate.viSensorConfig[3].viAlarmLowerDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,262
	CALL SUBOPT_0xFA
; 002C 00A2     viDVConfigUpdate.viSensorConfig[3].viAlarmLowerExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,266
	CALL SUBOPT_0xFA
; 002C 00A3     viDVConfigUpdate.viSensorConfig[3].viAlarmUpper = 0.0;
	__POINTW2MN _viDVConfigUpdate,270
	CALL SUBOPT_0xFA
; 002C 00A4     viDVConfigUpdate.viSensorConfig[3].viAlarmUpperDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,274
	CALL SUBOPT_0xFA
; 002C 00A5     viDVConfigUpdate.viSensorConfig[3].viAlarmUpperExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,278
	CALL SUBOPT_0xFA
; 002C 00A6 
; 002C 00A7     viDVConfigUpdate.viSensorConfig[4].viAlarmEnable = 0x01;
	__POINTW2MN _viDVConfigUpdate,285
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002C 00A8     viDVConfigUpdate.viSensorConfig[4].viAlarmLower = 0.0;
	__POINTW2MN _viDVConfigUpdate,286
	CALL SUBOPT_0xFA
; 002C 00A9     viDVConfigUpdate.viSensorConfig[4].viAlarmLowerDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,290
	CALL SUBOPT_0xFA
; 002C 00AA     viDVConfigUpdate.viSensorConfig[4].viAlarmLowerExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,294
	CALL SUBOPT_0xFA
; 002C 00AB     viDVConfigUpdate.viSensorConfig[4].viAlarmUpper = 0.0;
	__POINTW2MN _viDVConfigUpdate,298
	CALL SUBOPT_0xFA
; 002C 00AC     viDVConfigUpdate.viSensorConfig[4].viAlarmUpperDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,302
	CALL SUBOPT_0xFA
; 002C 00AD     viDVConfigUpdate.viSensorConfig[4].viAlarmUpperExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,306
	CALL SUBOPT_0xFA
; 002C 00AE 
; 002C 00AF     viDVConfigUpdate.viSensorConfig[5].viAlarmEnable = 0x01;
	__POINTW2MN _viDVConfigUpdate,313
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002C 00B0     viDVConfigUpdate.viSensorConfig[5].viAlarmLower = 0.0;
	__POINTW2MN _viDVConfigUpdate,314
	CALL SUBOPT_0xFA
; 002C 00B1     viDVConfigUpdate.viSensorConfig[5].viAlarmLowerDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,318
	CALL SUBOPT_0xFA
; 002C 00B2     viDVConfigUpdate.viSensorConfig[5].viAlarmLowerExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,322
	CALL SUBOPT_0xFA
; 002C 00B3     viDVConfigUpdate.viSensorConfig[5].viAlarmUpper = 0.0;
	__POINTW2MN _viDVConfigUpdate,326
	CALL SUBOPT_0xFA
; 002C 00B4     viDVConfigUpdate.viSensorConfig[5].viAlarmUpperDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,330
	CALL SUBOPT_0xFA
; 002C 00B5     viDVConfigUpdate.viSensorConfig[5].viAlarmUpperExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,334
	CALL SUBOPT_0xFA
; 002C 00B6 
; 002C 00B7     viDVConfigUpdate.viSensorConfig[6].viAlarmEnable = 0x01;
	__POINTW2MN _viDVConfigUpdate,341
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002C 00B8     viDVConfigUpdate.viSensorConfig[6].viAlarmLower = 0.0;
	__POINTW2MN _viDVConfigUpdate,342
	CALL SUBOPT_0xFA
; 002C 00B9     viDVConfigUpdate.viSensorConfig[6].viAlarmLowerDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,346
	CALL SUBOPT_0xFA
; 002C 00BA     viDVConfigUpdate.viSensorConfig[6].viAlarmLowerExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,350
	CALL SUBOPT_0xFA
; 002C 00BB     viDVConfigUpdate.viSensorConfig[6].viAlarmUpper = 0.0;
	__POINTW2MN _viDVConfigUpdate,354
	CALL SUBOPT_0xFA
; 002C 00BC     viDVConfigUpdate.viSensorConfig[6].viAlarmUpperDelay = 0.0;
	__POINTW2MN _viDVConfigUpdate,358
	CALL SUBOPT_0xFA
; 002C 00BD     viDVConfigUpdate.viSensorConfig[6].viAlarmUpperExtreme = 0.0;
	__POINTW2MN _viDVConfigUpdate,362
	CALL SUBOPT_0xFA
; 002C 00BE }
	RET
;#include "logManager.h"
;#include "ds1672.h"
;
;eeprom unsigned long viDate_e = 0;
;extern iChar_t viDataFName[];
;
;void iGenFileDaily(){
; 002D 0007 void iGenFileDaily(){

	.CSEG
_iGenFileDaily:
; 002D 0008     iChar_t viFileName[20];
; 002D 0009     struct rtc_structure viRTCGet;
; 002D 000A     RTC_getDateTime(&viRTCGet,7);
	SBIW R28,46
;	viFileName -> Y+26
;	viRTCGet -> Y+0
	MOVW R30,R28
	CALL SUBOPT_0x3
	CALL _RTC_getDateTime
; 002D 000B 
; 002D 000C     if((viDate_e == 0) || (viDate_e != viRTCGet.date) || (strncmp(viDataFName,"0:./00000000",12)==0)){
	LDI  R26,LOW(_viDate_e)
	LDI  R27,HIGH(_viDate_e)
	CALL __EEPROMRDD
	CALL __CPD10
	BREQ _0x5A0004
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0x58
	CALL __CPD12
	BRNE _0x5A0004
	LDI  R30,LOW(_viDataFName)
	LDI  R31,HIGH(_viDataFName)
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _0x5A0005,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(12)
	CALL _strncmp
	CPI  R30,0
	BREQ _0x5A0004
	RJMP _0x5A0003
_0x5A0004:
; 002D 000D         printDebug("[iGenFileDaily]\r\n");
	__POINTD1FN _0x5A0000,13
	CALL SUBOPT_0x0
; 002D 000E         viDate_e =  viRTCGet.date;
	CALL SUBOPT_0x58
	LDI  R26,LOW(_viDate_e)
	LDI  R27,HIGH(_viDate_e)
	CALL __EEPROMWRD
; 002D 000F         printRTC(viRTCGet);
	CALL SUBOPT_0x60
; 002D 0010         sprintf(viFileName,"0:./%04d%02d%02d.nc",viRTCGet.year,viRTCGet.month,viRTCGet.date);
	MOVW R30,R28
	ADIW R30,26
	ST   -Y,R31
	ST   -Y,R30
	__POINTD1FN _0x5A0000,31
	CALL __PUTPARD1
	CALL SUBOPT_0x40
	CALL __PUTPARD1
	CALL SUBOPT_0x52
	CALL __PUTPARD1
	CALL SUBOPT_0x4C
	CALL __PUTPARD1
	LDI  R24,12
	CALL _sprintf
	ADIW R28,18
; 002D 0011         memcpy(viDataFName,viFileName,strlen(viFileName));
	LDI  R30,LOW(_viDataFName)
	LDI  R31,HIGH(_viDataFName)
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,28
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,30
	CALL SUBOPT_0xBA
; 002D 0012         printDebug("[iGenFileDaily]File name: %s\r\n",viDataFName);
	__POINTD1FN _0x5A0000,51
	CALL __PUTPARD1
	LDI  R30,LOW(_viDataFName)
	LDI  R31,HIGH(_viDataFName)
	CALL SUBOPT_0x5F
	CALL SUBOPT_0x63
; 002D 0013     }
; 002D 0014 
; 002D 0015 }
_0x5A0003:
	ADIW R28,46
	RET

	.DSEG
_0x5A0005:
	.BYTE 0xD
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif

	.DSEG

	.CSEG
_wait_ready_G100:
	ST   -Y,R17
	LDI  R30,LOW(50)
	STS  _timer2_G100,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000004:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000004
_0x2000008:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200000A:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200000A
	IN   R17,46
	CPI  R17,255
	BREQ _0x200000D
	LDS  R30,_timer2_G100
	CPI  R30,0
	BRNE _0x200000E
_0x200000D:
	RJMP _0x2000009
_0x200000E:
	RJMP _0x2000008
_0x2000009:
	MOV  R30,R17
	LD   R17,Y+
	RET
_release_spi_G100:
	SBI  0x5,0
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200000F:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200000F
	RET
_rx_datablock_G100:
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR4
	LDI  R30,LOW(10)
	STS  _timer1_G100,R30
_0x2000013:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000015:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000015
	IN   R17,46
	CPI  R17,255
	BRNE _0x2000018
	LDS  R30,_timer1_G100
	CPI  R30,0
	BRNE _0x2000019
_0x2000018:
	RJMP _0x2000014
_0x2000019:
	RJMP _0x2000013
_0x2000014:
	CPI  R17,254
	BREQ _0x200001A
	LDI  R30,LOW(0)
	CALL __LOADLOCR4
	RJMP _0x20E0026
_0x200001A:
	__GETWRS 18,19,6
_0x200001C:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200001E:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200001E
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000021:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000021
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000024:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000024
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000027:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000027
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	SBIW R30,4
	STD  Y+4,R30
	STD  Y+4+1,R31
	BRNE _0x200001C
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200002A:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200002A
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200002D:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200002D
	LDI  R30,LOW(1)
	CALL __LOADLOCR4
	RJMP _0x20E0026
_tx_datablock_G100:
	ST   -Y,R26
	CALL __SAVELOCR4
	RCALL _wait_ready_G100
	CPI  R30,LOW(0xFF)
	BREQ _0x2000030
	LDI  R30,LOW(0)
	CALL __LOADLOCR4
	RJMP _0x20E0027
_0x2000030:
	LDD  R30,Y+4
	OUT  0x2E,R30
_0x2000031:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000031
	LDD  R26,Y+4
	CPI  R26,LOW(0xFD)
	BREQ _0x2000034
	LDI  R16,LOW(0)
	__GETWRS 18,19,5
_0x2000036:
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R30,X
	OUT  0x2E,R30
_0x2000038:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000038
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R30,X
	OUT  0x2E,R30
_0x200003B:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200003B
	SUBI R16,LOW(1)
	CPI  R16,0
	BRNE _0x2000036
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200003E:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200003E
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000041:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000041
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000044:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000044
	IN   R17,46
	MOV  R30,R17
	ANDI R30,LOW(0x1F)
	CPI  R30,LOW(0x5)
	BREQ _0x2000047
	LDI  R30,LOW(0)
	CALL __LOADLOCR4
	RJMP _0x20E0027
_0x2000047:
_0x2000034:
	LDI  R30,LOW(1)
	CALL __LOADLOCR4
	RJMP _0x20E0027
_send_cmd_G100:
	CALL __PUTPARD2
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+6
	ANDI R30,LOW(0x80)
	BREQ _0x2000048
	LDD  R30,Y+6
	ANDI R30,0x7F
	STD  Y+6,R30
	LDI  R30,LOW(119)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	MOV  R16,R30
	CPI  R16,2
	BRLO _0x2000049
	MOV  R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0027
_0x2000049:
_0x2000048:
	SBI  0x5,0
	CBI  0x5,0
	RCALL _wait_ready_G100
	CPI  R30,LOW(0xFF)
	BREQ _0x200004A
	LDI  R30,LOW(255)
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0027
_0x200004A:
	LDD  R30,Y+6
	OUT  0x2E,R30
_0x200004B:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200004B
	LDD  R30,Y+5
	OUT  0x2E,R30
_0x200004E:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200004E
	LDD  R30,Y+4
	OUT  0x2E,R30
_0x2000051:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000051
	LDD  R30,Y+3
	OUT  0x2E,R30
_0x2000054:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000054
	LDD  R30,Y+2
	OUT  0x2E,R30
_0x2000057:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000057
	LDI  R17,LOW(1)
	LDD  R26,Y+6
	CPI  R26,LOW(0x40)
	BRNE _0x200005A
	LDI  R17,LOW(149)
	RJMP _0x200005B
_0x200005A:
	LDD  R26,Y+6
	CPI  R26,LOW(0x48)
	BRNE _0x200005C
	LDI  R17,LOW(135)
_0x200005C:
_0x200005B:
	OUT  0x2E,R17
_0x200005D:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200005D
	LDD  R26,Y+6
	CPI  R26,LOW(0x4C)
	BRNE _0x2000060
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000061:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000061
_0x2000060:
	LDI  R17,LOW(255)
_0x2000065:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000067:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000067
	IN   R16,46
	SBRS R16,7
	RJMP _0x200006A
	SUBI R17,LOW(1)
	CPI  R17,0
	BRNE _0x200006B
_0x200006A:
	RJMP _0x2000066
_0x200006B:
	RJMP _0x2000065
_0x2000066:
	MOV  R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0027
_rx_spi4_G100:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	LDI  R17,4
_0x200006D:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200006F:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200006F
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,1
	STD  Y+1,R26
	STD  Y+1+1,R27
	SBIW R26,1
	IN   R30,0x2E
	ST   X,R30
	SUBI R17,LOW(1)
	CPI  R17,0
	BRNE _0x200006D
	RJMP _0x20E0024
_disk_initialize:
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
	LDD  R30,Y+8
	CPI  R30,0
	BREQ _0x2000072
	LDI  R30,LOW(1)
	RJMP _0x20E002B
_0x2000072:
	CBI  0x1,0
	CBI  0x1,1
	LDI  R30,LOW(10)
	STS  _timer1_G100,R30
_0x2000073:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BRNE _0x2000073
	LDS  R30,_status_G100
	ANDI R30,LOW(0x2)
	BREQ _0x2000076
	RJMP _0x20E002A
_0x2000076:
	SBI  0x4,0
	SBI  0x5,0
	IN   R30,0x5
	ANDI R30,LOW(0xF9)
	OUT  0x5,R30
	SBI  0x5,3
	CBI  0x4,3
	IN   R30,0x4
	ORI  R30,LOW(0x7)
	OUT  0x4,R30
	LDI  R30,LOW(82)
	OUT  0x2C,R30
	LDI  R30,LOW(0)
	OUT  0x2D,R30
	LDI  R19,LOW(255)
_0x2000078:
	LDI  R17,LOW(10)
_0x200007B:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200007D:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200007D
	SUBI R17,LOW(1)
	CPI  R17,0
	BRNE _0x200007B
	LDI  R30,LOW(64)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	MOV  R16,R30
	SUBI R19,LOW(1)
	CPI  R16,1
	BREQ _0x2000080
	CPI  R19,0
	BRNE _0x2000081
_0x2000080:
	RJMP _0x2000079
_0x2000081:
	RJMP _0x2000078
_0x2000079:
	LDI  R19,LOW(0)
	CPI  R16,1
	BREQ PC+3
	JMP _0x2000082
	LDI  R30,LOW(100)
	STS  _timer1_G100,R30
	LDI  R30,LOW(72)
	ST   -Y,R30
	__GETD2N 0x1AA
	RCALL _send_cmd_G100
	CPI  R30,LOW(0x1)
	BRNE _0x2000083
	MOVW R26,R28
	ADIW R26,4
	RCALL _rx_spi4_G100
	LDD  R26,Y+6
	CPI  R26,LOW(0x1)
	BRNE _0x2000085
	LDD  R26,Y+7
	CPI  R26,LOW(0xAA)
	BREQ _0x2000086
_0x2000085:
	RJMP _0x2000084
_0x2000086:
_0x2000087:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x200008A
	LDI  R30,LOW(233)
	ST   -Y,R30
	__GETD2N 0x40000000
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x200008B
_0x200008A:
	RJMP _0x2000089
_0x200008B:
	RJMP _0x2000087
_0x2000089:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x200008D
	LDI  R30,LOW(122)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BREQ _0x200008E
_0x200008D:
	RJMP _0x200008C
_0x200008E:
	MOVW R26,R28
	ADIW R26,4
	RCALL _rx_spi4_G100
	LDD  R30,Y+4
	ANDI R30,LOW(0x40)
	BREQ _0x200008F
	LDI  R30,LOW(12)
	RJMP _0x2000090
_0x200008F:
	LDI  R30,LOW(4)
_0x2000090:
	MOV  R19,R30
_0x200008C:
_0x2000084:
	RJMP _0x2000092
_0x2000083:
	LDI  R30,LOW(233)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,LOW(0x2)
	BRSH _0x2000093
	LDI  R19,LOW(2)
	LDI  R16,LOW(233)
	RJMP _0x2000094
_0x2000093:
	LDI  R19,LOW(1)
	LDI  R16,LOW(65)
_0x2000094:
_0x2000095:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x2000098
	ST   -Y,R16
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x2000099
_0x2000098:
	RJMP _0x2000097
_0x2000099:
	RJMP _0x2000095
_0x2000097:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x200009B
	LDI  R30,LOW(80)
	ST   -Y,R30
	__GETD2N 0x200
	RCALL _send_cmd_G100
	CPI  R30,0
	BREQ _0x200009A
_0x200009B:
	LDI  R19,LOW(0)
_0x200009A:
_0x2000092:
_0x2000082:
	STS  _card_type_G100,R19
	RCALL _release_spi_G100
	CPI  R19,0
	BREQ _0x200009D
	LDS  R30,_status_G100
	ANDI R30,0xFE
	STS  _status_G100,R30
	LDI  R30,LOW(80)
	OUT  0x2C,R30
	LDI  R30,LOW(1)
	OUT  0x2D,R30
	RJMP _0x200009E
_0x200009D:
	CBI  0x5,0
	RCALL _wait_ready_G100
	RCALL _release_spi_G100
	LDI  R30,LOW(0)
	OUT  0x2C,R30
	IN   R30,0x4
	ANDI R30,LOW(0xF0)
	OUT  0x4,R30
	IN   R30,0x5
	ANDI R30,LOW(0xF0)
	OUT  0x5,R30
	CBI  0x4,0
	LDS  R30,_status_G100
	ORI  R30,1
	STS  _status_G100,R30
_0x200009E:
_0x20E002A:
	LDS  R30,_status_G100
_0x20E002B:
	CALL __LOADLOCR4
	ADIW R28,9
	RET
_disk_status:
	ST   -Y,R26
	LD   R30,Y
	CPI  R30,0
	BREQ _0x200009F
	LDI  R30,LOW(1)
	RJMP _0x20E0029
_0x200009F:
	LDS  R30,_status_G100
_0x20E0029:
	ADIW R28,1
	RET
_disk_read:
	ST   -Y,R26
	LDD  R30,Y+7
	CPI  R30,0
	BRNE _0x20000A1
	LD   R30,Y
	CPI  R30,0
	BRNE _0x20000A0
_0x20000A1:
	LDI  R30,LOW(4)
	RJMP _0x20E0026
_0x20000A0:
	LDS  R30,_status_G100
	ANDI R30,LOW(0x1)
	BREQ _0x20000A3
	LDI  R30,LOW(3)
	RJMP _0x20E0026
_0x20000A3:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x8)
	BRNE _0x20000A4
	__GETD1S 1
	__GETD2N 0x200
	CALL __MULD12U
	__PUTD1S 1
_0x20000A4:
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRNE _0x20000A5
	LDI  R30,LOW(81)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000A7
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000A8
_0x20000A7:
	RJMP _0x20000A6
_0x20000A8:
	LDI  R30,LOW(0)
	ST   Y,R30
_0x20000A6:
	RJMP _0x20000A9
_0x20000A5:
	LDI  R30,LOW(82)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000AA
_0x20000AC:
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	RCALL _rx_datablock_G100
	CPI  R30,0
	BREQ _0x20000AD
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	SUBI R30,LOW(-512)
	SBCI R31,HIGH(-512)
	STD  Y+5,R30
	STD  Y+5+1,R31
	LD   R30,Y
	SUBI R30,LOW(1)
	ST   Y,R30
	BRNE _0x20000AC
_0x20000AD:
	LDI  R30,LOW(76)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
_0x20000AA:
_0x20000A9:
	RCALL _release_spi_G100
	LD   R30,Y
	CPI  R30,0
	BREQ _0x20000AF
	LDI  R30,LOW(1)
	RJMP _0x20000B0
_0x20000AF:
	LDI  R30,LOW(0)
_0x20000B0:
	RJMP _0x20E0026
_disk_write:
	ST   -Y,R26
	LDD  R30,Y+7
	CPI  R30,0
	BRNE _0x20000B3
	LD   R30,Y
	CPI  R30,0
	BRNE _0x20000B2
_0x20000B3:
	LDI  R30,LOW(4)
	RJMP _0x20E0026
_0x20000B2:
	LDS  R30,_status_G100
	ANDI R30,LOW(0x1)
	BREQ _0x20000B5
	LDI  R30,LOW(3)
	RJMP _0x20E0026
_0x20000B5:
	LDS  R30,_status_G100
	ANDI R30,LOW(0x4)
	BREQ _0x20000B6
	LDI  R30,LOW(2)
	RJMP _0x20E0026
_0x20000B6:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x8)
	BRNE _0x20000B7
	__GETD1S 1
	__GETD2N 0x200
	CALL __MULD12U
	__PUTD1S 1
_0x20000B7:
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRNE _0x20000B8
	LDI  R30,LOW(88)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000BA
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(254)
	RCALL _tx_datablock_G100
	CPI  R30,0
	BRNE _0x20000BB
_0x20000BA:
	RJMP _0x20000B9
_0x20000BB:
	LDI  R30,LOW(0)
	ST   Y,R30
_0x20000B9:
	RJMP _0x20000BC
_0x20000B8:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x6)
	BREQ _0x20000BD
	LDI  R30,LOW(215)
	ST   -Y,R30
	LDD  R26,Y+1
	CLR  R27
	CLR  R24
	CLR  R25
	RCALL _send_cmd_G100
_0x20000BD:
	LDI  R30,LOW(89)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000BE
_0x20000C0:
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(252)
	RCALL _tx_datablock_G100
	CPI  R30,0
	BREQ _0x20000C1
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	SUBI R30,LOW(-512)
	SBCI R31,HIGH(-512)
	STD  Y+5,R30
	STD  Y+5+1,R31
	LD   R30,Y
	SUBI R30,LOW(1)
	ST   Y,R30
	BRNE _0x20000C0
_0x20000C1:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(253)
	RCALL _tx_datablock_G100
	CPI  R30,0
	BRNE _0x20000C3
	LDI  R30,LOW(1)
	ST   Y,R30
_0x20000C3:
_0x20000BE:
_0x20000BC:
	RCALL _release_spi_G100
	LD   R30,Y
	CPI  R30,0
	BREQ _0x20000C4
	LDI  R30,LOW(1)
	RJMP _0x20000C5
_0x20000C4:
	LDI  R30,LOW(0)
_0x20000C5:
	RJMP _0x20E0026
_disk_ioctl:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,16
	CALL __SAVELOCR6
	LDD  R30,Y+25
	CPI  R30,0
	BREQ _0x20000C7
	LDI  R30,LOW(4)
	RJMP _0x20E0028
_0x20000C7:
	LDI  R17,LOW(1)
	LDS  R30,_status_G100
	ANDI R30,LOW(0x1)
	BREQ _0x20000C8
	LDI  R30,LOW(3)
	RJMP _0x20E0028
_0x20000C8:
	__GETWRS 20,21,22
	LDD  R30,Y+24
	CPI  R30,0
	BRNE _0x20000CC
	CBI  0x5,0
	RCALL _wait_ready_G100
	CPI  R30,LOW(0xFF)
	BRNE _0x20000CD
	LDI  R17,LOW(0)
_0x20000CD:
	RJMP _0x20000CB
_0x20000CC:
	CPI  R30,LOW(0x1)
	BREQ PC+3
	JMP _0x20000CE
	LDI  R30,LOW(73)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000D0
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000D1
_0x20000D0:
	RJMP _0x20000CF
_0x20000D1:
	LDD  R30,Y+6
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	LSR  R30
	CPI  R30,LOW(0x1)
	BRNE _0x20000D2
	LDI  R30,0
	LDD  R31,Y+14
	LDD  R26,Y+15
	LDI  R27,0
	ADD  R30,R26
	ADC  R31,R27
	ADIW R30,1
	MOVW R18,R30
	MOVW R26,R18
	CLR  R24
	CLR  R25
	LDI  R30,LOW(10)
	RJMP _0x2000101
_0x20000D2:
	LDD  R30,Y+11
	ANDI R30,LOW(0xF)
	MOV  R26,R30
	LDD  R30,Y+16
	ANDI R30,LOW(0x80)
	ROL  R30
	LDI  R30,0
	ROL  R30
	ADD  R26,R30
	LDD  R30,Y+15
	ANDI R30,LOW(0x3)
	LSL  R30
	ADD  R30,R26
	SUBI R30,-LOW(2)
	MOV  R16,R30
	LDD  R30,Y+14
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	LSR  R30
	MOV  R26,R30
	LDD  R30,Y+13
	LDI  R31,0
	CALL __LSLW2
	LDI  R27,0
	ADD  R26,R30
	ADC  R27,R31
	LDD  R30,Y+12
	ANDI R30,LOW(0x3)
	LDI  R31,0
	CALL __LSLW2
	MOV  R31,R30
	LDI  R30,0
	ADD  R30,R26
	ADC  R31,R27
	ADIW R30,1
	MOVW R18,R30
	MOVW R26,R18
	CLR  R24
	CLR  R25
	MOV  R30,R16
	SUBI R30,LOW(9)
_0x2000101:
	CALL __LSLD12
	MOVW R26,R20
	CALL __PUTDP1
	LDI  R17,LOW(0)
_0x20000CF:
	RJMP _0x20000CB
_0x20000CE:
	CPI  R30,LOW(0x2)
	BRNE _0x20000D4
	MOVW R26,R20
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	ST   X+,R30
	ST   X,R31
	LDI  R17,LOW(0)
	RJMP _0x20000CB
_0x20000D4:
	CPI  R30,LOW(0x3)
	BREQ PC+3
	JMP _0x20000D5
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x4)
	BREQ _0x20000D6
	LDI  R30,LOW(205)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000D7
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x20000D8:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x20000D8
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BREQ _0x20000DB
	LDI  R16,LOW(48)
_0x20000DD:
	CPI  R16,0
	BREQ _0x20000DE
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x20000DF:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x20000DF
	SUBI R16,1
	RJMP _0x20000DD
_0x20000DE:
	LDD  R30,Y+16
	SWAP R30
	ANDI R30,0xF
	__GETD2N 0x10
	CALL __LSLD12
	MOVW R26,R20
	CALL __PUTDP1
	LDI  R17,LOW(0)
_0x20000DB:
_0x20000D7:
	RJMP _0x20000E2
_0x20000D6:
	LDI  R30,LOW(73)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000E4
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000E5
_0x20000E4:
	RJMP _0x20000E3
_0x20000E5:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x2)
	BREQ _0x20000E6
	LDD  R30,Y+16
	ANDI R30,LOW(0x3F)
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __LSLD1
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+17
	ANDI R30,LOW(0x80)
	CLR  R31
	CLR  R22
	CLR  R23
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(7)
	CALL __LSRD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ADDD12
	__ADDD1N 1
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+19
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	LSR  R30
	SUBI R30,LOW(1)
	CALL __LSLD12
	RJMP _0x2000102
_0x20000E6:
	LDD  R30,Y+16
	ANDI R30,LOW(0x7C)
	LSR  R30
	LSR  R30
	CLR  R31
	CLR  R22
	CLR  R23
	__ADDD1N 1
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+17
	ANDI R30,LOW(0x3)
	CLR  R31
	CLR  R22
	CLR  R23
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(3)
	CALL __LSLD12
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+17
	ANDI R30,LOW(0xE0)
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __ADDD12
	__ADDD1N 1
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __MULD12U
_0x2000102:
	MOVW R26,R20
	CALL __PUTDP1
	LDI  R17,LOW(0)
_0x20000E3:
_0x20000E2:
	RJMP _0x20000CB
_0x20000D5:
	CPI  R30,LOW(0xA)
	BRNE _0x20000E8
	LDS  R30,_card_type_G100
	MOVW R26,R20
	ST   X,R30
	LDI  R17,LOW(0)
	RJMP _0x20000CB
_0x20000E8:
	CPI  R30,LOW(0xB)
	BRNE _0x20000E9
	LDI  R30,LOW(73)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000EB
	ST   -Y,R21
	ST   -Y,R20
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000EC
_0x20000EB:
	RJMP _0x20000EA
_0x20000EC:
	LDI  R17,LOW(0)
_0x20000EA:
	RJMP _0x20000CB
_0x20000E9:
	CPI  R30,LOW(0xC)
	BRNE _0x20000ED
	LDI  R30,LOW(74)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000EF
	ST   -Y,R21
	ST   -Y,R20
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000F0
_0x20000EF:
	RJMP _0x20000EE
_0x20000F0:
	LDI  R17,LOW(0)
_0x20000EE:
	RJMP _0x20000CB
_0x20000ED:
	CPI  R30,LOW(0xD)
	BRNE _0x20000F1
	LDI  R30,LOW(122)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000F2
	MOVW R26,R20
	RCALL _rx_spi4_G100
	LDI  R17,LOW(0)
_0x20000F2:
	RJMP _0x20000CB
_0x20000F1:
	CPI  R30,LOW(0xE)
	BRNE _0x20000F9
	LDI  R30,LOW(205)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000F4
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x20000F5:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x20000F5
	ST   -Y,R21
	ST   -Y,R20
	LDI  R26,LOW(64)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BREQ _0x20000F8
	LDI  R17,LOW(0)
_0x20000F8:
_0x20000F4:
	RJMP _0x20000CB
_0x20000F9:
	LDI  R17,LOW(4)
_0x20000CB:
	RCALL _release_spi_G100
	MOV  R30,R17
_0x20E0028:
	CALL __LOADLOCR6
	ADIW R28,26
	RET
_disk_timerproc:
	ST   -Y,R17
	ST   -Y,R16
	LDS  R17,_timer1_G100
	CPI  R17,0
	BREQ _0x20000FA
	SUBI R17,LOW(1)
	STS  _timer1_G100,R17
_0x20000FA:
	LDS  R17,_timer2_G100
	CPI  R17,0
	BREQ _0x20000FB
	SUBI R17,LOW(1)
	STS  _timer2_G100,R17
_0x20000FB:
	LDS  R17,_pv_S100000B000
	IN   R30,0x0
	ANDI R30,LOW(0x2)
	MOV  R26,R30
	IN   R30,0x0
	ANDI R30,LOW(0x1)
	OR   R30,R26
	STS  _pv_S100000B000,R30
	CP   R30,R17
	BRNE _0x20000FC
	LDS  R16,_status_G100
	ANDI R30,LOW(0x2)
	BREQ _0x20000FD
	ORI  R16,LOW(4)
	RJMP _0x20000FE
_0x20000FD:
	ANDI R16,LOW(251)
_0x20000FE:
	LDS  R30,_pv_S100000B000
	ANDI R30,LOW(0x1)
	BREQ _0x20000FF
	ORI  R16,LOW(3)
	RJMP _0x2000100
_0x20000FF:
	ANDI R16,LOW(253)
_0x2000100:
	STS  _status_G100,R16
_0x20000FC:
	LD   R16,Y+
	LD   R17,Y+
	RET

	.CSEG
_get_fattime:
	SBIW R28,7
	LDS  R26,_prtc_get_time
	LDS  R27,_prtc_get_time+1
	LDS  R24,_prtc_get_time+2
	LDS  R25,_prtc_get_time+3
	CALL __CPD02
	BREQ _0x2020004
	LDS  R26,_prtc_get_date
	LDS  R27,_prtc_get_date+1
	LDS  R24,_prtc_get_date+2
	LDS  R25,_prtc_get_date+3
	CALL __CPD02
	BRNE _0x2020003
_0x2020004:
	__GETD1N 0x3A210000
	RJMP _0x20E0027
_0x2020003:
	CALL SUBOPT_0x97
	MOVW R30,R28
	ADIW R30,7
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,8
	__CALL1MN _prtc_get_time,0
	MOVW R30,R28
	ADIW R30,3
	CALL SUBOPT_0x6A
	MOVW R26,R28
	ADIW R26,4
	__CALL1MN _prtc_get_date,0
	LD   R30,Y
	LDD  R31,Y+1
	SUBI R30,LOW(1980)
	SBCI R31,HIGH(1980)
	CLR  R22
	CLR  R23
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(25)
	CALL __LSLD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+2
	CALL SUBOPT_0xFB
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(21)
	CALL __LSLD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ORD12
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+3
	CALL SUBOPT_0xFB
	CALL __LSLD16
	CALL __ORD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+6
	CALL SUBOPT_0xFB
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(11)
	CALL __LSLD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ORD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+5
	CALL SUBOPT_0xFB
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(5)
	CALL __LSLD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ORD12
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+4
	LDI  R31,0
	ASR  R31
	ROR  R30
	CALL __CWD1
	CALL __ORD12
_0x20E0027:
	ADIW R28,7
	RET
_mem_cpy_G101:
	CALL SUBOPT_0xEA
	__GETWRS 16,17,8
	__GETWRS 18,19,6
_0x2020006:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	SBIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	ADIW R30,1
	BREQ _0x2020008
	PUSH R17
	PUSH R16
	__ADDWRN 16,17,1
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R30,X
	POP  R26
	POP  R27
	ST   X,R30
	RJMP _0x2020006
_0x2020008:
	CALL __LOADLOCR4
	RJMP _0x20E0021
_mem_set_G101:
	CALL SUBOPT_0x13
	__GETWRS 16,17,6
_0x202000C:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,1
	STD  Y+2,R30
	STD  Y+2+1,R31
	ADIW R30,1
	BREQ _0x202000E
	PUSH R17
	PUSH R16
	__ADDWRN 16,17,1
	LDD  R30,Y+4
	POP  R26
	POP  R27
	ST   X,R30
	RJMP _0x202000C
_0x202000E:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E0026:
	ADIW R28,8
	RET
_mem_cmp_G101:
	CALL SUBOPT_0x6D
	__GETWRS 16,17,10
	__GETWRS 18,19,8
	__GETWRN 20,21,0
_0x202000F:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	ADIW R30,1
	BREQ _0x2020012
	MOVW R26,R16
	__ADDWRN 16,17,1
	LD   R0,X
	CLR  R1
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R26,X
	CLR  R27
	MOVW R30,R0
	SUB  R30,R26
	SBC  R31,R27
	MOVW R20,R30
	SBIW R30,0
	BREQ _0x2020013
_0x2020012:
	RJMP _0x2020011
_0x2020013:
	RJMP _0x202000F
_0x2020011:
	MOVW R30,R20
	CALL __LOADLOCR6
	ADIW R28,12
	RET
_chk_chrf_G101:
	ST   -Y,R27
	ST   -Y,R26
_0x2020014:
	CALL SUBOPT_0x3E
	__GETBRPF 30
	CPI  R30,0
	BREQ _0x2020017
	CALL SUBOPT_0x3E
	__GETBRPF 26
	LD   R30,Y
	LDD  R31,Y+1
	LDI  R27,0
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x2020018
_0x2020017:
	RJMP _0x2020016
_0x2020018:
	MOVW R26,R28
	ADIW R26,2
	CALL SUBOPT_0xFC
	RJMP _0x2020014
_0x2020016:
	CALL SUBOPT_0x3E
	__GETBRPF 30
	LDI  R31,0
	ADIW R28,6
	RET
_move_window_G101:
	CALL __PUTPARD2
	SBIW R28,4
	ST   -Y,R17
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,46
	CALL SUBOPT_0xFD
	CALL SUBOPT_0xFE
	CALL SUBOPT_0x66
	CALL __CPD12
	BRNE PC+3
	JMP _0x2020019
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R30,Z+4
	CPI  R30,0
	BREQ _0x202001A
	CALL SUBOPT_0xFF
	CPI  R30,0
	BREQ _0x202001B
	LDI  R30,LOW(1)
	RJMP _0x20E0025
_0x202001B:
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,4
	LDI  R30,LOW(0)
	ST   X,R30
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	CALL SUBOPT_0x100
	MOVW R0,R26
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,26
	CALL __GETD1P
	MOVW R26,R0
	CALL __ADDD12
	CALL SUBOPT_0x66
	CALL __CPD21
	BRSH _0x202001C
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R17,Z+3
_0x202001E:
	CPI  R17,2
	BRLO _0x202001F
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,26
	CALL __GETD1P
	CALL SUBOPT_0x66
	CALL __ADDD12
	__PUTD1S 1
	CALL SUBOPT_0xFF
	SUBI R17,1
	RJMP _0x202001E
_0x202001F:
_0x202001C:
_0x202001A:
	CALL SUBOPT_0xFE
	CALL __CPD10
	BREQ _0x2020020
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	ADIW R30,50
	CALL SUBOPT_0x101
	BREQ _0x2020021
	LDI  R30,LOW(1)
	RJMP _0x20E0025
_0x2020021:
	CALL SUBOPT_0xFE
	__PUTD1SNS 9,46
_0x2020020:
_0x2020019:
	LDI  R30,LOW(0)
_0x20E0025:
	LDD  R17,Y+0
	ADIW R28,11
	RET
_sync_G101:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	CALL SUBOPT_0x102
	CALL SUBOPT_0x103
	BREQ PC+3
	JMP _0x2020022
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R26,X
	CPI  R26,LOW(0x3)
	BRNE _0x2020024
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	LDD  R30,Z+5
	CPI  R30,0
	BRNE _0x2020025
_0x2020024:
	RJMP _0x2020023
_0x2020025:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,46
	CALL SUBOPT_0x104
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xC2
	CALL SUBOPT_0x105
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	SUBI R30,LOW(-510)
	SBCI R31,HIGH(-510)
	LDI  R26,LOW(43605)
	LDI  R27,HIGH(43605)
	STD  Z+0,R26
	STD  Z+1,R27
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	__GETD2N 0x41615252
	CALL SUBOPT_0x106
	SUBI R30,LOW(-484)
	SBCI R31,HIGH(-484)
	__GETD2N 0x61417272
	CALL SUBOPT_0x106
	SUBI R30,LOW(-488)
	SBCI R31,HIGH(-488)
	MOVW R0,R30
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,14
	CALL SUBOPT_0x107
	ADIW R30,50
	SUBI R30,LOW(-492)
	SBCI R31,HIGH(-492)
	MOVW R0,R30
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,10
	CALL SUBOPT_0x107
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x108
	RCALL _disk_write
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,5
	LDI  R30,LOW(0)
	ST   X,R30
_0x2020023:
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	RCALL _disk_ioctl
	CPI  R30,0
	BREQ _0x2020026
	LDI  R17,LOW(1)
_0x2020026:
_0x2020022:
	MOV  R30,R17
_0x20E0024:
	LDD  R17,Y+0
	ADIW R28,3
	RET
_get_fat:
	CALL __PUTPARD2
	SBIW R28,4
	CALL __SAVELOCR4
	CALL SUBOPT_0x56
	CALL SUBOPT_0x109
	BRLO _0x2020028
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,30
	CALL __GETD1P
	CALL SUBOPT_0x56
	CALL __CPD21
	BRLO _0x2020027
_0x2020028:
	CALL SUBOPT_0x10A
	RJMP _0x20E0023
_0x2020027:
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,34
	CALL SUBOPT_0x10B
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	CALL SUBOPT_0x7A
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x202002D
	__GETWRS 18,19,8
	MOVW R30,R18
	LSR  R31
	ROR  R30
	__ADDWRR 18,19,30,31
	CALL SUBOPT_0x75
	CALL SUBOPT_0x10C
	BREQ _0x202002E
	RJMP _0x202002C
_0x202002E:
	CALL SUBOPT_0x10D
	LD   R16,X
	CLR  R17
	__ADDWRN 18,19,1
	CALL SUBOPT_0x75
	CALL SUBOPT_0x10C
	BRNE _0x202002C
	CALL SUBOPT_0x10D
	LD   R30,X
	MOV  R31,R30
	LDI  R30,0
	__ORWRR 16,17,30,31
	LDD  R30,Y+8
	ANDI R30,LOW(0x1)
	BREQ _0x2020030
	MOVW R30,R16
	CALL __LSRW4
	RJMP _0x202022B
_0x2020030:
	MOVW R30,R16
	ANDI R31,HIGH(0xFFF)
_0x202022B:
	CLR  R22
	CLR  R23
	RJMP _0x20E0023
_0x202002D:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x2020033
	CALL SUBOPT_0x75
	CALL SUBOPT_0x10E
	CALL SUBOPT_0x10F
	CALL SUBOPT_0x110
	BRNE _0x202002C
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(2)
	CALL SUBOPT_0x111
	CALL SUBOPT_0x112
	RJMP _0x20E0023
_0x2020033:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x202002C
	CALL SUBOPT_0x75
	CALL SUBOPT_0x10E
	CALL SUBOPT_0x113
	CALL SUBOPT_0x110
	BRNE _0x202002C
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(4)
	CALL SUBOPT_0x111
	CALL SUBOPT_0x114
	RJMP _0x20E0023
_0x202002C:
	CALL SUBOPT_0x1D
_0x20E0023:
	CALL __LOADLOCR4
	ADIW R28,14
	RET
_put_fat:
	CALL __PUTPARD2
	SBIW R28,4
	CALL __SAVELOCR6
	CALL SUBOPT_0x115
	CALL SUBOPT_0x109
	BRLO _0x2020038
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,30
	CALL __GETD1P
	CALL SUBOPT_0x115
	CALL __CPD21
	BRLO _0x2020037
_0x2020038:
	LDI  R21,LOW(2)
	RJMP _0x202003A
_0x2020037:
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,34
	CALL __GETD1P
	CALL SUBOPT_0x41
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL SUBOPT_0x7A
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BREQ PC+3
	JMP _0x202003E
	__GETWRS 16,17,14
	MOVW R30,R16
	LSR  R31
	ROR  R30
	__ADDWRR 16,17,30,31
	CALL SUBOPT_0xE7
	CALL SUBOPT_0x116
	BREQ _0x202003F
	RJMP _0x202003D
_0x202003F:
	CALL SUBOPT_0x117
	BREQ _0x2020040
	MOVW R26,R18
	LD   R30,X
	ANDI R30,LOW(0xF)
	MOV  R26,R30
	LDD  R30,Y+10
	LDI  R31,0
	CALL __LSLW4
	OR   R30,R26
	RJMP _0x2020041
_0x2020040:
	LDD  R30,Y+10
_0x2020041:
	MOVW R26,R18
	ST   X,R30
	__ADDWRN 16,17,1
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	CALL SUBOPT_0xE7
	CALL SUBOPT_0x116
	BREQ _0x2020043
	RJMP _0x202003D
_0x2020043:
	CALL SUBOPT_0x117
	BREQ _0x2020044
	CALL SUBOPT_0x10E
	LDI  R30,LOW(4)
	CALL __LSRD12
	CLR  R31
	CLR  R22
	CLR  R23
	RJMP _0x2020045
_0x2020044:
	MOVW R26,R18
	LD   R30,X
	ANDI R30,LOW(0xF0)
	MOV  R1,R30
	CALL SUBOPT_0x10E
	LDI  R30,LOW(8)
	CALL __LSRD12
	CLR  R31
	CLR  R22
	CLR  R23
	ANDI R30,LOW(0xF)
	OR   R30,R1
_0x2020045:
	MOVW R26,R18
	ST   X,R30
	RJMP _0x202003D
_0x202003E:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x2020047
	CALL SUBOPT_0xE7
	CALL SUBOPT_0x118
	CALL SUBOPT_0x10F
	CALL SUBOPT_0x119
	BRNE _0x202003D
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	LDI  R30,LOW(2)
	CALL SUBOPT_0x11A
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	STD  Z+0,R26
	STD  Z+1,R27
	RJMP _0x202003D
_0x2020047:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x202004B
	CALL SUBOPT_0xE7
	CALL SUBOPT_0x118
	CALL SUBOPT_0x113
	CALL SUBOPT_0x119
	BRNE _0x202003D
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	LDI  R30,LOW(4)
	CALL SUBOPT_0x11A
	CALL SUBOPT_0x10E
	CALL SUBOPT_0x11B
	RJMP _0x202003D
_0x202004B:
	LDI  R21,LOW(2)
_0x202003D:
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
_0x202003A:
	MOV  R30,R21
	CALL __LOADLOCR6
	ADIW R28,20
	RET
_remove_chain_G101:
	CALL __PUTPARD2
	SBIW R28,4
	ST   -Y,R17
	CALL SUBOPT_0x11C
	CALL SUBOPT_0x109
	BRLO _0x202004D
	CALL SUBOPT_0x11D
	BRLO _0x202004C
_0x202004D:
	LDI  R17,LOW(2)
	RJMP _0x202004F
_0x202004C:
	LDI  R17,LOW(0)
_0x2020050:
	CALL SUBOPT_0x11D
	BRLO PC+3
	JMP _0x2020052
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	ST   -Y,R31
	ST   -Y,R30
	__GETD2S 7
	RCALL _get_fat
	__PUTD1S 1
	CALL SUBOPT_0x11E
	CALL __CPD10
	BREQ _0x2020052
	CALL SUBOPT_0x66
	CALL SUBOPT_0x11F
	BRNE _0x2020054
	LDI  R17,LOW(2)
	RJMP _0x2020052
_0x2020054:
	CALL SUBOPT_0x66
	CALL SUBOPT_0x5E
	BRNE _0x2020055
	LDI  R17,LOW(1)
	RJMP _0x2020052
_0x2020055:
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	ST   -Y,R31
	ST   -Y,R30
	__GETD1S 7
	CALL __PUTPARD1
	CALL SUBOPT_0x120
	RCALL _put_fat
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x2020052
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	CALL SUBOPT_0x121
	BREQ _0x2020057
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,14
	CALL SUBOPT_0x26
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,5
	LDI  R30,LOW(1)
	ST   X,R30
_0x2020057:
	CALL SUBOPT_0x11E
	CALL SUBOPT_0x122
	RJMP _0x2020050
_0x2020052:
_0x202004F:
	MOV  R30,R17
	LDD  R17,Y+0
	RJMP _0x20E001F
_create_chain_G101:
	CALL __PUTPARD2
	SBIW R28,16
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,30
	CALL __GETD1P
	CALL SUBOPT_0x1E
	CALL SUBOPT_0x123
	CALL __CPD10
	BRNE _0x2020058
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,10
	CALL SUBOPT_0x10B
	CALL SUBOPT_0x31
	CALL __CPD02
	BREQ _0x202005A
	CALL SUBOPT_0x1A
	CALL SUBOPT_0x31
	CALL __CPD21
	BRLO _0x2020059
_0x202005A:
	CALL SUBOPT_0x10A
	CALL SUBOPT_0x30
_0x2020059:
	RJMP _0x202005C
_0x2020058:
	CALL SUBOPT_0x124
	CALL SUBOPT_0x125
	CALL SUBOPT_0x126
	CALL SUBOPT_0x57
	CALL SUBOPT_0x109
	BRSH _0x202005D
	CALL SUBOPT_0x10A
	RJMP _0x20E0022
_0x202005D:
	CALL SUBOPT_0x1A
	CALL SUBOPT_0x57
	CALL __CPD21
	BRSH _0x202005E
	CALL SUBOPT_0x55
	RJMP _0x20E0022
_0x202005E:
	CALL SUBOPT_0x123
	CALL SUBOPT_0x30
_0x202005C:
	CALL SUBOPT_0x1C
	CALL SUBOPT_0x54
_0x2020060:
	CALL SUBOPT_0x58
	CALL SUBOPT_0x47
	CALL SUBOPT_0x54
	CALL SUBOPT_0x1A
	CALL SUBOPT_0x56
	CALL __CPD21
	BRLO _0x2020062
	CALL SUBOPT_0x127
	CALL SUBOPT_0x54
	CALL SUBOPT_0x128
	BRSH _0x2020063
	CALL SUBOPT_0x23
	RJMP _0x20E0022
_0x2020063:
_0x2020062:
	CALL SUBOPT_0x124
	CALL SUBOPT_0x10E
	CALL SUBOPT_0x126
	CALL SUBOPT_0x129
	BREQ _0x2020061
	CALL SUBOPT_0x12A
	BREQ _0x2020066
	CALL SUBOPT_0x12B
	BRNE _0x2020065
_0x2020066:
	CALL SUBOPT_0x55
	RJMP _0x20E0022
_0x2020065:
	CALL SUBOPT_0x128
	BRNE _0x2020068
	CALL SUBOPT_0x23
	RJMP _0x20E0022
_0x2020068:
	RJMP _0x2020060
_0x2020061:
	CALL SUBOPT_0x124
	CALL SUBOPT_0x53
	CALL __PUTPARD1
	__GETD2N 0xFFFFFFF
	RCALL _put_fat
	CPI  R30,0
	BREQ _0x2020069
	CALL SUBOPT_0x1D
	RJMP _0x20E0022
_0x2020069:
	CALL SUBOPT_0x123
	CALL __CPD10
	BREQ _0x202006A
	CALL SUBOPT_0x124
	CALL SUBOPT_0x51
	CALL __PUTPARD1
	CALL SUBOPT_0x115
	RCALL _put_fat
	CPI  R30,0
	BREQ _0x202006B
	CALL SUBOPT_0x1D
	RJMP _0x20E0022
_0x202006B:
_0x202006A:
	CALL SUBOPT_0x58
	__PUTD1SNS 20,10
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	CALL SUBOPT_0x121
	BREQ _0x202006C
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,14
	CALL __GETD1P_INC
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	CALL __PUTDP1_DEC
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,5
	LDI  R30,LOW(1)
	ST   X,R30
_0x202006C:
	CALL SUBOPT_0x58
_0x20E0022:
	ADIW R28,22
	RET
_clust2sect:
	CALL SUBOPT_0x19
	__SUBD1N 2
	CALL SUBOPT_0x1E
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	__GETD2Z 30
	CALL SUBOPT_0x127
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x20
	CALL __CPD21
	BRLO _0x202006D
	CALL SUBOPT_0x23
	RJMP _0x20E001B
_0x202006D:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x65
	CALL SUBOPT_0x20
	CALL SUBOPT_0x67
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,42
	CALL __GETD1P
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ADDD12
	RJMP _0x20E001B
_dir_seek_G101:
	CALL SUBOPT_0x5C
	ST   -Y,R16
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	__PUTW1SNS 8,4
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,6
	CALL __GETD1P
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x11F
	BREQ _0x202006F
	CALL SUBOPT_0xA2
	CALL SUBOPT_0x12C
	BRLO _0x202006E
_0x202006F:
	LDI  R30,LOW(2)
	RJMP _0x20E0020
_0x202006E:
	CALL SUBOPT_0x3E
	CALL __CPD10
	BRNE _0x2020072
	CALL SUBOPT_0xA2
	LD   R26,Z
	CPI  R26,LOW(0x3)
	BREQ _0x2020073
_0x2020072:
	RJMP _0x2020071
_0x2020073:
	CALL SUBOPT_0xA2
	ADIW R30,38
	MOVW R26,R30
	CALL __GETD1P
	CALL SUBOPT_0x3D
_0x2020071:
	CALL SUBOPT_0x3E
	CALL __CPD10
	BRNE _0x2020074
	CALL SUBOPT_0x12D
	ADIW R30,8
	MOVW R26,R30
	CALL __GETW1P
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x2020075
	LDI  R30,LOW(2)
	RJMP _0x20E0020
_0x2020075:
	CALL SUBOPT_0xA2
	ADIW R30,38
	MOVW R26,R30
	CALL __GETD1P
	RJMP _0x202022C
_0x2020074:
	CALL SUBOPT_0xA2
	LDD  R30,Z+2
	LDI  R26,LOW(16)
	MUL  R30,R26
	MOVW R16,R0
_0x2020077:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R16
	CPC  R27,R17
	BRLO _0x2020079
	CALL SUBOPT_0xA2
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x31
	RCALL _get_fat
	CALL SUBOPT_0x5D
	CALL SUBOPT_0x5E
	BRNE _0x202007A
	LDI  R30,LOW(1)
	RJMP _0x20E0020
_0x202007A:
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x109
	BRLO _0x202007C
	CALL SUBOPT_0xA2
	CALL SUBOPT_0x12C
	BRLO _0x202007B
_0x202007C:
	LDI  R30,LOW(2)
	RJMP _0x20E0020
_0x202007B:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SUB  R30,R16
	SBC  R31,R17
	STD  Y+6,R30
	STD  Y+6+1,R31
	RJMP _0x2020077
_0x2020079:
	CALL SUBOPT_0x12D
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x31
	RCALL _clust2sect
_0x202022C:
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL __LSRW4
	CALL SUBOPT_0x12E
	__PUTD1SNS 8,14
	CALL SUBOPT_0xA2
	ADIW R30,50
	MOVW R26,R30
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x12F
	__PUTW1SNS 8,18
	LDI  R30,LOW(0)
_0x20E0020:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E0021:
	ADIW R28,10
	RET
_dir_next_G101:
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,4
	CALL __GETW1P
	ADIW R30,1
	MOVW R16,R30
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x202007F
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,14
	CALL SUBOPT_0x130
	BRNE _0x202007E
_0x202007F:
	LDI  R30,LOW(4)
	RJMP _0x20E001E
_0x202007E:
	MOVW R30,R16
	ANDI R30,LOW(0xF)
	BREQ PC+3
	JMP _0x2020081
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,14
	CALL SUBOPT_0x26
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,10
	CALL SUBOPT_0x130
	BRNE _0x2020082
	CALL SUBOPT_0x131
	ADIW R30,8
	MOVW R26,R30
	CALL __GETW1P
	CP   R16,R30
	CPC  R17,R31
	BRLO _0x2020083
	LDI  R30,LOW(4)
	RJMP _0x20E001E
_0x2020083:
	RJMP _0x2020084
_0x2020082:
	MOVW R30,R16
	CALL __LSRW4
	MOVW R0,R30
	CALL SUBOPT_0x131
	CALL SUBOPT_0x65
	SBIW R30,1
	AND  R30,R0
	AND  R31,R1
	SBIW R30,0
	BREQ PC+3
	JMP _0x2020085
	CALL SUBOPT_0x132
	LDD  R30,Y+11
	LDD  R31,Y+11+1
	CALL SUBOPT_0xE6
	RCALL _get_fat
	CALL SUBOPT_0x30
	CALL SUBOPT_0x31
	CALL SUBOPT_0x109
	BRSH _0x2020086
	LDI  R30,LOW(2)
	RJMP _0x20E001E
_0x2020086:
	CALL SUBOPT_0x31
	CALL SUBOPT_0x5E
	BRNE _0x2020087
	LDI  R30,LOW(1)
	RJMP _0x20E001E
_0x2020087:
	CALL SUBOPT_0x131
	CALL SUBOPT_0x133
	CALL SUBOPT_0x31
	CALL __CPD21
	BRSH PC+3
	JMP _0x2020088
	LDD  R30,Y+8
	CPI  R30,0
	BRNE _0x2020089
	LDI  R30,LOW(4)
	RJMP _0x20E001E
_0x2020089:
	CALL SUBOPT_0x132
	LDD  R30,Y+11
	LDD  R31,Y+11+1
	CALL SUBOPT_0xE6
	RCALL _create_chain_G101
	CALL SUBOPT_0x38
	CALL __CPD10
	BRNE _0x202008A
	LDI  R30,LOW(7)
	RJMP _0x20E001E
_0x202008A:
	CALL SUBOPT_0x31
	CALL SUBOPT_0x11F
	BRNE _0x202008B
	LDI  R30,LOW(2)
	RJMP _0x20E001E
_0x202008B:
	CALL SUBOPT_0x31
	CALL SUBOPT_0x5E
	BRNE _0x202008C
	LDI  R30,LOW(1)
	RJMP _0x20E001E
_0x202008C:
	CALL SUBOPT_0x132
	CALL SUBOPT_0x120
	RCALL _move_window_G101
	CPI  R30,0
	BREQ _0x202008D
	LDI  R30,LOW(1)
	RJMP _0x20E001E
_0x202008D:
	CALL SUBOPT_0x131
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xC2
	CALL SUBOPT_0x105
	CALL SUBOPT_0x131
	MOVW R26,R30
	ADIW R30,46
	PUSH R31
	PUSH R30
	MOVW R30,R26
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x3C
	RCALL _clust2sect
	POP  R26
	POP  R27
	CALL __PUTDP1
	LDI  R19,LOW(0)
_0x202008F:
	CALL SUBOPT_0x131
	LDD  R30,Z+2
	CP   R19,R30
	BRSH _0x2020090
	CALL SUBOPT_0x131
	ADIW R30,4
	LDI  R26,LOW(1)
	STD  Z+0,R26
	CALL SUBOPT_0x132
	CALL SUBOPT_0x120
	RCALL _move_window_G101
	CPI  R30,0
	BREQ _0x2020091
	LDI  R30,LOW(1)
	RJMP _0x20E001E
_0x2020091:
	CALL SUBOPT_0x131
	ADIW R30,46
	MOVW R26,R30
	CALL SUBOPT_0x26
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	SUBI R19,-1
	RJMP _0x202008F
_0x2020090:
	CALL SUBOPT_0x131
	ADIW R30,46
	PUSH R31
	PUSH R30
	MOVW R26,R30
	CALL __GETD1P
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0x33
	CALL __CWD1
	CALL SUBOPT_0x4A
	POP  R26
	POP  R27
	CALL __PUTDP1
_0x2020088:
	CALL SUBOPT_0x1C
	__PUTD1SNS 9,10
	CALL SUBOPT_0x132
	CALL SUBOPT_0x3C
	RCALL _clust2sect
	__PUTD1SNS 9,14
_0x2020085:
_0x2020084:
_0x2020081:
	MOVW R30,R16
	__PUTW1SNS 9,4
	CALL SUBOPT_0x131
	ADIW R30,50
	MOVW R26,R30
	MOVW R30,R16
	CALL SUBOPT_0x12F
	__PUTW1SNS 9,18
	LDI  R30,LOW(0)
_0x20E001E:
	CALL __LOADLOCR4
_0x20E001F:
	ADIW R28,11
	RET
_dir_find_G101:
	CALL SUBOPT_0xEA
	CALL SUBOPT_0x134
	CALL SUBOPT_0x135
	BREQ _0x2020092
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20E001B
_0x2020092:
_0x2020094:
	CALL SUBOPT_0x136
	CALL SUBOPT_0x137
	BRNE _0x2020095
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	MOVW R26,R18
	LD   R16,X
	CPI  R16,0
	BRNE _0x2020097
	LDI  R17,LOW(4)
	RJMP _0x2020095
_0x2020097:
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x8)
	BRNE _0x2020099
	CALL SUBOPT_0x138
	RCALL _mem_cmp_G101
	SBIW R30,0
	BREQ _0x202009A
_0x2020099:
	RJMP _0x2020098
_0x202009A:
	RJMP _0x2020095
_0x2020098:
	CALL SUBOPT_0x134
	RCALL _dir_next_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x2020094
_0x2020095:
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20E001B
_dir_register_G101:
	CALL SUBOPT_0xEA
	CALL SUBOPT_0x134
	CALL SUBOPT_0x135
	BRNE _0x20200A7
_0x20200A9:
	CALL SUBOPT_0x136
	CALL SUBOPT_0x137
	BRNE _0x20200AA
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	LDD  R26,Z+18
	LDD  R27,Z+19
	LD   R16,X
	CPI  R16,229
	BREQ _0x20200AD
	CPI  R16,0
	BRNE _0x20200AC
_0x20200AD:
	RJMP _0x20200AA
_0x20200AC:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(1)
	RCALL _dir_next_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x20200A9
_0x20200AA:
_0x20200A7:
	CPI  R17,0
	BRNE _0x20200AF
	CALL SUBOPT_0x136
	CALL SUBOPT_0x137
	BRNE _0x20200B0
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	CALL SUBOPT_0x139
	LDI  R26,LOW(32)
	CALL SUBOPT_0x13A
	CALL SUBOPT_0x138
	RCALL _mem_cpy_G101
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,20
	CALL __GETW1P
	LDD  R30,Z+11
	ANDI R30,LOW(0x18)
	__PUTB1RNS 18,12
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL __GETW1P
	ADIW R30,4
	LDI  R26,LOW(1)
	STD  Z+0,R26
_0x20200B0:
_0x20200AF:
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20E001B
_create_name_G101:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,5
	CALL __SAVELOCR6
	LDD  R26,Y+13
	LDD  R27,Y+13+1
	ADIW R26,20
	LD   R20,X+
	LD   R21,X
	ST   -Y,R21
	ST   -Y,R20
	CALL SUBOPT_0x13B
	LDI  R30,LOW(0)
	STD  Y+8,R30
	STD  Y+8+1,R30
	MOV  R17,R30
	MOV  R18,R30
	LDI  R30,LOW(8)
	STD  Y+10,R30
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	CALL SUBOPT_0x13C
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CALL SUBOPT_0x81
	LD   R26,X
	CPI  R26,LOW(0x2E)
	BRNE _0x20200B3
_0x20200B5:
	CALL SUBOPT_0x13D
	LD   R16,X
	CPI  R16,46
	BRNE _0x20200B8
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,3
	BRLT _0x20200B7
_0x20200B8:
	RJMP _0x20200B6
_0x20200B7:
	CALL SUBOPT_0x13E
	RJMP _0x20200B5
_0x20200B6:
	CPI  R16,47
	BREQ _0x20200BB
	CPI  R16,92
	BREQ _0x20200BB
	CPI  R16,33
	BRSH _0x20200BC
_0x20200BB:
	RJMP _0x20200BA
_0x20200BC:
	LDI  R30,LOW(6)
	RJMP _0x20E001C
_0x20200BA:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CALL SUBOPT_0x77
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	ST   X+,R30
	ST   X,R31
	CPI  R16,33
	BRSH _0x20200BD
	LDI  R30,LOW(36)
	RJMP _0x20200BE
_0x20200BD:
	LDI  R30,LOW(32)
_0x20200BE:
	__PUTB1RNS 20,11
	RJMP _0x20E001D
_0x20200B3:
_0x20200C1:
	CALL SUBOPT_0x13D
	LD   R16,X
	CPI  R16,33
	BRLO _0x20200C4
	CPI  R16,47
	BREQ _0x20200C4
	CPI  R16,92
	BRNE _0x20200C3
_0x20200C4:
	RJMP _0x20200C2
_0x20200C3:
	CPI  R16,46
	BREQ _0x20200C7
	LDD  R30,Y+10
	CP   R18,R30
	BRLO _0x20200C6
_0x20200C7:
	LDD  R26,Y+10
	CPI  R26,LOW(0x8)
	BRNE _0x20200CA
	CPI  R16,46
	BREQ _0x20200C9
_0x20200CA:
	LDI  R30,LOW(6)
	RJMP _0x20E001C
_0x20200C9:
	LDI  R18,LOW(8)
	LDI  R30,LOW(11)
	STD  Y+10,R30
	LSL  R17
	LSL  R17
	RJMP _0x20200C0
_0x20200C6:
	CPI  R16,128
	BRLO _0x20200CC
	ORI  R17,LOW(3)
	LDI  R30,LOW(6)
	RJMP _0x20E001C
_0x20200CC:
	__POINTD1FN _k1,0
	CALL __PUTPARD1
	MOV  R26,R16
	CLR  R27
	RCALL _chk_chrf_G101
	SBIW R30,0
	BREQ _0x20200D2
	LDI  R30,LOW(6)
	RJMP _0x20E001C
_0x20200D2:
	CPI  R16,65
	BRLO _0x20200D4
	CPI  R16,91
	BRLO _0x20200D5
_0x20200D4:
	RJMP _0x20200D3
_0x20200D5:
	ORI  R17,LOW(2)
	RJMP _0x20200D6
_0x20200D3:
	CPI  R16,97
	BRLO _0x20200D8
	CPI  R16,123
	BRLO _0x20200D9
_0x20200D8:
	RJMP _0x20200D7
_0x20200D9:
	ORI  R17,LOW(1)
	SUBI R16,LOW(32)
_0x20200D7:
_0x20200D6:
	CALL SUBOPT_0x13E
_0x20200C0:
	RJMP _0x20200C1
_0x20200C2:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CALL SUBOPT_0x77
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	ST   X+,R30
	ST   X,R31
	CPI  R16,33
	BRSH _0x20200DA
	LDI  R30,LOW(4)
	RJMP _0x20200DB
_0x20200DA:
	LDI  R30,LOW(0)
_0x20200DB:
	MOV  R16,R30
	CPI  R18,0
	BRNE _0x20200DD
	LDI  R30,LOW(6)
	RJMP _0x20E001C
_0x20200DD:
	MOVW R26,R20
	LD   R26,X
	CPI  R26,LOW(0xE5)
	BRNE _0x20200DE
	MOVW R26,R20
	LDI  R30,LOW(5)
	ST   X,R30
_0x20200DE:
	LDD  R26,Y+10
	CPI  R26,LOW(0x8)
	BRNE _0x20200DF
	LSL  R17
	LSL  R17
_0x20200DF:
	MOV  R30,R17
	ANDI R30,LOW(0x3)
	CPI  R30,LOW(0x1)
	BRNE _0x20200E0
	ORI  R16,LOW(16)
_0x20200E0:
	MOV  R30,R17
	ANDI R30,LOW(0xC)
	CPI  R30,LOW(0x4)
	BRNE _0x20200E1
	ORI  R16,LOW(8)
_0x20200E1:
	MOVW R30,R20
	__PUTBZR 16,11
_0x20E001D:
	LDI  R30,LOW(0)
_0x20E001C:
	CALL __LOADLOCR6
	ADIW R28,15
	RET
_follow_path_G101:
	CALL SUBOPT_0xEA
_0x20200F7:
	LDI  R30,LOW(1)
	CPI  R30,0
	BREQ _0x20200FA
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x20)
	BREQ _0x20200FB
_0x20200FA:
	RJMP _0x20200F9
_0x20200FB:
	CALL SUBOPT_0xAB
	RJMP _0x20200F7
_0x20200F9:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x2F)
	BREQ _0x20200FD
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x5C)
	BRNE _0x20200FC
_0x20200FD:
	CALL SUBOPT_0xAB
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,6
	CALL SUBOPT_0x104
	RJMP _0x20200FF
_0x20200FC:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL __GETW1P
	ADIW R30,22
	MOVW R26,R30
	CALL __GETD1P
	CALL SUBOPT_0x140
_0x20200FF:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CLR  R27
	SBIW R26,32
	BRSH _0x2020100
	CALL SUBOPT_0x74
	CALL SUBOPT_0x141
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,18
	CALL SUBOPT_0xB1
	RJMP _0x2020101
_0x2020100:
_0x2020103:
	CALL SUBOPT_0x74
	MOVW R26,R28
	ADIW R26,6
	RCALL _create_name_G101
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x2020104
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	RCALL _dir_find_G101
	MOV  R17,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,20
	CALL __GETW1P
	LDD  R30,Z+11
	ANDI R30,LOW(0x4)
	MOV  R16,R30
	CPI  R17,0
	BREQ _0x2020106
	CPI  R17,4
	BRNE _0x2020108
	CPI  R16,0
	BREQ _0x2020109
_0x2020108:
	RJMP _0x2020107
_0x2020109:
	LDI  R17,LOW(5)
_0x2020107:
	RJMP _0x2020104
_0x2020106:
	CPI  R16,0
	BRNE _0x2020104
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BRNE _0x202010B
	LDI  R17,LOW(5)
	RJMP _0x2020104
_0x202010B:
	CALL SUBOPT_0x142
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x143
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x144
	CALL SUBOPT_0x140
	RJMP _0x2020103
_0x2020104:
_0x2020101:
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,8
	RET
_check_fs_G101:
	CALL __PUTPARD2
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	__GETD1S 3
	CALL SUBOPT_0x145
	BREQ _0x202010C
	LDI  R30,LOW(3)
	RJMP _0x20E001B
_0x202010C:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x146
	BREQ _0x202010D
	LDI  R30,LOW(2)
	RJMP _0x20E001B
_0x202010D:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	SUBI R26,LOW(-104)
	SBCI R27,HIGH(-104)
	CALL SUBOPT_0x147
	BRNE _0x202010E
	LDI  R30,LOW(0)
	RJMP _0x20E001B
_0x202010E:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,50
	SUBI R30,LOW(-82)
	SBCI R31,HIGH(-82)
	MOVW R26,R30
	CALL SUBOPT_0x147
	BRNE _0x202010F
	LDI  R30,LOW(0)
	RJMP _0x20E001B
_0x202010F:
	LDI  R30,LOW(1)
_0x20E001B:
	ADIW R28,6
	RET
_chk_mounted:
	ST   -Y,R26
	SBIW R28,20
	CALL __SAVELOCR6
	LDD  R26,Y+29
	LDD  R27,Y+29+1
	CALL __GETW1P
	STD  Y+8,R30
	STD  Y+8+1,R31
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LD   R30,X
	SUBI R30,LOW(48)
	MOV  R16,R30
	CPI  R16,10
	BRSH _0x2020111
	ADIW R26,1
	LD   R26,X
	CPI  R26,LOW(0x3A)
	BREQ _0x2020112
_0x2020111:
	RJMP _0x2020110
_0x2020112:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,2
	STD  Y+8,R30
	STD  Y+8+1,R31
	LDD  R26,Y+29
	LDD  R27,Y+29+1
	ST   X+,R30
	ST   X,R31
	RJMP _0x2020113
_0x2020110:
	LDS  R16,_Drive_G101
_0x2020113:
	CPI  R16,1
	BRLO _0x2020114
	LDI  R30,LOW(11)
	RJMP _0x20E0019
_0x2020114:
	MOV  R30,R16
	CALL SUBOPT_0x148
	CALL SUBOPT_0xB7
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+27
	LDD  R27,Y+27+1
	ST   X+,R30
	ST   X,R31
	SBIW R30,0
	BRNE _0x2020115
	LDI  R30,LOW(12)
	RJMP _0x20E0019
_0x2020115:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R30,X
	CPI  R30,0
	BREQ _0x2020116
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+1
	CALL _disk_status
	MOV  R21,R30
	SBRC R21,0
	RJMP _0x2020117
	LDD  R30,Y+26
	CPI  R30,0
	BREQ _0x2020119
	SBRC R21,2
	RJMP _0x202011A
_0x2020119:
	RJMP _0x2020118
_0x202011A:
	LDI  R30,LOW(10)
	RJMP _0x20E0019
_0x2020118:
	RJMP _0x20E001A
_0x2020117:
_0x2020116:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
	MOV  R30,R16
	__PUTB1SNS 6,1
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+1
	CALL _disk_initialize
	MOV  R21,R30
	SBRS R21,0
	RJMP _0x202011B
	LDI  R30,LOW(3)
	RJMP _0x20E0019
_0x202011B:
	LDD  R30,Y+26
	CPI  R30,0
	BREQ _0x202011D
	SBRC R21,2
	RJMP _0x202011E
_0x202011D:
	RJMP _0x202011C
_0x202011E:
	LDI  R30,LOW(10)
	RJMP _0x20E0019
_0x202011C:
	CALL SUBOPT_0x74
	CALL SUBOPT_0x23
	__PUTD1S 24
	MOVW R26,R30
	MOVW R24,R22
	RCALL _check_fs_G101
	MOV  R17,R30
	CPI  R17,1
	BRNE _0x202011F
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-446)
	SBCI R31,HIGH(-446)
	MOVW R18,R30
	MOVW R30,R18
	LDD  R30,Z+4
	CPI  R30,0
	BREQ _0x2020120
	MOVW R26,R18
	ADIW R26,8
	CALL __GETD1P
	CALL SUBOPT_0x4B
	CALL SUBOPT_0x74
	__GETD2S 24
	RCALL _check_fs_G101
	MOV  R17,R30
_0x2020120:
_0x202011F:
	CPI  R17,3
	BRNE _0x2020121
	LDI  R30,LOW(1)
	RJMP _0x20E0019
_0x2020121:
	CPI  R17,0
	BRNE _0x2020123
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,61
	CALL __GETW1P
	CPI  R30,LOW(0x200)
	LDI  R26,HIGH(0x200)
	CPC  R31,R26
	BREQ _0x2020122
_0x2020123:
	LDI  R30,LOW(13)
	RJMP _0x20E0019
_0x2020122:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-72)
	SBCI R27,HIGH(-72)
	CALL SUBOPT_0x112
	CALL SUBOPT_0x149
	CALL SUBOPT_0x51
	CALL __CPD10
	BRNE _0x2020125
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-86)
	SBCI R27,HIGH(-86)
	CALL __GETD1P
	CALL SUBOPT_0x149
_0x2020125:
	CALL SUBOPT_0x51
	__PUTD1SNS 6,26
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SUBI R30,LOW(-66)
	SBCI R31,HIGH(-66)
	LD   R30,Z
	__PUTB1SNS 6,3
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R30,Z+3
	LDI  R31,0
	CALL SUBOPT_0x125
	CALL SUBOPT_0x67
	CALL SUBOPT_0x149
	CALL SUBOPT_0x14A
	CALL SUBOPT_0x4F
	CALL SUBOPT_0x12E
	__PUTD1SNS 6,34
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R30,Z+63
	__PUTB1SNS 6,2
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-67)
	SBCI R27,HIGH(-67)
	CALL __GETW1P
	__PUTW1SNS 6,8
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-69)
	SBCI R27,HIGH(-69)
	CALL SUBOPT_0x112
	CALL SUBOPT_0x14B
	CALL SUBOPT_0x52
	CALL __CPD10
	BRNE _0x2020126
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-82)
	SBCI R27,HIGH(-82)
	CALL __GETD1P
	CALL SUBOPT_0x14B
_0x2020126:
	CALL SUBOPT_0x14A
	CALL SUBOPT_0x115
	CLR  R22
	CLR  R23
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x125
	CALL __SUBD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x14C
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CLR  R22
	CLR  R23
	CALL __SUBD21
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x65
	CALL __CWD1
	CALL __DIVD21U
	__ADDD1N 2
	__PUTD1S 10
	__PUTD1SNS 6,30
	LDI  R17,LOW(1)
	CALL SUBOPT_0x10E
	__CPD2N 0xFF7
	BRLO _0x2020127
	LDI  R17,LOW(2)
_0x2020127:
	CALL SUBOPT_0x10E
	__CPD2N 0xFFF7
	BRLO _0x2020128
	LDI  R17,LOW(3)
_0x2020128:
	CPI  R17,3
	BRNE _0x2020129
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-94)
	SBCI R27,HIGH(-94)
	CALL __GETD1P
	RJMP _0x202022D
_0x2020129:
	CALL SUBOPT_0x14D
_0x202022D:
	__PUTD1SNS 6,38
	CALL SUBOPT_0x14D
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x14C
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x12E
	__PUTD1SNS 6,42
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,14
	CALL SUBOPT_0x1D
	CALL __PUTDP1
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,4
	LDI  R30,LOW(0)
	ST   X,R30
	CPI  R17,3
	BREQ PC+3
	JMP _0x202012B
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,5
	ST   X,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-98)
	SBCI R27,HIGH(-98)
	CALL __GETW1P
	CALL SUBOPT_0x4F
	CALL SUBOPT_0x12E
	__PUTD1SNS 6,18
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	CALL SUBOPT_0x108
	CALL _disk_read
	CPI  R30,0
	BRNE _0x202012D
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x146
	BRNE _0x202012D
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,50
	CALL __GETD1P
	__CPD1N 0x41615252
	BRNE _0x202012D
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-484)
	SBCI R31,HIGH(-484)
	MOVW R26,R30
	CALL __GETD1P
	__CPD1N 0x61417272
	BREQ _0x202012E
_0x202012D:
	RJMP _0x202012C
_0x202012E:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-492)
	SBCI R31,HIGH(-492)
	MOVW R26,R30
	CALL __GETD1P
	__PUTD1SNS 6,10
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-488)
	SBCI R31,HIGH(-488)
	MOVW R26,R30
	CALL __GETD1P
	__PUTD1SNS 6,14
_0x202012C:
_0x202012B:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ST   X,R17
	ADIW R26,46
	CALL SUBOPT_0x104
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,22
	CALL SUBOPT_0x104
	LDI  R26,LOW(_Fsid_G101)
	LDI  R27,HIGH(_Fsid_G101)
	CALL SUBOPT_0x11
	__PUTW1SNS 6,6
_0x20E001A:
	LDI  R30,LOW(0)
_0x20E0019:
	CALL __LOADLOCR6
	ADIW R28,31
	RET
_validate_G101:
	ST   -Y,R27
	ST   -Y,R26
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,0
	BREQ _0x2020130
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LD   R30,X
	CPI  R30,0
	BREQ _0x2020130
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	LDD  R26,Z+6
	LDD  R27,Z+7
	LD   R30,Y
	LDD  R31,Y+1
	CP   R30,R26
	CPC  R31,R27
	BREQ _0x202012F
_0x2020130:
	LDI  R30,LOW(9)
	RJMP _0x20E0018
_0x202012F:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	LDD  R26,Z+1
	CALL _disk_status
	ANDI R30,LOW(0x1)
	BREQ _0x2020132
	LDI  R30,LOW(3)
	RJMP _0x20E0018
_0x2020132:
	LDI  R30,LOW(0)
_0x20E0018:
	ADIW R28,4
	RET
_f_mount:
	CALL SUBOPT_0x13
	LDD  R26,Y+4
	CPI  R26,LOW(0x1)
	BRLO _0x2020133
	LDI  R30,LOW(11)
	RJMP _0x20E0017
_0x2020133:
	LDD  R30,Y+4
	CALL SUBOPT_0x148
	LSL  R30
	ROL  R31
	ADD  R26,R30
	ADC  R27,R31
	LD   R16,X+
	LD   R17,X
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x2020134
	MOVW R26,R16
	LDI  R30,LOW(0)
	ST   X,R30
_0x2020134:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,0
	BREQ _0x2020135
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(0)
	ST   X,R30
_0x2020135:
	LDD  R30,Y+4
	CALL SUBOPT_0x148
	CALL SUBOPT_0xB2
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	STD  Z+0,R26
	STD  Z+1,R27
	LDI  R30,LOW(0)
_0x20E0017:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,5
	RET
_f_open:
	ST   -Y,R26
	SBIW R28,34
	CALL __SAVELOCR4
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	CALL SUBOPT_0xB1
	LDD  R30,Y+38
	ANDI R30,LOW(0x1F)
	STD  Y+38,R30
	MOVW R30,R28
	ADIW R30,39
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xF2
	LDD  R30,Y+42
	ANDI R30,LOW(0x1E)
	MOV  R26,R30
	CALL SUBOPT_0x14E
	BREQ _0x2020136
	MOV  R30,R17
	RJMP _0x20E0016
_0x2020136:
	CALL SUBOPT_0x14F
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	RCALL _follow_path_G101
	MOV  R17,R30
	LDD  R30,Y+38
	ANDI R30,LOW(0x1C)
	BRNE PC+3
	JMP _0x2020137
	SBIW R28,8
	CPI  R17,0
	BREQ _0x2020138
	CPI  R17,4
	BRNE _0x2020139
	MOVW R26,R28
	ADIW R26,24
	RCALL _dir_register_G101
	MOV  R17,R30
_0x2020139:
	CPI  R17,0
	BREQ _0x202013A
	MOV  R30,R17
	ADIW R28,8
	RJMP _0x20E0016
_0x202013A:
	LDD  R30,Y+46
	ORI  R30,8
	STD  Y+46,R30
	__GETWRS 18,19,42
	RJMP _0x202013B
_0x2020138:
	LDD  R30,Y+46
	ANDI R30,LOW(0x4)
	BREQ _0x202013C
	LDI  R30,LOW(8)
	ADIW R28,8
	RJMP _0x20E0016
_0x202013C:
	__GETWRS 18,19,42
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x202013E
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x11)
	BREQ _0x202013D
_0x202013E:
	LDI  R30,LOW(7)
	ADIW R28,8
	RJMP _0x20E0016
_0x202013D:
	LDD  R30,Y+46
	ANDI R30,LOW(0x8)
	BRNE PC+3
	JMP _0x2020140
	CALL SUBOPT_0x142
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x143
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x144
	CALL SUBOPT_0x1E
	MOVW R30,R18
	ADIW R30,20
	CALL SUBOPT_0xA7
	MOVW R30,R18
	ADIW R30,26
	CALL SUBOPT_0xA7
	MOVW R30,R18
	ADIW R30,28
	CALL SUBOPT_0x120
	CALL SUBOPT_0x11B
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	ADIW R26,46
	CALL SUBOPT_0x10B
	CALL SUBOPT_0x1A
	CALL __CPD10
	BREQ _0x2020141
	CALL SUBOPT_0x150
	CALL SUBOPT_0x3F
	RCALL _remove_chain_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x2020142
	MOV  R30,R17
	ADIW R28,8
	RJMP _0x20E0016
_0x2020142:
	CALL SUBOPT_0x1A
	CALL SUBOPT_0x151
	__PUTD1SNS 24,10
_0x2020141:
	CALL SUBOPT_0x150
	CALL SUBOPT_0x3C
	CALL SUBOPT_0x103
	BREQ _0x2020143
	MOV  R30,R17
	ADIW R28,8
	RJMP _0x20E0016
_0x2020143:
_0x2020140:
_0x202013B:
	LDD  R30,Y+46
	ANDI R30,LOW(0x8)
	BREQ _0x2020144
	MOVW R30,R18
	ADIW R30,11
	LDI  R26,LOW(0)
	STD  Z+0,R26
	CALL SUBOPT_0x152
	__PUTD1RNS 18,14
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	LDD  R30,Y+46
	ORI  R30,0x20
	STD  Y+46,R30
_0x2020144:
	ADIW R28,8
	RJMP _0x2020145
_0x2020137:
	CPI  R17,0
	BREQ _0x2020146
	MOV  R30,R17
	RJMP _0x20E0016
_0x2020146:
	__GETWRS 18,19,34
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x2020148
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BREQ _0x2020147
_0x2020148:
	LDI  R30,LOW(4)
	RJMP _0x20E0016
_0x2020147:
	LDD  R30,Y+38
	ANDI R30,LOW(0x2)
	BREQ _0x202014B
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x1)
	BRNE _0x202014C
_0x202014B:
	RJMP _0x202014A
_0x202014C:
	LDI  R30,LOW(7)
	RJMP _0x20E0016
_0x202014A:
_0x2020145:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,46
	CALL __GETD1P
	__PUTD1SNS 41,26
	LDD  R30,Y+34
	LDD  R31,Y+34+1
	__PUTW1SNS 41,30
	LDD  R30,Y+38
	__PUTB1SNS 41,4
	CALL SUBOPT_0x142
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x143
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x144
	__PUTD1SNS 41,14
	MOVW R26,R18
	ADIW R26,28
	CALL __GETD1P
	__PUTD1SNS 41,10
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ADIW R26,6
	CALL SUBOPT_0x104
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ADIW R26,5
	LDI  R30,LOW(255)
	ST   X,R30
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ADIW R26,22
	CALL SUBOPT_0x104
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ST   X+,R30
	ST   X,R31
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,6
	CALL __GETW1P
	__PUTW1SNS 41,2
	LDI  R30,LOW(0)
_0x20E0016:
	CALL __LOADLOCR4
	ADIW R28,43
	RET
_f_read:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,14
	CALL __SAVELOCR6
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	CALL SUBOPT_0xB1
	CALL SUBOPT_0x153
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	CALL SUBOPT_0x154
	BREQ _0x202014D
	MOV  R30,R17
	RJMP _0x20E0015
_0x202014D:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x80)
	BREQ _0x202014E
	LDI  R30,LOW(2)
	RJMP _0x20E0015
_0x202014E:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x1)
	BRNE _0x202014F
	LDI  R30,LOW(7)
	RJMP _0x20E0015
_0x202014F:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	CALL SUBOPT_0xE6
	PUSH R25
	PUSH R24
	PUSH R27
	PUSH R26
	CALL SUBOPT_0x155
	POP  R30
	POP  R31
	POP  R22
	POP  R23
	CALL __SUBD12
	CALL SUBOPT_0x54
	CALL SUBOPT_0x58
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CLR  R24
	CLR  R25
	CALL __CPD12
	BRSH _0x2020150
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	STD  Y+22,R30
	STD  Y+22+1,R31
_0x2020150:
_0x2020152:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	SBIW R30,0
	BRNE PC+3
	JMP _0x2020153
	CALL SUBOPT_0x155
	CALL SUBOPT_0x156
	BREQ PC+3
	JMP _0x2020154
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	LDD  R0,Z+5
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	CALL __GETW1P
	LDD  R30,Z+2
	CP   R0,R30
	BRLO _0x2020155
	CALL SUBOPT_0x155
	CALL __CPD02
	BRNE _0x2020156
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	ADIW R26,14
	CALL __GETD1P
	RJMP _0x2020157
_0x2020156:
	CALL SUBOPT_0x153
	CALL SUBOPT_0x157
	CALL _get_fat
_0x2020157:
	CALL SUBOPT_0x158
	CALL SUBOPT_0x118
	CALL SUBOPT_0x109
	BRSH _0x2020159
	CALL SUBOPT_0x159
	LDI  R30,LOW(2)
	RJMP _0x20E0015
_0x2020159:
	CALL SUBOPT_0x118
	CALL SUBOPT_0x5E
	BRNE _0x202015A
	CALL SUBOPT_0x159
	LDI  R30,LOW(1)
	RJMP _0x20E0015
_0x202015A:
	CALL SUBOPT_0x123
	__PUTD1SNS 26,18
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	ADIW R26,5
	LDI  R30,LOW(0)
	ST   X,R30
_0x2020155:
	CALL SUBOPT_0x153
	CALL SUBOPT_0x157
	RCALL _clust2sect
	CALL SUBOPT_0x15A
	CALL SUBOPT_0x129
	BRNE _0x202015B
	CALL SUBOPT_0x159
	LDI  R30,LOW(2)
	RJMP _0x20E0015
_0x202015B:
	CALL SUBOPT_0x15B
	CALL SUBOPT_0x57
	CALL SUBOPT_0x37
	CALL SUBOPT_0x15A
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x15C
	BRNE PC+3
	JMP _0x202015C
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	LDD  R30,Z+5
	CALL SUBOPT_0x13F
	MOVW R0,R30
	CALL SUBOPT_0x15D
	CALL SUBOPT_0x15E
	BRSH _0x202015D
	CALL SUBOPT_0x15D
	CALL SUBOPT_0x65
	MOVW R26,R30
	CALL SUBOPT_0x15B
	SUB  R26,R30
	SBC  R27,R31
	MOVW R20,R26
_0x202015D:
	CALL SUBOPT_0x15D
	CALL SUBOPT_0x15F
	__GETD1S 15
	CALL __PUTPARD1
	MOV  R26,R20
	CALL _disk_read
	CPI  R30,0
	BREQ _0x202015E
	CALL SUBOPT_0x159
	LDI  R30,LOW(1)
	RJMP _0x20E0015
_0x202015E:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x2020160
	CALL SUBOPT_0x160
	CALL SUBOPT_0x161
	BRLO _0x2020161
_0x2020160:
	RJMP _0x202015F
_0x2020161:
	CALL SUBOPT_0x160
	CALL SUBOPT_0x162
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CLR  R24
	CLR  R25
	CALL SUBOPT_0xDA
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	CALL _mem_cpy_G101
_0x202015F:
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	CALL SUBOPT_0x163
	RJMP _0x2020151
_0x202015C:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x2020162
	CALL SUBOPT_0x15D
	CALL SUBOPT_0x164
	LDD  R30,Y+29
	LDD  R31,Y+29+1
	CALL SUBOPT_0x165
	BREQ _0x2020163
	CALL SUBOPT_0x159
	LDI  R30,LOW(1)
	RJMP _0x20E0015
_0x2020163:
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	CALL SUBOPT_0x166
_0x2020162:
	CALL SUBOPT_0x160
	CALL __CPD12
	BREQ _0x2020164
	CALL SUBOPT_0x15D
	CALL SUBOPT_0x164
	__GETD1S 15
	CALL SUBOPT_0x145
	BREQ _0x2020165
	CALL SUBOPT_0x159
	LDI  R30,LOW(1)
	RJMP _0x20E0015
_0x2020165:
_0x2020164:
	CALL SUBOPT_0x55
	__PUTD1SNS 26,22
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	CALL SUBOPT_0x167
_0x2020154:
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	CALL SUBOPT_0x168
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	SUB  R26,R30
	SBC  R27,R31
	MOVW R18,R26
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	CP   R30,R18
	CPC  R31,R19
	BRSH _0x2020166
	__GETWRS 18,19,22
_0x2020166:
	CALL SUBOPT_0x74
	LDD  R26,Y+28
	LDD  R27,Y+28+1
	CALL SUBOPT_0x168
	LDD  R26,Y+28
	LDD  R27,Y+28+1
	ADIW R26,32
	CALL SUBOPT_0xDA
	MOVW R26,R18
	CALL _mem_cpy_G101
_0x2020151:
	MOVW R30,R18
	CALL SUBOPT_0x77
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	CALL SUBOPT_0x169
	MOVW R26,R0
	CALL __PUTDP1
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	CALL SUBOPT_0x16A
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	SUB  R30,R18
	SBC  R31,R19
	STD  Y+22,R30
	STD  Y+22+1,R31
	RJMP _0x2020152
_0x2020153:
	LDI  R30,LOW(0)
_0x20E0015:
	CALL __LOADLOCR6
	ADIW R28,28
	RET
_f_write:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,10
	CALL __SAVELOCR6
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	CALL SUBOPT_0xB1
	CALL SUBOPT_0x16B
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	CALL SUBOPT_0x154
	BREQ _0x2020167
	MOV  R30,R17
	RJMP _0x20E0014
_0x2020167:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x80)
	BREQ _0x2020168
	LDI  R30,LOW(2)
	RJMP _0x20E0014
_0x2020168:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x2)
	BRNE _0x2020169
	LDI  R30,LOW(7)
	RJMP _0x20E0014
_0x2020169:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	CALL SUBOPT_0xE6
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CALL SUBOPT_0x12E
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x16C
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD21
	BRSH _0x202016A
	LDI  R30,LOW(0)
	STD  Y+18,R30
	STD  Y+18+1,R30
_0x202016A:
_0x202016C:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	SBIW R30,0
	BRNE PC+3
	JMP _0x202016D
	CALL SUBOPT_0x16D
	CALL SUBOPT_0x156
	BREQ PC+3
	JMP _0x202016E
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R0,Z+5
	CALL SUBOPT_0x16E
	LDD  R30,Z+2
	CP   R0,R30
	BRSH PC+3
	JMP _0x202016F
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,6
	CALL SUBOPT_0x130
	BRNE _0x2020170
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,14
	CALL __GETD1P
	CALL SUBOPT_0x15A
	CALL SUBOPT_0x129
	BRNE _0x2020171
	CALL SUBOPT_0x16B
	CALL SUBOPT_0x120
	CALL SUBOPT_0x16F
	__PUTD1SNS 22,14
_0x2020171:
	RJMP _0x2020172
_0x2020170:
	CALL SUBOPT_0x16B
	CALL SUBOPT_0x170
	CALL SUBOPT_0x16F
_0x2020172:
	CALL SUBOPT_0x129
	BRNE _0x2020173
	RJMP _0x202016D
_0x2020173:
	CALL SUBOPT_0x12B
	BRNE _0x2020174
	CALL SUBOPT_0x171
	LDI  R30,LOW(2)
	RJMP _0x20E0014
_0x2020174:
	CALL SUBOPT_0x12A
	BRNE _0x2020175
	CALL SUBOPT_0x171
	LDI  R30,LOW(1)
	RJMP _0x20E0014
_0x2020175:
	CALL SUBOPT_0x55
	__PUTD1SNS 22,18
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,5
	LDI  R30,LOW(0)
	ST   X,R30
_0x202016F:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x2020176
	CALL SUBOPT_0x16E
	CALL SUBOPT_0x172
	LDD  R30,Y+25
	LDD  R31,Y+25+1
	CALL SUBOPT_0x165
	BREQ _0x2020177
	CALL SUBOPT_0x171
	LDI  R30,LOW(1)
	RJMP _0x20E0014
_0x2020177:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x166
_0x2020176:
	CALL SUBOPT_0x16B
	CALL SUBOPT_0x170
	CALL _clust2sect
	CALL SUBOPT_0x54
	CALL SUBOPT_0x58
	CALL __CPD10
	BRNE _0x2020178
	CALL SUBOPT_0x171
	LDI  R30,LOW(2)
	RJMP _0x20E0014
_0x2020178:
	CALL SUBOPT_0x173
	CALL SUBOPT_0x56
	CALL SUBOPT_0x37
	CALL SUBOPT_0x54
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL SUBOPT_0x15C
	BRNE PC+3
	JMP _0x2020179
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R30,Z+5
	CALL SUBOPT_0x13F
	MOVW R0,R30
	CALL SUBOPT_0x16E
	CALL SUBOPT_0x15E
	BRSH _0x202017A
	CALL SUBOPT_0x16E
	CALL SUBOPT_0x65
	MOVW R26,R30
	CALL SUBOPT_0x173
	SUB  R26,R30
	SBC  R27,R31
	MOVW R20,R26
_0x202017A:
	CALL SUBOPT_0x16E
	CALL SUBOPT_0x15F
	__GETD1S 11
	CALL __PUTPARD1
	MOV  R26,R20
	CALL _disk_write
	CPI  R30,0
	BREQ _0x202017B
	CALL SUBOPT_0x171
	LDI  R30,LOW(1)
	RJMP _0x20E0014
_0x202017B:
	CALL SUBOPT_0x174
	CALL SUBOPT_0x161
	BRSH _0x202017C
	CALL SUBOPT_0x175
	__GETD2Z 22
	CALL SUBOPT_0x53
	CALL SUBOPT_0x162
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CLR  R24
	CLR  R25
	CALL SUBOPT_0xDA
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	CALL _mem_cpy_G101
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x166
_0x202017C:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x163
	RJMP _0x202016B
_0x2020179:
	CALL SUBOPT_0x174
	CALL __CPD12
	BREQ _0x202017D
	CALL SUBOPT_0x16D
	MOVW R0,R26
	CALL SUBOPT_0x16C
	MOVW R26,R0
	CALL __CPD21
	BRSH _0x202017F
	CALL SUBOPT_0x16E
	CALL SUBOPT_0x172
	__GETD1S 11
	CALL SUBOPT_0x145
	BRNE _0x2020180
_0x202017F:
	RJMP _0x202017E
_0x2020180:
	CALL SUBOPT_0x171
	LDI  R30,LOW(1)
	RJMP _0x20E0014
_0x202017E:
_0x202017D:
	CALL SUBOPT_0x58
	__PUTD1SNS 22,22
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x167
_0x202016E:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x168
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	SUB  R26,R30
	SBC  R27,R31
	MOVW R18,R26
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CP   R30,R18
	CPC  R31,R19
	BRSH _0x2020181
	__GETWRS 18,19,18
_0x2020181:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL SUBOPT_0x168
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,32
	CALL SUBOPT_0xDA
	CALL SUBOPT_0xD7
	MOVW R26,R18
	CALL _mem_cpy_G101
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x40
	ST   X,R30
_0x202016B:
	MOVW R30,R18
	CALL SUBOPT_0x77
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	CALL SUBOPT_0x169
	MOVW R26,R0
	CALL __PUTDP1
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	CALL SUBOPT_0x16A
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	SUB  R30,R18
	SBC  R31,R19
	STD  Y+18,R30
	STD  Y+18+1,R31
	RJMP _0x202016C
_0x202016D:
	CALL SUBOPT_0x16D
	MOVW R0,R26
	CALL SUBOPT_0x16C
	MOVW R26,R0
	CALL __CPD12
	BRSH _0x2020182
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,6
	CALL __GETD1P
	__PUTD1SNS 22,10
_0x2020182:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x20
	ST   X,R30
	LDI  R30,LOW(0)
_0x20E0014:
	CALL __LOADLOCR6
	ADIW R28,24
	RET
_f_sync:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
	CALL SUBOPT_0xA2
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL SUBOPT_0x154
	BREQ PC+3
	JMP _0x2020183
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x20)
	BRNE PC+3
	JMP _0x2020184
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x2020185
	CALL SUBOPT_0xA2
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+11
	LDD  R31,Y+11+1
	CALL SUBOPT_0x165
	BREQ _0x2020186
	LDI  R30,LOW(1)
	RJMP _0x20E0013
_0x2020186:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL SUBOPT_0x166
_0x2020185:
	CALL SUBOPT_0xA2
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	__GETD2Z 26
	CALL SUBOPT_0x103
	BRNE _0x2020187
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,30
	LD   R18,X+
	LD   R19,X
	MOVW R26,R18
	ADIW R26,11
	LD   R30,X
	ORI  R30,0x20
	ST   X,R30
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,10
	CALL __GETD1P
	__PUTD1RNS 18,28
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,14
	CALL __GETW1P
	CALL SUBOPT_0x176
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	__GETD2Z 14
	MOVW R30,R26
	MOVW R22,R24
	CALL __LSRD16
	CALL SUBOPT_0x177
	CALL SUBOPT_0x152
	CALL SUBOPT_0x178
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,4
	LD   R30,X
	ANDI R30,0xDF
	ST   X,R30
	CALL SUBOPT_0xA2
	ADIW R30,4
	LDI  R26,LOW(1)
	STD  Z+0,R26
	CALL SUBOPT_0xA2
	MOVW R26,R30
	CALL _sync_G101
	MOV  R17,R30
_0x2020187:
_0x2020184:
_0x2020183:
	MOV  R30,R17
_0x20E0013:
	CALL __LOADLOCR4
	ADIW R28,10
	RET
_f_close:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	RCALL _f_sync
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x2020188
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CALL SUBOPT_0xB1
_0x2020188:
	MOV  R30,R17
	JMP  _0x20E000D
_f_chdir:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,34
	CALL __SAVELOCR4
	MOVW R30,R28
	ADIW R30,38
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xF2
	LDI  R26,LOW(0)
	CALL SUBOPT_0x14E
	BRNE _0x202018A
	CALL SUBOPT_0x14F
	LDD  R26,Y+40
	LDD  R27,Y+40+1
	CALL SUBOPT_0x179
	BRNE _0x202018B
	__GETWRS 18,19,34
	MOV  R0,R18
	OR   R0,R19
	BRNE _0x202018C
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,22
	CALL SUBOPT_0x104
	RJMP _0x202018D
_0x202018C:
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BREQ _0x202018E
	CALL SUBOPT_0x142
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x143
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x144
	__PUTD1SNS 16,22
	RJMP _0x202018F
_0x202018E:
	LDI  R17,LOW(5)
_0x202018F:
_0x202018D:
_0x202018B:
	CPI  R17,4
	BRNE _0x2020190
	LDI  R17,LOW(5)
_0x2020190:
_0x202018A:
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,40
	RET
_f_lseek:
	CALL __PUTPARD2
	SBIW R28,16
	ST   -Y,R17
	CALL SUBOPT_0x17A
	LDD  R30,Y+23
	LDD  R31,Y+23+1
	CALL SUBOPT_0x154
	BREQ _0x2020191
	RJMP _0x20E0012
_0x2020191:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x80)
	BREQ _0x2020192
	LDI  R30,LOW(2)
	RJMP _0x20E0011
_0x2020192:
	CALL SUBOPT_0x17B
	CALL SUBOPT_0x17C
	CALL __CPD12
	BRSH _0x2020194
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x2)
	BREQ _0x2020195
_0x2020194:
	RJMP _0x2020193
_0x2020195:
	CALL SUBOPT_0x17B
	CALL SUBOPT_0x17D
_0x2020193:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,6
	CALL SUBOPT_0xFD
	CALL SUBOPT_0x23
	CALL SUBOPT_0x122
	CALL SUBOPT_0x17E
	ADIW R26,5
	LDI  R30,LOW(255)
	ST   X,R30
	CALL SUBOPT_0x17C
	CALL __CPD02
	BRLO PC+3
	JMP _0x2020196
	CALL SUBOPT_0x17F
	CALL SUBOPT_0x65
	CALL __CWD1
	__GETD2N 0x200
	CALL __MULD12U
	CALL SUBOPT_0x180
	CALL SUBOPT_0x66
	CALL __CPD02
	BRSH _0x2020198
	CALL SUBOPT_0x181
	CALL SUBOPT_0x182
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x11E
	CALL SUBOPT_0x182
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD21
	BRSH _0x2020199
_0x2020198:
	RJMP _0x2020197
_0x2020199:
	CALL SUBOPT_0x11E
	CALL SUBOPT_0x151
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0x183
	CALL SUBOPT_0x151
	CALL __COMD1
	CALL __ANDD12
	CALL SUBOPT_0x17E
	ADIW R26,6
	CALL __GETD1P
	CALL SUBOPT_0x17C
	CALL __SUBD21
	__PUTD2S 17
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,18
	CALL SUBOPT_0x184
	RJMP _0x202019A
_0x2020197:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,14
	CALL SUBOPT_0x184
	CALL SUBOPT_0x185
	CALL __CPD10
	BRNE _0x202019B
	CALL SUBOPT_0x17A
	CALL SUBOPT_0x120
	CALL SUBOPT_0x186
	CALL SUBOPT_0x187
	CALL SUBOPT_0x11F
	BRNE _0x202019C
	CALL SUBOPT_0x188
	LDI  R30,LOW(2)
	RJMP _0x20E0011
_0x202019C:
	CALL SUBOPT_0x187
	CALL SUBOPT_0x5E
	BRNE _0x202019D
	CALL SUBOPT_0x188
	LDI  R30,LOW(1)
	RJMP _0x20E0011
_0x202019D:
	CALL SUBOPT_0x185
	__PUTD1SNS 21,14
_0x202019B:
	CALL SUBOPT_0x189
_0x202019A:
	CALL SUBOPT_0x185
	CALL __CPD10
	BRNE PC+3
	JMP _0x202019E
_0x202019F:
	CALL SUBOPT_0x183
	CALL SUBOPT_0x17C
	CALL __CPD12
	BRLO PC+3
	JMP _0x20201A1
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x2)
	BREQ _0x20201A2
	CALL SUBOPT_0x17A
	CALL SUBOPT_0x18A
	CALL SUBOPT_0x186
	CALL SUBOPT_0x185
	CALL __CPD10
	BRNE _0x20201A3
	CALL SUBOPT_0x183
	CALL SUBOPT_0x17D
	RJMP _0x20201A1
_0x20201A3:
	RJMP _0x20201A4
_0x20201A2:
	CALL SUBOPT_0x17A
	CALL SUBOPT_0x18A
	CALL _get_fat
	__PUTD1S 13
_0x20201A4:
	CALL SUBOPT_0x187
	CALL SUBOPT_0x5E
	BRNE _0x20201A5
	CALL SUBOPT_0x188
	LDI  R30,LOW(1)
	RJMP _0x20E0011
_0x20201A5:
	CALL SUBOPT_0x187
	CALL SUBOPT_0x109
	BRLO _0x20201A7
	CALL SUBOPT_0x17F
	CALL SUBOPT_0x133
	CALL SUBOPT_0x187
	CALL __CPD21
	BRLO _0x20201A6
_0x20201A7:
	CALL SUBOPT_0x188
	LDI  R30,LOW(2)
	RJMP _0x20E0011
_0x20201A6:
	CALL SUBOPT_0x189
	CALL SUBOPT_0x18B
	CALL SUBOPT_0x18C
	CALL __ADDD12
	MOVW R26,R0
	CALL __PUTDP1
	CALL SUBOPT_0x18C
	CALL SUBOPT_0x181
	CALL __SUBD12
	CALL SUBOPT_0x17D
	RJMP _0x202019F
_0x20201A1:
	CALL SUBOPT_0x18B
	CALL SUBOPT_0x17C
	CALL __ADDD12
	MOVW R26,R0
	CALL __PUTDP1
	CALL SUBOPT_0x17C
	__GETD1N 0x200
	CALL __DIVD21U
	__PUTB1SNS 21,5
	CALL SUBOPT_0x181
	ANDI R31,HIGH(0x1FF)
	SBIW R30,0
	BREQ _0x20201A9
	CALL SUBOPT_0x17A
	CALL SUBOPT_0x18A
	CALL _clust2sect
	CALL SUBOPT_0x122
	CALL SUBOPT_0xFE
	CALL __CPD10
	BRNE _0x20201AA
	CALL SUBOPT_0x188
	LDI  R30,LOW(2)
	RJMP _0x20E0011
_0x20201AA:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R30,Z+5
	LDI  R31,0
	CALL SUBOPT_0x11C
	CALL SUBOPT_0x37
	CALL SUBOPT_0x122
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	CALL SUBOPT_0x167
_0x20201A9:
_0x202019E:
_0x2020196:
	CALL SUBOPT_0x18D
	CALL SUBOPT_0x156
	BREQ _0x20201AC
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,22
	CALL __GETD1P
	CALL SUBOPT_0x11C
	CALL __CPD12
	BRNE _0x20201AD
_0x20201AC:
	RJMP _0x20201AB
_0x20201AD:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x20201AE
	CALL SUBOPT_0x17F
	LDD  R30,Z+1
	ST   -Y,R30
	CALL SUBOPT_0x175
	CALL SUBOPT_0x165
	BREQ _0x20201AF
	CALL SUBOPT_0x188
	LDI  R30,LOW(1)
	RJMP _0x20E0011
_0x20201AF:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	CALL SUBOPT_0x166
_0x20201AE:
	CALL SUBOPT_0x17F
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ADIW R30,32
	CALL SUBOPT_0x101
	BREQ _0x20201B0
	CALL SUBOPT_0x188
	LDI  R30,LOW(1)
	RJMP _0x20E0011
_0x20201B0:
	CALL SUBOPT_0xFE
	__PUTD1SNS 21,22
_0x20201AB:
	CALL SUBOPT_0x18D
	MOVW R0,R26
	CALL SUBOPT_0x17B
	MOVW R26,R0
	CALL __CPD12
	BRSH _0x20201B1
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,6
	CALL __GETD1P
	__PUTD1SNS 21,10
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x20
	ST   X,R30
_0x20201B1:
_0x20E0012:
	MOV  R30,R17
_0x20E0011:
	LDD  R17,Y+0
	ADIW R28,23
	RET
_f_opendir:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,12
	CALL __SAVELOCR4
	CALL SUBOPT_0x87
	CALL SUBOPT_0x124
	LDI  R26,LOW(0)
	CALL SUBOPT_0x14E
	BREQ PC+3
	JMP _0x20201B2
	MOVW R30,R28
	ADIW R30,4
	__PUTW1SNS 18,20
	CALL SUBOPT_0xE7
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL SUBOPT_0x179
	BRNE _0x20201B3
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x20201B4
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BREQ _0x20201B5
	CALL SUBOPT_0x142
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x143
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0x144
	__PUTD1SNS 18,6
	RJMP _0x20201B6
_0x20201B5:
	LDI  R17,LOW(5)
_0x20201B6:
_0x20201B4:
	CPI  R17,0
	BRNE _0x20201B7
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL __GETW1P
	ADIW R30,6
	MOVW R26,R30
	CALL __GETW1P
	__PUTW1SNS 18,2
	CALL SUBOPT_0xE7
	CALL SUBOPT_0x141
_0x20201B7:
_0x20201B3:
	CPI  R17,4
	BRNE _0x20201B8
	LDI  R17,LOW(5)
_0x20201B8:
_0x20201B2:
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,20
	RET
_f_getfree:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,16
	CALL __SAVELOCR6
	MOVW R30,R28
	ADIW R30,26
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x150
	LDI  R26,LOW(0)
	CALL SUBOPT_0x14E
	BREQ _0x20201C3
	MOV  R30,R17
	RJMP _0x20E000F
_0x20201C3:
	CALL SUBOPT_0x16E
	MOVW R0,R30
	ADIW R30,14
	MOVW R26,R30
	CALL __GETD1P
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R0
	ADIW R26,30
	CALL __GETD1P
	__SUBD1N 2
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD12
	BRLO _0x20201C4
	CALL SUBOPT_0x16E
	ADIW R30,14
	MOVW R26,R30
	CALL __GETD1P
	RJMP _0x20E0010
_0x20201C4:
	CALL SUBOPT_0x16E
	LD   R16,Z
	LDI  R30,LOW(0)
	__CLRD1S 18
	CPI  R16,1
	BRNE _0x20201C5
	CALL SUBOPT_0x127
	CALL SUBOPT_0x14B
_0x20201C7:
	CALL SUBOPT_0x16B
	CALL SUBOPT_0x118
	CALL _get_fat
	CALL SUBOPT_0x41
	CALL SUBOPT_0x3C
	CALL SUBOPT_0x5E
	BRNE _0x20201C9
	LDI  R30,LOW(1)
	RJMP _0x20E000F
_0x20201C9:
	CALL SUBOPT_0x3C
	CALL SUBOPT_0x11F
	BRNE _0x20201CA
	LDI  R30,LOW(2)
	RJMP _0x20E000F
_0x20201CA:
	CALL SUBOPT_0xED
	BRNE _0x20201CB
	CALL SUBOPT_0x18E
_0x20201CB:
	CALL SUBOPT_0x52
	CALL SUBOPT_0x47
	CALL SUBOPT_0x14B
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0x16E
	CALL SUBOPT_0x133
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD21
	BRLO _0x20201C7
	RJMP _0x20201CC
_0x20201C5:
	CALL SUBOPT_0x16E
	CALL SUBOPT_0x133
	CALL SUBOPT_0x14B
	CALL SUBOPT_0x16E
	ADIW R30,34
	MOVW R26,R30
	CALL __GETD1P
	__PUTD1S 10
	__GETWRN 18,19,0
	__GETWRN 20,21,0
_0x20201CE:
	MOV  R0,R18
	OR   R0,R19
	BRNE _0x20201D0
	CALL SUBOPT_0x16B
	CALL SUBOPT_0x55
	CALL SUBOPT_0x47
	CALL SUBOPT_0x15A
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0x103
	BREQ _0x20201D1
	MOV  R30,R17
	RJMP _0x20E000F
_0x20201D1:
	CALL SUBOPT_0x16E
	ADIW R30,50
	MOVW R20,R30
	__GETWRN 18,19,512
_0x20201D0:
	CPI  R16,2
	BRNE _0x20201D2
	MOVW R26,R20
	CALL __GETW1P
	SBIW R30,0
	BRNE _0x20201D3
	CALL SUBOPT_0x18E
_0x20201D3:
	__ADDWRN 20,21,2
	__SUBWRN 18,19,2
	RJMP _0x20201D4
_0x20201D2:
	MOVW R26,R20
	CALL SUBOPT_0x114
	CALL __CPD10
	BRNE _0x20201D5
	CALL SUBOPT_0x18E
_0x20201D5:
	__ADDWRN 20,21,4
	__SUBWRN 18,19,4
_0x20201D4:
	CALL SUBOPT_0x52
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	CALL SUBOPT_0x14B
	BRNE _0x20201CE
_0x20201CC:
	CALL SUBOPT_0x16E
	ADIW R30,14
	CALL SUBOPT_0x125
	CALL SUBOPT_0x11B
	CPI  R16,3
	BRNE _0x20201D6
	CALL SUBOPT_0x16E
	ADIW R30,5
	LDI  R26,LOW(1)
	STD  Z+0,R26
_0x20201D6:
	CALL SUBOPT_0x51
_0x20E0010:
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	CALL __PUTDP1
	LDI  R30,LOW(0)
_0x20E000F:
	CALL __LOADLOCR6
	ADIW R28,28
	RET
_f_mkdir:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,50
	CALL __SAVELOCR4
	MOVW R30,R28
	ADIW R30,54
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,34
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(1)
	CALL SUBOPT_0x14E
	BREQ _0x20201F3
	RJMP _0x20E000E
_0x20201F3:
	MOVW R30,R28
	ADIW R30,20
	STD  Y+52,R30
	STD  Y+52+1,R31
	MOVW R30,R28
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+56
	LDD  R27,Y+56+1
	CALL SUBOPT_0x179
	BRNE _0x20201F4
	LDI  R17,LOW(8)
_0x20201F4:
	LDI  R30,LOW(1)
	CPI  R30,0
	BREQ _0x20201F6
	CPI  R17,4
	BRNE _0x20201F6
	LDD  R30,Y+52
	LDD  R31,Y+52+1
	LDD  R30,Z+11
	ANDI R30,LOW(0x20)
	BRNE _0x20201F7
_0x20201F6:
	RJMP _0x20201F5
_0x20201F7:
	LDI  R17,LOW(6)
_0x20201F5:
	CPI  R17,4
	BREQ _0x20201F8
	RJMP _0x20E000E
_0x20201F8:
	CALL SUBOPT_0x18F
	CALL SUBOPT_0x16F
	LDI  R17,LOW(0)
	CALL SUBOPT_0x129
	BRNE _0x20201F9
	LDI  R17,LOW(7)
_0x20201F9:
	CALL SUBOPT_0x12B
	BRNE _0x20201FA
	LDI  R17,LOW(2)
_0x20201FA:
	CALL SUBOPT_0x12A
	BRNE _0x20201FB
	LDI  R17,LOW(1)
_0x20201FB:
	CPI  R17,0
	BRNE _0x20201FC
	CALL SUBOPT_0x18F
	CALL _move_window_G101
	MOV  R17,R30
_0x20201FC:
	CPI  R17,0
	BREQ _0x20201FD
	RJMP _0x20E000E
_0x20201FD:
	CALL SUBOPT_0x190
	CALL _clust2sect
	CALL SUBOPT_0x158
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	ADIW R30,50
	MOVW R18,R30
	CALL SUBOPT_0x139
	CALL SUBOPT_0x105
	MOVW R30,R18
	ADIW R30,0
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x13B
	MOVW R26,R18
	LDI  R30,LOW(46)
	ST   X,R30
	MOVW R30,R18
	ADIW R30,11
	LDI  R26,LOW(16)
	STD  Z+0,R26
	CALL SUBOPT_0x152
	CALL SUBOPT_0x178
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	CALL SUBOPT_0x176
	CALL SUBOPT_0x5B
	CALL SUBOPT_0x177
	MOVW R30,R18
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R19
	ST   -Y,R18
	LDI  R26,LOW(32)
	LDI  R27,0
	CALL _mem_cpy_G101
	MOVW R30,R18
	ADIW R30,33
	LDI  R26,LOW(46)
	STD  Z+0,R26
	CALL SUBOPT_0x49
	CALL SUBOPT_0x54
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	LD   R26,X
	CPI  R26,LOW(0x3)
	BRNE _0x20201FF
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	ADIW R26,38
	CALL __GETD1P
	CALL SUBOPT_0x56
	CALL __CPD12
	BREQ _0x2020200
_0x20201FF:
	RJMP _0x20201FE
_0x2020200:
	LDI  R30,LOW(0)
	__CLRD1S 8
_0x20201FE:
	MOVW R30,R18
	ADIW R30,58
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	STD  Z+0,R26
	STD  Z+1,R27
	CALL SUBOPT_0x58
	CALL __LSRD16
	__PUTW1RNS 18,52
	LDI  R16,LOW(0)
_0x2020202:
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	LDD  R30,Z+2
	CP   R16,R30
	BRSH _0x2020203
	CALL SUBOPT_0x123
	CALL SUBOPT_0x47
	CALL SUBOPT_0x158
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	__PUTD1SNS 32,46
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	CALL SUBOPT_0x18F
	CALL SUBOPT_0x103
	BRNE _0x20E000E
	CALL SUBOPT_0x139
	CALL SUBOPT_0x105
	SUBI R16,-1
	RJMP _0x2020202
_0x2020203:
	MOVW R26,R28
	ADIW R26,32
	CALL _dir_register_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x2020205
	CALL SUBOPT_0x190
	CALL _remove_chain_G101
	RJMP _0x2020206
_0x2020205:
	__GETWRS 18,19,50
	MOVW R30,R18
	ADIW R30,11
	LDI  R26,LOW(16)
	STD  Z+0,R26
	CALL SUBOPT_0x1C
	CALL SUBOPT_0x178
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	CALL SUBOPT_0x176
	CALL SUBOPT_0x5B
	CALL SUBOPT_0x177
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	CALL _sync_G101
	MOV  R17,R30
_0x2020206:
_0x20E000E:
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,56
	RET
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif

	.CSEG
_putchar:
	ST   -Y,R26
_0x2040003:
	LDS  R30,192
	ANDI R30,LOW(0x20)
	BREQ _0x2040003
	LD   R30,Y
	STS  198,R30
	ADIW R28,1
	RET
_puts:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
_0x2040006:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R30,X+
	STD  Y+1,R26
	STD  Y+1+1,R27
	MOV  R17,R30
	CPI  R30,0
	BREQ _0x2040008
	MOV  R26,R17
	RCALL _putchar
	RJMP _0x2040006
_0x2040008:
	LDI  R26,LOW(10)
	RCALL _putchar
_0x20E000D:
	LDD  R17,Y+0
	ADIW R28,3
	RET
_put_buff_G102:
	CALL SUBOPT_0x13
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,2
	CALL __GETW1P
	SBIW R30,0
	BREQ _0x204002A
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,4
	CALL __GETW1P
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x204002C
	__CPWRN 16,17,2
	BRLO _0x204002D
	MOVW R30,R16
	SBIW R30,1
	MOVW R16,R30
	__PUTW1SNS 2,4
_0x204002C:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,2
	CALL SUBOPT_0x11
	SBIW R30,1
	LDD  R26,Y+4
	STD  Z+0,R26
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	CALL __GETW1P
	TST  R31
	BRMI _0x204002E
	CALL SUBOPT_0x11
_0x204002E:
_0x204002D:
	RJMP _0x204002F
_0x204002A:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	ST   X+,R30
	ST   X,R31
_0x204002F:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,5
	RET
__ftoe_G102:
	CALL SUBOPT_0x73
	ST   Y,R30
	LDI  R30,LOW(0)
	STD  Y+1,R30
	LDI  R30,LOW(128)
	STD  Y+2,R30
	LDI  R30,LOW(63)
	STD  Y+3,R30
	CALL __SAVELOCR4
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	CPI  R30,LOW(0xFFFF)
	LDI  R26,HIGH(0xFFFF)
	CPC  R31,R26
	BRNE _0x2040037
	CALL SUBOPT_0xD7
	__POINTD2FN _0x2040000,0
	CALL _strcpyf
	CALL __LOADLOCR4
	RJMP _0x20E000B
_0x2040037:
	CPI  R30,LOW(0x7FFF)
	LDI  R26,HIGH(0x7FFF)
	CPC  R31,R26
	BRNE _0x2040036
	CALL SUBOPT_0xD7
	__POINTD2FN _0x2040000,1
	CALL _strcpyf
	CALL __LOADLOCR4
	RJMP _0x20E000B
_0x2040036:
	LDD  R26,Y+11
	CPI  R26,LOW(0x7)
	BRLO _0x2040039
	LDI  R30,LOW(6)
	STD  Y+11,R30
_0x2040039:
	LDD  R17,Y+11
_0x204003A:
	MOV  R30,R17
	SUBI R17,1
	CPI  R30,0
	BREQ _0x204003C
	CALL SUBOPT_0x191
	RJMP _0x204003A
_0x204003C:
	CALL SUBOPT_0x129
	BRNE _0x204003D
	LDI  R19,LOW(0)
	CALL SUBOPT_0x191
	RJMP _0x204003E
_0x204003D:
	LDD  R19,Y+11
	CALL SUBOPT_0x192
	BREQ PC+2
	BRCC PC+3
	JMP  _0x204003F
	CALL SUBOPT_0x191
_0x2040040:
	CALL SUBOPT_0x192
	BRLO _0x2040042
	CALL SUBOPT_0x193
	RJMP _0x2040040
_0x2040042:
	RJMP _0x2040043
_0x204003F:
_0x2040044:
	CALL SUBOPT_0x192
	BRSH _0x2040046
	CALL SUBOPT_0x57
	CALL SUBOPT_0x194
	CALL SUBOPT_0x15A
	SUBI R19,LOW(1)
	RJMP _0x2040044
_0x2040046:
	CALL SUBOPT_0x191
_0x2040043:
	CALL SUBOPT_0x55
	CALL SUBOPT_0x195
	CALL SUBOPT_0x15A
	CALL SUBOPT_0x192
	BRLO _0x2040047
	CALL SUBOPT_0x193
_0x2040047:
_0x204003E:
	LDI  R17,LOW(0)
_0x2040048:
	LDD  R30,Y+11
	CP   R30,R17
	BRLO _0x204004A
	CALL SUBOPT_0x31
	CALL SUBOPT_0x196
	CALL SUBOPT_0x195
	MOVW R26,R30
	MOVW R24,R22
	CALL _floor
	CALL SUBOPT_0x38
	CALL SUBOPT_0x57
	CALL __DIVF21
	CALL __CFD1U
	MOV  R16,R30
	CALL SUBOPT_0x197
	MOV  R30,R16
	SUBI R30,-LOW(48)
	ST   X,R30
	MOV  R30,R16
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __CDF1
	CALL SUBOPT_0x31
	CALL __MULF12
	CALL SUBOPT_0x57
	CALL SUBOPT_0x198
	CALL SUBOPT_0x15A
	MOV  R30,R17
	SUBI R17,-1
	CPI  R30,0
	BRNE _0x2040048
	CALL SUBOPT_0x197
	LDI  R30,LOW(46)
	ST   X,R30
	RJMP _0x2040048
_0x204004A:
	CALL SUBOPT_0x199
	SBIW R30,1
	LDD  R26,Y+10
	STD  Z+0,R26
	CPI  R19,0
	BRGE _0x204004C
	NEG  R19
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(45)
	RJMP _0x2040137
_0x204004C:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(43)
_0x2040137:
	ST   X,R30
	CALL SUBOPT_0x199
	CALL SUBOPT_0x199
	SBIW R30,1
	MOVW R22,R30
	MOV  R26,R19
	LDI  R30,LOW(10)
	CALL __DIVB21
	SUBI R30,-LOW(48)
	MOVW R26,R22
	ST   X,R30
	CALL SUBOPT_0x199
	SBIW R30,1
	MOVW R22,R30
	MOV  R26,R19
	LDI  R30,LOW(10)
	CALL __MODB21
	SUBI R30,-LOW(48)
	MOVW R26,R22
	ST   X,R30
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(0)
	ST   X,R30
	CALL __LOADLOCR4
	RJMP _0x20E000B
__print_G102:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,63
	SBIW R28,21
	CALL __SAVELOCR6
	LDI  R17,0
	__GETD1SX 92
	CALL SUBOPT_0x54
	CALL SUBOPT_0x91
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL SUBOPT_0xB1
_0x204004E:
	MOVW R26,R28
	SUBI R26,LOW(-(98))
	SBCI R27,HIGH(-(98))
	CALL SUBOPT_0xFC
	__GETBRPF 30
	MOV  R18,R30
	CPI  R30,0
	BRNE PC+3
	JMP _0x2040050
	MOV  R30,R17
	CPI  R30,0
	BRNE _0x2040054
	CPI  R18,37
	BRNE _0x2040055
	LDI  R17,LOW(1)
	RJMP _0x2040056
_0x2040055:
	CALL SUBOPT_0x19A
_0x2040056:
	RJMP _0x2040053
_0x2040054:
	CPI  R30,LOW(0x1)
	BRNE _0x2040057
	CPI  R18,37
	BRNE _0x2040058
	CALL SUBOPT_0x19A
	RJMP _0x2040138
_0x2040058:
	LDI  R17,LOW(2)
	LDI  R30,LOW(0)
	STD  Y+25,R30
	LDI  R16,LOW(0)
	CPI  R18,45
	BRNE _0x2040059
	LDI  R16,LOW(1)
	RJMP _0x2040053
_0x2040059:
	CPI  R18,43
	BRNE _0x204005A
	LDI  R30,LOW(43)
	STD  Y+25,R30
	RJMP _0x2040053
_0x204005A:
	CPI  R18,32
	BRNE _0x204005B
	LDI  R30,LOW(32)
	STD  Y+25,R30
	RJMP _0x2040053
_0x204005B:
	RJMP _0x204005C
_0x2040057:
	CPI  R30,LOW(0x2)
	BRNE _0x204005D
_0x204005C:
	LDI  R21,LOW(0)
	LDI  R17,LOW(3)
	CPI  R18,48
	BRNE _0x204005E
	ORI  R16,LOW(128)
	RJMP _0x2040053
_0x204005E:
	RJMP _0x204005F
_0x204005D:
	CPI  R30,LOW(0x3)
	BRNE _0x2040060
_0x204005F:
	CPI  R18,48
	BRLO _0x2040062
	CPI  R18,58
	BRLO _0x2040063
_0x2040062:
	RJMP _0x2040061
_0x2040063:
	LDI  R26,LOW(10)
	MUL  R21,R26
	MOV  R21,R0
	MOV  R30,R18
	SUBI R30,LOW(48)
	ADD  R21,R30
	RJMP _0x2040053
_0x2040061:
	LDI  R20,LOW(0)
	CPI  R18,46
	BRNE _0x2040064
	LDI  R17,LOW(4)
	RJMP _0x2040053
_0x2040064:
	RJMP _0x2040065
_0x2040060:
	CPI  R30,LOW(0x4)
	BRNE _0x2040067
	CPI  R18,48
	BRLO _0x2040069
	CPI  R18,58
	BRLO _0x204006A
_0x2040069:
	RJMP _0x2040068
_0x204006A:
	ORI  R16,LOW(32)
	LDI  R26,LOW(10)
	MUL  R20,R26
	MOV  R20,R0
	MOV  R30,R18
	SUBI R30,LOW(48)
	ADD  R20,R30
	RJMP _0x2040053
_0x2040068:
_0x2040065:
	CPI  R18,108
	BRNE _0x204006B
	ORI  R16,LOW(2)
	LDI  R17,LOW(5)
	RJMP _0x2040053
_0x204006B:
	RJMP _0x204006C
_0x2040067:
	CPI  R30,LOW(0x5)
	BREQ PC+3
	JMP _0x2040053
_0x204006C:
	MOV  R30,R18
	CPI  R30,LOW(0x63)
	BRNE _0x2040071
	CALL SUBOPT_0x19B
	CALL SUBOPT_0x90
	LDD  R26,Z+4
	ST   -Y,R26
	CALL SUBOPT_0x19C
	RJMP _0x2040072
_0x2040071:
	CPI  R30,LOW(0x45)
	BREQ _0x2040075
	CPI  R30,LOW(0x65)
	BRNE _0x2040076
_0x2040075:
	RJMP _0x2040077
_0x2040076:
	CPI  R30,LOW(0x66)
	BREQ PC+3
	JMP _0x2040078
_0x2040077:
	MOVW R30,R28
	ADIW R30,26
	STD  Y+16,R30
	STD  Y+16+1,R31
	CALL SUBOPT_0x93
	CALL __GETD1P
	CALL SUBOPT_0x15A
	CALL SUBOPT_0x19B
	LDD  R26,Y+15
	TST  R26
	BRMI _0x2040079
	LDD  R26,Y+25
	CPI  R26,LOW(0x2B)
	BREQ _0x204007B
	RJMP _0x204007C
_0x2040079:
	CALL SUBOPT_0x55
	CALL __ANEGF1
	CALL SUBOPT_0x15A
	LDI  R30,LOW(45)
	STD  Y+25,R30
_0x204007B:
	SBRS R16,7
	RJMP _0x204007D
	LDD  R30,Y+25
	ST   -Y,R30
	CALL SUBOPT_0x19C
	RJMP _0x204007E
_0x204007D:
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	ADIW R30,1
	STD  Y+16,R30
	STD  Y+16+1,R31
	SBIW R30,1
	LDD  R26,Y+25
	STD  Z+0,R26
_0x204007E:
_0x204007C:
	SBRS R16,5
	LDI  R20,LOW(6)
	CPI  R18,102
	BRNE _0x2040080
	CALL SUBOPT_0x55
	CALL __PUTPARD1
	ST   -Y,R20
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	CALL _ftoa
	RJMP _0x2040081
_0x2040080:
	CALL SUBOPT_0x55
	CALL __PUTPARD1
	ST   -Y,R20
	ST   -Y,R18
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	RCALL __ftoe_G102
_0x2040081:
	MOVW R30,R28
	ADIW R30,26
	CALL SUBOPT_0x19D
	RJMP _0x2040082
_0x2040078:
	CPI  R30,LOW(0x73)
	BRNE _0x2040084
	CALL SUBOPT_0x19B
	CALL SUBOPT_0x93
	ADIW R26,4
	CALL __GETW1P
	CALL SUBOPT_0x19D
	RJMP _0x2040085
_0x2040084:
	CPI  R30,LOW(0x70)
	BRNE _0x2040087
	CALL SUBOPT_0x19B
	CALL SUBOPT_0x93
	ADIW R26,4
	CALL __GETD1P
	CALL SUBOPT_0x158
	CALL SUBOPT_0x118
	CALL _strlenf
	MOV  R17,R30
	ORI  R16,LOW(8)
_0x2040085:
	ANDI R16,LOW(127)
	CPI  R20,0
	BREQ _0x2040089
	CP   R20,R17
	BRLO _0x204008A
_0x2040089:
	RJMP _0x2040088
_0x204008A:
	MOV  R17,R20
_0x2040088:
_0x2040082:
	LDI  R20,LOW(0)
	LDI  R30,LOW(0)
	STD  Y+24,R30
	LDI  R19,LOW(0)
	RJMP _0x204008B
_0x2040087:
	CPI  R30,LOW(0x64)
	BREQ _0x204008E
	CPI  R30,LOW(0x69)
	BRNE _0x204008F
_0x204008E:
	ORI  R16,LOW(4)
	RJMP _0x2040090
_0x204008F:
	CPI  R30,LOW(0x75)
	BRNE _0x2040091
_0x2040090:
	LDI  R30,LOW(10)
	STD  Y+24,R30
	SBRS R16,1
	RJMP _0x2040092
	__GETD1N 0x3B9ACA00
	CALL SUBOPT_0x19E
	LDI  R17,LOW(10)
	RJMP _0x2040093
_0x2040092:
	__GETD1N 0x2710
	CALL SUBOPT_0x19E
	LDI  R17,LOW(5)
	RJMP _0x2040093
_0x2040091:
	CPI  R30,LOW(0x58)
	BRNE _0x2040095
	ORI  R16,LOW(8)
	RJMP _0x2040096
_0x2040095:
	CPI  R30,LOW(0x78)
	BREQ PC+3
	JMP _0x20400D4
_0x2040096:
	LDI  R30,LOW(16)
	STD  Y+24,R30
	SBRS R16,1
	RJMP _0x2040098
	__GETD1N 0x10000000
	CALL SUBOPT_0x19E
	LDI  R17,LOW(8)
	RJMP _0x2040093
_0x2040098:
	__GETD1N 0x1000
	CALL SUBOPT_0x19E
	LDI  R17,LOW(4)
_0x2040093:
	CPI  R20,0
	BREQ _0x2040099
	ANDI R16,LOW(127)
	RJMP _0x204009A
_0x2040099:
	LDI  R20,LOW(1)
_0x204009A:
	SBRS R16,1
	RJMP _0x204009B
	CALL SUBOPT_0x19B
	CALL SUBOPT_0x93
	ADIW R26,4
	CALL __GETD1P
	RJMP _0x2040139
_0x204009B:
	SBRS R16,2
	RJMP _0x204009D
	CALL SUBOPT_0x19B
	CALL SUBOPT_0x93
	ADIW R26,4
	CALL __GETW1P
	CALL __CWD1
	RJMP _0x2040139
_0x204009D:
	CALL SUBOPT_0x19B
	CALL SUBOPT_0x93
	ADIW R26,4
	CALL SUBOPT_0x112
_0x2040139:
	__PUTD1S 12
	SBRS R16,2
	RJMP _0x204009F
	LDD  R26,Y+15
	TST  R26
	BRPL _0x20400A0
	CALL SUBOPT_0x55
	CALL __ANEGD1
	CALL SUBOPT_0x15A
	LDI  R30,LOW(45)
	STD  Y+25,R30
_0x20400A0:
	LDD  R30,Y+25
	CPI  R30,0
	BREQ _0x20400A1
	SUBI R17,-LOW(1)
	SUBI R20,-LOW(1)
	RJMP _0x20400A2
_0x20400A1:
	ANDI R16,LOW(251)
_0x20400A2:
_0x204009F:
	MOV  R19,R20
_0x204008B:
	SBRC R16,0
	RJMP _0x20400A3
_0x20400A4:
	CP   R17,R21
	BRSH _0x20400A7
	CP   R19,R21
	BRLO _0x20400A8
_0x20400A7:
	RJMP _0x20400A6
_0x20400A8:
	SBRS R16,7
	RJMP _0x20400A9
	SBRS R16,2
	RJMP _0x20400AA
	ANDI R16,LOW(251)
	LDD  R18,Y+25
	SUBI R17,LOW(1)
	RJMP _0x20400AB
_0x20400AA:
	LDI  R18,LOW(48)
_0x20400AB:
	RJMP _0x20400AC
_0x20400A9:
	LDI  R18,LOW(32)
_0x20400AC:
	CALL SUBOPT_0x19A
	SUBI R21,LOW(1)
	RJMP _0x20400A4
_0x20400A6:
_0x20400A3:
_0x20400AD:
	CP   R17,R20
	BRSH _0x20400AF
	ORI  R16,LOW(16)
	SBRS R16,2
	RJMP _0x20400B0
	CALL SUBOPT_0x19F
	BREQ _0x20400B1
	SUBI R21,LOW(1)
_0x20400B1:
	SUBI R17,LOW(1)
	SUBI R20,LOW(1)
_0x20400B0:
	LDI  R30,LOW(48)
	ST   -Y,R30
	CALL SUBOPT_0x19C
	CPI  R21,0
	BREQ _0x20400B2
	SUBI R21,LOW(1)
_0x20400B2:
	SUBI R20,LOW(1)
	RJMP _0x20400AD
_0x20400AF:
	MOV  R19,R17
	LDD  R30,Y+24
	CPI  R30,0
	BRNE _0x20400B3
_0x20400B4:
	CPI  R19,0
	BREQ _0x20400B6
	SBRS R16,3
	RJMP _0x20400B7
	MOVW R26,R28
	ADIW R26,16
	CALL SUBOPT_0xFC
	__GETBRPF 18
	RJMP _0x20400B8
_0x20400B7:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	LD   R18,X+
	STD  Y+16,R26
	STD  Y+16+1,R27
_0x20400B8:
	CALL SUBOPT_0x19A
	CPI  R21,0
	BREQ _0x20400B9
	SUBI R21,LOW(1)
_0x20400B9:
	SUBI R19,LOW(1)
	RJMP _0x20400B4
_0x20400B6:
	RJMP _0x20400BA
_0x20400B3:
_0x20400BC:
	CALL SUBOPT_0x59
	CALL SUBOPT_0x57
	CALL __DIVD21U
	MOV  R18,R30
	CPI  R18,10
	BRLO _0x20400BE
	SBRS R16,3
	RJMP _0x20400BF
	SUBI R18,-LOW(55)
	RJMP _0x20400C0
_0x20400BF:
	SUBI R18,-LOW(87)
_0x20400C0:
	RJMP _0x20400C1
_0x20400BE:
	SUBI R18,-LOW(48)
_0x20400C1:
	SBRC R16,4
	RJMP _0x20400C3
	CPI  R18,49
	BRSH _0x20400C5
	__GETD2S 20
	CALL SUBOPT_0x11F
	BRNE _0x20400C4
_0x20400C5:
	RJMP _0x20400C7
_0x20400C4:
	CP   R20,R19
	BRSH _0x204013A
	CP   R21,R19
	BRLO _0x20400CA
	SBRS R16,0
	RJMP _0x20400CB
_0x20400CA:
	RJMP _0x20400C9
_0x20400CB:
	LDI  R18,LOW(32)
	SBRS R16,7
	RJMP _0x20400CC
_0x204013A:
	LDI  R18,LOW(48)
_0x20400C7:
	ORI  R16,LOW(16)
	SBRS R16,2
	RJMP _0x20400CD
	CALL SUBOPT_0x19F
	BREQ _0x20400CE
	SUBI R21,LOW(1)
_0x20400CE:
_0x20400CD:
_0x20400CC:
_0x20400C3:
	CALL SUBOPT_0x19A
	CPI  R21,0
	BREQ _0x20400CF
	SUBI R21,LOW(1)
_0x20400CF:
_0x20400C9:
	SUBI R19,LOW(1)
	CALL SUBOPT_0x59
	CALL SUBOPT_0x57
	CALL __MODD21U
	CALL SUBOPT_0x15A
	LDD  R30,Y+24
	__GETD2S 20
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __DIVD21U
	CALL SUBOPT_0x19E
	CALL SUBOPT_0x59
	CALL __CPD10
	BREQ _0x20400BD
	RJMP _0x20400BC
_0x20400BD:
_0x20400BA:
	SBRS R16,0
	RJMP _0x20400D0
_0x20400D1:
	CPI  R21,0
	BREQ _0x20400D3
	SUBI R21,LOW(1)
	LDI  R30,LOW(32)
	ST   -Y,R30
	CALL SUBOPT_0x19C
	RJMP _0x20400D1
_0x20400D3:
_0x20400D0:
_0x20400D4:
_0x2040072:
_0x2040138:
	LDI  R17,LOW(0)
_0x2040053:
	RJMP _0x204004E
_0x2040050:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL __GETW1P
	CALL __LOADLOCR6
	ADIW R28,63
	ADIW R28,39
	RET
_sprintf:
	PUSH R15
	MOV  R15,R24
	SBIW R28,6
	CALL __SAVELOCR4
	MOVW R26,R28
	ADIW R26,14
	CALL __ADDW2R15
	CALL __GETW1P
	SBIW R30,0
	BRNE _0x20400D5
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E000C
_0x20400D5:
	MOVW R26,R28
	ADIW R26,6
	CALL __ADDW2R15
	MOVW R16,R26
	MOVW R26,R28
	ADIW R26,14
	CALL __ADDW2R15
	CALL SUBOPT_0x13C
	LDI  R30,LOW(0)
	STD  Y+8,R30
	STD  Y+8+1,R30
	MOVW R26,R28
	ADIW R26,10
	CALL SUBOPT_0x6C
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x1A0
	MOVW R26,R28
	ADIW R26,14
	RCALL __print_G102
	MOVW R18,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
	MOVW R30,R18
_0x20E000C:
	CALL __LOADLOCR4
	ADIW R28,10
	POP  R15
	RET
_vsprintf:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,6
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	SBIW R30,0
	BRNE _0x20400D8
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E000A
_0x20400D8:
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	STD  Y+4,R30
	STD  Y+4+1,R31
	LDI  R30,LOW(0)
	STD  Y+6,R30
	STD  Y+6+1,R30
	CALL SUBOPT_0x53
	CALL __PUTPARD1
	CALL SUBOPT_0x75
	CALL SUBOPT_0x1A0
	MOVW R26,R28
	ADIW R26,12
	RCALL __print_G102
	MOVW R16,R30
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LDI  R30,LOW(0)
	ST   X,R30
	MOVW R30,R16
_0x20E000A:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E000B:
	ADIW R28,16
	RET

	.CSEG
_atoi:
	ST   -Y,R27
	ST   -Y,R26
   	ldd  r27,y+1
   	ld   r26,y
__atoi0:
   	ld   r30,x
        mov  r24,r26
	MOV  R26,R30
	CALL _isspace
        mov  r26,r24
   	tst  r30
   	breq __atoi1
   	adiw r26,1
   	rjmp __atoi0
__atoi1:
   	clt
   	ld   r30,x
   	cpi  r30,'-'
   	brne __atoi2
   	set
   	rjmp __atoi3
__atoi2:
   	cpi  r30,'+'
   	brne __atoi4
__atoi3:
   	adiw r26,1
__atoi4:
   	clr  r22
   	clr  r23
__atoi5:
   	ld   r30,x
        mov  r24,r26
	MOV  R26,R30
	CALL _isdigit
        mov  r26,r24
   	tst  r30
   	breq __atoi6
   	movw r30,r22
   	lsl  r22
   	rol  r23
   	lsl  r22
   	rol  r23
   	add  r22,r30
   	adc  r23,r31
   	lsl  r22
   	rol  r23
   	ld   r30,x+
   	clr  r31
   	subi r30,'0'
   	add  r22,r30
   	adc  r23,r31
   	rjmp __atoi5
__atoi6:
   	movw r30,r22
   	brtc __atoi7
   	com  r30
   	com  r31
   	adiw r30,1
__atoi7:
   	adiw r28,2
   	ret
_ftoa:
	CALL SUBOPT_0x73
	ST   Y,R30
	LDI  R30,LOW(0)
	STD  Y+1,R30
	STD  Y+2,R30
	LDI  R30,LOW(63)
	STD  Y+3,R30
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+11
	LDD  R31,Y+11+1
	CPI  R30,LOW(0xFFFF)
	LDI  R26,HIGH(0xFFFF)
	CPC  R31,R26
	BRNE _0x206000D
	CALL SUBOPT_0x74
	__POINTD2FN _0x2060000,0
	CALL _strcpyf
	RJMP _0x20E0009
_0x206000D:
	CPI  R30,LOW(0x7FFF)
	LDI  R26,HIGH(0x7FFF)
	CPC  R31,R26
	BRNE _0x206000C
	CALL SUBOPT_0x74
	__POINTD2FN _0x2060000,1
	CALL _strcpyf
	RJMP _0x20E0009
_0x206000C:
	LDD  R26,Y+12
	TST  R26
	BRPL _0x206000F
	CALL SUBOPT_0x183
	CALL __ANEGF1
	CALL SUBOPT_0x180
	CALL SUBOPT_0x1A1
	LDI  R30,LOW(45)
	ST   X,R30
_0x206000F:
	LDD  R26,Y+8
	CPI  R26,LOW(0x7)
	BRLO _0x2060010
	LDI  R30,LOW(6)
	STD  Y+8,R30
_0x2060010:
	LDD  R17,Y+8
_0x2060011:
	MOV  R30,R17
	SUBI R17,1
	CPI  R30,0
	BREQ _0x2060013
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x196
	CALL SUBOPT_0x3D
	RJMP _0x2060011
_0x2060013:
	CALL SUBOPT_0x1A2
	CALL __ADDF12
	CALL SUBOPT_0x180
	LDI  R17,LOW(0)
	__GETD1N 0x3F800000
	CALL SUBOPT_0x3D
_0x2060014:
	CALL SUBOPT_0x1A2
	CALL __CMPF12
	BRLO _0x2060016
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x194
	CALL SUBOPT_0x3D
	SUBI R17,-LOW(1)
	CPI  R17,39
	BRLO _0x2060017
	CALL SUBOPT_0x74
	__POINTD2FN _0x2060000,5
	CALL _strcpyf
	RJMP _0x20E0009
_0x2060017:
	RJMP _0x2060014
_0x2060016:
	CPI  R17,0
	BRNE _0x2060018
	CALL SUBOPT_0x1A1
	LDI  R30,LOW(48)
	ST   X,R30
	RJMP _0x2060019
_0x2060018:
_0x206001A:
	MOV  R30,R17
	SUBI R17,1
	CPI  R30,0
	BREQ _0x206001C
	CALL SUBOPT_0x3F
	CALL SUBOPT_0x196
	CALL SUBOPT_0x195
	MOVW R26,R30
	MOVW R24,R22
	CALL _floor
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x1A2
	CALL __DIVF21
	CALL __CFD1U
	MOV  R16,R30
	CALL SUBOPT_0x1A1
	MOV  R30,R16
	SUBI R30,-LOW(48)
	ST   X,R30
	CALL SUBOPT_0x35
	CALL SUBOPT_0x3F
	CALL __CWD1
	CALL __CDF1
	CALL __MULF12
	CALL SUBOPT_0x18C
	CALL SUBOPT_0x198
	CALL SUBOPT_0x180
	RJMP _0x206001A
_0x206001C:
_0x2060019:
	LDD  R30,Y+8
	CPI  R30,0
	BREQ _0x20E0008
	CALL SUBOPT_0x1A1
	LDI  R30,LOW(46)
	ST   X,R30
_0x206001E:
	LDD  R30,Y+8
	SUBI R30,LOW(1)
	STD  Y+8,R30
	SUBI R30,-LOW(1)
	BREQ _0x2060020
	CALL SUBOPT_0x18C
	CALL SUBOPT_0x194
	CALL SUBOPT_0x180
	CALL SUBOPT_0x183
	CALL __CFD1U
	MOV  R16,R30
	CALL SUBOPT_0x1A1
	MOV  R30,R16
	SUBI R30,-LOW(48)
	ST   X,R30
	CALL SUBOPT_0x35
	CALL SUBOPT_0x18C
	CALL __CWD1
	CALL __CDF1
	CALL SUBOPT_0x198
	CALL SUBOPT_0x180
	RJMP _0x206001E
_0x2060020:
_0x20E0008:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
_0x20E0009:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,13
	RET

	.DSEG

	.CSEG
_srand:
	CALL SUBOPT_0x28
	CALL __CWD1
	CALL SUBOPT_0x1A3
	RJMP _0x20E0005
_rand:
	LDS  R30,__seed_G103
	LDS  R31,__seed_G103+1
	LDS  R22,__seed_G103+2
	LDS  R23,__seed_G103+3
	__GETD2N 0x41C64E6D
	CALL __MULD12U
	__ADDD1N 30562
	CALL SUBOPT_0x1A3
	movw r30,r22
	andi r31,0x7F
	RET
_allocate_block_G103:
	CALL SUBOPT_0xDF
	__GETWRN 16,17,6656
	MOVW R26,R16
	CALL SUBOPT_0xB1
_0x2060061:
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x2060063
	MOVW R26,R16
	CALL __GETW1P
	ADD  R30,R16
	ADC  R31,R17
	ADIW R30,4
	MOVW R20,R30
	CALL SUBOPT_0xB3
	MOVW R18,R30
	SBIW R30,0
	BREQ _0x2060064
	__PUTWSR 18,19,6
	RJMP _0x2060065
_0x2060064:
	LDI  R30,LOW(8704)
	LDI  R31,HIGH(8704)
	STD  Y+6,R30
	STD  Y+6+1,R31
_0x2060065:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUB  R26,R20
	SBC  R27,R21
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,4
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x2060066
	MOVW R30,R20
	__PUTW1RNS 16,2
	MOVW R30,R18
	__PUTW1RNS 20,2
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	MOVW R26,R20
	ST   X+,R30
	ST   X,R31
	__ADDWRN 20,21,4
	MOVW R30,R20
	RJMP _0x20E0007
_0x2060066:
	MOVW R16,R18
	RJMP _0x2060061
_0x2060063:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0007:
	CALL __LOADLOCR6
	ADIW R28,10
	RET
_find_prev_block_G103:
	CALL SUBOPT_0xEA
	__GETWRN 16,17,6656
_0x2060067:
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x2060069
	CALL SUBOPT_0xB3
	MOVW R18,R30
	MOVW R26,R30
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x206006A
	MOVW R30,R16
	CALL __LOADLOCR4
	JMP  _0x20E0004
_0x206006A:
	MOVW R16,R18
	RJMP _0x2060067
_0x2060069:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	CALL __LOADLOCR4
	JMP  _0x20E0004
_realloc:
	CALL SUBOPT_0xDF
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	SBIW R30,0
	BREQ _0x206006B
	SBIW R30,4
	MOVW R16,R30
	MOVW R26,R16
	RCALL _find_prev_block_G103
	MOVW R18,R30
	SBIW R30,0
	BREQ _0x206006C
	CALL SUBOPT_0xB3
	__PUTW1RNS 18,2
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	SBIW R30,0
	BREQ _0x206006D
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	RCALL _allocate_block_G103
	MOVW R20,R30
	SBIW R30,0
	BREQ _0x206006E
	MOVW R26,R16
	CALL SUBOPT_0x13C
	MOVW R26,R30
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CP   R26,R30
	CPC  R27,R31
	BRSH _0x206006F
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	STD  Y+8,R30
	STD  Y+8+1,R31
_0x206006F:
	ST   -Y,R21
	ST   -Y,R20
	CALL SUBOPT_0x75
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	CALL _memmove
	MOVW R30,R20
	RJMP _0x20E0006
_0x206006E:
	MOVW R30,R16
	__PUTW1RNS 18,2
_0x206006D:
_0x206006C:
_0x206006B:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0006:
	CALL __LOADLOCR6
	ADIW R28,12
	RET
_malloc:
	CALL SUBOPT_0x13
	__GETWRN 16,17,0
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,0
	BREQ _0x2060070
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	RCALL _allocate_block_G103
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x2060071
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDD  R26,Y+5
	LDD  R27,Y+5+1
	CALL _memset
_0x2060071:
_0x2060070:
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20E0001
_free:
	CALL SUBOPT_0x28
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(0)
	LDI  R27,0
	RCALL _realloc
_0x20E0005:
	ADIW R28,2
	RET

	.CSEG
_memcmp:
	ST   -Y,R27
	ST   -Y,R26
    clr  r22
    clr  r23
    ld   r24,y+
    ld   r25,y+
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
memcmp0:
    adiw r24,0
    breq memcmp1
    sbiw r24,1
    ld   r22,x+
    ld   r23,z+
    cp   r22,r23
    breq memcmp0
memcmp1:
    sub  r22,r23
    brcc memcmp2
    ldi  r30,-1
    ret
memcmp2:
    ldi  r30,0
    breq memcmp3
    inc  r30
memcmp3:
    ret
_memcpy:
	ST   -Y,R27
	ST   -Y,R26
    ldd  r25,y+1
    ld   r24,y
    adiw r24,0
    breq memcpy1
    ldd  r27,y+5
    ldd  r26,y+4
    ldd  r31,y+3
    ldd  r30,y+2
memcpy0:
    ld   r22,z+
    st   x+,r22
    sbiw r24,1
    brne memcpy0
memcpy1:
    ldd  r31,y+5
    ldd  r30,y+4
	JMP  _0x20E0003
_memmove:
	ST   -Y,R27
	ST   -Y,R26
    ldd  r25,y+1
    ld   r24,y
    adiw r24,0
    breq memmove3
    ldd  r27,y+5
    ldd  r26,y+4
    ldd  r31,y+3
    ldd  r30,y+2
    cp   r30,r26
    cpc  r31,r27
    breq memmove3
    brlt memmove1
memmove0:
    ld   r22,z+
    st   x+,r22
    sbiw r24,1
    brne memmove0
    rjmp memmove3
memmove1:
    add  r26,r24
    adc  r27,r25
    add  r30,r24
    adc  r31,r25
memmove2:
    ld   r22,-z
    st   -x,r22
    sbiw r24,1
    brne memmove2
memmove3:
    ldd  r31,y+5
    ldd  r30,y+4
	JMP  _0x20E0003
_memset:
	ST   -Y,R27
	ST   -Y,R26
    ldd  r27,y+1
    ld   r26,y
    adiw r26,0
    breq memset1
    ldd  r31,y+4
    ldd  r30,y+3
    ldd  r22,y+2
memset0:
    st   z+,r22
    sbiw r26,1
    brne memset0
memset1:
    ldd  r30,y+3
    ldd  r31,y+4
	ADIW R28,5
	RET
_strcpyf:
	CALL __PUTPARD2
    ld   r30,y+
    ld   r31,y+
    ld   r22,y+
    ld   r23,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
    out  rampz,r22
strcpyf0:
    elpm r0,z+
    st   x+,r0
    tst  r0
    brne strcpyf0
    movw r30,r24
    ret
_strlen:
	ST   -Y,R27
	ST   -Y,R26
    ld   r26,y+
    ld   r27,y+
    clr  r30
    clr  r31
strlen0:
    ld   r22,x+
    tst  r22
    breq strlen1
    adiw r30,1
    rjmp strlen0
strlen1:
    ret
_strlenf:
	CALL __PUTPARD2
    clr  r26
    clr  r27
    ld   r30,y+
    ld   r31,y+
    ld   r22,y+
    ld   r23,y+
    out  rampz,r22
strlenf0:
    elpm r0,z+
    tst  r0
    breq strlenf1
    adiw r26,1
    rjmp strlenf0
strlenf1:
    movw r30,r26
    ret
_strncmp:
	ST   -Y,R26
    clr  r22
    clr  r23
    ld   r24,y+
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
strncmp0:
    tst  r24
    breq strncmp1
    dec  r24
    ld   r22,x+
    ld   r23,z+
    cp   r22,r23
    brne strncmp1
    tst  r22
    brne strncmp0
strncmp3:
    clr  r30
    ret
strncmp1:
    sub  r22,r23
    breq strncmp3
    ldi  r30,1
    brcc strncmp2
    subi r30,2
strncmp2:
    ret
_strpbrkf:
	CALL __PUTPARD2
    ldd  r27,y+5
    ldd  r26,y+4
strpbrkf0:
    ld   r23,x
    tst  r23
    breq strpbrkf2
    ldd  r22,y+2
    ldd  r31,y+1
    ld   r30,y
strpbrkf1:
    out  rampz,r22
    elpm
    tst  r0
    breq strpbrkf3
    subi r30,255
    sbci r31,255
    sbci r22,255
    cp   r23,r0
    brne strpbrkf1
    movw r30,r26
    rjmp strpbrkf4
strpbrkf3:
    adiw r26,1
    rjmp strpbrkf0
strpbrkf2:
    clr  r30
    clr  r31
strpbrkf4:
	JMP  _0x20E0003
_strstr:
	ST   -Y,R27
	ST   -Y,R26
    ldd  r26,y+2
    ldd  r27,y+3
    movw r24,r26
strstr0:
    ld   r30,y
    ldd  r31,y+1
strstr1:
    ld   r23,z+
    tst  r23
    brne strstr2
    movw r30,r24
    rjmp strstr3
strstr2:
    ld   r22,x+
    cp   r22,r23
    breq strstr1
    adiw r24,1
    movw r26,r24
    tst  r22
    brne strstr0
    clr  r30
    clr  r31
strstr3:
	JMP  _0x20E0001
_strspnf:
	CALL __PUTPARD2
    ldd  r27,y+5
    ldd  r26,y+4
    clr  r24
    clr  r25
strspnf0:
    ld   r23,x+
    tst  r23
    breq strspnf2
    ldd  r22,y+2
    ldd  r31,y+1
    ld   r30,y
    out  rampz,r22
strspnf1:
    elpm r0,z+
    tst  r0
    breq strspnf2
    cp   r23,r0
    brne strspnf1
    adiw r24,1
    rjmp strspnf0
strspnf2:
    movw r30,r24
_0x20E0003:
_0x20E0004:
	ADIW R28,6
	RET
_strtok:
	CALL __PUTPARD2
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,0
	BRNE _0x2080003
	LDS  R30,_p_S1040026000
	LDS  R31,_p_S1040026000+1
	SBIW R30,0
	BRNE _0x2080004
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E0002
_0x2080004:
	LDS  R30,_p_S1040026000
	LDS  R31,_p_S1040026000+1
	STD  Y+6,R30
	STD  Y+6+1,R31
_0x2080003:
	CALL SUBOPT_0x74
	CALL SUBOPT_0x31
	CALL _strspnf
	CALL SUBOPT_0x77
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R30,X
	CPI  R30,0
	BRNE _0x2080005
	LDI  R30,LOW(0)
	STS  _p_S1040026000,R30
	STS  _p_S1040026000+1,R30
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E0002
_0x2080005:
	CALL SUBOPT_0x74
	CALL SUBOPT_0x31
	CALL _strpbrkf
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x2080006
	MOVW R26,R16
	__ADDWRN 16,17,1
	LDI  R30,LOW(0)
	ST   X,R30
_0x2080006:
	__PUTWMRN _p_S1040026000,0,16,17
	LDD  R30,Y+6
	LDD  R31,Y+6+1
_0x20E0002:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,8
	RET

	.CSEG
_isdigit:
	ST   -Y,R26
    ldi  r30,1
    ld   r31,y+
    cpi  r31,'0'
    brlo isdigit0
    cpi  r31,'9'+1
    brlo isdigit1
isdigit0:
    clr  r30
isdigit1:
    ret
_isprint:
	ST   -Y,R26
    ldi  r30,1
    ld   r31,y+
    cpi  r31,32
    brlo isprint0
    cpi  r31,128
    brlo isprint1
isprint0:
    clr  r30
isprint1:
    ret
_isspace:
	ST   -Y,R26
    ldi  r30,1
    ld   r31,y+
    cpi  r31,' '
    breq isspace1
    cpi  r31,9
    brlo isspace0
    cpi  r31,13+1
    brlo isspace1
isspace0:
    clr  r30
isspace1:
    ret

	.CSEG
_ftrunc:
	CALL __PUTPARD2
   ldd  r23,y+3
   ldd  r22,y+2
   ldd  r31,y+1
   ld   r30,y
   bst  r23,7
   lsl  r23
   sbrc r22,7
   sbr  r23,1
   mov  r25,r23
   subi r25,0x7e
   breq __ftrunc0
   brcs __ftrunc0
   cpi  r25,24
   brsh __ftrunc1
   clr  r26
   clr  r27
   clr  r24
__ftrunc2:
   sec
   ror  r24
   ror  r27
   ror  r26
   dec  r25
   brne __ftrunc2
   and  r30,r26
   and  r31,r27
   and  r22,r24
   rjmp __ftrunc1
__ftrunc0:
   clt
   clr  r23
   clr  r30
   clr  r31
   clr  r22
__ftrunc1:
   cbr  r22,0x80
   lsr  r23
   brcc __ftrunc3
   sbr  r22,0x80
__ftrunc3:
   bld  r23,7
   ld   r26,y+
   ld   r27,y+
   ld   r24,y+
   ld   r25,y+
   cp   r30,r26
   cpc  r31,r27
   cpc  r22,r24
   cpc  r23,r25
   bst  r25,7
   ret
_floor:
	CALL __PUTPARD2
	RCALL SUBOPT_0x20
	CALL _ftrunc
	RCALL SUBOPT_0x1E
    brne __floor1
__floor0:
	RCALL SUBOPT_0x1A
	RJMP _0x20E0001
__floor1:
    brtc __floor0
	RCALL SUBOPT_0x1A
	__GETD2N 0x3F800000
	CALL __SUBF12
_0x20E0001:
	ADIW R28,4
	RET

	.DSEG
_prtc_get_time:
	.BYTE 0x4
_prtc_get_date:
	.BYTE 0x4
_flag_PackageTerminate3:
	.BYTE 0x1
_rxPackage3:
	.BYTE 0x40
_rx_buffer0:
	.BYTE 0x2
_rx0Buffer:
	.BYTE 0x190
_rxBeginCount:
	.BYTE 0x2
_rx_rd_index0:
	.BYTE 0x2
_rx_counter0:
	.BYTE 0x2
_index0Buffer:
	.BYTE 0x2
_hwCalId:
	.BYTE 0x2
_pviQueueSensorToMang:
	.BYTE 0x2
_pviQueueMangToConfig:
	.BYTE 0x2
_pviQueueDeviceToMang:
	.BYTE 0x2
_viRXData:
	.BYTE 0x12E
_viDataReport:
	.BYTE 0x66
_viStatusReport:
	.BYTE 0x66
_viEventReport:
	.BYTE 0x66
_baseCounter:
	.BYTE 0x4
_countTimerIntpTask:
	.BYTE 0x2

	.ESEG
_DEVICE_SERIAL:
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x2,0x22

	.DSEG
_ETH_current_mode:
	.BYTE 0x1
_viDataReportBuff:
	.BYTE 0x31
_viStatusReportBuff:
	.BYTE 0x6
_pviUart0TimeOut:
	.BYTE 0x2
_wiz100srSetTimer:
	.BYTE 0x2

	.ESEG
_viFlagTerInit:
	.DB  0x0

	.DSEG
_iWizRXMode:
	.BYTE 0x1
_iWizData:
	.BYTE 0x4
_iHTTPStatus:
	.BYTE 0x4
_sdFreeSpace:
	.BYTE 0x4
_viFolderDataName:
	.BYTE 0x7
_viFolderDataLogName:
	.BYTE 0x4
_viFolderEventName:
	.BYTE 0x6
_viFolderStatusName:
	.BYTE 0x7
_viFolderErrorName:
	.BYTE 0x6
_viFolderConfigName:
	.BYTE 0x7
_viDirDataPath:
	.BYTE 0xA
_viDirDataLogPath:
	.BYTE 0x7
_viDirEventPath:
	.BYTE 0x9
_viDirStatusPath:
	.BYTE 0xA
_viDirErrorPath:
	.BYTE 0x9
_viDirConfigPath:
	.BYTE 0xA
_viDataFName:
	.BYTE 0x10

	.ESEG
_viLineID:
	.DB  0x0,0x0
_viDVConfigUpdate:
	.BYTE 0x18D

	.DSEG
_raw_rtc:
	.BYTE 0x4
_adcData:
	.BYTE 0x14

	.ESEG
_eep_vref_val:
	.DB  0xA,0xD7,0x23,0x40

	.DSEG
_LOGFILE_DATA:
	.BYTE 0x9
_LOGFILE_EVENT:
	.BYTE 0xA
_LOGFILE_ERROR:
	.BYTE 0xA
_LOG_INIT_STR:
	.BYTE 0x10
_isDataLogEmpty:
	.BYTE 0x1
_isEventLogEmpty:
	.BYTE 0x1
_adcBatt:
	.BYTE 0x4
_sensorCalConfig:
	.BYTE 0xC

	.ESEG
_sensorCalulate:
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0

	.DSEG
_pfCalibrate:
	.BYTE 0x4
_dhtDevice:
	.BYTE 0xA
_dataQ:
	.BYTE 0x64
_last_wr_dataQ:
	.BYTE 0x2
_last_rd_dataQ:
	.BYTE 0x2
_dataQ_len:
	.BYTE 0x2
_eventQ:
	.BYTE 0x78
_last_wr_eventQ:
	.BYTE 0x2
_last_rd_eventQ:
	.BYTE 0x2
_eventQ_len:
	.BYTE 0x2
_fat:
	.BYTE 0x232
_pfat:
	.BYTE 0x2
_root_path:
	.BYTE 0x4
_eventLogQueue:
	.BYTE 0x8C
_eventLogQCount:
	.BYTE 0x1
_dataLogQueue:
	.BYTE 0x6E
_dataLogQCount:
	.BYTE 0x1
_n:
	.BYTE 0x2
_a:
	.BYTE 0x30
_iPTC_RX:
	.BYTE 0x16
_viMangQueue:
	.BYTE 0x12
_task_count_g:
	.BYTE 0x2
_pviTaskList:
	.BYTE 0xC
_iWiz100srConfig:
	.BYTE 0x59
_pfiWiz100rs:
	.BYTE 0x4
_viDataConfig:
	.BYTE 0x7

	.ESEG
_viDate_e:
	.DB  0x0,0x0,0x0,0x0

	.DSEG
_status_G100:
	.BYTE 0x1
_timer1_G100:
	.BYTE 0x1
_timer2_G100:
	.BYTE 0x1
_card_type_G100:
	.BYTE 0x1
_pv_S100000B000:
	.BYTE 0x1
_FatFs_G101:
	.BYTE 0x2
_Fsid_G101:
	.BYTE 0x2
_Drive_G101:
	.BYTE 0x1
__seed_G103:
	.BYTE 0x4
_p_S1040026000:
	.BYTE 0x2

	.CSEG
;OPTIMIZER ADDED SUBROUTINE, CALLED 98 TIMES, CODE SIZE REDUCTION:385 WORDS
SUBOPT_0x0:
	CALL __PUTPARD1
	LDI  R24,0
	CALL _printDebug
	ADIW R28,4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(18)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0x2:
	LDI  R24,0
	CALL _printDebug
	ADIW R28,4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x3:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(7)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x4:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(1)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:24 WORDS
SUBOPT_0x5:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(5)
	LDI  R27,0
	CALL _iTaskCreate
	MOVW R6,R30
	MOV  R0,R6
	OR   R0,R7
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:24 WORDS
SUBOPT_0x6:
	CALL __PUTPARD1
	MOVW R30,R6
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	LDI  R24,4
	CALL _printDebug
	ADIW R28,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 19 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0x7:
	LDI  R26,LOW(2)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x8:
	LDI  R26,LOW(100)
	LDI  R27,0
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x9:
	LDI  R27,0
	JMP  _enable_interrupt

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:29 WORDS
SUBOPT_0xA:
	STS  258,R30
	LDI  R26,LOW(200)
	LDI  R27,0
	CALL _delay_ms
	LDS  R30,258
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xB:
	LDI  R26,LOW(50)
	LDI  R27,0
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:42 WORDS
SUBOPT_0xC:
	ST   -Y,R0
	ST   -Y,R1
	ST   -Y,R15
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R24
	ST   -Y,R25
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,RAMPZ
	ST   -Y,R30
	IN   R30,EIND
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD:
	CALL __SAVELOCR4
	__GETWRN 18,19,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:16 WORDS
SUBOPT_0xE:
	LDI  R26,LOW(_index0Buffer)
	LDI  R27,HIGH(_index0Buffer)
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	SBIW R30,1
	SUBI R30,LOW(-_rx0Buffer)
	SBCI R31,HIGH(-_rx0Buffer)
	ST   Z,R16
	MOV  R26,R16
	CALL _putchar3
	LDS  R26,_index0Buffer
	LDS  R27,_index0Buffer+1
	CPI  R26,LOW(0x190)
	LDI  R30,HIGH(0x190)
	CPC  R27,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xF:
	CALL _send_uart
	LDI  R30,LOW(3)
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x10:
	CALL _send_uart
	LDI  R30,LOW(0)
	STS  _index0Buffer,R30
	STS  _index0Buffer+1,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x11:
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x12:
	LDS  R26,_index0Buffer
	LDS  R27,_index0Buffer+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x13:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	ST   -Y,R16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x14:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	CP   R16,R30
	CPC  R17,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x15:
	ADD  R26,R30
	ADC  R27,R31
	LD   R26,X
	JMP  _putchar0

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x16:
	LDI  R31,0
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x17:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	LD   R30,X
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x18:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	LD   R26,X
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x19:
	CALL __PUTPARD2
	CALL __GETD1S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x1A:
	CALL __GETD1S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x1B:
	LDS  R26,_baseCounter
	LDS  R27,_baseCounter+1
	LDS  R24,_baseCounter+2
	LDS  R25,_baseCounter+3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 19 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0x1C:
	__GETD1S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x1D:
	__GETD1N 0xFFFFFFFF
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x1E:
	CALL __PUTD1S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x1F:
	LDS  R30,_baseCounter
	LDS  R31,_baseCounter+1
	LDS  R22,_baseCounter+2
	LDS  R23,_baseCounter+3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x20:
	CALL __GETD2S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x21:
	CALL __PUTPARD1
	__GETD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x22:
	CALL __PUTPARD1
	LDI  R24,12
	CALL _printDebug
	ADIW R28,16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 56 TIMES, CODE SIZE REDUCTION:107 WORDS
SUBOPT_0x23:
	__GETD1N 0x0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x24:
	LDI  R30,LOW(254)
	STS  133,R30
	LDI  R30,LOW(121)
	STS  132,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x25:
	LDI  R30,LOW(133)
	STS  149,R30
	LDI  R30,LOW(237)
	STS  148,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x26:
	CALL __GETD1P_INC
	__SUBD1N -1
	CALL __PUTDP1_DEC
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x27:
	LDI  R30,LOW(133)
	STS  165,R30
	LDI  R30,LOW(237)
	STS  164,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x28:
	ST   -Y,R27
	ST   -Y,R26
	LD   R30,Y
	LDD  R31,Y+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:77 WORDS
SUBOPT_0x29:
	IN   R30,0x6
	ANDI R30,LOW(0xC0)
	LDI  R31,0
	CALL __ASRW2
	CALL __ASRW4
	COM  R30
	COM  R31
	ANDI R30,LOW(0x3)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x2A:
	IN   R30,0x6
	ANDI R30,LOW(0xC0)
	LDI  R31,0
	CALL __ASRW2
	CALL __ASRW4
	COM  R30
	COM  R31
	ANDI R30,LOW(0x3)
	ANDI R31,HIGH(0x3)
	SBIW R30,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x2B:
	LDI  R26,LOW(20)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x2C:
	CLR  R22
	CLR  R23
	CALL __CDF1
	CALL __PUTDP1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x2D:
	CALL _i2c_start
	LDI  R26,LOW(208)
	JMP  _i2c_write

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x2E:
	CALL _i2c_write
	JMP  _i2c_stop

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2F:
	LDI  R26,LOW(10)
	LDI  R27,0
	CALL _delay_ms
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 24 TIMES, CODE SIZE REDUCTION:43 WORDS
SUBOPT_0x30:
	__PUTD1S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 28 TIMES, CODE SIZE REDUCTION:51 WORDS
SUBOPT_0x31:
	__GETD2S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x32:
	LDI  R30,LOW(8)
	CALL __LSLD12
	RJMP SUBOPT_0x30

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x33:
	MOV  R30,R19
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x34:
	RCALL SUBOPT_0x31
	CALL __CWD1
	CALL __ADDD12
	RCALL SUBOPT_0x30
	RCALL SUBOPT_0x31
	RJMP SUBOPT_0x32

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x35:
	MOV  R30,R16
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x36:
	MOV  R30,R17
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x37:
	CALL __CWD1
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x38:
	RCALL SUBOPT_0x30
	RJMP SUBOPT_0x1C

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x39:
	__GETD1N 0x3C
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3A:
	__PUTD1S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x3B:
	__GETD2N 0x3C
	CALL __MULD12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 16 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x3C:
	__GETD2S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x3D:
	__PUTD1S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x3E:
	__GETD1S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x3F:
	__GETD2S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x40:
	__GETD1S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x41:
	__PUTD1S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x42:
	RCALL SUBOPT_0x3C
	__GETD1N 0x5B5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x43:
	__PUTD1S 30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x44:
	__PUTD1S 26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x45:
	__GETD2S 26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x46:
	__CPD2N 0x3C
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x47:
	__SUBD1N -1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x48:
	__GETD2S 30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x49:
	__GETD1S 38
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x4A:
	CALL __SWAPD12
	CALL __SUBD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x4B:
	__PUTD1S 22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x4C:
	__GETD1S 22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x4D:
	__GETD1S 34
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x4E:
	__GETD1S 26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x4F:
	__GETD2S 22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x50:
	__ADDD1N 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x51:
	__GETD1S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x52:
	__GETD1S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x53:
	__GETD1S 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x54:
	__PUTD1S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:45 WORDS
SUBOPT_0x55:
	__GETD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0x56:
	__GETD2S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:45 WORDS
SUBOPT_0x57:
	__GETD2S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 16 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x58:
	__GETD1S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x59:
	__GETD1S 20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5A:
	CALL __PUTPARD1
	__GETD1S 16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5B:
	RCALL SUBOPT_0x55
	CALL __LSRD16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x5C:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	ST   -Y,R17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5D:
	RCALL SUBOPT_0x3D
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:62 WORDS
SUBOPT_0x5E:
	__CPD2N 0xFFFFFFFF
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 31 TIMES, CODE SIZE REDUCTION:57 WORDS
SUBOPT_0x5F:
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x60:
	MOVW R30,R28
	LDI  R26,26
	CALL __PUTPARL
	JMP  _printRTC

;OPTIMIZER ADDED SUBROUTINE, CALLED 24 TIMES, CODE SIZE REDUCTION:89 WORDS
SUBOPT_0x61:
	CALL __PUTPARD1
	LDI  R24,4
	CALL _printDebug
	ADIW R28,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x62:
	CALL __PUTPARD1
	LDI  R30,LOW(_root_path)
	LDI  R31,HIGH(_root_path)
	RJMP SUBOPT_0x5F

;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:45 WORDS
SUBOPT_0x63:
	LDI  R24,4
	CALL _printDebug
	ADIW R28,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0x64:
	CALL _error
	LDI  R30,LOW(0)
	STS  _sdFreeSpace,R30
	STS  _sdFreeSpace+1,R30
	STS  _sdFreeSpace+2,R30
	STS  _sdFreeSpace+3,R30
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x65:
	LDD  R30,Z+2
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x66:
	__GETD2S 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x67:
	CALL __CWD1
	CALL __MULD12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x68:
	LDS  R30,_sdFreeSpace
	LDS  R31,_sdFreeSpace+1
	LDS  R22,_sdFreeSpace+2
	LDS  R23,_sdFreeSpace+3
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x69:
	MOVW R30,R28
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6A:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6B:
	LDI  R26,LOW(1000)
	LDI  R27,HIGH(1000)
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6C:
	CALL __ADDW2R15
	CALL __GETD1P
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x6D:
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x6E:
	CALL __PUTPARD1
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x6F:
	CALL __CWD1
	RJMP SUBOPT_0x61

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x70:
	CALL __PUTPARD1
	MOVW R26,R20
	LD   R30,X
	CLR  R31
	CLR  R22
	CLR  R23
	RJMP SUBOPT_0x61

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x71:
	__POINTD1FN _0x2A0000,147
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x72:
	__POINTD1FN _0x2A0000,1170
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x73:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	LDI  R30,LOW(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x74:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x75:
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x76:
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	JMP  _print_hex_ascii_line

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x77:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x78:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,10
	LDI  R24,10
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0x79:
	LD   R30,X
	CLR  R31
	CLR  R22
	CLR  R23
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x7A:
	LD   R30,X
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x7B:
	CALL __PUTPARD1
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	RJMP SUBOPT_0x6F

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x7C:
	ST   -Y,R31
	ST   -Y,R30
	LDS  R26,_viRXData
	LDS  R27,_viRXData+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x7D:
	STD  Y+10,R30
	STD  Y+10+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:39 WORDS
SUBOPT_0x7E:
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x7F:
	LDI  R24,8
	CALL _printDebug
	ADIW R28,12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x80:
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR4
	__GETWRN 16,17,0
	__GETWRN 18,19,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x81:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:32 WORDS
SUBOPT_0x82:
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	ADIW R30,2
	ADD  R30,R16
	ADC  R31,R17
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:24 WORDS
SUBOPT_0x83:
	LDI  R27,0
	JMP  _memcpy

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x84:
	ST   -Y,R31
	ST   -Y,R30
	RJMP SUBOPT_0x7

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x85:
	CALL _memcpy
	__ADDWRN 16,17,2
	RJMP SUBOPT_0x82

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x86:
	MOVW R30,R28
	ADIW R30,8
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x87:
	MOVW R30,R28
	ADIW R30,16
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x88:
	ADD  R30,R16
	ADC  R31,R17
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:22 WORDS
SUBOPT_0x89:
	LDI  R30,LOW(8)
	STD  Y+24,R30
	LDI  R30,LOW(0)
	STD  Y+25,R30
	MOVW R30,R28
	SUBI R30,LOW(-(396))
	SBCI R31,HIGH(-(396))
	ST   -Y,R31
	ST   -Y,R30
	__POINTD1FN _0x340000,30
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,30
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,24
	JMP  _iPTCPack

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x8A:
	MOVW R26,R28
	SUBI R26,LOW(-(396))
	SBCI R27,HIGH(-(396))
	CALL _iLanWriteData
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x8B:
	MOVW R26,R28
	SUBI R26,LOW(-(94))
	SBCI R27,HIGH(-(94))
	CALL _iLanReadData
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x8C:
	MOVW R30,R28
	SUBI R30,LOW(-(88))
	SBCI R31,HIGH(-(88))
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	SUBI R30,LOW(-(96))
	SBCI R31,HIGH(-(96))
	ADIW R30,15
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(4)
	RJMP SUBOPT_0x83

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x8D:
	MOVW R26,R28
	SUBI R26,LOW(-(94))
	SBCI R27,HIGH(-(94))
	CALL _iPTCParser
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x8E:
	MOVW R26,R28
	SUBI R26,LOW(-(94))
	SBCI R27,HIGH(-(94))
	CALL _iTagParser
	MOVW R26,R28
	SUBI R26,LOW(-(94))
	SBCI R27,HIGH(-(94))
	JMP  _iPTCCheckHostReq

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x8F:
	__GETW2SX 92
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:29 WORDS
SUBOPT_0x90:
	__GETW1SX 96
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x91:
	__GETW1SX 90
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x92:
	MOVW R30,R28
	SUBI R30,LOW(-(396))
	SBCI R31,HIGH(-(396))
	ADIW R30,19
	MOVW R26,R30
	CALL _iMangCheckRetransmit
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x93:
	__GETW2SX 96
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x94:
	CALL _print_payload
	__POINTD1FN _0x340000,137
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x95:
	CALL __GETW1P
	MOVW R26,R30
	RJMP SUBOPT_0x94

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x96:
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	RJMP SUBOPT_0x95

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x97:
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x98:
	CALL __PUTPARD1
	MOVW R30,R20
	RJMP SUBOPT_0x5F

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x99:
	ADIW R30,2
	ADD  R30,R16
	ADC  R31,R17
	LD   R30,Z
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x9A:
	__POINTD1FN _0x340000,320
	RJMP SUBOPT_0x6E

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:39 WORDS
SUBOPT_0x9B:
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	ADIW R26,2
	MOVW R30,R16
	ADIW R30,1
	ADD  R26,R30
	ADC  R27,R31
	RJMP SUBOPT_0x79

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x9C:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,5
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R20
	JMP  _memcpye

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x9D:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R30,Z+4
	ANDI R30,LOW(0xF0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x9E:
	CLR  R31
	CLR  R22
	CLR  R23
	RJMP SUBOPT_0x61

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0x9F:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	CALL __SAVELOCR4
	__GETWRN 16,17,-1
	MOVW R30,R28
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	RJMP SUBOPT_0x84

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:42 WORDS
SUBOPT_0xA0:
	__MULBNWRU 18,19,9
	__ADDW1MN _viMangQueue,7
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xA1:
	MOVW R26,R30
	CALL __GETW1P
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 20 TIMES, CODE SIZE REDUCTION:35 WORDS
SUBOPT_0xA2:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:30 WORDS
SUBOPT_0xA3:
	__MULBNWRU 18,19,9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 24 TIMES, CODE SIZE REDUCTION:43 WORDS
SUBOPT_0xA4:
	CALL __GETW1P
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xA5:
	__ADDW1MN _viMangQueue,2
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,6
	RJMP SUBOPT_0x84

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA6:
	CALL __PUTPARD1
	LDD  R30,Y+8
	RJMP SUBOPT_0x7E

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xA7:
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	STD  Z+0,R26
	STD  Z+1,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0xA8:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA9:
	__POINTD1FN _0x340000,137
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0xAA:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	SBIW R30,1
	MOVW R0,R30
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xAB:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xAC:
	__POINTD1FN _0x340000,1162
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xAD:
	RCALL SUBOPT_0x48
	RCALL SUBOPT_0x4E
	CALL __SUBD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xAE:
	LDI  R27,0
	JMP  _malloc

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xAF:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL __MULW12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB0:
	MOVW R26,R16
	ADIW R26,8
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0xB1:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB2:
	LSL  R30
	ROL  R31
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB3:
	MOVW R26,R16
	ADIW R26,2
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xB4:
	SBIW R28,2
	LDI  R30,LOW(0)
	ST   Y,R30
	STD  Y+1,R30
	CALL __SAVELOCR6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB5:
	LDS  R30,_task_count_g
	LDS  R31,_task_count_g+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xB6:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDI  R26,LOW(_pviTaskList)
	LDI  R27,HIGH(_pviTaskList)
	LSL  R30
	ROL  R31
	ADD  R26,R30
	ADC  R27,R31
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB7:
	LSL  R30
	ROL  R31
	ADD  R26,R30
	ADC  R27,R31
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xB8:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xB9:
	CALL _malloc
	MOVW R16,R30
	MOV  R0,R16
	OR   R0,R17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0xBA:
	CALL _strlen
	MOVW R26,R30
	JMP  _memcpy

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:22 WORDS
SUBOPT_0xBB:
	CALL _strlen
	__ADDWRR 18,19,30,31
	MOVW R30,R18
	RJMP SUBOPT_0x88

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:18 WORDS
SUBOPT_0xBC:
	LDI  R30,LOW(0)
	STS  _index0Buffer,R30
	STS  _index0Buffer+1,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xBD:
	LDI  R27,0
	JMP  _memset

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xBE:
	MOVW R30,R28
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0xBF:
	LDI  R30,LOW(_rx0Buffer)
	LDI  R31,HIGH(_rx0Buffer)
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0x12
	JMP  _memcpy

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xC0:
	__POINTD2FN _0x420000,287
	CALL _strtok
	MOVW R18,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0xC1:
	__POINTD1FN _0x420000,289
	CALL __PUTPARD1
	MOVW R30,R18
	RJMP SUBOPT_0x5F

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0xC2:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC3:
	__GETD2N 0x3
	JMP  _TIMER_setTimer

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC4:
	MOVW R30,R28
	ADIW R30,10
	RJMP SUBOPT_0xA8

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC5:
	LDI  R26,LOW(400)
	LDI  R27,HIGH(400)
	JMP  _memset

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xC6:
	RCALL SUBOPT_0x12
	CALL __CPW02
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xC7:
	MOVW R30,R28
	ADIW R30,10
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:24 WORDS
SUBOPT_0xC8:
	__POINTD2FN _0x420000,15
	CALL _strtok
	__PUTW1SX 414
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0xC9:
	__GETW1SX 414
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xCA:
	RCALL SUBOPT_0xC9
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xCB:
	__POINTD2FN _0x420000,18
	CALL _strtok
	MOVW R20,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xCC:
	__POINTD2FN _0x420000,18
	CALL _strtok
	__PUTW1SX 420
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xCD:
	__GETW1SX 420
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xCE:
	__GETW1SX 418
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xCF:
	CALL _strlen
	MOV  R26,R16
	LDI  R27,0
	CP   R26,R30
	CPC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD0:
	__GETD2N 0x1
	JMP  _TIMER_setTimer

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD1:
	RCALL SUBOPT_0x31
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0xD2:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD3:
	__POINTD1FN _0x420000,356
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xD4:
	__POINTD1FN _0x420000,15
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD5:
	__POINTD1FN _0x420000,381
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD6:
	CLR  R30
	ADD  R26,R16
	ADC  R27,R30
	RJMP SUBOPT_0x79

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xD7:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xD8:
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	__POINTD2FN _0x420000,385
	CALL _strtok
	MOVW R16,R30
	LDI  R20,LOW(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xD9:
	__POINTD2FN _0x420000,385
	CALL _strtok
	MOVW R16,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0xDA:
	ADD  R30,R26
	ADC  R31,R27
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xDB:
	MOVW R30,R28
	ADIW R30,1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xDC:
	CALL _f_opendir
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xDD:
	MOV  R26,R17
	CALL _iFDisplayReturn
	CPI  R17,5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xDE:
	CALL _f_mkdir
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xDF:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	CALL __SAVELOCR6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE0:
	LDI  R26,LOW(544)
	LDI  R27,HIGH(544)
	RJMP SUBOPT_0xB9

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE1:
	CALL _f_chdir
	MOV  R19,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE2:
	CALL __PUTPARD1
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	RJMP SUBOPT_0x5F

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE3:
	CALL _f_open
	MOV  R19,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xE4:
	CALL __PUTPARD1
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	RJMP SUBOPT_0x5F

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xE5:
	CALL __PUTPARD1
	MOVW R30,R16
	__GETD2Z 10
	CALL __PUTPARD2
	RJMP SUBOPT_0x63

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xE6:
	__GETD2Z 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0xE7:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE8:
	MOVW R26,R16
	CALL _f_close
	MOV  R19,R30
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:32 WORDS
SUBOPT_0xE9:
	MOV  R26,R19
	CALL _iFDisplayReturn
	__POINTD1FN _0x4C0000,1331
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xEA:
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xEB:
	CALL __PUTPARD1
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	RJMP SUBOPT_0x5F

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xEC:
	LDI  R30,LOW(_viDirDataPath)
	LDI  R31,HIGH(_viDirDataPath)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(_viDataFName)
	LDI  R31,HIGH(_viDataFName)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xED:
	RCALL SUBOPT_0x40
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xEE:
	MOVW R26,R28
	ADIW R26,14
	RJMP SUBOPT_0xDA

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xEF:
	CALL _memcpy
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF0:
	LDI  R30,LOW(255)
	LDI  R31,HIGH(255)
	ST   -Y,R31
	ST   -Y,R30
	RJMP SUBOPT_0xEC

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF1:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(255)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF2:
	MOVW R30,R28
	ADIW R30,18
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xF3:
	STD  Y+1,R30
	CALL __SAVELOCR4
	LDI  R16,0
	LDI  R19,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xF4:
	LDI  R26,LOW(7)
	MUL  R17,R26
	MOVW R30,R0
	SUBI R30,LOW(-_viDataReportBuff)
	SBCI R31,HIGH(-_viDataReportBuff)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0xF5:
	__POINTW2MN _viDVConfigUpdate,170
	RJMP SUBOPT_0x36

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0xF6:
	MOVW R22,R26
	LDI  R26,LOW(28)
	LDI  R27,HIGH(28)
	CALL __MULW12U
	MOVW R26,R22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xF7:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,2
	RJMP SUBOPT_0x33

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xF8:
	MOV  R30,R19
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R31,0
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0xF9:
	LDI  R26,LOW(7)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _viDataReportBuff,3
	MOVW R26,R30
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 42 TIMES, CODE SIZE REDUCTION:79 WORDS
SUBOPT_0xFA:
	RCALL SUBOPT_0x23
	CALL __EEPROMWRD
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0xFB:
	LDI  R31,0
	CALL __CWD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0xFC:
	CALL __GETD1P_INC
	RCALL SUBOPT_0x50
	CALL __PUTDP1_DEC
	__SUBD1N 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xFD:
	CALL __GETD1P
	__PUTD1S 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xFE:
	__GETD1S 5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0xFF:
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0x1C
	CALL __PUTPARD1
	LDI  R26,LOW(1)
	JMP  _disk_write

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x100:
	__GETD2Z 34
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x101:
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0x58
	CALL __PUTPARD1
	LDI  R26,LOW(1)
	CALL _disk_read
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x102:
	ST   -Y,R31
	ST   -Y,R30
	__GETD2N 0x0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x103:
	CALL _move_window_G101
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x104:
	RCALL SUBOPT_0x23
	CALL __PUTDP1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x105:
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	JMP  _mem_set_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x106:
	CALL __PUTDZ20
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x107:
	CALL __GETD1P
	MOVW R26,R0
	CALL __PUTDP1
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x108:
	__GETD2Z 18
	CALL __PUTPARD2
	LDI  R26,LOW(1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:32 WORDS
SUBOPT_0x109:
	__CPD2N 0x2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x10A:
	__GETD1N 0x1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x10B:
	CALL __GETD1P
	RJMP SUBOPT_0x30

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x10C:
	MOVW R26,R18
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	CALL __DIVW21U
	RCALL SUBOPT_0x3C
	CLR  R22
	CLR  R23
	CALL __ADDD21
	CALL _move_window_G101
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x10D:
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,50
	MOVW R30,R18
	ANDI R31,HIGH(0x1FF)
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x10E:
	__GETD2S 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x10F:
	__GETD1N 0x100
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x110:
	RCALL SUBOPT_0x3C
	CALL __ADDD21
	CALL _move_window_G101
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x111:
	CALL __MULB1W2U
	ANDI R31,HIGH(0x1FF)
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,50
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x112:
	CALL __GETW1P
	CLR  R22
	CLR  R23
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x113:
	__GETD1N 0x80
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x114:
	CALL __GETD1P
	__ANDD1N 0xFFFFFFF
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x115:
	__GETD2S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
SUBOPT_0x116:
	MOVW R26,R16
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	CALL __DIVW21U
	RCALL SUBOPT_0x56
	CLR  R22
	CLR  R23
	CALL __ADDD21
	CALL _move_window_G101
	MOV  R21,R30
	CPI  R21,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x117:
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,50
	MOVW R30,R16
	ANDI R31,HIGH(0x1FF)
	ADD  R30,R26
	ADC  R31,R27
	MOVW R18,R30
	LDD  R30,Y+14
	ANDI R30,LOW(0x1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x118:
	__GETD2S 16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x119:
	RCALL SUBOPT_0x56
	CALL __ADDD21
	CALL _move_window_G101
	MOV  R21,R30
	CPI  R21,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x11A:
	CALL __MULB1W2U
	ANDI R31,HIGH(0x1FF)
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,50
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x11B:
	CALL __PUTDZ20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x11C:
	__GETD2S 5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x11D:
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,30
	CALL __GETD1P
	RCALL SUBOPT_0x11C
	CALL __CPD21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x11E:
	__GETD1S 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:37 WORDS
SUBOPT_0x11F:
	__CPD2N 0x1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x120:
	__GETD2N 0x0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x121:
	__GETD2Z 14
	RJMP SUBOPT_0x5E

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x122:
	__PUTD1S 5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x123:
	__GETD1S 16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x124:
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x125:
	__GETD2S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x126:
	CALL _get_fat
	__PUTD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x127:
	__GETD1N 0x2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x128:
	RCALL SUBOPT_0x1C
	RCALL SUBOPT_0x56
	CALL __CPD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x129:
	RCALL SUBOPT_0x55
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x12A:
	RCALL SUBOPT_0x57
	RJMP SUBOPT_0x5E

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x12B:
	RCALL SUBOPT_0x57
	RJMP SUBOPT_0x11F

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x12C:
	ADIW R30,30
	MOVW R26,R30
	CALL __GETD1P
	RCALL SUBOPT_0x3F
	CALL __CPD21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x12D:
	RCALL SUBOPT_0x3E
	__PUTD1SNS 8,10
	RJMP SUBOPT_0xA2

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x12E:
	CLR  R22
	CLR  R23
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x12F:
	ANDI R30,LOW(0xF)
	ANDI R31,HIGH(0xF)
	LSL  R30
	CALL __LSLW4
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x130:
	CALL __GETD1P
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x131:
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x132:
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	RJMP SUBOPT_0xA4

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x133:
	ADIW R30,30
	MOVW R26,R30
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x134:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x135:
	LDI  R27,0
	CALL _dir_seek_G101
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x136:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	RJMP SUBOPT_0xA4

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x137:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	__GETD2Z 14
	RJMP SUBOPT_0x103

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x138:
	ST   -Y,R19
	ST   -Y,R18
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+20
	LDD  R27,Z+21
	ST   -Y,R27
	ST   -Y,R26
	LDI  R26,LOW(11)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x139:
	ST   -Y,R19
	ST   -Y,R18
	RJMP SUBOPT_0xC2

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x13A:
	LDI  R27,0
	JMP  _mem_set_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x13B:
	LDI  R30,LOW(32)
	LDI  R31,HIGH(32)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(11)
	RJMP SUBOPT_0x13A

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x13C:
	CALL __GETW1P
	STD  Y+6,R30
	STD  Y+6+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x13D:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,1
	STD  Y+8,R30
	STD  Y+8+1,R31
	SBIW R30,1
	RJMP SUBOPT_0x81

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x13E:
	MOV  R30,R18
	SUBI R18,-1
	LDI  R31,0
	ADD  R30,R20
	ADC  R31,R21
	ST   Z,R16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x13F:
	LDI  R31,0
	ADD  R30,R20
	ADC  R31,R21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x140:
	__PUTD1SNS 6,6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x141:
	LDI  R26,LOW(0)
	LDI  R27,0
	CALL _dir_seek_G101
	MOV  R17,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x142:
	MOVW R26,R18
	ADIW R26,20
	RJMP SUBOPT_0x112

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x143:
	MOVW R26,R18
	ADIW R26,26
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x144:
	CLR  R22
	CLR  R23
	CALL __ORD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x145:
	CALL __PUTPARD1
	LDI  R26,LOW(1)
	CALL _disk_read
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x146:
	ADIW R30,50
	SUBI R30,LOW(-510)
	SBCI R31,HIGH(-510)
	MOVW R26,R30
	CALL __GETW1P
	CPI  R30,LOW(0xAA55)
	LDI  R26,HIGH(0xAA55)
	CPC  R31,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0x147:
	CALL __GETD1P
	__ANDD1N 0xFFFFFF
	__CPD1N 0x544146
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x148:
	LDI  R26,LOW(_FatFs_G101)
	LDI  R27,HIGH(_FatFs_G101)
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x149:
	__PUTD1S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x14A:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-64)
	SBCI R27,HIGH(-64)
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x14B:
	__PUTD1S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x14C:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+8
	LDD  R27,Z+9
	MOVW R30,R26
	CALL __LSRW4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x14D:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	RCALL SUBOPT_0x100
	RCALL SUBOPT_0x51
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x14E:
	CALL _chk_mounted
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x14F:
	MOVW R30,R28
	ADIW R30,4
	STD  Y+36,R30
	STD  Y+36+1,R31
	RJMP SUBOPT_0x87

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x150:
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x151:
	__SUBD1N 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x152:
	CALL _get_fattime
	RJMP SUBOPT_0x38

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x153:
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	RJMP SUBOPT_0xA4

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x154:
	LDD  R26,Z+2
	LDD  R27,Z+3
	CALL _validate_G101
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x155:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	__GETD2Z 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x156:
	MOVW R30,R26
	MOVW R22,R24
	ANDI R31,HIGH(0x1FF)
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x157:
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	__GETD2Z 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x158:
	__PUTD1S 16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x159:
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x80
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 16 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x15A:
	__PUTD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x15B:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	LDD  R30,Z+5
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x15C:
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	CALL __DIVW21U
	MOVW R20,R30
	MOV  R0,R20
	OR   R0,R21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x15D:
	LDD  R26,Y+26
	LDD  R27,Y+26+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x15E:
	LDD  R30,Z+2
	MOVW R26,R0
	LDI  R31,0
	CP   R30,R26
	CPC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x15F:
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x160:
	LDD  R30,Y+26
	LDD  R31,Y+26+1
	__GETD2Z 22
	RJMP SUBOPT_0x55

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x161:
	CALL __SUBD21
	MOVW R30,R20
	CLR  R22
	CLR  R23
	CALL __CPD21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x162:
	CALL __SUBD21
	__GETD1N 0x200
	CALL __MULD12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x163:
	ADIW R26,5
	LD   R30,X
	ADD  R30,R20
	ST   X,R30
	MOVW R30,R20
	LSL  R30
	ROL  R31
	MOV  R31,R30
	LDI  R30,0
	MOVW R18,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x164:
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+27
	LDD  R31,Y+27+1
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x165:
	__GETD2Z 22
	CALL __PUTPARD2
	LDI  R26,LOW(1)
	CALL _disk_write
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x166:
	ADIW R26,4
	LD   R30,X
	ANDI R30,0xBF
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x167:
	ADIW R26,5
	LD   R30,X
	SUBI R30,-LOW(1)
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x168:
	ADIW R26,6
	CALL __GETW1P
	ANDI R31,HIGH(0x1FF)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x169:
	ADIW R30,6
	MOVW R0,R30
	MOVW R26,R30
	CALL __GETD1P
	MOVW R26,R30
	MOVW R24,R22
	MOVW R30,R18
	RJMP SUBOPT_0x12E

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x16A:
	LD   R30,X+
	LD   R31,X+
	ADD  R30,R18
	ADC  R31,R19
	ST   -X,R31
	ST   -X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x16B:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	RJMP SUBOPT_0xA4

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x16C:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,10
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x16D:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	__GETD2Z 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x16E:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x16F:
	CALL _create_chain_G101
	RJMP SUBOPT_0x15A

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x170:
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	__GETD2Z 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x171:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x80
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x172:
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+23
	LDD  R31,Y+23+1
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x173:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R30,Z+5
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x174:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	__GETD2Z 22
	RJMP SUBOPT_0x58

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x175:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x176:
	__PUTW1RNS 18,26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x177:
	__PUTW1RNS 18,20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x178:
	__PUTD1RNS 18,22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x179:
	CALL _follow_path_G101
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x17A:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	RJMP SUBOPT_0xA4

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x17B:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,10
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x17C:
	__GETD2S 17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x17D:
	__PUTD1S 17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x17E:
	__PUTD1SNS 21,6
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x17F:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x180:
	__PUTD1S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x181:
	__GETD1S 17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x182:
	RCALL SUBOPT_0x151
	MOVW R26,R30
	MOVW R24,R22
	__GETD1S 9
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0x183:
	__GETD1S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x184:
	CALL __GETD1P
	__PUTD1S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x185:
	__GETD1S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x186:
	CALL _create_chain_G101
	__PUTD1S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x187:
	__GETD2S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x188:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x80
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x189:
	RCALL SUBOPT_0x185
	__PUTD1SNS 21,18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x18A:
	__GETD2S 15
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x18B:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	ADIW R30,6
	MOVW R0,R30
	MOVW R26,R30
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x18C:
	__GETD2S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x18D:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	__GETD2Z 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x18E:
	RCALL SUBOPT_0x51
	RCALL SUBOPT_0x47
	RJMP SUBOPT_0x149

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x18F:
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	RJMP SUBOPT_0x102

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x190:
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	ST   -Y,R31
	ST   -Y,R30
	RJMP SUBOPT_0x115

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x191:
	CALL SUBOPT_0x31
	__GETD1N 0x41200000
	CALL __MULF12
	JMP SUBOPT_0x30

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x192:
	CALL SUBOPT_0x1C
	RCALL SUBOPT_0x57
	CALL __CMPF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x193:
	RCALL SUBOPT_0x57
	__GETD1N 0x3DCCCCCD
	CALL __MULF12
	RCALL SUBOPT_0x15A
	SUBI R19,-LOW(1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x194:
	__GETD1N 0x41200000
	CALL __MULF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x195:
	__GETD2N 0x3F000000
	CALL __ADDF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x196:
	__GETD1N 0x3DCCCCCD
	CALL __MULF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x197:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,1
	STD  Y+8,R26
	STD  Y+8+1,R27
	SBIW R26,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x198:
	CALL __SWAPD12
	CALL __SUBF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x199:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,1
	STD  Y+8,R30
	STD  Y+8+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x19A:
	ST   -Y,R18
	LDD  R26,Y+7
	LDD  R27,Y+7+1
	RCALL SUBOPT_0x183
	OUT  EIND,R22
	EICALL
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0x19B:
	RCALL SUBOPT_0x90
	SBIW R30,4
	__PUTW1SX 96
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x19C:
	LDD  R26,Y+7
	LDD  R27,Y+7+1
	RCALL SUBOPT_0x183
	OUT  EIND,R22
	EICALL
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x19D:
	STD  Y+16,R30
	STD  Y+16+1,R31
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	CALL _strlen
	MOV  R17,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x19E:
	__PUTD1S 20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x19F:
	ANDI R16,LOW(251)
	LDD  R30,Y+25
	ST   -Y,R30
	__GETW2SX 91
	__GETD1SX 93
	OUT  EIND,R22
	EICALL
	CPI  R21,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1A0:
	__POINTD1M _put_buff_G102
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x1A1:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,1
	STD  Y+6,R26
	STD  Y+6+1,R27
	SBIW R26,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1A2:
	CALL SUBOPT_0x3E
	RJMP SUBOPT_0x18C

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x1A3:
	STS  __seed_G103,R30
	STS  __seed_G103+1,R31
	STS  __seed_G103+2,R22
	STS  __seed_G103+3,R23
	RET


	.CSEG
	.equ __i2c_dir=__i2c_port-1
	.equ __i2c_pin=__i2c_port-2

_i2c_init:
	cbi  __i2c_port,__scl_bit
	cbi  __i2c_port,__sda_bit
	sbi  __i2c_dir,__scl_bit
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_delay2
_i2c_start:
	cbi  __i2c_dir,__sda_bit
	cbi  __i2c_dir,__scl_bit
	clr  r30
	nop
	sbis __i2c_pin,__sda_bit
	ret
	sbis __i2c_pin,__scl_bit
	ret
	rcall __i2c_delay1
	sbi  __i2c_dir,__sda_bit
	rcall __i2c_delay1
	sbi  __i2c_dir,__scl_bit
	ldi  r30,1
__i2c_delay1:
	ldi  r22,13
	rjmp __i2c_delay2l
_i2c_stop:
	sbi  __i2c_dir,__sda_bit
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__sda_bit
__i2c_delay2:
	ldi  r22,27
__i2c_delay2l:
	dec  r22
	brne __i2c_delay2l
	ret
_i2c_read:
	ldi  r23,8
__i2c_read0:
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
__i2c_read3:
	sbis __i2c_pin,__scl_bit
	rjmp __i2c_read3
	rcall __i2c_delay1
	clc
	sbic __i2c_pin,__sda_bit
	sec
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	rol  r30
	dec  r23
	brne __i2c_read0
	mov  r23,r26
	tst  r23
	brne __i2c_read1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_read2
__i2c_read1:
	sbi  __i2c_dir,__sda_bit
__i2c_read2:
	rcall __i2c_delay1
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_delay1

_i2c_write:
	ldi  r23,8
__i2c_write0:
	lsl  r26
	brcc __i2c_write1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_write2
__i2c_write1:
	sbi  __i2c_dir,__sda_bit
__i2c_write2:
	rcall __i2c_delay2
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
__i2c_write3:
	sbis __i2c_pin,__scl_bit
	rjmp __i2c_write3
	rcall __i2c_delay1
	sbi  __i2c_dir,__scl_bit
	dec  r23
	brne __i2c_write0
	cbi  __i2c_dir,__sda_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	ldi  r30,1
	sbic __i2c_pin,__sda_bit
	clr  r30
	sbi  __i2c_dir,__scl_bit
	rjmp __i2c_delay1

_delay_ms:
	adiw r26,0
	breq __delay_ms1
__delay_ms0:
	__DELAY_USW 0x7D0
	wdr
	sbiw r26,1
	brne __delay_ms0
__delay_ms1:
	ret

__ANEGF1:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	BREQ __ANEGF10
	SUBI R23,0x80
__ANEGF10:
	RET

__ROUND_REPACK:
	TST  R21
	BRPL __REPACK
	CPI  R21,0x80
	BRNE __ROUND_REPACK0
	SBRS R30,0
	RJMP __REPACK
__ROUND_REPACK0:
	ADIW R30,1
	ADC  R22,R25
	ADC  R23,R25
	BRVS __REPACK1

__REPACK:
	LDI  R21,0x80
	EOR  R21,R23
	BRNE __REPACK0
	PUSH R21
	RJMP __ZERORES
__REPACK0:
	CPI  R21,0xFF
	BREQ __REPACK1
	LSL  R22
	LSL  R0
	ROR  R21
	ROR  R22
	MOV  R23,R21
	RET
__REPACK1:
	PUSH R21
	TST  R0
	BRMI __REPACK2
	RJMP __MAXRES
__REPACK2:
	RJMP __MINRES

__UNPACK:
	LDI  R21,0x80
	MOV  R1,R25
	AND  R1,R21
	LSL  R24
	ROL  R25
	EOR  R25,R21
	LSL  R21
	ROR  R24

__UNPACK1:
	LDI  R21,0x80
	MOV  R0,R23
	AND  R0,R21
	LSL  R22
	ROL  R23
	EOR  R23,R21
	LSL  R21
	ROR  R22
	RET

__CFD1U:
	SET
	RJMP __CFD1U0
__CFD1:
	CLT
__CFD1U0:
	PUSH R21
	RCALL __UNPACK1
	CPI  R23,0x80
	BRLO __CFD10
	CPI  R23,0xFF
	BRCC __CFD10
	RJMP __ZERORES
__CFD10:
	LDI  R21,22
	SUB  R21,R23
	BRPL __CFD11
	NEG  R21
	CPI  R21,8
	BRTC __CFD19
	CPI  R21,9
__CFD19:
	BRLO __CFD17
	SER  R30
	SER  R31
	SER  R22
	LDI  R23,0x7F
	BLD  R23,7
	RJMP __CFD15
__CFD17:
	CLR  R23
	TST  R21
	BREQ __CFD15
__CFD18:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	DEC  R21
	BRNE __CFD18
	RJMP __CFD15
__CFD11:
	CLR  R23
__CFD12:
	CPI  R21,8
	BRLO __CFD13
	MOV  R30,R31
	MOV  R31,R22
	MOV  R22,R23
	SUBI R21,8
	RJMP __CFD12
__CFD13:
	TST  R21
	BREQ __CFD15
__CFD14:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	DEC  R21
	BRNE __CFD14
__CFD15:
	TST  R0
	BRPL __CFD16
	RCALL __ANEGD1
__CFD16:
	POP  R21
	RET

__CDF1U:
	SET
	RJMP __CDF1U0
__CDF1:
	CLT
__CDF1U0:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	BREQ __CDF10
	CLR  R0
	BRTS __CDF11
	TST  R23
	BRPL __CDF11
	COM  R0
	RCALL __ANEGD1
__CDF11:
	MOV  R1,R23
	LDI  R23,30
	TST  R1
__CDF12:
	BRMI __CDF13
	DEC  R23
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R1
	RJMP __CDF12
__CDF13:
	MOV  R30,R31
	MOV  R31,R22
	MOV  R22,R1
	PUSH R21
	RCALL __REPACK
	POP  R21
__CDF10:
	RET

__SWAPACC:
	PUSH R20
	MOVW R20,R30
	MOVW R30,R26
	MOVW R26,R20
	MOVW R20,R22
	MOVW R22,R24
	MOVW R24,R20
	MOV  R20,R0
	MOV  R0,R1
	MOV  R1,R20
	POP  R20
	RET

__UADD12:
	ADD  R30,R26
	ADC  R31,R27
	ADC  R22,R24
	RET

__NEGMAN1:
	COM  R30
	COM  R31
	COM  R22
	SUBI R30,-1
	SBCI R31,-1
	SBCI R22,-1
	RET

__SUBF12:
	PUSH R21
	RCALL __UNPACK
	CPI  R25,0x80
	BREQ __ADDF129
	LDI  R21,0x80
	EOR  R1,R21

	RJMP __ADDF120

__ADDF12:
	PUSH R21
	RCALL __UNPACK
	CPI  R25,0x80
	BREQ __ADDF129

__ADDF120:
	CPI  R23,0x80
	BREQ __ADDF128
__ADDF121:
	MOV  R21,R23
	SUB  R21,R25
	BRVS __ADDF1211
	BRPL __ADDF122
	RCALL __SWAPACC
	RJMP __ADDF121
__ADDF122:
	CPI  R21,24
	BRLO __ADDF123
	CLR  R26
	CLR  R27
	CLR  R24
__ADDF123:
	CPI  R21,8
	BRLO __ADDF124
	MOV  R26,R27
	MOV  R27,R24
	CLR  R24
	SUBI R21,8
	RJMP __ADDF123
__ADDF124:
	TST  R21
	BREQ __ADDF126
__ADDF125:
	LSR  R24
	ROR  R27
	ROR  R26
	DEC  R21
	BRNE __ADDF125
__ADDF126:
	MOV  R21,R0
	EOR  R21,R1
	BRMI __ADDF127
	RCALL __UADD12
	BRCC __ADDF129
	ROR  R22
	ROR  R31
	ROR  R30
	INC  R23
	BRVC __ADDF129
	RJMP __MAXRES
__ADDF128:
	RCALL __SWAPACC
__ADDF129:
	RCALL __REPACK
	POP  R21
	RET
__ADDF1211:
	BRCC __ADDF128
	RJMP __ADDF129
__ADDF127:
	SUB  R30,R26
	SBC  R31,R27
	SBC  R22,R24
	BREQ __ZERORES
	BRCC __ADDF1210
	COM  R0
	RCALL __NEGMAN1
__ADDF1210:
	TST  R22
	BRMI __ADDF129
	LSL  R30
	ROL  R31
	ROL  R22
	DEC  R23
	BRVC __ADDF1210

__ZERORES:
	CLR  R30
	CLR  R31
	CLR  R22
	CLR  R23
	POP  R21
	RET

__MINRES:
	SER  R30
	SER  R31
	LDI  R22,0x7F
	SER  R23
	POP  R21
	RET

__MAXRES:
	SER  R30
	SER  R31
	LDI  R22,0x7F
	LDI  R23,0x7F
	POP  R21
	RET

__MULF12:
	PUSH R21
	RCALL __UNPACK
	CPI  R23,0x80
	BREQ __ZERORES
	CPI  R25,0x80
	BREQ __ZERORES
	EOR  R0,R1
	SEC
	ADC  R23,R25
	BRVC __MULF124
	BRLT __ZERORES
__MULF125:
	TST  R0
	BRMI __MINRES
	RJMP __MAXRES
__MULF124:
	PUSH R0
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	CLR  R17
	CLR  R18
	CLR  R25
	MUL  R22,R24
	MOVW R20,R0
	MUL  R24,R31
	MOV  R19,R0
	ADD  R20,R1
	ADC  R21,R25
	MUL  R22,R27
	ADD  R19,R0
	ADC  R20,R1
	ADC  R21,R25
	MUL  R24,R30
	RCALL __MULF126
	MUL  R27,R31
	RCALL __MULF126
	MUL  R22,R26
	RCALL __MULF126
	MUL  R27,R30
	RCALL __MULF127
	MUL  R26,R31
	RCALL __MULF127
	MUL  R26,R30
	ADD  R17,R1
	ADC  R18,R25
	ADC  R19,R25
	ADC  R20,R25
	ADC  R21,R25
	MOV  R30,R19
	MOV  R31,R20
	MOV  R22,R21
	MOV  R21,R18
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	POP  R0
	TST  R22
	BRMI __MULF122
	LSL  R21
	ROL  R30
	ROL  R31
	ROL  R22
	RJMP __MULF123
__MULF122:
	INC  R23
	BRVS __MULF125
__MULF123:
	RCALL __ROUND_REPACK
	POP  R21
	RET

__MULF127:
	ADD  R17,R0
	ADC  R18,R1
	ADC  R19,R25
	RJMP __MULF128
__MULF126:
	ADD  R18,R0
	ADC  R19,R1
__MULF128:
	ADC  R20,R25
	ADC  R21,R25
	RET

__DIVF21:
	PUSH R21
	RCALL __UNPACK
	CPI  R23,0x80
	BRNE __DIVF210
	TST  R1
__DIVF211:
	BRPL __DIVF219
	RJMP __MINRES
__DIVF219:
	RJMP __MAXRES
__DIVF210:
	CPI  R25,0x80
	BRNE __DIVF218
__DIVF217:
	RJMP __ZERORES
__DIVF218:
	EOR  R0,R1
	SEC
	SBC  R25,R23
	BRVC __DIVF216
	BRLT __DIVF217
	TST  R0
	RJMP __DIVF211
__DIVF216:
	MOV  R23,R25
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	CLR  R1
	CLR  R17
	CLR  R18
	CLR  R19
	CLR  R20
	CLR  R21
	LDI  R25,32
__DIVF212:
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	CPC  R20,R17
	BRLO __DIVF213
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R20,R17
	SEC
	RJMP __DIVF214
__DIVF213:
	CLC
__DIVF214:
	ROL  R21
	ROL  R18
	ROL  R19
	ROL  R1
	ROL  R26
	ROL  R27
	ROL  R24
	ROL  R20
	DEC  R25
	BRNE __DIVF212
	MOVW R30,R18
	MOV  R22,R1
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	TST  R22
	BRMI __DIVF215
	LSL  R21
	ROL  R30
	ROL  R31
	ROL  R22
	DEC  R23
	BRVS __DIVF217
__DIVF215:
	RCALL __ROUND_REPACK
	POP  R21
	RET

__CMPF12:
	TST  R25
	BRMI __CMPF120
	TST  R23
	BRMI __CMPF121
	CP   R25,R23
	BRLO __CMPF122
	BRNE __CMPF121
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	BRLO __CMPF122
	BREQ __CMPF123
__CMPF121:
	CLZ
	CLC
	RET
__CMPF122:
	CLZ
	SEC
	RET
__CMPF123:
	SEZ
	CLC
	RET
__CMPF120:
	TST  R23
	BRPL __CMPF122
	CP   R25,R23
	BRLO __CMPF121
	BRNE __CMPF122
	CP   R30,R26
	CPC  R31,R27
	CPC  R22,R24
	BRLO __CMPF122
	BREQ __CMPF123
	RJMP __CMPF121

__ADDW2R15:
	CLR  R0
	ADD  R26,R15
	ADC  R27,R0
	RET

__ADDD12:
	ADD  R30,R26
	ADC  R31,R27
	ADC  R22,R24
	ADC  R23,R25
	RET

__ADDD21:
	ADD  R26,R30
	ADC  R27,R31
	ADC  R24,R22
	ADC  R25,R23
	RET

__SUBD12:
	SUB  R30,R26
	SBC  R31,R27
	SBC  R22,R24
	SBC  R23,R25
	RET

__SUBD21:
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R25,R23
	RET

__ANDD12:
	AND  R30,R26
	AND  R31,R27
	AND  R22,R24
	AND  R23,R25
	RET

__ORD12:
	OR   R30,R26
	OR   R31,R27
	OR   R22,R24
	OR   R23,R25
	RET

__ANEGW1:
	NEG  R31
	NEG  R30
	SBCI R31,0
	RET

__ANEGD1:
	COM  R31
	COM  R22
	COM  R23
	NEG  R30
	SBCI R31,-1
	SBCI R22,-1
	SBCI R23,-1
	RET

__LSLB12:
	TST  R30
	MOV  R0,R30
	MOV  R30,R26
	BREQ __LSLB12R
__LSLB12L:
	LSL  R30
	DEC  R0
	BRNE __LSLB12L
__LSLB12R:
	RET

__LSLD12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	MOVW R22,R24
	BREQ __LSLD12R
__LSLD12L:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	DEC  R0
	BRNE __LSLD12L
__LSLD12R:
	RET

__LSRD12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	MOVW R22,R24
	BREQ __LSRD12R
__LSRD12L:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	DEC  R0
	BRNE __LSRD12L
__LSRD12R:
	RET

__LSLW4:
	LSL  R30
	ROL  R31
__LSLW3:
	LSL  R30
	ROL  R31
__LSLW2:
	LSL  R30
	ROL  R31
	LSL  R30
	ROL  R31
	RET

__ASRW4:
	ASR  R31
	ROR  R30
__ASRW3:
	ASR  R31
	ROR  R30
__ASRW2:
	ASR  R31
	ROR  R30
	ASR  R31
	ROR  R30
	RET

__LSRW4:
	LSR  R31
	ROR  R30
__LSRW3:
	LSR  R31
	ROR  R30
__LSRW2:
	LSR  R31
	ROR  R30
	LSR  R31
	ROR  R30
	RET

__LSRD1:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	RET

__LSLD1:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	RET

__LSRD16:
	MOV  R30,R22
	MOV  R31,R23
	LDI  R22,0
	LDI  R23,0
	RET

__LSLD16:
	MOV  R22,R30
	MOV  R23,R31
	LDI  R30,0
	LDI  R31,0
	RET

__CBD1:
	MOV  R31,R30
	ADD  R31,R31
	SBC  R31,R31
	MOV  R22,R31
	MOV  R23,R31
	RET

__CWD1:
	MOV  R22,R31
	ADD  R22,R22
	SBC  R22,R22
	MOV  R23,R22
	RET

__COMD1:
	COM  R30
	COM  R31
	COM  R22
	COM  R23
	RET

__MULW12U:
	MUL  R31,R26
	MOV  R31,R0
	MUL  R30,R27
	ADD  R31,R0
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	RET

__MULD12U:
	MUL  R23,R26
	MOV  R23,R0
	MUL  R22,R27
	ADD  R23,R0
	MUL  R31,R24
	ADD  R23,R0
	MUL  R30,R25
	ADD  R23,R0
	MUL  R22,R26
	MOV  R22,R0
	ADD  R23,R1
	MUL  R31,R27
	ADD  R22,R0
	ADC  R23,R1
	MUL  R30,R24
	ADD  R22,R0
	ADC  R23,R1
	CLR  R24
	MUL  R31,R26
	MOV  R31,R0
	ADD  R22,R1
	ADC  R23,R24
	MUL  R30,R27
	ADD  R31,R0
	ADC  R22,R1
	ADC  R23,R24
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	ADC  R22,R24
	ADC  R23,R24
	RET

__MULB1W2U:
	MOV  R22,R30
	MUL  R22,R26
	MOVW R30,R0
	MUL  R22,R27
	ADD  R31,R0
	RET

__MULW12:
	RCALL __CHKSIGNW
	RCALL __MULW12U
	BRTC __MULW121
	RCALL __ANEGW1
__MULW121:
	RET

__DIVB21U:
	CLR  R0
	LDI  R25,8
__DIVB21U1:
	LSL  R26
	ROL  R0
	SUB  R0,R30
	BRCC __DIVB21U2
	ADD  R0,R30
	RJMP __DIVB21U3
__DIVB21U2:
	SBR  R26,1
__DIVB21U3:
	DEC  R25
	BRNE __DIVB21U1
	MOV  R30,R26
	MOV  R26,R0
	RET

__DIVB21:
	RCALL __CHKSIGNB
	RCALL __DIVB21U
	BRTC __DIVB211
	NEG  R30
__DIVB211:
	RET

__DIVW21U:
	CLR  R0
	CLR  R1
	LDI  R25,16
__DIVW21U1:
	LSL  R26
	ROL  R27
	ROL  R0
	ROL  R1
	SUB  R0,R30
	SBC  R1,R31
	BRCC __DIVW21U2
	ADD  R0,R30
	ADC  R1,R31
	RJMP __DIVW21U3
__DIVW21U2:
	SBR  R26,1
__DIVW21U3:
	DEC  R25
	BRNE __DIVW21U1
	MOVW R30,R26
	MOVW R26,R0
	RET

__DIVD21U:
	PUSH R19
	PUSH R20
	PUSH R21
	CLR  R0
	CLR  R1
	CLR  R20
	CLR  R21
	LDI  R19,32
__DIVD21U1:
	LSL  R26
	ROL  R27
	ROL  R24
	ROL  R25
	ROL  R0
	ROL  R1
	ROL  R20
	ROL  R21
	SUB  R0,R30
	SBC  R1,R31
	SBC  R20,R22
	SBC  R21,R23
	BRCC __DIVD21U2
	ADD  R0,R30
	ADC  R1,R31
	ADC  R20,R22
	ADC  R21,R23
	RJMP __DIVD21U3
__DIVD21U2:
	SBR  R26,1
__DIVD21U3:
	DEC  R19
	BRNE __DIVD21U1
	MOVW R30,R26
	MOVW R22,R24
	MOVW R26,R0
	MOVW R24,R20
	POP  R21
	POP  R20
	POP  R19
	RET

__MODB21:
	CLT
	SBRS R26,7
	RJMP __MODB211
	NEG  R26
	SET
__MODB211:
	SBRC R30,7
	NEG  R30
	RCALL __DIVB21U
	MOV  R30,R26
	BRTC __MODB212
	NEG  R30
__MODB212:
	RET

__MODW21:
	CLT
	SBRS R27,7
	RJMP __MODW211
	COM  R26
	COM  R27
	ADIW R26,1
	SET
__MODW211:
	SBRC R31,7
	RCALL __ANEGW1
	RCALL __DIVW21U
	MOVW R30,R26
	BRTC __MODW212
	RCALL __ANEGW1
__MODW212:
	RET

__MODD21U:
	RCALL __DIVD21U
	MOVW R30,R26
	MOVW R22,R24
	RET

__CHKSIGNB:
	CLT
	SBRS R30,7
	RJMP __CHKSB1
	NEG  R30
	SET
__CHKSB1:
	SBRS R26,7
	RJMP __CHKSB2
	NEG  R26
	BLD  R0,0
	INC  R0
	BST  R0,0
__CHKSB2:
	RET

__CHKSIGNW:
	CLT
	SBRS R31,7
	RJMP __CHKSW1
	RCALL __ANEGW1
	SET
__CHKSW1:
	SBRS R27,7
	RJMP __CHKSW2
	COM  R26
	COM  R27
	ADIW R26,1
	BLD  R0,0
	INC  R0
	BST  R0,0
__CHKSW2:
	RET

__GETW1P:
	LD   R30,X+
	LD   R31,X
	SBIW R26,1
	RET

__GETD1P:
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X
	SBIW R26,3
	RET

__GETD1P_INC:
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X+
	RET

__PUTDP1:
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	RET

__PUTDP1_DEC:
	ST   -X,R23
	ST   -X,R22
	ST   -X,R31
	ST   -X,R30
	RET

__GETD1PF:
	OUT  RAMPZ,R22
	ELPM R0,Z+
	ELPM R1,Z+
	ELPM R22,Z+
	ELPM R23,Z
	MOVW R30,R0
	RET

__GETD1S0:
	LD   R30,Y
	LDD  R31,Y+1
	LDD  R22,Y+2
	LDD  R23,Y+3
	RET

__GETD2S0:
	LD   R26,Y
	LDD  R27,Y+1
	LDD  R24,Y+2
	LDD  R25,Y+3
	RET

__PUTD1S0:
	ST   Y,R30
	STD  Y+1,R31
	STD  Y+2,R22
	STD  Y+3,R23
	RET

__PUTDZ20:
	ST   Z,R26
	STD  Z+1,R27
	STD  Z+2,R24
	STD  Z+3,R25
	RET

__PUTPARD1:
	ST   -Y,R23
	ST   -Y,R22
	ST   -Y,R31
	ST   -Y,R30
	RET

__PUTPARD2:
	ST   -Y,R25
	ST   -Y,R24
	ST   -Y,R27
	ST   -Y,R26
	RET

__PUTPARL:
	CLR  R27
__PUTPAR:
	ADD  R30,R26
	ADC  R31,R27
__PUTPAR0:
	LD   R0,-Z
	ST   -Y,R0
	SBIW R26,1
	BRNE __PUTPAR0
	RET

__SWAPD12:
	MOV  R1,R24
	MOV  R24,R22
	MOV  R22,R1
	MOV  R1,R25
	MOV  R25,R23
	MOV  R23,R1

__SWAPW12:
	MOV  R1,R27
	MOV  R27,R31
	MOV  R31,R1

__SWAPB12:
	MOV  R1,R26
	MOV  R26,R30
	MOV  R30,R1
	RET

__EEPROMRDD:
	ADIW R26,2
	RCALL __EEPROMRDW
	MOVW R22,R30
	SBIW R26,2

__EEPROMRDW:
	ADIW R26,1
	RCALL __EEPROMRDB
	MOV  R31,R30
	SBIW R26,1

__EEPROMRDB:
	SBIC EECR,EEWE
	RJMP __EEPROMRDB
	PUSH R31
	IN   R31,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R30,EEDR
	OUT  SREG,R31
	POP  R31
	RET

__EEPROMWRD:
	RCALL __EEPROMWRW
	ADIW R26,2
	MOVW R0,R30
	MOVW R30,R22
	RCALL __EEPROMWRW
	MOVW R30,R0
	SBIW R26,2
	RET

__EEPROMWRW:
	RCALL __EEPROMWRB
	ADIW R26,1
	PUSH R30
	MOV  R30,R31
	RCALL __EEPROMWRB
	POP  R30
	SBIW R26,1
	RET

__EEPROMWRB:
	SBIS EECR,EEWE
	RJMP __EEPROMWRB1
	WDR
	RJMP __EEPROMWRB
__EEPROMWRB1:
	IN   R25,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R24,EEDR
	CP   R30,R24
	BREQ __EEPROMWRB0
	OUT  EEDR,R30
	SBI  EECR,EEMWE
	SBI  EECR,EEWE
__EEPROMWRB0:
	OUT  SREG,R25
	RET

__CPD10:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	RET

__CPW02:
	CLR  R0
	CP   R0,R26
	CPC  R0,R27
	RET

__CPD20:
	SBIW R26,0
	SBCI R24,0
	SBCI R25,0
	RET

__CPD02:
	CLR  R0
	CP   R0,R26
	CPC  R0,R27
	CPC  R0,R24
	CPC  R0,R25
	RET

__CPD12:
	CP   R30,R26
	CPC  R31,R27
	CPC  R22,R24
	CPC  R23,R25
	RET

__CPD21:
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	CPC  R25,R23
	RET

__SAVELOCR6:
	ST   -Y,R21
__SAVELOCR5:
	ST   -Y,R20
__SAVELOCR4:
	ST   -Y,R19
__SAVELOCR3:
	ST   -Y,R18
__SAVELOCR2:
	ST   -Y,R17
	ST   -Y,R16
	RET

__LOADLOCR6:
	LDD  R21,Y+5
__LOADLOCR5:
	LDD  R20,Y+4
__LOADLOCR4:
	LDD  R19,Y+3
__LOADLOCR3:
	LDD  R18,Y+2
__LOADLOCR2:
	LDD  R17,Y+1
	LD   R16,Y
	RET

__INITLOCB:
	CLR  R25
__INITLOCW:
	ADD  R26,R28
	ADC  R27,R29
	OUT  RAMPZ,R22
__INITLOC0:
	ELPM R0,Z+
	ST   X+,R0
	SBIW R24,1
	BRNE __INITLOC0
	RET

;END OF CODE MARKER
__END_OF_CODE:
