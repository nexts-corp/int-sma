
;CodeVisionAVR C Compiler V2.05.3 Standard
;(C) Copyright 1998-2011 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com

;Chip type                : ATmega2560
;Program type             : Application
;Clock frequency          : 8.000000 MHz
;Memory model             : Large
;Optimize for             : Size
;(s)printf features       : float, width, precision
;(s)scanf features        : long, width
;External RAM size        : 0
;Data Stack size          : 2800 byte(s)
;Heap size                : 2284 byte(s)
;Promote 'char' to 'int'  : Yes
;'char' is unsigned       : Yes
;8 bit enums              : Yes
;Global 'const' stored in FLASH     : Yes
;Enhanced function parameter passing: Yes
;Enhanced core instructions         : On
;Smart register allocation          : On
;Automatic register allocation      : On

	#pragma AVRPART ADMIN PART_NAME ATmega2560
	#pragma AVRPART MEMORY PROG_FLASH 262144
	#pragma AVRPART MEMORY EEPROM 4096
	#pragma AVRPART MEMORY INT_SRAM SIZE 8703
	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200

	#define CALL_SUPPORTED 1

	.LISTMAC
	.EQU EERE=0x0
	.EQU EEWE=0x1
	.EQU EEMWE=0x2
	.EQU UDRE=0x5
	.EQU RXC=0x7
	.EQU EECR=0x1F
	.EQU EEDR=0x20
	.EQU EEARL=0x21
	.EQU EEARH=0x22
	.EQU SPSR=0x2D
	.EQU SPDR=0x2E
	.EQU SMCR=0x33
	.EQU MCUSR=0x34
	.EQU MCUCR=0x35
	.EQU WDTCSR=0x60
	.EQU UCSR0A=0xC0
	.EQU UDR0=0xC6
	.EQU RAMPZ=0x3B
	.EQU EIND=0x3C
	.EQU SPL=0x3D
	.EQU SPH=0x3E
	.EQU SREG=0x3F
	.EQU XMCRA=0x74
	.EQU XMCRB=0x75
	.EQU GPIOR0=0x1E

	.DEF R0X0=R0
	.DEF R0X1=R1
	.DEF R0X2=R2
	.DEF R0X3=R3
	.DEF R0X4=R4
	.DEF R0X5=R5
	.DEF R0X6=R6
	.DEF R0X7=R7
	.DEF R0X8=R8
	.DEF R0X9=R9
	.DEF R0XA=R10
	.DEF R0XB=R11
	.DEF R0XC=R12
	.DEF R0XD=R13
	.DEF R0XE=R14
	.DEF R0XF=R15
	.DEF R0X10=R16
	.DEF R0X11=R17
	.DEF R0X12=R18
	.DEF R0X13=R19
	.DEF R0X14=R20
	.DEF R0X15=R21
	.DEF R0X16=R22
	.DEF R0X17=R23
	.DEF R0X18=R24
	.DEF R0X19=R25
	.DEF R0X1A=R26
	.DEF R0X1B=R27
	.DEF R0X1C=R28
	.DEF R0X1D=R29
	.DEF R0X1E=R30
	.DEF R0X1F=R31

	.EQU __SRAM_START=0x0200
	.EQU __SRAM_END=0x21FF
	.EQU __DSTACK_SIZE=0x0AF0
	.EQU __HEAP_SIZE=0x08EC
	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1

	.MACRO __CPD1N
	CPI  R30,LOW(@0)
	LDI  R26,HIGH(@0)
	CPC  R31,R26
	LDI  R26,BYTE3(@0)
	CPC  R22,R26
	LDI  R26,BYTE4(@0)
	CPC  R23,R26
	.ENDM

	.MACRO __CPD2N
	CPI  R26,LOW(@0)
	LDI  R30,HIGH(@0)
	CPC  R27,R30
	LDI  R30,BYTE3(@0)
	CPC  R24,R30
	LDI  R30,BYTE4(@0)
	CPC  R25,R30
	.ENDM

	.MACRO __CPWRR
	CP   R@0,R@2
	CPC  R@1,R@3
	.ENDM

	.MACRO __CPWRN
	CPI  R@0,LOW(@2)
	LDI  R30,HIGH(@2)
	CPC  R@1,R30
	.ENDM

	.MACRO __ADDB1MN
	SUBI R30,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDB2MN
	SUBI R26,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDW1MN
	SUBI R30,LOW(-@0-(@1))
	SBCI R31,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW2MN
	SUBI R26,LOW(-@0-(@1))
	SBCI R27,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	SBCI R22,BYTE3(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1N
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	SBCI R22,BYTE3(-@0)
	SBCI R23,BYTE4(-@0)
	.ENDM

	.MACRO __ADDD2N
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	SBCI R24,BYTE3(-@0)
	SBCI R25,BYTE4(-@0)
	.ENDM

	.MACRO __SUBD1N
	SUBI R30,LOW(@0)
	SBCI R31,HIGH(@0)
	SBCI R22,BYTE3(@0)
	SBCI R23,BYTE4(@0)
	.ENDM

	.MACRO __SUBD2N
	SUBI R26,LOW(@0)
	SBCI R27,HIGH(@0)
	SBCI R24,BYTE3(@0)
	SBCI R25,BYTE4(@0)
	.ENDM

	.MACRO __ANDBMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ANDWMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ANDI R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ANDD1N
	ANDI R30,LOW(@0)
	ANDI R31,HIGH(@0)
	ANDI R22,BYTE3(@0)
	ANDI R23,BYTE4(@0)
	.ENDM

	.MACRO __ANDD2N
	ANDI R26,LOW(@0)
	ANDI R27,HIGH(@0)
	ANDI R24,BYTE3(@0)
	ANDI R25,BYTE4(@0)
	.ENDM

	.MACRO __ORBMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ORWMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ORI  R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ORD1N
	ORI  R30,LOW(@0)
	ORI  R31,HIGH(@0)
	ORI  R22,BYTE3(@0)
	ORI  R23,BYTE4(@0)
	.ENDM

	.MACRO __ORD2N
	ORI  R26,LOW(@0)
	ORI  R27,HIGH(@0)
	ORI  R24,BYTE3(@0)
	ORI  R25,BYTE4(@0)
	.ENDM

	.MACRO __DELAY_USB
	LDI  R24,LOW(@0)
__DELAY_USB_LOOP:
	DEC  R24
	BRNE __DELAY_USB_LOOP
	.ENDM

	.MACRO __DELAY_USW
	LDI  R24,LOW(@0)
	LDI  R25,HIGH(@0)
__DELAY_USW_LOOP:
	SBIW R24,1
	BRNE __DELAY_USW_LOOP
	.ENDM

	.MACRO __GETD1S
	LDD  R30,Y+@0
	LDD  R31,Y+@0+1
	LDD  R22,Y+@0+2
	LDD  R23,Y+@0+3
	.ENDM

	.MACRO __GETD2S
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	LDD  R24,Y+@0+2
	LDD  R25,Y+@0+3
	.ENDM

	.MACRO __PUTD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R31
	STD  Y+@0+2,R22
	STD  Y+@0+3,R23
	.ENDM

	.MACRO __PUTD2S
	STD  Y+@0,R26
	STD  Y+@0+1,R27
	STD  Y+@0+2,R24
	STD  Y+@0+3,R25
	.ENDM

	.MACRO __PUTDZ2
	STD  Z+@0,R26
	STD  Z+@0+1,R27
	STD  Z+@0+2,R24
	STD  Z+@0+3,R25
	.ENDM

	.MACRO __CLRD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R30
	STD  Y+@0+2,R30
	STD  Y+@0+3,R30
	.ENDM

	.MACRO __POINTB1MN
	LDI  R30,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW1MN
	LDI  R30,LOW(@0+(@1))
	LDI  R31,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTD1M
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __POINTW1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	.ENDM

	.MACRO __POINTD1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	LDI  R22,BYTE3(2*@0+(@1))
	LDI  R23,BYTE4(2*@0+(@1))
	.ENDM

	.MACRO __POINTB2MN
	LDI  R26,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW2MN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTW2FN
	LDI  R26,LOW(2*@0+(@1))
	LDI  R27,HIGH(2*@0+(@1))
	.ENDM

	.MACRO __POINTD2FN
	LDI  R26,LOW(2*@0+(@1))
	LDI  R27,HIGH(2*@0+(@1))
	LDI  R24,BYTE3(2*@0+(@1))
	LDI  R25,BYTE4(2*@0+(@1))
	.ENDM

	.MACRO __POINTBRM
	LDI  R@0,LOW(@1)
	.ENDM

	.MACRO __POINTWRM
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __POINTBRMN
	LDI  R@0,LOW(@1+(@2))
	.ENDM

	.MACRO __POINTWRMN
	LDI  R@0,LOW(@2+(@3))
	LDI  R@1,HIGH(@2+(@3))
	.ENDM

	.MACRO __POINTWRFN
	LDI  R@0,LOW(@2*2+(@3))
	LDI  R@1,HIGH(@2*2+(@3))
	.ENDM

	.MACRO __GETD1N
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __GETD2N
	LDI  R26,LOW(@0)
	LDI  R27,HIGH(@0)
	LDI  R24,BYTE3(@0)
	LDI  R25,BYTE4(@0)
	.ENDM

	.MACRO __GETB1MN
	LDS  R30,@0+(@1)
	.ENDM

	.MACRO __GETB1HMN
	LDS  R31,@0+(@1)
	.ENDM

	.MACRO __GETW1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	.ENDM

	.MACRO __GETD1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	LDS  R22,@0+(@1)+2
	LDS  R23,@0+(@1)+3
	.ENDM

	.MACRO __GETBRMN
	LDS  R@0,@1+(@2)
	.ENDM

	.MACRO __GETWRMN
	LDS  R@0,@2+(@3)
	LDS  R@1,@2+(@3)+1
	.ENDM

	.MACRO __GETWRZ
	LDD  R@0,Z+@2
	LDD  R@1,Z+@2+1
	.ENDM

	.MACRO __GETD2Z
	LDD  R26,Z+@0
	LDD  R27,Z+@0+1
	LDD  R24,Z+@0+2
	LDD  R25,Z+@0+3
	.ENDM

	.MACRO __GETB2MN
	LDS  R26,@0+(@1)
	.ENDM

	.MACRO __GETW2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	.ENDM

	.MACRO __GETD2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	LDS  R24,@0+(@1)+2
	LDS  R25,@0+(@1)+3
	.ENDM

	.MACRO __PUTB1MN
	STS  @0+(@1),R30
	.ENDM

	.MACRO __PUTW1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	.ENDM

	.MACRO __PUTD1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	STS  @0+(@1)+2,R22
	STS  @0+(@1)+3,R23
	.ENDM

	.MACRO __PUTB1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRB
	.ENDM

	.MACRO __PUTW1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRW
	.ENDM

	.MACRO __PUTD1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRD
	.ENDM

	.MACRO __PUTBR0MN
	STS  @0+(@1),R0
	.ENDM

	.MACRO __PUTBMRN
	STS  @0+(@1),R@2
	.ENDM

	.MACRO __PUTWMRN
	STS  @0+(@1),R@2
	STS  @0+(@1)+1,R@3
	.ENDM

	.MACRO __PUTBZR
	STD  Z+@1,R@0
	.ENDM

	.MACRO __PUTWZR
	STD  Z+@2,R@0
	STD  Z+@2+1,R@1
	.ENDM

	.MACRO __GETW1R
	MOV  R30,R@0
	MOV  R31,R@1
	.ENDM

	.MACRO __GETW2R
	MOV  R26,R@0
	MOV  R27,R@1
	.ENDM

	.MACRO __GETWRN
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __PUTW1R
	MOV  R@0,R30
	MOV  R@1,R31
	.ENDM

	.MACRO __PUTW2R
	MOV  R@0,R26
	MOV  R@1,R27
	.ENDM

	.MACRO __ADDWRN
	SUBI R@0,LOW(-@2)
	SBCI R@1,HIGH(-@2)
	.ENDM

	.MACRO __ADDWRR
	ADD  R@0,R@2
	ADC  R@1,R@3
	.ENDM

	.MACRO __SUBWRN
	SUBI R@0,LOW(@2)
	SBCI R@1,HIGH(@2)
	.ENDM

	.MACRO __SUBWRR
	SUB  R@0,R@2
	SBC  R@1,R@3
	.ENDM

	.MACRO __ANDWRN
	ANDI R@0,LOW(@2)
	ANDI R@1,HIGH(@2)
	.ENDM

	.MACRO __ANDWRR
	AND  R@0,R@2
	AND  R@1,R@3
	.ENDM

	.MACRO __ORWRN
	ORI  R@0,LOW(@2)
	ORI  R@1,HIGH(@2)
	.ENDM

	.MACRO __ORWRR
	OR   R@0,R@2
	OR   R@1,R@3
	.ENDM

	.MACRO __EORWRR
	EOR  R@0,R@2
	EOR  R@1,R@3
	.ENDM

	.MACRO __GETWRS
	LDD  R@0,Y+@2
	LDD  R@1,Y+@2+1
	.ENDM

	.MACRO __PUTBSR
	STD  Y+@1,R@0
	.ENDM

	.MACRO __PUTWSR
	STD  Y+@2,R@0
	STD  Y+@2+1,R@1
	.ENDM

	.MACRO __MOVEWRR
	MOV  R@0,R@2
	MOV  R@1,R@3
	.ENDM

	.MACRO __INWR
	IN   R@0,@2
	IN   R@1,@2+1
	.ENDM

	.MACRO __OUTWR
	OUT  @2+1,R@1
	OUT  @2,R@0
	.ENDM

	.MACRO __GETBRPF
	OUT  RAMPZ,R22
	ELPM R@0,Z
	.ENDM

	.MACRO __GETBRPF_INC
	OUT  RAMPZ,R22
	ELPM R@0,Z+
	.ENDM

	.MACRO __CALL1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	LDS  R22,@0+(@1)+2
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	LDI  R22,BYTE3(2*@0+(@1))
	CALL __GETD1PF
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL1FX
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	SBCI R22,BYTE3(-@0)
	CALL __GETD1PF
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL2EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMRDD
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __CALL2EX
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	CALL __EEPROMRDD
	OUT  EIND,R22
	EICALL
	.ENDM

	.MACRO __GETW1STACK
	IN   R26,SPL
	IN   R27,SPH
	ADIW R26,@0+1
	LD   R30,X+
	LD   R31,X
	.ENDM

	.MACRO __GETD1STACK
	IN   R26,SPL
	IN   R27,SPH
	ADIW R26,@0+1
	LD   R30,X+
	LD   R31,X+
	LD   R22,X
	.ENDM

	.MACRO __NBST
	BST  R@0,@1
	IN   R30,SREG
	LDI  R31,0x40
	EOR  R30,R31
	OUT  SREG,R30
	.ENDM


	.MACRO __PUTB1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RNS
	MOVW R26,R@0
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	CALL __PUTDP1
	.ENDM


	.MACRO __GETB1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R30,Z
	.ENDM

	.MACRO __GETB1HSX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	.ENDM

	.MACRO __GETW1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R31,Z
	MOV  R30,R0
	.ENDM

	.MACRO __GETD1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R1,Z+
	LD   R22,Z+
	LD   R23,Z
	MOVW R30,R0
	.ENDM

	.MACRO __GETB2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R26,X
	.ENDM

	.MACRO __GETW2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	.ENDM

	.MACRO __GETD2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R1,X+
	LD   R24,X+
	LD   R25,X
	MOVW R26,R0
	.ENDM

	.MACRO __GETBRSX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	LD   R@0,Z
	.ENDM

	.MACRO __GETWRSX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	LD   R@0,Z+
	LD   R@1,Z
	.ENDM

	.MACRO __GETBRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	LD   R@0,X
	.ENDM

	.MACRO __GETWRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	LD   R@0,X+
	LD   R@1,X
	.ENDM

	.MACRO __LSLW8SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	CLR  R30
	.ENDM

	.MACRO __PUTB1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __CLRW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __CLRD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R30
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __PUTB2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z,R26
	.ENDM

	.MACRO __PUTW2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z,R27
	.ENDM

	.MACRO __PUTD2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z+,R27
	ST   Z+,R24
	ST   Z,R25
	.ENDM

	.MACRO __PUTBSRX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	ST   Z,R@0
	.ENDM

	.MACRO __PUTWSRX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	ST   Z+,R@0
	ST   Z,R@1
	.ENDM

	.MACRO __PUTB1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __MULBRR
	MULS R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRRU
	MUL  R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRR0
	MULS R@0,R@1
	.ENDM

	.MACRO __MULBRRU0
	MUL  R@0,R@1
	.ENDM

	.MACRO __MULBNWRU
	LDI  R26,@2
	MUL  R26,R@0
	MOVW R30,R0
	MUL  R26,R@1
	ADD  R31,R0
	.ENDM

;NAME DEFINITIONS FOR GLOBAL VARIABLES ALLOCATED TO REGISTERS
	.DEF _pviQueueData1=R4
	.DEF _piDeviceTask=R6
	.DEF _rxPackageIndex3=R9
	.DEF _rxPackageIndexCount3=R8
	.DEF _flagCountStart0=R10
	.DEF _rx0IndexWriteConn=R12

;GPIOR0 INITIALIZATION VALUE
	.EQU __GPIOR0_INIT=0x00

	.CSEG
	.ORG 0x00

;START OF CODE MARKER
__START_OF_CODE:

;INTERRUPT VECTORS
	JMP  __RESET
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _wdt_timeout_isr
	JMP  0x00
	JMP  0x00
	JMP  _timer2_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer1_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  _timer0_ovf_isr
	JMP  0x00
	JMP  _usart0_rx_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer3_ovf_isr
	JMP  _usart1_rx_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer4_ovf_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _usart2_rx_isr
	JMP  0x00
	JMP  0x00
	JMP  _usart3_rx_isr
	JMP  0x00
	JMP  0x00

_error_msg:
	.DB  LOW(_0x240000*2),HIGH(_0x240000*2),BYTE3(_0x240000*2),BYTE4(_0x240000*2),LOW(_0x240000*2+1),HIGH(_0x240000*2+1),BYTE3(_0x240000*2+1),BYTE4(_0x240000*2+1)
	.DB  LOW(_0x240000*2+13),HIGH(_0x240000*2+13),BYTE3(_0x240000*2+13),BYTE4(_0x240000*2+13),LOW(_0x240000*2+24),HIGH(_0x240000*2+24),BYTE3(_0x240000*2+24),BYTE4(_0x240000*2+24)
	.DB  LOW(_0x240000*2+37),HIGH(_0x240000*2+37),BYTE3(_0x240000*2+37),BYTE4(_0x240000*2+37),LOW(_0x240000*2+48),HIGH(_0x240000*2+48),BYTE3(_0x240000*2+48),BYTE4(_0x240000*2+48)
	.DB  LOW(_0x240000*2+59),HIGH(_0x240000*2+59),BYTE3(_0x240000*2+59),BYTE4(_0x240000*2+59),LOW(_0x240000*2+75),HIGH(_0x240000*2+75),BYTE3(_0x240000*2+75),BYTE4(_0x240000*2+75)
	.DB  LOW(_0x240000*2+85),HIGH(_0x240000*2+85),BYTE3(_0x240000*2+85),BYTE4(_0x240000*2+85),LOW(_0x240000*2+94),HIGH(_0x240000*2+94),BYTE3(_0x240000*2+94),BYTE4(_0x240000*2+94)
	.DB  LOW(_0x240000*2+112),HIGH(_0x240000*2+112),BYTE3(_0x240000*2+112),BYTE4(_0x240000*2+112),LOW(_0x240000*2+131),HIGH(_0x240000*2+131),BYTE3(_0x240000*2+131),BYTE4(_0x240000*2+131)
	.DB  LOW(_0x240000*2+148),HIGH(_0x240000*2+148),BYTE3(_0x240000*2+148),BYTE4(_0x240000*2+148),LOW(_0x240000*2+163),HIGH(_0x240000*2+163),BYTE3(_0x240000*2+163),BYTE4(_0x240000*2+163)
	.DB  LOW(_0x240000*2+180),HIGH(_0x240000*2+180),BYTE3(_0x240000*2+180),BYTE4(_0x240000*2+180),LOW(_0x240000*2+196),HIGH(_0x240000*2+196),BYTE3(_0x240000*2+196),BYTE4(_0x240000*2+196)
_cmdSetRTCDateTime:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x44,0x54,0x0
_cmdResetAlarmStatus:
	.DB  0x24,0x43,0x4D,0x44,0x52,0x41,0x53,0x0
_cmdClearLogFile:
	.DB  0x24,0x43,0x4D,0x44,0x43,0x4C,0x46,0x0
_cmdSetVref:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x56,0x52,0x0
_cmdSensorSelect:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x4E,0x53,0x0
_cmdDeviceEnable:
	.DB  0x24,0x43,0x4D,0x44,0x44,0x45,0x4E,0x0
_cmdDeviceDisable:
	.DB  0x24,0x43,0x4D,0x44,0x44,0x44,0x53,0x0
_cmdSetSerialNumber:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x53,0x4E,0x0
_cmdReadSerialNumber:
	.DB  0x24,0x43,0x4D,0x44,0x52,0x53,0x4E,0x0
_cmdGetCal:
	.DB  0x24,0x43,0x4D,0x44,0x47,0x43,0x4C,0x0
_cmdSetCal:
	.DB  0x24,0x43,0x4D,0x44,0x53,0x43,0x4C,0x0
_cmdConfirmCal:
	.DB  0x24,0x43,0x4D,0x44,0x43,0x43,0x4C,0x0
_cmdGetCurSensor:
	.DB  0x24,0x43,0x4D,0x44,0x47,0x43,0x53,0x0
_k1:
	.DB  0x20,0x22,0x2A,0x2B,0x2C,0x5B,0x3D,0x5D
	.DB  0x7C,0x7F,0x0

;HEAP START MARKER INITIALIZATION
__HEAP_START_MARKER:
	.DW  0,0

_0x3:
	.DB  0x0,0x0,0x44,0x61,0x74,0x61,0x20,0x54
	.DB  0x65,0x73,0x74,0x20,0x31,0x31,0x31,0x31
	.DB  0x31,0x31,0x31,0x39,0x39,0x39,0x39,0x39
	.DB  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39
	.DB  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39
	.DB  0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x30,0x3A,0x2E,0x2F,0x64,0x61,0x74,0x61
	.DB  0x37,0x2E,0x74,0x78,0x74,0x0,0x30,0x3A
	.DB  0x2F,0x44,0x41,0x54,0x41,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x30,0x3A,0x2F,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
_0x15:
	.DB  0x0,0x0,0x0,0x0
_0x0:
	.DB  0x3C,0x6D,0x61,0x69,0x6E,0x3E,0x53,0x65
	.DB  0x6D,0x69,0x2D,0x52,0x54,0x4F,0x53,0x2D
	.DB  0x56,0x31,0xD,0xA,0x0,0x5B,0x6D,0x61
	.DB  0x69,0x6E,0x5D,0x4C,0x61,0x6E,0x20,0x43
	.DB  0x6F,0x6E,0x6E,0x65,0x63,0x74,0x65,0x64
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x6D,0x61,0x69
	.DB  0x6E,0x5D,0x4C,0x61,0x6E,0x20,0x46,0x61
	.DB  0x69,0x6C,0x2E,0xD,0xA,0x0,0x5B,0x6D
	.DB  0x61,0x69,0x6E,0x5D,0x2C,0x70,0x76,0x69
	.DB  0x51,0x75,0x65,0x75,0x65,0x53,0x65,0x6E
	.DB  0x73,0x6F,0x72,0x54,0x6F,0x4D,0x61,0x6E
	.DB  0x67,0x20,0x63,0x61,0x6E,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x6D,0x61,0x69
	.DB  0x6E,0x5D,0x2C,0x70,0x76,0x69,0x51,0x75
	.DB  0x65,0x75,0x65,0x53,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x54,0x6F,0x4D,0x61,0x6E,0x67,0x20
	.DB  0x63,0x61,0x6E,0x20,0x63,0x72,0x65,0x61
	.DB  0x74,0x65,0x2E,0xD,0xA,0x0,0x5B,0x6D
	.DB  0x61,0x69,0x6E,0x5D,0x2C,0x70,0x76,0x69
	.DB  0x51,0x75,0x65,0x75,0x65,0x4D,0x61,0x6E
	.DB  0x67,0x54,0x6F,0x43,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x20,0x63,0x61,0x6E,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x6D,0x61,0x69
	.DB  0x6E,0x5D,0x2C,0x70,0x76,0x69,0x51,0x75
	.DB  0x65,0x75,0x65,0x4D,0x61,0x6E,0x67,0x54
	.DB  0x6F,0x43,0x6F,0x6E,0x66,0x69,0x67,0x20
	.DB  0x63,0x61,0x6E,0x20,0x63,0x72,0x65,0x61
	.DB  0x74,0x65,0x2E,0xD,0xA,0x0,0x5B,0x6D
	.DB  0x61,0x69,0x6E,0x5D,0x2C,0x70,0x76,0x69
	.DB  0x51,0x75,0x65,0x75,0x65,0x44,0x65,0x76
	.DB  0x69,0x63,0x65,0x54,0x6F,0x4D,0x61,0x6E
	.DB  0x67,0x20,0x63,0x61,0x6E,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x6D,0x61,0x69
	.DB  0x6E,0x5D,0x2C,0x70,0x76,0x69,0x51,0x75
	.DB  0x65,0x75,0x65,0x44,0x65,0x76,0x69,0x63
	.DB  0x65,0x54,0x6F,0x4D,0x61,0x6E,0x67,0x20
	.DB  0x63,0x61,0x6E,0x20,0x63,0x72,0x65,0x61
	.DB  0x74,0x65,0x2E,0xD,0xA,0x0,0x73,0x65
	.DB  0x6E,0x73,0x6F,0x72,0x0,0x3C,0x6D,0x61
	.DB  0x69,0x6E,0x3E,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x54,0x61,0x73,0x6B,0x20,0x61,0x64
	.DB  0x64,0x72,0x20,0x3A,0x20,0x25,0x70,0xD
	.DB  0xA,0x0
_0x20000:
	.DB  0xD,0xA,0x50,0x6F,0x77,0x65,0x72,0x2D
	.DB  0x6F,0x6E,0x20,0x52,0x65,0x73,0x65,0x74
	.DB  0xD,0xA,0x0,0xD,0xA,0x45,0x78,0x74
	.DB  0x65,0x72,0x6E,0x61,0x6C,0x20,0x52,0x65
	.DB  0x73,0x65,0x74,0xD,0xA,0x0,0xD,0xA
	.DB  0x42,0x72,0x6F,0x77,0x6E,0x2D,0x6F,0x75
	.DB  0x74,0x20,0x52,0x65,0x73,0x65,0x74,0xD
	.DB  0xA,0x0,0xD,0xA,0x57,0x61,0x74,0x63
	.DB  0x68,0x64,0x6F,0x67,0x20,0x52,0x65,0x73
	.DB  0x65,0x74,0xD,0xA,0x0,0xD,0xA,0x4A
	.DB  0x54,0x41,0x47,0x20,0x52,0x65,0x73,0x65
	.DB  0x74,0xD,0xA,0x0,0x3C,0x69,0x6E,0x69
	.DB  0x74,0x69,0x61,0x6C,0x5F,0x73,0x79,0x73
	.DB  0x74,0x65,0x6D,0x3E,0x20,0x4C,0x4F,0x47
	.DB  0x5F,0x69,0x6E,0x69,0x74,0x28,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x69,0x6E,0x69,0x74,0x69,0x61
	.DB  0x6C,0x5F,0x73,0x79,0x73,0x74,0x65,0x6D
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x69,0x6E,0x69
	.DB  0x74,0x28,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0
_0x40042:
	.DB  0x0,0x0,0x0,0x0
_0x40000:
	.DB  0xD,0xA,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0xD,0xA,0x0,0x21,0x21,0x21,0x21,0x21
	.DB  0x21,0x21,0x20,0x45,0x74,0x68,0x20,0x42
	.DB  0x75,0x66,0x66,0x65,0x72,0x20,0x4F,0x76
	.DB  0x65,0x72,0x66,0x6C,0x6F,0x77,0x20,0x21
	.DB  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21
	.DB  0x0
_0x60000:
	.DB  0x3C,0x54,0x49,0x4D,0x45,0x52,0x5F,0x73
	.DB  0x65,0x74,0x54,0x69,0x6D,0x65,0x72,0x3E
	.DB  0x20,0x45,0x52,0x52,0x3A,0x20,0x70,0x65
	.DB  0x72,0x69,0x6F,0x64,0x20,0x3D,0x20,0x30
	.DB  0xD,0xA,0x0,0x3C,0x54,0x49,0x4D,0x45
	.DB  0x52,0x5F,0x73,0x65,0x74,0x54,0x69,0x6D
	.DB  0x65,0x72,0x3E,0x20,0x62,0x61,0x73,0x65
	.DB  0x43,0x6F,0x75,0x6E,0x74,0x65,0x72,0x5B
	.DB  0x25,0x6C,0x64,0x5D,0x20,0x2B,0x20,0x70
	.DB  0x65,0x72,0x69,0x6F,0x64,0x5B,0x25,0x6C
	.DB  0x64,0x5D,0x20,0x3D,0x20,0x25,0x6C,0x64
	.DB  0x20,0x4F,0x56,0x45,0x52,0x46,0x4C,0x4F
	.DB  0x57,0x21,0x21,0xD,0xA,0x0,0x3C,0x57
	.DB  0x44,0x54,0x3E,0x20,0x57,0x61,0x74,0x63
	.DB  0x68,0x44,0x6F,0x67,0x20,0x54,0x69,0x6D
	.DB  0x65,0x72,0x20,0x52,0x65,0x73,0x65,0x74
	.DB  0x21,0x21,0xD,0xA,0x0
_0x80000:
	.DB  0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79,0x43
	.DB  0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B,0x65
	.DB  0x79,0x20,0x4D,0x4F,0x44,0x45,0xD,0xA
	.DB  0x0,0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79
	.DB  0x43,0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B
	.DB  0x65,0x79,0x20,0x55,0x50,0xD,0xA,0x0
	.DB  0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79,0x43
	.DB  0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B,0x65
	.DB  0x79,0x20,0x44,0x4F,0x57,0x4E,0xD,0xA
	.DB  0x0,0x3C,0x49,0x4F,0x5F,0x6B,0x65,0x79
	.DB  0x43,0x68,0x65,0x63,0x6B,0x3E,0x20,0x6B
	.DB  0x65,0x79,0x20,0x4F,0x4B,0xD,0xA,0x0
_0xA0000:
	.DB  0x49,0x6E,0x69,0x74,0x69,0x61,0x6C,0x69
	.DB  0x7A,0x69,0x6E,0x67,0x20,0x41,0x44,0x43
	.DB  0x2E,0x2E,0x20,0x0,0x4F,0x4B,0xD,0xA
	.DB  0x0
_0xC0003:
	.DB  0x63,0x0,0x0,0x0,0x63,0x0,0x0,0x0
	.DB  0x63,0x0,0x0,0x0
_0xC0000:
	.DB  0x63,0x5F,0x74,0x69,0x6D,0x65,0x5B,0x25
	.DB  0x6C,0x64,0x5D,0x20,0x26,0x20,0x73,0x5F
	.DB  0x74,0x69,0x6D,0x65,0x5B,0x25,0x6C,0x64
	.DB  0x5D,0x20,0x3D,0x3E,0x20,0x64,0x69,0x66
	.DB  0x66,0x5B,0x25,0x6C,0x64,0x5D,0xD,0xA
	.DB  0x0,0x3E,0x3E,0x20,0x52,0x54,0x43,0x5F
	.DB  0x73,0x65,0x74,0x42,0x69,0x6E,0x61,0x72
	.DB  0x79,0x20,0x52,0x54,0x43,0x20,0x53,0x79
	.DB  0x6E,0x63,0x2E,0xD,0xA,0x0,0x3C,0x52
	.DB  0x54,0x43,0x5F,0x73,0x65,0x74,0x44,0x61
	.DB  0x74,0x65,0x54,0x69,0x6D,0x65,0x3E,0x20
	.DB  0x54,0x69,0x6D,0x65,0x7A,0x6F,0x6E,0x65
	.DB  0x20,0x6F,0x75,0x74,0x20,0x6F,0x66,0x20
	.DB  0x72,0x61,0x6E,0x67,0x65,0x20,0x28,0x25
	.DB  0x2B,0x64,0x29,0xD,0xA,0x0,0x4D,0x6F
	.DB  0x6E,0x2E,0x20,0x0,0x54,0x75,0x65,0x2E
	.DB  0x20,0x0,0x57,0x65,0x64,0x2E,0x20,0x0
	.DB  0x54,0x68,0x75,0x2E,0x20,0x0,0x46,0x72
	.DB  0x69,0x2E,0x20,0x0,0x53,0x61,0x74,0x2E
	.DB  0x20,0x0,0x53,0x75,0x6E,0x2E,0x20,0x0
	.DB  0x5B,0x25,0x64,0x5D,0x25,0x30,0x34,0x64
	.DB  0x2D,0x25,0x30,0x32,0x64,0x2D,0x25,0x30
	.DB  0x32,0x64,0x20,0x25,0x30,0x32,0x64,0x3A
	.DB  0x25,0x30,0x32,0x64,0x3A,0x25,0x30,0x32
	.DB  0x64,0xD,0xA,0x0,0x52,0x75,0x6E,0x6E
	.DB  0x69,0x6E,0x67,0x20,0x77,0x69,0x74,0x68
	.DB  0x20,0x53,0x79,0x73,0x74,0x65,0x6D,0x20
	.DB  0x43,0x6C,0x6F,0x63,0x6B,0x20,0x40,0x20
	.DB  0x0
_0x120000:
	.DB  0x3C,0x45,0x54,0x48,0x5F,0x73,0x77,0x69
	.DB  0x74,0x63,0x68,0x4D,0x6F,0x64,0x65,0x3E
	.DB  0x20,0x73,0x77,0x69,0x74,0x63,0x68,0x20
	.DB  0x74,0x6F,0x20,0x43,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x20,0x6D,0x6F,0x64,0x65,0xD,0xA
	.DB  0x0,0x3C,0x45,0x54,0x48,0x5F,0x73,0x77
	.DB  0x69,0x74,0x63,0x68,0x4D,0x6F,0x64,0x65
	.DB  0x3E,0x20,0x73,0x77,0x69,0x74,0x63,0x68
	.DB  0x20,0x74,0x6F,0x20,0x4E,0x6F,0x72,0x6D
	.DB  0x61,0x6C,0x20,0x6D,0x6F,0x64,0x65,0xD
	.DB  0xA,0x0
_0x140000:
	.DB  0x3C,0x73,0x74,0x61,0x74,0x75,0x73,0x52
	.DB  0x65,0x71,0x75,0x65,0x73,0x74,0x50,0x61
	.DB  0x72,0x73,0x65,0x72,0x3E,0x20,0x6D,0x61
	.DB  0x6C,0x6C,0x6F,0x63,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x63
	.DB  0x6F,0x6E,0x66,0x69,0x67,0x4D,0x61,0x6E
	.DB  0x61,0x67,0x65,0x50,0x61,0x72,0x73,0x65
	.DB  0x72,0x3E,0xD,0xA,0x0,0x3C,0x63,0x6F
	.DB  0x6E,0x66,0x69,0x67,0x4D,0x61,0x6E,0x61
	.DB  0x67,0x65,0x50,0x61,0x72,0x73,0x65,0x72
	.DB  0x3E,0x20,0x52,0x45,0x41,0x44,0x49,0x4E
	.DB  0x47,0xD,0xA,0x0,0x3C,0x63,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x4D,0x61,0x6E,0x61,0x67
	.DB  0x65,0x50,0x61,0x72,0x73,0x65,0x72,0x3E
	.DB  0x20,0x57,0x52,0x49,0x54,0x49,0x4E,0x47
	.DB  0xD,0xA,0x0,0x3C,0x63,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x4D,0x61,0x6E,0x61,0x67,0x65
	.DB  0x50,0x61,0x72,0x73,0x65,0x72,0x3E,0x20
	.DB  0x63,0x6F,0x6E,0x66,0x4C,0x65,0x6E,0x20
	.DB  0x3D,0x20,0x25,0x64,0xD,0xA,0x0,0x3C
	.DB  0x63,0x6F,0x6E,0x66,0x69,0x67,0x4D,0x61
	.DB  0x6E,0x61,0x67,0x65,0x50,0x61,0x72,0x73
	.DB  0x65,0x72,0x3E,0x20,0x6D,0x61,0x6C,0x6C
	.DB  0x6F,0x63,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x6E,0x65,0x74
	.DB  0x77,0x6F,0x72,0x6B,0x4D,0x61,0x69,0x6E
	.DB  0x74,0x65,0x6E,0x61,0x6E,0x63,0x65,0x50
	.DB  0x61,0x72,0x73,0x65,0x72,0x3E,0x20,0x6D
	.DB  0x61,0x6C,0x6C,0x6F,0x63,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0x20,0x28,0x25,0x64
	.DB  0x29,0xD,0xA,0x0
_0x1A0011:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x94,0x41,0x0,0x0,0x0,0x0
_0x1A0000:
	.DB  0x53,0x65,0x6E,0x73,0x6F,0x72,0x20,0x63
	.DB  0x68,0x5B,0x25,0x64,0x5D,0x20,0x69,0x73
	.DB  0x20,0x61,0x20,0x72,0x61,0x77,0x20,0x64
	.DB  0x61,0x74,0x61,0x5B,0x25,0x30,0x2E,0x32
	.DB  0x66,0x5D,0x20,0x2C,0x20,0x63,0x61,0x6C
	.DB  0x50,0x72,0x6F,0x63,0x65,0x73,0x73,0x5B
	.DB  0x25,0x30,0x2E,0x32,0x66,0x5D,0xD,0xA
	.DB  0x0
_0x240003:
	.DB  0x30,0x3A,0x2F
_0x240000:
	.DB  0x0,0x46,0x52,0x5F,0x44,0x49,0x53,0x4B
	.DB  0x5F,0x45,0x52,0x52,0x0,0x46,0x52,0x5F
	.DB  0x49,0x4E,0x54,0x5F,0x45,0x52,0x52,0x0
	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x54,0x5F,0x52
	.DB  0x45,0x41,0x44,0x59,0x0,0x46,0x52,0x5F
	.DB  0x4E,0x4F,0x5F,0x46,0x49,0x4C,0x45,0x0
	.DB  0x46,0x52,0x5F,0x4E,0x4F,0x5F,0x50,0x41
	.DB  0x54,0x48,0x0,0x46,0x52,0x5F,0x49,0x4E
	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x4E,0x41
	.DB  0x4D,0x45,0x0,0x46,0x52,0x5F,0x44,0x45
	.DB  0x4E,0x49,0x45,0x44,0x0,0x46,0x52,0x5F
	.DB  0x45,0x58,0x49,0x53,0x54,0x0,0x46,0x52
	.DB  0x5F,0x49,0x4E,0x56,0x41,0x4C,0x49,0x44
	.DB  0x5F,0x4F,0x42,0x4A,0x45,0x43,0x54,0x0
	.DB  0x46,0x52,0x5F,0x57,0x52,0x49,0x54,0x45
	.DB  0x5F,0x50,0x52,0x4F,0x54,0x45,0x43,0x54
	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x49,0x4E
	.DB  0x56,0x41,0x4C,0x49,0x44,0x5F,0x44,0x52
	.DB  0x49,0x56,0x45,0x0,0x46,0x52,0x5F,0x4E
	.DB  0x4F,0x54,0x5F,0x45,0x4E,0x41,0x42,0x4C
	.DB  0x45,0x44,0x0,0x46,0x52,0x5F,0x4E,0x4F
	.DB  0x5F,0x46,0x49,0x4C,0x45,0x53,0x59,0x53
	.DB  0x54,0x45,0x4D,0x0,0x46,0x52,0x5F,0x4D
	.DB  0x4B,0x46,0x53,0x5F,0x41,0x42,0x4F,0x52
	.DB  0x54,0x45,0x44,0x0,0x46,0x52,0x5F,0x54
	.DB  0x49,0x4D,0x45,0x4F,0x55,0x54,0x0,0x3C
	.DB  0x45,0x52,0x52,0x3E,0x20,0x25,0x70,0x2E
	.DB  0xD,0xA,0x0,0x3C,0x53,0x44,0x5F,0x77
	.DB  0x72,0x69,0x74,0x65,0x44,0x61,0x74,0x61
	.DB  0x3E,0x20,0x53,0x44,0x20,0x43,0x61,0x72
	.DB  0x64,0x20,0x6E,0x6F,0x74,0x20,0x72,0x65
	.DB  0x61,0x64,0x79,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x3E,0x20,0x66,0x5F,0x6C
	.DB  0x73,0x65,0x65,0x6B,0x28,0x25,0x75,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0x21
	.DB  0x21,0xD,0xA,0x0,0x3C,0x53,0x44,0x5F
	.DB  0x77,0x72,0x69,0x74,0x65,0x44,0x61,0x74
	.DB  0x61,0x3E,0x20,0x66,0x5F,0x77,0x72,0x69
	.DB  0x74,0x65,0x28,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x3E,0x20,0x61,0x63,0x74
	.DB  0x75,0x61,0x6C,0x5F,0x77,0x72,0x69,0x74
	.DB  0x65,0x5B,0x25,0x75,0x5D,0x20,0x21,0x3D
	.DB  0x20,0x6C,0x65,0x6E,0x5B,0x25,0x75,0x5D
	.DB  0xD,0xA,0x0,0x3C,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x3E
	.DB  0x20,0x53,0x44,0x20,0x43,0x61,0x72,0x64
	.DB  0x20,0x6E,0x6F,0x74,0x20,0x72,0x65,0x61
	.DB  0x64,0x79,0xD,0xA,0x0,0x3C,0x53,0x44
	.DB  0x5F,0x72,0x65,0x61,0x64,0x44,0x61,0x74
	.DB  0x61,0x3E,0x20,0x66,0x5F,0x6C,0x73,0x65
	.DB  0x65,0x6B,0x28,0x25,0x75,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0x21,0x21,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x72,0x65
	.DB  0x61,0x64,0x44,0x61,0x74,0x61,0x3E,0x20
	.DB  0x66,0x5F,0x72,0x65,0x61,0x64,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x77,0x72
	.DB  0x69,0x74,0x65,0x44,0x61,0x74,0x61,0x3E
	.DB  0x20,0x61,0x63,0x74,0x75,0x61,0x6C,0x5F
	.DB  0x72,0x65,0x61,0x64,0x5B,0x25,0x75,0x5D
	.DB  0x20,0x21,0x3D,0x20,0x6C,0x65,0x6E,0x5B
	.DB  0x25,0x75,0x5D,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x72,0x65,0x61,0x64,0x4D,0x65
	.DB  0x6D,0x6F,0x72,0x79,0x52,0x65,0x6D,0x61
	.DB  0x69,0x6E,0x3E,0x20,0x66,0x5F,0x67,0x65
	.DB  0x74,0x66,0x72,0x65,0x65,0x28,0x25,0x73
	.DB  0x29,0x20,0x65,0x72,0x72,0x6F,0x72,0x21
	.DB  0x21,0xD,0xA,0x0,0x4C,0x6F,0x67,0x69
	.DB  0x63,0x61,0x6C,0x20,0x64,0x72,0x69,0x76
	.DB  0x65,0x20,0x30,0x3A,0x20,0x6D,0x6F,0x75
	.DB  0x6E,0x74,0x65,0x64,0x20,0x45,0x52,0x52
	.DB  0x4F,0x52,0xD,0xA,0x0,0x4C,0x6F,0x67
	.DB  0x69,0x63,0x61,0x6C,0x20,0x64,0x72,0x69
	.DB  0x76,0x65,0x20,0x30,0x3A,0x20,0x6D,0x6F
	.DB  0x75,0x6E,0x74,0x65,0x64,0x20,0x4F,0x4B
	.DB  0xD,0xA,0x0,0x4C,0x6F,0x67,0x69,0x63
	.DB  0x61,0x6C,0x20,0x64,0x72,0x69,0x76,0x65
	.DB  0x20,0x30,0x3A,0x20,0x75,0x6E,0x6D,0x6F
	.DB  0x75,0x6E,0x74,0x65,0x64,0x20,0x45,0x52
	.DB  0x52,0x4F,0x52,0xD,0xA,0x0,0x4C,0x6F
	.DB  0x67,0x69,0x63,0x61,0x6C,0x20,0x64,0x72
	.DB  0x69,0x76,0x65,0x20,0x30,0x3A,0x20,0x75
	.DB  0x6E,0x6D,0x6F,0x75,0x6E,0x74,0x65,0x64
	.DB  0x20,0x4F,0x4B,0xD,0xA,0x0,0x3C,0x53
	.DB  0x44,0x5F,0x72,0x65,0x6D,0x6F,0x75,0x6E
	.DB  0x74,0x3E,0x20,0x53,0x44,0x5F,0x75,0x6E
	.DB  0x6D,0x6F,0x75,0x6E,0x74,0x28,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x53,0x44,0x5F,0x72,0x65,0x6D
	.DB  0x6F,0x75,0x6E,0x74,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x6D,0x6F,0x75,0x6E,0x74,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x53,0x44,0x20,0x43,0x61,0x72
	.DB  0x64,0x20,0x6E,0x6F,0x74,0x20,0x72,0x65
	.DB  0x61,0x64,0x79,0xD,0xA,0x0,0x25,0x73
	.DB  0x25,0x73,0x0,0x3C,0x53,0x44,0x5F,0x63
	.DB  0x72,0x65,0x61,0x74,0x65,0x46,0x69,0x6C
	.DB  0x65,0x3E,0x20,0x66,0x5F,0x6F,0x70,0x65
	.DB  0x6E,0x28,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x53,0x44
	.DB  0x5F,0x63,0x72,0x65,0x61,0x74,0x65,0x46
	.DB  0x69,0x6C,0x65,0x3E,0x20,0x66,0x5F,0x63
	.DB  0x6C,0x6F,0x73,0x65,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x53,0x44,0x5F,0x6F,0x70,0x65,0x6E
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x53,0x44
	.DB  0x20,0x43,0x61,0x72,0x64,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x72,0x65,0x61,0x64,0x79,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x6F,0x70
	.DB  0x65,0x6E,0x46,0x69,0x6C,0x65,0x3E,0x20
	.DB  0x66,0x5F,0x6F,0x70,0x65,0x6E,0x28,0x29
	.DB  0x20,0x5B,0x25,0x73,0x5D,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x53,0x44,0x5F,0x63,0x6C,0x6F,0x73,0x65
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x53,0x44
	.DB  0x20,0x43,0x61,0x72,0x64,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x72,0x65,0x61,0x64,0x79,0xD
	.DB  0xA,0x0,0x3C,0x53,0x44,0x5F,0x63,0x6C
	.DB  0x6F,0x73,0x65,0x46,0x69,0x6C,0x65,0x3E
	.DB  0x20,0x66,0x5F,0x63,0x6C,0x6F,0x73,0x65
	.DB  0x28,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x53,0x44,0x5F
	.DB  0x69,0x6E,0x69,0x74,0x3E,0x20,0x53,0x74
	.DB  0x61,0x72,0x74,0x20,0x69,0x6E,0x69,0x74
	.DB  0x69,0x61,0x6C,0x20,0x6D,0x65,0x6D,0x6F
	.DB  0x72,0x79,0x20,0x63,0x61,0x72,0x64,0xD
	.DB  0xA,0x0,0xD,0xA,0x3C,0x53,0x44,0x5F
	.DB  0x69,0x6E,0x69,0x74,0x3E,0x20,0x4D,0x6F
	.DB  0x75,0x6E,0x74,0x69,0x6E,0x67,0x20,0x53
	.DB  0x44,0x20,0x43,0x61,0x72,0x64,0x2E,0x2E
	.DB  0x2E,0x0,0x3C,0x53,0x44,0x5F,0x69,0x6E
	.DB  0x69,0x74,0x3E,0x20,0x53,0x44,0x5F,0x6D
	.DB  0x6F,0x75,0x6E,0x74,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0xD,0xA,0x3C,0x53,0x44,0x5F,0x69,0x6E
	.DB  0x69,0x74,0x3E,0x20,0x43,0x68,0x65,0x63
	.DB  0x6B,0x20,0x43,0x61,0x72,0x64,0x20,0x53
	.DB  0x69,0x7A,0x65,0x2E,0x2E,0x2E,0x0,0x3C
	.DB  0x53,0x44,0x5F,0x69,0x6E,0x69,0x74,0x3E
	.DB  0x20,0x53,0x44,0x5F,0x72,0x65,0x61,0x64
	.DB  0x4D,0x65,0x6D,0x6F,0x72,0x79,0x52,0x65
	.DB  0x6D,0x61,0x69,0x6E,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x53,0x44,0x5F,0x69,0x6E,0x69,0x74
	.DB  0x3E,0x20,0x46,0x72,0x65,0x65,0x20,0x73
	.DB  0x70,0x61,0x63,0x65,0x20,0x6F,0x6E,0x20
	.DB  0x6C,0x6F,0x67,0x69,0x63,0x61,0x6C,0x20
	.DB  0x64,0x72,0x69,0x76,0x65,0x20,0x30,0x3A
	.DB  0x20,0x25,0x6C,0x75,0x20,0x6B,0x62,0x79
	.DB  0x74,0x65,0x73,0xD,0xA,0x0
_0x260003:
	.DB  0x64,0x61,0x74,0x61,0x2E,0x6C,0x6F,0x67
_0x260004:
	.DB  0x65,0x76,0x65,0x6E,0x74,0x2E,0x6C,0x6F
	.DB  0x67
_0x260005:
	.DB  0x65,0x72,0x72,0x6F,0x72,0x2E,0x6C,0x6F
	.DB  0x67
_0x260006:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
_0x260007:
	.DB  LOW(_SD_openFile),HIGH(_SD_openFile),BYTE3(_SD_openFile),BYTE4(_SD_openFile)
_0x260008:
	.DB  LOW(_SD_closeFile),HIGH(_SD_closeFile),BYTE3(_SD_closeFile),BYTE4(_SD_closeFile)
_0x260000:
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x69,0x6E,0x73
	.DB  0x65,0x72,0x74,0x44,0x61,0x74,0x61,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x49,0x6E,0x73,0x65
	.DB  0x72,0x74,0x28,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x73,0x65,0x72
	.DB  0x74,0x44,0x61,0x74,0x61,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x28,0x66,0x6C,0x61,0x67
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x69,0x6E,0x73,0x65,0x72,0x74,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x53,0x44,0x5F,0x77
	.DB  0x72,0x69,0x74,0x65,0x44,0x61,0x74,0x61
	.DB  0x28,0x74,0x69,0x6D,0x65,0x73,0x74,0x61
	.DB  0x6D,0x70,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x69,0x6E,0x73,0x65,0x72,0x74
	.DB  0x44,0x61,0x74,0x61,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x77,0x72,0x69,0x74,0x65,0x44,0x61
	.DB  0x74,0x61,0x28,0x63,0x68,0x61,0x6E,0x6E
	.DB  0x65,0x6C,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x69,0x6E,0x73,0x65,0x72,0x74
	.DB  0x44,0x61,0x74,0x61,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x77,0x72,0x69,0x74,0x65,0x44,0x61
	.DB  0x74,0x61,0x28,0x76,0x61,0x6C,0x75,0x65
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x69,0x6E,0x73,0x65,0x72,0x74,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x4C,0x4F,0x47,0x5F
	.DB  0x73,0x65,0x74,0x4C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x28,0x25,0x6C
	.DB  0x64,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x44,0x61,0x74
	.DB  0x61,0x3E,0x20,0x4C,0x4F,0x47,0x5F,0x67
	.DB  0x65,0x74,0x4C,0x61,0x73,0x74,0x49,0x6E
	.DB  0x73,0x65,0x72,0x74,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x3E,0x20,0x4C
	.DB  0x4F,0x47,0x5F,0x67,0x65,0x74,0x4C,0x61
	.DB  0x73,0x74,0x53,0x65,0x6E,0x64,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x72
	.DB  0x65,0x61,0x64,0x45,0x76,0x65,0x6E,0x74
	.DB  0x3E,0x20,0x6C,0x61,0x73,0x74,0x53,0x65
	.DB  0x6E,0x64,0x2F,0x6C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x20,0x20,0x2D
	.DB  0x2D,0x3E,0x20,0x25,0x6C,0x64,0x2F,0x25
	.DB  0x6C,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x4C,0x6F,0x67,0x20
	.DB  0x65,0x6D,0x70,0x74,0x79,0x2E,0x2E,0x21
	.DB  0x21,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x43,0x6C,0x65,0x61,0x72
	.DB  0x4C,0x6F,0x67,0x46,0x69,0x6C,0x65,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x28
	.DB  0x25,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x3E,0x20,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x28
	.DB  0x66,0x6C,0x61,0x67,0x29,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x44,0x61,0x74,0x61,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x72,0x65,0x61,0x64,0x44,0x61,0x74
	.DB  0x61,0x28,0x74,0x69,0x6D,0x65,0x73,0x74
	.DB  0x61,0x6D,0x70,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x3E,0x20,0x53,0x44,0x5F
	.DB  0x72,0x65,0x61,0x64,0x44,0x61,0x74,0x61
	.DB  0x28,0x63,0x68,0x61,0x6E,0x6E,0x65,0x6C
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x72,0x65,0x61,0x64,0x44,0x61,0x74,0x61
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x72,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x28,0x76,0x61
	.DB  0x6C,0x75,0x65,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x73,0x65,0x72
	.DB  0x74,0x45,0x76,0x65,0x6E,0x74,0x3E,0x20
	.DB  0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74,0x4C
	.DB  0x61,0x73,0x74,0x49,0x6E,0x73,0x65,0x72
	.DB  0x74,0x28,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x69,0x6E,0x73,0x65,0x72,0x74
	.DB  0x45,0x76,0x65,0x6E,0x74,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x77,0x72,0x69,0x74,0x65,0x44
	.DB  0x61,0x74,0x61,0x28,0x66,0x6C,0x61,0x67
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x69,0x6E,0x73,0x65,0x72,0x74,0x45,0x76
	.DB  0x65,0x6E,0x74,0x3E,0x20,0x53,0x44,0x5F
	.DB  0x77,0x72,0x69,0x74,0x65,0x44,0x61,0x74
	.DB  0x61,0x28,0x74,0x69,0x6D,0x65,0x73,0x74
	.DB  0x61,0x6D,0x70,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x73,0x65,0x72
	.DB  0x74,0x45,0x76,0x65,0x6E,0x74,0x3E,0x20
	.DB  0x53,0x44,0x5F,0x77,0x72,0x69,0x74,0x65
	.DB  0x44,0x61,0x74,0x61,0x28,0x69,0x64,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x69
	.DB  0x6E,0x73,0x65,0x72,0x74,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x53,0x44,0x5F,0x77
	.DB  0x72,0x69,0x74,0x65,0x44,0x61,0x74,0x61
	.DB  0x28,0x73,0x74,0x61,0x74,0x75,0x73,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0xD
	.DB  0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x69
	.DB  0x6E,0x73,0x65,0x72,0x74,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x4C,0x4F,0x47,0x5F
	.DB  0x73,0x65,0x74,0x4C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x28,0x25,0x6C
	.DB  0x64,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x4C,0x4F,0x47,0x5F
	.DB  0x67,0x65,0x74,0x4C,0x61,0x73,0x74,0x49
	.DB  0x6E,0x73,0x65,0x72,0x74,0x28,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x72,0x65
	.DB  0x61,0x64,0x45,0x76,0x65,0x6E,0x74,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x53,0x65,0x6E,0x64
	.DB  0x28,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x4C,0x6F,0x67,0x20
	.DB  0x65,0x6D,0x70,0x74,0x79,0x2E,0x2E,0x21
	.DB  0x21,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x72,0x65,0x61,0x64,0x45,0x76,0x65
	.DB  0x6E,0x74,0x3E,0x20,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x28
	.DB  0x66,0x6C,0x61,0x67,0x29,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x45,0x76,0x65,0x6E,0x74,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x28,0x74,0x69,0x6D,0x65,0x73
	.DB  0x74,0x61,0x6D,0x70,0x29,0x20,0x66,0x61
	.DB  0x69,0x6C,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x45,0x76,0x65,0x6E,0x74,0x3E,0x20,0x53
	.DB  0x44,0x5F,0x72,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x28,0x69,0x64,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x72,0x65,0x61
	.DB  0x64,0x45,0x76,0x65,0x6E,0x74,0x3E,0x20
	.DB  0x53,0x44,0x5F,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x28,0x73,0x74,0x61,0x74
	.DB  0x75,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x67,0x65,0x74,0x4C,0x61,0x73
	.DB  0x74,0x49,0x6E,0x73,0x65,0x72,0x74,0x3E
	.DB  0x20,0x53,0x44,0x5F,0x72,0x65,0x61,0x64
	.DB  0x44,0x61,0x74,0x61,0x28,0x29,0x20,0x66
	.DB  0x61,0x69,0x6C,0x65,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x67,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x49,0x6E,0x73,0x65
	.DB  0x72,0x74,0x3E,0x20,0x67,0x6F,0x74,0x20
	.DB  0x25,0x6C,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x73,0x65,0x74,0x4C,0x61
	.DB  0x73,0x74,0x49,0x6E,0x73,0x65,0x72,0x74
	.DB  0x3E,0x20,0x77,0x72,0x69,0x74,0x69,0x6E
	.DB  0x67,0x20,0x25,0x6C,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x73,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x49,0x6E,0x73,0x65
	.DB  0x72,0x74,0x3E,0x20,0x53,0x44,0x5F,0x72
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x28
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47,0x5F
	.DB  0x67,0x65,0x74,0x4C,0x61,0x73,0x74,0x53
	.DB  0x65,0x6E,0x64,0x3E,0x20,0x53,0x44,0x5F
	.DB  0x72,0x65,0x61,0x64,0x44,0x61,0x74,0x61
	.DB  0x28,0x29,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x67,0x65,0x74,0x4C,0x61,0x73,0x74
	.DB  0x53,0x65,0x6E,0x64,0x3E,0x20,0x67,0x6F
	.DB  0x74,0x20,0x25,0x6C,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x73,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x53,0x65,0x6E,0x64
	.DB  0x3E,0x20,0x77,0x72,0x69,0x74,0x69,0x6E
	.DB  0x67,0x20,0x25,0x6C,0x64,0xD,0xA,0x0
	.DB  0x3C,0x4C,0x4F,0x47,0x5F,0x73,0x65,0x74
	.DB  0x4C,0x61,0x73,0x74,0x53,0x65,0x6E,0x64
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x72,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x28,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x28
	.DB  0x25,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x25,0x73
	.DB  0x20,0x61,0x6C,0x72,0x65,0x61,0x64,0x79
	.DB  0x20,0x65,0x78,0x69,0x73,0x74,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x25,0x73,0x20,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x64,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65,0x61
	.DB  0x74,0x65,0x46,0x69,0x6C,0x65,0x3E,0x20
	.DB  0x25,0x73,0x20,0x63,0x6F,0x6E,0x74,0x61
	.DB  0x69,0x6E,0x65,0x64,0x20,0x6E,0x6F,0x20
	.DB  0x69,0x6E,0x69,0x74,0x69,0x61,0x6C,0x20
	.DB  0x64,0x61,0x74,0x61,0xD,0xA,0x0,0x3C
	.DB  0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65,0x61
	.DB  0x74,0x65,0x46,0x69,0x6C,0x65,0x3E,0x20
	.DB  0x53,0x44,0x5F,0x6F,0x70,0x65,0x6E,0x46
	.DB  0x69,0x6C,0x65,0x28,0x25,0x73,0x29,0x20
	.DB  0x66,0x61,0x69,0x6C,0x65,0x64,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x77,0x72,0x69,0x74,0x69,0x6E
	.DB  0x67,0x20,0x69,0x6E,0x69,0x74,0x69,0x61
	.DB  0x6C,0x20,0x64,0x61,0x74,0x61,0xD,0xA
	.DB  0x0,0x3C,0x4C,0x4F,0x47,0x5F,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x46,0x69,0x6C,0x65
	.DB  0x3E,0x20,0x53,0x44,0x5F,0x77,0x72,0x69
	.DB  0x74,0x65,0x44,0x61,0x74,0x61,0x28,0x29
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0x20
	.DB  0x57,0x72,0x69,0x74,0x69,0x6E,0x67,0x2E
	.DB  0x2E,0x20,0xD,0xA,0x0,0x3C,0x4C,0x4F
	.DB  0x47,0x5F,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x46,0x69,0x6C,0x65,0x3E,0x20,0x53,0x44
	.DB  0x5F,0x63,0x6C,0x6F,0x73,0x65,0x46,0x69
	.DB  0x6C,0x65,0x28,0x29,0x20,0x66,0x61,0x69
	.DB  0x6C,0x65,0x64,0xD,0xA,0x0,0x3C,0x4C
	.DB  0x4F,0x47,0x5F,0x69,0x6E,0x69,0x74,0x3E
	.DB  0x20,0x49,0x6E,0x69,0x74,0x69,0x61,0x6C
	.DB  0x20,0x6C,0x6F,0x67,0x20,0x66,0x69,0x6C
	.DB  0x65,0xD,0xA,0x0,0x3C,0x4C,0x4F,0x47
	.DB  0x5F,0x69,0x6E,0x69,0x74,0x3E,0x20,0x4C
	.DB  0x4F,0x47,0x5F,0x63,0x72,0x65,0x61,0x74
	.DB  0x65,0x46,0x69,0x6C,0x65,0x28,0x25,0x73
	.DB  0x29,0x20,0x66,0x61,0x69,0x6C,0x65,0x64
	.DB  0xD,0xA,0x0
_0x280000:
	.DB  0xD,0xA,0xD,0xA,0x3C,0x61,0x64,0x64
	.DB  0x44,0x61,0x74,0x61,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x3E,0x20,0x57,0x41
	.DB  0x52,0x4E,0x49,0x4E,0x47,0x20,0x3A,0x20
	.DB  0x64,0x61,0x74,0x61,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x20,0x46,0x55,0x4C
	.DB  0x4C,0xD,0xA,0xD,0xA,0x0,0xD,0xA
	.DB  0x3C,0x61,0x64,0x64,0x44,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x3E,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x41,0x64,0x64,0x65
	.DB  0x64,0x20,0x28,0x25,0x30,0x32,0x58,0x29
	.DB  0x20,0x74,0x6F,0x20,0x64,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x5B,0x25,0x64,0x5D,0x20,0x43,0x6F,0x75
	.DB  0x6E,0x74,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x3C,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x4C,0x6F,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x3E,0x20,0x57,0x41,0x52
	.DB  0x4E,0x3A,0x20,0x64,0x61,0x74,0x61,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x20
	.DB  0x65,0x6D,0x70,0x74,0x79,0x21,0x21,0xD
	.DB  0xA,0x0,0x3C,0x72,0x65,0x61,0x64,0x44
	.DB  0x61,0x74,0x61,0x4C,0x6F,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x3E,0x20,0x57,0x41,0x52
	.DB  0x4E,0x3A,0x20,0x6E,0x6F,0x74,0x20,0x66
	.DB  0x6F,0x75,0x6E,0x64,0x20,0x69,0x64,0x5B
	.DB  0x30,0x78,0x25,0x30,0x32,0x58,0x5D,0x20
	.DB  0x69,0x6E,0x20,0x64,0x61,0x74,0x61,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0xD
	.DB  0xA,0x0,0xD,0xA,0x3C,0x72,0x65,0x6D
	.DB  0x6F,0x76,0x65,0x44,0x61,0x74,0x61,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x3E
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x52,0x65,0x6D,0x6F,0x76,0x65,0x64,0x20
	.DB  0x28,0x25,0x30,0x32,0x58,0x29,0x20,0x66
	.DB  0x72,0x6F,0x6D,0x20,0x64,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x5B,0x25,0x64,0x5D,0xD,0xA,0x0,0x3C
	.DB  0x72,0x65,0x6D,0x6F,0x76,0x65,0x44,0x61
	.DB  0x74,0x61,0x4C,0x6F,0x67,0x51,0x75,0x65
	.DB  0x75,0x65,0x3E,0x20,0x57,0x41,0x52,0x4E
	.DB  0x3A,0x20,0x6E,0x6F,0x74,0x20,0x66,0x6F
	.DB  0x75,0x6E,0x64,0x20,0x69,0x64,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x58,0x5D,0x20,0x69
	.DB  0x6E,0x20,0x64,0x61,0x74,0x61,0x4C,0x6F
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0xD,0xA
	.DB  0x0,0xD,0xA,0xD,0xA,0x3C,0x61,0x64
	.DB  0x64,0x45,0x76,0x65,0x6E,0x74,0x4C,0x6F
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0x3E,0x20
	.DB  0x57,0x41,0x52,0x4E,0x49,0x4E,0x47,0x20
	.DB  0x3A,0x20,0x65,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x20
	.DB  0x46,0x55,0x4C,0x4C,0xD,0xA,0xD,0xA
	.DB  0x0,0xD,0xA,0x3C,0x61,0x64,0x64,0x45
	.DB  0x76,0x65,0x6E,0x74,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x3E,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x41,0x64
	.DB  0x64,0x65,0x64,0x20,0x28,0x25,0x30,0x32
	.DB  0x58,0x29,0x20,0x74,0x6F,0x20,0x65,0x76
	.DB  0x65,0x6E,0x74,0x4C,0x6F,0x67,0x51,0x75
	.DB  0x65,0x75,0x65,0x5B,0x25,0x64,0x5D,0x20
	.DB  0x43,0x6F,0x75,0x6E,0x74,0x20,0x3D,0x20
	.DB  0x25,0x64,0xD,0xA,0x0,0x3C,0x72,0x65
	.DB  0x61,0x64,0x45,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x3E
	.DB  0x20,0x57,0x41,0x52,0x4E,0x3A,0x20,0x65
	.DB  0x76,0x65,0x6E,0x74,0x4C,0x6F,0x67,0x51
	.DB  0x75,0x65,0x75,0x65,0x20,0x65,0x6D,0x70
	.DB  0x74,0x79,0x21,0x21,0xD,0xA,0x0,0x3C
	.DB  0x72,0x65,0x61,0x64,0x45,0x76,0x65,0x6E
	.DB  0x74,0x4C,0x6F,0x67,0x51,0x75,0x65,0x75
	.DB  0x65,0x3E,0x20,0x57,0x41,0x52,0x4E,0x3A
	.DB  0x20,0x6E,0x6F,0x74,0x20,0x66,0x6F,0x75
	.DB  0x6E,0x64,0x20,0x69,0x64,0x5B,0x30,0x78
	.DB  0x25,0x30,0x32,0x58,0x5D,0x20,0x69,0x6E
	.DB  0x20,0x65,0x76,0x65,0x6E,0x74,0x4C,0x6F
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0xD,0xA
	.DB  0x0,0xD,0xA,0x3C,0x72,0x65,0x6D,0x6F
	.DB  0x76,0x65,0x45,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x3E
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	.DB  0x20,0x20,0x20,0x20,0x20,0x20,0x52,0x65
	.DB  0x6D,0x6F,0x76,0x65,0x64,0x20,0x28,0x25
	.DB  0x30,0x32,0x58,0x29,0x20,0x66,0x72,0x6F
	.DB  0x6D,0x20,0x65,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0x5B
	.DB  0x25,0x64,0x5D,0xD,0xA,0x0,0x3C,0x72
	.DB  0x65,0x6D,0x6F,0x76,0x65,0x45,0x76,0x65
	.DB  0x6E,0x74,0x4C,0x6F,0x67,0x51,0x75,0x65
	.DB  0x75,0x65,0x3E,0x20,0x57,0x41,0x52,0x4E
	.DB  0x3A,0x20,0x6E,0x6F,0x74,0x20,0x66,0x6F
	.DB  0x75,0x6E,0x64,0x20,0x69,0x64,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x58,0x5D,0x20,0x69
	.DB  0x6E,0x20,0x65,0x76,0x65,0x6E,0x74,0x4C
	.DB  0x6F,0x67,0x51,0x75,0x65,0x75,0x65,0xD
	.DB  0xA,0x0
_0x2A0003:
	.DB  0x9
_0x2A0000:
	.DB  0xD,0xA,0x3C,0x44,0x65,0x62,0x75,0x67
	.DB  0x3E,0x47,0x65,0x74,0x43,0x75,0x72,0x53
	.DB  0x65,0x6E,0x73,0x6F,0x72,0x3A,0x20,0xD
	.DB  0xA,0x0,0x43,0x68,0x61,0x6E,0x6E,0x65
	.DB  0x6C,0x20,0x49,0x44,0x3A,0x25,0x64,0x20
	.DB  0xD,0xA,0x0,0x63,0x75,0x72,0x72,0x65
	.DB  0x6E,0x74,0x20,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x20,0x63,0x68,0x5B,0x25,0x64,0x5D
	.DB  0x20,0x2C,0x20,0x76,0x61,0x6C,0x75,0x65
	.DB  0x3A,0x25,0x30,0x2E,0x32,0x66,0xD,0xA
	.DB  0x0,0x43,0x68,0x61,0x6E,0x6E,0x65,0x6C
	.DB  0x20,0x49,0x44,0x20,0x69,0x73,0x20,0x69
	.DB  0x6E,0x20,0x72,0x61,0x6E,0x67,0x65,0x2E
	.DB  0xD,0xA,0x0,0xD,0xA,0x3C,0x44,0x65
	.DB  0x62,0x75,0x67,0x3E,0x47,0x65,0x74,0x43
	.DB  0x61,0x6C,0x3A,0x20,0xD,0xA,0x0,0x73
	.DB  0x74,0x64,0x52,0x65,0x66,0x5B,0x25,0x64
	.DB  0x5D,0x20,0x3A,0x20,0x25,0x30,0x2E,0x32
	.DB  0x66,0x20,0x2C,0x20,0x0,0x73,0x65,0x6E
	.DB  0x73,0x6F,0x72,0x52,0x65,0x66,0x5B,0x25
	.DB  0x64,0x5D,0x20,0x3A,0x20,0x25,0x30,0x2E
	.DB  0x32,0x66,0xD,0xA,0x0,0x43,0x61,0x6C
	.DB  0x54,0x79,0x70,0x65,0x20,0x3A,0x20,0x43
	.DB  0x41,0x4C,0x5F,0x44,0x45,0x46,0x41,0x55
	.DB  0x4C,0x54,0x0,0x43,0x61,0x6C,0x54,0x79
	.DB  0x70,0x65,0x20,0x3A,0x20,0x43,0x41,0x4C
	.DB  0x5F,0x45,0x58,0x54,0x4F,0x46,0x46,0x53
	.DB  0x45,0x54,0x0,0x43,0x61,0x6C,0x54,0x79
	.DB  0x70,0x65,0x20,0x3A,0x20,0x43,0x41,0x4C
	.DB  0x5F,0x45,0x58,0x54,0x4C,0x49,0x4E,0x45
	.DB  0x41,0x52,0x0,0x43,0x61,0x6C,0x54,0x79
	.DB  0x70,0x65,0x20,0x3A,0x20,0x43,0x41,0x4C
	.DB  0x5F,0x45,0x58,0x54,0x50,0x4F,0x4C,0x59
	.DB  0x4E,0x4F,0x4D,0x49,0x41,0x4C,0x0,0xD
	.DB  0xA,0x3C,0x44,0x65,0x62,0x75,0x67,0x3E
	.DB  0x53,0x65,0x74,0x43,0x61,0x6C,0x3A,0x20
	.DB  0xD,0xA,0x0,0x50,0x6F,0x69,0x6E,0x74
	.DB  0x20,0x49,0x44,0x3A,0x25,0x64,0x20,0xD
	.DB  0xA,0x0,0x70,0x6F,0x69,0x6E,0x74,0x56
	.DB  0x61,0x6C,0x75,0x65,0x28,0x6D,0x65,0x74
	.DB  0x65,0x72,0x52,0x65,0x66,0x29,0x20,0x3A
	.DB  0x25,0x30,0x2E,0x32,0x66,0x20,0xD,0xA
	.DB  0x0,0xD,0xA,0x3C,0x44,0x65,0x62,0x75
	.DB  0x67,0x3E,0x43,0x6F,0x6E,0x66,0x69,0x72
	.DB  0x6D,0x43,0x61,0x6C,0x3A,0x20,0xD,0xA
	.DB  0x0,0x67,0x65,0x74,0x20,0x79,0x65,0x61
	.DB  0x72,0x20,0x3D,0x20,0x25,0x64,0xD,0xA
	.DB  0x0,0x67,0x65,0x74,0x20,0x6D,0x6F,0x6E
	.DB  0x74,0x68,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x67,0x65,0x74,0x20,0x64,0x61
	.DB  0x74,0x65,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x67,0x65,0x74,0x20,0x68,0x6F
	.DB  0x75,0x72,0x20,0x3D,0x20,0x25,0x64,0xD
	.DB  0xA,0x0,0x67,0x65,0x74,0x20,0x6D,0x69
	.DB  0x6E,0x20,0x3D,0x20,0x25,0x64,0xD,0xA
	.DB  0x0,0x67,0x65,0x74,0x20,0x73,0x65,0x63
	.DB  0x20,0x3D,0x20,0x25,0x64,0xD,0xA,0x0
	.DB  0x67,0x65,0x74,0x20,0x74,0x69,0x6D,0x65
	.DB  0x7A,0x6F,0x6E,0x65,0x20,0x3D,0x20,0x25
	.DB  0x2B,0x64,0xD,0xA,0x0,0xD,0xA,0x3C
	.DB  0x44,0x45,0x42,0x55,0x47,0x3E,0x20,0x41
	.DB  0x6C,0x61,0x72,0x6D,0x20,0x53,0x74,0x61
	.DB  0x74,0x75,0x73,0x20,0x52,0x65,0x73,0x65
	.DB  0x74,0x2E,0x2E,0x21,0x21,0xD,0xA,0x0
	.DB  0x3C,0x44,0x45,0x42,0x55,0x47,0x5F,0x43
	.DB  0x6C,0x65,0x61,0x72,0x4C,0x6F,0x67,0x46
	.DB  0x69,0x6C,0x65,0x3E,0x20,0x52,0x65,0x2D
	.DB  0x69,0x6E,0x69,0x74,0x69,0x61,0x74,0x65
	.DB  0x20,0x6C,0x6F,0x67,0x20,0x66,0x69,0x6C
	.DB  0x65,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x43,0x6C,0x65,0x61,0x72
	.DB  0x4C,0x6F,0x67,0x46,0x69,0x6C,0x65,0x3E
	.DB  0x20,0x4C,0x4F,0x47,0x5F,0x63,0x72,0x65
	.DB  0x61,0x74,0x65,0x46,0x69,0x6C,0x65,0x28
	.DB  0x25,0x73,0x29,0x20,0x66,0x61,0x69,0x6C
	.DB  0x65,0x64,0xD,0xA,0x0,0x3C,0x44,0x45
	.DB  0x42,0x55,0x47,0x5F,0x73,0x65,0x74,0x52
	.DB  0x65,0x61,0x6C,0x56,0x72,0x65,0x66,0x3E
	.DB  0x20,0x67,0x65,0x74,0x20,0x73,0x65,0x74
	.DB  0x20,0x56,0x72,0x65,0x66,0x3C,0x73,0x74
	.DB  0x72,0x69,0x6E,0x67,0x3E,0x20,0x25,0x73
	.DB  0xD,0xA,0x0,0x3C,0x44,0x45,0x42,0x55
	.DB  0x47,0x5F,0x73,0x65,0x74,0x52,0x65,0x61
	.DB  0x6C,0x56,0x72,0x65,0x66,0x3E,0x20,0x41
	.DB  0x66,0x74,0x65,0x72,0x20,0x63,0x6F,0x6E
	.DB  0x76,0x65,0x72,0x74,0x20,0x3D,0x20,0x25
	.DB  0x66,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x53,0x65,0x6C,0x65,0x63,0x74,0x3E
	.DB  0x20,0x54,0x68,0x69,0x73,0x20,0x54,0x45
	.DB  0x4D,0x50,0x5F,0x53,0x45,0x4C,0x20,0x6E
	.DB  0x6F,0x74,0x20,0x73,0x75,0x70,0x70,0x6F
	.DB  0x72,0x74,0xD,0xA,0xD,0xA,0x0,0x3C
	.DB  0x44,0x45,0x42,0x55,0x47,0x5F,0x73,0x65
	.DB  0x6E,0x73,0x6F,0x72,0x53,0x65,0x6C,0x65
	.DB  0x63,0x74,0x3E,0x20,0x44,0x65,0x73,0x65
	.DB  0x6C,0x65,0x63,0x74,0x20,0x73,0x65,0x6E
	.DB  0x73,0x6F,0x72,0xD,0xA,0xD,0xA,0x0
	.DB  0x3C,0x44,0x45,0x42,0x55,0x47,0x5F,0x73
	.DB  0x65,0x6E,0x73,0x6F,0x72,0x53,0x65,0x6C
	.DB  0x65,0x63,0x74,0x3E,0x20,0x53,0x65,0x6C
	.DB  0x65,0x63,0x74,0x65,0x64,0x20,0x73,0x65
	.DB  0x6E,0x73,0x6F,0x72,0x20,0x25,0x64,0xD
	.DB  0xA,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x53,0x65,0x6C,0x65,0x63,0x74,0x3E
	.DB  0x20,0x45,0x52,0x52,0x4F,0x52,0x20,0x3A
	.DB  0x20,0x53,0x65,0x6C,0x65,0x63,0x74,0x69
	.DB  0x6E,0x67,0x20,0x73,0x65,0x6E,0x73,0x6F
	.DB  0x72,0x20,0x5B,0x25,0x63,0x5D,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x58,0x5D,0xD,0xA
	.DB  0xD,0xA,0x0,0x3C,0x44,0x45,0x42,0x55
	.DB  0x47,0x5F,0x73,0x65,0x74,0x53,0x65,0x72
	.DB  0x69,0x61,0x6C,0x4E,0x75,0x6D,0x62,0x65
	.DB  0x72,0x3E,0x20,0x69,0x6E,0x76,0x61,0x6C
	.DB  0x69,0x64,0x20,0x73,0x65,0x74,0x74,0x69
	.DB  0x6E,0x67,0x20,0x73,0x74,0x72,0x69,0x6E
	.DB  0x67,0x20,0x28,0x25,0x63,0x29,0x5B,0x30
	.DB  0x78,0x25,0x30,0x32,0x5D,0xD,0xA,0x0
	.DB  0x3C,0x44,0x45,0x42,0x55,0x47,0x5F,0x73
	.DB  0x65,0x74,0x53,0x65,0x72,0x69,0x61,0x6C
	.DB  0x4E,0x75,0x6D,0x62,0x65,0x72,0x3E,0x20
	.DB  0x52,0x65,0x70,0x6C,0x61,0x63,0x69,0x6E
	.DB  0x67,0x20,0x44,0x45,0x56,0x49,0x43,0x45
	.DB  0x5F,0x53,0x45,0x52,0x49,0x41,0x4C,0x2E
	.DB  0x2E,0xD,0xA,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x74,0x53,0x65
	.DB  0x72,0x69,0x61,0x6C,0x4E,0x75,0x6D,0x62
	.DB  0x65,0x72,0x3E,0x20,0x53,0x65,0x74,0x20
	.DB  0x53,0x74,0x72,0x69,0x6E,0x67,0x20,0x2D
	.DB  0x2D,0x3E,0x20,0x0,0x5B,0x25,0x63,0x0
	.DB  0x25,0x63,0x5D,0x0,0x3C,0x44,0x45,0x42
	.DB  0x55,0x47,0x5F,0x73,0x65,0x74,0x53,0x65
	.DB  0x72,0x69,0x61,0x6C,0x4E,0x75,0x6D,0x62
	.DB  0x65,0x72,0x3E,0x20,0x53,0x75,0x63,0x63
	.DB  0x65,0x73,0x73,0x21,0x21,0x20,0x44,0x45
	.DB  0x56,0x5F,0x53,0x45,0x52,0x49,0x41,0x4C
	.DB  0x20,0x3D,0x3D,0x3E,0x20,0x0,0x5B,0x25
	.DB  0x30,0x32,0x58,0x5D,0x0,0x3C,0x44,0x45
	.DB  0x42,0x55,0x47,0x5F,0x72,0x65,0x61,0x64
	.DB  0x53,0x65,0x72,0x69,0x61,0x6C,0x4E,0x75
	.DB  0x6D,0x62,0x65,0x72,0x3E,0x20,0x44,0x45
	.DB  0x56,0x5F,0x53,0x45,0x52,0x49,0x41,0x4C
	.DB  0x20,0x3D,0x3D,0x3E,0x20,0x0,0x47,0x65
	.DB  0x74,0x20,0x44,0x65,0x62,0x75,0x67,0x20
	.DB  0x52,0x65,0x71,0x2E,0x3A,0x0,0x25,0x30
	.DB  0x35,0x64,0x20,0x20,0x20,0x0,0x25,0x30
	.DB  0x32,0x78,0x20,0x0,0x2E,0x0
_0x2C0003:
	.DB  0x3
_0x2E0007:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0
_0x300022:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
_0x300000:
	.DB  0x3C,0x43,0x61,0x6C,0x20,0x53,0x74,0x64
	.DB  0x20,0x72,0x65,0x66,0x3E,0x63,0x68,0x5B
	.DB  0x25,0x64,0x5D,0x2C,0x66,0x6F,0x72,0x6D
	.DB  0x61,0x74,0x54,0x79,0x70,0x65,0x3A,0x25
	.DB  0x30,0x2E,0x32,0x66,0xD,0xA,0x0,0x73
	.DB  0x74,0x64,0x52,0x65,0x66,0x3A,0x25,0x30
	.DB  0x2E,0x32,0x66,0x2C,0x73,0x65,0x6E,0x73
	.DB  0x6F,0x72,0x52,0x65,0x66,0x3A,0x25,0x30
	.DB  0x2E,0x32,0x66,0xD,0xA,0x0,0x3C,0x63
	.DB  0x61,0x6C,0x69,0x62,0x72,0x61,0x74,0x69
	.DB  0x6F,0x6E,0x3E,0x43,0x61,0x6C,0x20,0x70
	.DB  0x72,0x6F,0x70,0x65,0x72,0x74,0x69,0x65
	.DB  0x73,0x3A,0x73,0x65,0x74,0x20,0x63,0x61
	.DB  0x6E,0x20,0x6E,0x6F,0x74,0x20,0x67,0x65
	.DB  0x74,0x20,0x76,0x61,0x6C,0x75,0x65,0x2E
	.DB  0x0,0x3C,0x63,0x61,0x6C,0x69,0x62,0x72
	.DB  0x61,0x74,0x69,0x6F,0x6E,0x3E,0x43,0x61
	.DB  0x6C,0x20,0x70,0x72,0x6F,0x70,0x65,0x72
	.DB  0x74,0x69,0x65,0x73,0x3A,0x67,0x65,0x74
	.DB  0x20,0x63,0x61,0x6E,0x20,0x6E,0x6F,0x74
	.DB  0x20,0x73,0x65,0x74,0x20,0x76,0x61,0x6C
	.DB  0x75,0x65,0x2E,0x0,0x3C,0x43,0x61,0x6C
	.DB  0x20,0x53,0x74,0x64,0x20,0x72,0x65,0x66
	.DB  0x3E,0x63,0x68,0x5B,0x25,0x64,0x5D,0x2C
	.DB  0x66,0x6F,0x72,0x6D,0x61,0x74,0x54,0x79
	.DB  0x70,0x65,0x3A,0x25,0x64,0xD,0xA,0x0
_0x320003:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0
_0x320000:
	.DB  0x5B,0x69,0x50,0x54,0x43,0x70,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x53,0x74,0x61,0x72
	.DB  0x74,0x20,0x44,0x65,0x6C,0x69,0x6D,0x69
	.DB  0x74,0x65,0x72,0x20,0x4F,0x4B,0x28,0x25
	.DB  0x30,0x32,0x78,0x29,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x50,0x54,0x43,0x70,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x4C,0x65,0x6E,0x67
	.DB  0x74,0x68,0x20,0x28,0x25,0x64,0x29,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x50,0x54,0x43
	.DB  0x70,0x61,0x72,0x73,0x65,0x72,0x5D,0x43
	.DB  0x68,0x65,0x63,0x6B,0x20,0x73,0x75,0x6D
	.DB  0x20,0x28,0x25,0x30,0x32,0x78,0x29,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x50,0x54,0x43
	.DB  0x70,0x61,0x72,0x73,0x65,0x72,0x5D,0x43
	.DB  0x68,0x65,0x63,0x6B,0x20,0x73,0x75,0x6D
	.DB  0x20,0x63,0x6F,0x72,0x72,0x65,0x63,0x74
	.DB  0x28,0x25,0x64,0x29,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x50,0x54,0x43,0x70,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x43,0x68,0x65,0x63
	.DB  0x6B,0x20,0x73,0x75,0x6D,0x20,0x69,0x6E
	.DB  0x63,0x6F,0x72,0x72,0x65,0x63,0x74,0x28
	.DB  0x25,0x64,0x29,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x50,0x54,0x43,0x43,0x68,0x65,0x63
	.DB  0x6B,0x48,0x6F,0x73,0x74,0x52,0x65,0x71
	.DB  0x5D,0x4D,0x54,0x49,0x28,0x25,0x30,0x32
	.DB  0x78,0x25,0x30,0x32,0x78,0x29,0x0,0x5B
	.DB  0x69,0x50,0x54,0x43,0x43,0x68,0x65,0x63
	.DB  0x6B,0x48,0x6F,0x73,0x74,0x52,0x65,0x71
	.DB  0x5D,0x48,0x6F,0x73,0x74,0x20,0x52,0x65
	.DB  0x71,0x75,0x65,0x73,0x74,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x50,0x54,0x43,0x43,0x68
	.DB  0x65,0x63,0x6B,0x48,0x6F,0x73,0x74,0x52
	.DB  0x65,0x71,0x5D,0x48,0x6F,0x73,0x74,0x20
	.DB  0x69,0x73,0x20,0x6E,0x6F,0x74,0x20,0x52
	.DB  0x65,0x71,0x75,0x65,0x73,0x74,0x2E,0xD
	.DB  0xA,0x0
_0x340003:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x2,0x0,0x2A,0x6,0x11,0x4,0xCD,0xCC
	.DB  0xC7,0x42,0x2A,0x6,0x12,0x4,0x0,0x0
	.DB  0x0,0x0,0x2A,0x6,0x13,0x4,0x0,0x0
	.DB  0xE0,0x41,0x5A,0x7,0x31,0xC,0xD,0x0
	.DB  0x0,0x0,0x0,0x5A,0x7,0x32,0xD,0xD
	.DB  0x1,0xF,0xF0,0x3B,0x5A,0x7,0x41,0xA
	.DB  0x9,0x0,0xF,0xE0,0x41,0x5A,0x7,0x42
	.DB  0xA,0xB,0x0,0xF,0x8,0x42
_0x34001F:
	.DB  0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1
	.DB  0x8,0x0
_0x340021:
	.DB  0x4B,0x2,0x10,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x8,0x0
_0x340000:
	.DB  0x3C,0x6D,0x61,0x6E,0x61,0x67,0x65,0x72
	.DB  0x54,0x61,0x73,0x6B,0x3E,0x54,0x61,0x73
	.DB  0x6B,0x20,0x52,0x75,0x6E,0x6E,0x69,0x6E
	.DB  0x67,0x2E,0x2E,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x6D,0x61,0x6E,0x61,0x67,0x65,0x72,0x54
	.DB  0x61,0x73,0x6B,0x5D,0x50,0x72,0x69,0x6E
	.DB  0x74,0x2E,0x5B,0xD,0xA,0x0,0x5D,0xD
	.DB  0xA,0x0,0x5B,0x69,0x48,0x6F,0x73,0x74
	.DB  0x52,0x65,0x71,0x50,0x72,0x6F,0x63,0x65
	.DB  0x73,0x73,0x5D,0x54,0x58,0x20,0x50,0x72
	.DB  0x69,0x6E,0x74,0x20,0x31,0x2E,0x5B,0xD
	.DB  0xA,0x0,0x5B,0x69,0x48,0x6F,0x73,0x74
	.DB  0x52,0x65,0x71,0x50,0x72,0x6F,0x63,0x65
	.DB  0x73,0x73,0x5D,0x52,0x58,0x20,0x50,0x72
	.DB  0x69,0x6E,0x74,0x20,0x32,0x2E,0x5B,0xD
	.DB  0xA,0x0,0x5B,0x69,0x48,0x6F,0x73,0x74
	.DB  0x52,0x65,0x71,0x50,0x72,0x6F,0x63,0x65
	.DB  0x73,0x73,0x5D,0x50,0x72,0x69,0x6E,0x74
	.DB  0x2E,0x5B,0xD,0xA,0x0,0x5B,0x69,0x54
	.DB  0x65,0x72,0x41,0x63,0x6B,0x42,0x79,0x54
	.DB  0x61,0x67,0x42,0x5D,0x4E,0x6F,0x74,0x20
	.DB  0x61,0x6C,0x6C,0x6F,0x63,0x61,0x74,0x65
	.DB  0x20,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x54,0x61,0x67
	.DB  0x50,0x61,0x72,0x73,0x65,0x72,0x5D,0x48
	.DB  0x6F,0x73,0x74,0x20,0x72,0x65,0x73,0x70
	.DB  0x6F,0x6E,0x73,0x65,0xD,0xA,0x0,0x5B
	.DB  0x69,0x54,0x61,0x67,0x50,0x61,0x72,0x73
	.DB  0x65,0x72,0x5D,0x4C,0x65,0x6E,0x28,0x25
	.DB  0x64,0x29,0xD,0xA,0x0,0x5B,0x69,0x54
	.DB  0x61,0x67,0x50,0x61,0x72,0x73,0x65,0x72
	.DB  0x5D,0x54,0x61,0x67,0x3A,0x25,0x30,0x32
	.DB  0x78,0x28,0x25,0x64,0x29,0xD,0xA,0x0
	.DB  0x5B,0x69,0x54,0x61,0x67,0x50,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x48,0x6F,0x73,0x74
	.DB  0x20,0x6E,0x65,0x65,0x64,0x20,0x74,0x6F
	.DB  0x20,0x63,0x6F,0x6E,0x66,0x69,0x67,0x28
	.DB  0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x69
	.DB  0x65,0x73,0x29,0xD,0xA,0x0,0x5B,0x69
	.DB  0x54,0x61,0x67,0x50,0x61,0x72,0x73,0x65
	.DB  0x72,0x5D,0x48,0x6F,0x73,0x74,0x20,0x6E
	.DB  0x65,0x65,0x64,0x20,0x74,0x6F,0x20,0x63
	.DB  0x6F,0x6E,0x66,0x69,0x67,0x28,0x4F,0x70
	.DB  0x65,0x72,0x61,0x74,0x69,0x6E,0x67,0x29
	.DB  0xD,0xA,0x0,0x5B,0x69,0x54,0x61,0x67
	.DB  0x50,0x61,0x72,0x73,0x65,0x72,0x5D,0x48
	.DB  0x6F,0x73,0x74,0x20,0x6E,0x65,0x65,0x64
	.DB  0x20,0x74,0x6F,0x20,0x63,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x28,0x42,0x75,0x7A,0x7A,0x65
	.DB  0x72,0x29,0xD,0xA,0x0,0x5B,0x69,0x54
	.DB  0x61,0x67,0x50,0x61,0x72,0x73,0x65,0x72
	.DB  0x5D,0x48,0x6F,0x73,0x74,0x20,0x6E,0x65
	.DB  0x65,0x64,0x20,0x74,0x6F,0x20,0x63,0x6F
	.DB  0x6E,0x66,0x69,0x67,0x28,0x45,0x6E,0x76
	.DB  0x69,0x72,0x6F,0x6E,0x6D,0x65,0x6E,0x74
	.DB  0x20,0x41,0x6C,0x61,0x72,0x6D,0x20,0x43
	.DB  0x6F,0x6E,0x64,0x69,0x74,0x69,0x6F,0x6E
	.DB  0x29,0xD,0xA,0x0,0x5B,0x69,0x54,0x61
	.DB  0x67,0x50,0x61,0x72,0x73,0x65,0x72,0x5D
	.DB  0x48,0x6F,0x73,0x74,0x20,0x6E,0x65,0x65
	.DB  0x64,0x20,0x74,0x6F,0x20,0x63,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x28,0x44,0x69,0x67,0x69
	.DB  0x74,0x61,0x6C,0x20,0x49,0x6E,0x70,0x75
	.DB  0x74,0x29,0xD,0xA,0x0,0x5B,0x69,0x54
	.DB  0x61,0x67,0x50,0x61,0x72,0x73,0x65,0x72
	.DB  0x5D,0x48,0x6F,0x73,0x74,0x20,0x6E,0x65
	.DB  0x65,0x64,0x20,0x74,0x6F,0x20,0x63,0x6F
	.DB  0x6E,0x66,0x69,0x67,0x28,0x44,0x69,0x67
	.DB  0x69,0x74,0x61,0x6C,0x20,0x4F,0x75,0x74
	.DB  0x70,0x75,0x74,0x29,0xD,0xA,0x0,0x5B
	.DB  0x69,0x54,0x61,0x67,0x50,0x61,0x72,0x73
	.DB  0x65,0x72,0x5D,0x48,0x6F,0x73,0x74,0x20
	.DB  0x6E,0x65,0x65,0x64,0x20,0x74,0x6F,0x20
	.DB  0x63,0x6F,0x6E,0x66,0x69,0x67,0x28,0x41
	.DB  0x6E,0x61,0x6C,0x6F,0x67,0x20,0x49,0x6E
	.DB  0x70,0x75,0x74,0x29,0xD,0xA,0x0,0x5B
	.DB  0x69,0x54,0x61,0x67,0x50,0x61,0x72,0x73
	.DB  0x65,0x72,0x5D,0x48,0x6F,0x73,0x74,0x20
	.DB  0x6E,0x65,0x65,0x64,0x20,0x74,0x6F,0x20
	.DB  0x63,0x6F,0x6E,0x66,0x69,0x67,0x28,0x41
	.DB  0x6E,0x61,0x6C,0x6F,0x67,0x20,0x4F,0x75
	.DB  0x74,0x70,0x75,0x74,0x29,0xD,0xA,0x0
	.DB  0x5B,0x69,0x54,0x61,0x67,0x50,0x61,0x72
	.DB  0x73,0x65,0x72,0x5D,0x48,0x6F,0x73,0x74
	.DB  0x20,0x72,0x65,0x73,0x70,0x6F,0x6E,0x73
	.DB  0x65,0x20,0x75,0x6E,0x6B,0x6E,0x6F,0x77
	.DB  0x28,0x25,0x30,0x32,0x78,0x29,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x4D,0x61,0x6E,0x67
	.DB  0x51,0x75,0x65,0x75,0x65,0x41,0x64,0x64
	.DB  0x49,0x74,0x65,0x6D,0x5D,0x41,0x64,0x64
	.DB  0x20,0x62,0x79,0x20,0x46,0x49,0x44,0x28
	.DB  0x25,0x30,0x32,0x78,0x25,0x30,0x32,0x78
	.DB  0x29,0x2E,0xD,0xA,0x0,0x5B,0x69,0x4D
	.DB  0x61,0x6E,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x41,0x64,0x64,0x49,0x74,0x65,0x6D,0x5D
	.DB  0x63,0x61,0x6E,0x27,0x74,0x20,0x61,0x6C
	.DB  0x6C,0x6F,0x63,0x61,0x74,0x65,0x20,0x6D
	.DB  0x65,0x6D,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x4D,0x61,0x6E,0x67,0x51,0x75,0x65,0x75
	.DB  0x65,0x41,0x64,0x64,0x49,0x74,0x65,0x6D
	.DB  0x5D,0x4D,0x61,0x6E,0x67,0x51,0x75,0x65
	.DB  0x75,0x65,0x20,0x46,0x75,0x6C,0x6C,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x4D,0x61,0x6E
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0x44,0x65
	.DB  0x6C,0x49,0x74,0x65,0x6D,0x5D,0x44,0x65
	.DB  0x6C,0x20,0x62,0x79,0x20,0x46,0x49,0x44
	.DB  0x28,0x25,0x30,0x32,0x78,0x25,0x30,0x32
	.DB  0x78,0x29,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x4D,0x61,0x6E,0x67,0x51,0x75,0x65,0x75
	.DB  0x65,0x44,0x65,0x6C,0x49,0x74,0x65,0x6D
	.DB  0x5D,0x51,0x75,0x65,0x75,0x65,0x20,0x69
	.DB  0x73,0x20,0x65,0x6D,0x70,0x74,0x79,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x4D,0x61,0x6E
	.DB  0x67,0x51,0x75,0x65,0x75,0x65,0x44,0x65
	.DB  0x6C,0x49,0x74,0x65,0x6D,0x5D,0x46,0x49
	.DB  0x44,0x20,0x69,0x6E,0x76,0x61,0x6C,0x69
	.DB  0x64,0x2E,0xD,0xA,0x0,0x5B,0x69,0x4D
	.DB  0x61,0x6E,0x67,0x51,0x75,0x65,0x75,0x65
	.DB  0x44,0x69,0x73,0x70,0x6C,0x61,0x79,0x5D
	.DB  0x51,0x75,0x65,0x75,0x65,0x20,0x25,0x64
	.DB  0x2E,0x5B,0xD,0xA,0x0,0x45,0x6D,0x70
	.DB  0x74,0x79,0xD,0xA,0x0,0x5B,0x69,0x4D
	.DB  0x61,0x6E,0x67,0x43,0x68,0x65,0x63,0x6B
	.DB  0x52,0x65,0x74,0x72,0x61,0x6E,0x73,0x6D
	.DB  0x69,0x74,0x5D,0x52,0x65,0x74,0x72,0x61
	.DB  0x6E,0x73,0x6D,0x69,0x74,0x20,0x72,0x65
	.DB  0x6D,0x61,0x69,0x6E,0x20,0x25,0x64,0x2E
	.DB  0xD,0xA,0x0,0x54,0x68,0x65,0x72,0x65
	.DB  0x20,0x69,0x73,0x20,0x6E,0x6F,0x20,0x46
	.DB  0x49,0x44,0x28,0x25,0x30,0x32,0x78,0x25
	.DB  0x30,0x32,0x78,0x29,0x20,0x69,0x6E,0x20
	.DB  0x71,0x75,0x65,0x75,0x65,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x70,0x72,0x69,0x6E,0x74,0x43
	.DB  0x6F,0x6E,0x66,0x69,0x67,0x5D,0x44,0x61
	.DB  0x74,0x61,0x3A,0x5B,0xD,0xA,0x0,0x25
	.DB  0x30,0x34,0x64,0x9,0x9,0x0,0x25,0x30
	.DB  0x32,0x78,0x0,0xD,0xA,0x5D,0xD,0xA
	.DB  0x0
_0x360000:
	.DB  0x5B,0x69,0x51,0x75,0x65,0x75,0x65,0x43
	.DB  0x72,0x65,0x61,0x74,0x65,0x5D,0x2C,0x69
	.DB  0x74,0x65,0x6D,0x43,0x6F,0x75,0x6E,0x74
	.DB  0x28,0x25,0x64,0x29,0xD,0xA,0x0,0x5B
	.DB  0x69,0x51,0x75,0x65,0x75,0x65,0x43,0x72
	.DB  0x65,0x61,0x74,0x65,0x5D,0x2C,0x51,0x75
	.DB  0x65,0x75,0x65,0x28,0x45,0x6C,0x65,0x6E
	.DB  0x20,0x73,0x69,0x7A,0x65,0x29,0x20,0x69
	.DB  0x73,0x20,0x6E,0x6F,0x74,0x20,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x64,0x21,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x51,0x75,0x65,0x75
	.DB  0x65,0x43,0x72,0x65,0x61,0x74,0x65,0x5D
	.DB  0x2C,0x51,0x75,0x65,0x75,0x65,0x20,0x69
	.DB  0x73,0x20,0x6E,0x6F,0x74,0x20,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x64,0x21,0x2E,0xD
	.DB  0xA,0x0,0x3C,0x69,0x51,0x75,0x65,0x75
	.DB  0x65,0x53,0x65,0x6E,0x64,0x3E,0x73,0x74
	.DB  0x61,0x74,0x75,0x73,0x28,0x65,0x6D,0x70
	.DB  0x74,0x79,0x29,0xD,0xA,0x0,0x3C,0x69
	.DB  0x51,0x75,0x65,0x75,0x65,0x53,0x65,0x6E
	.DB  0x64,0x3E,0x73,0x74,0x61,0x74,0x75,0x73
	.DB  0x28,0x69,0x74,0x65,0x6D,0x20,0x63,0x6F
	.DB  0x75,0x6E,0x74,0x20,0x69,0x73,0x20,0x6E
	.DB  0x6F,0x74,0x20,0x72,0x61,0x6E,0x67,0x65
	.DB  0x29,0xD,0xA,0x29,0x0,0x3C,0x69,0x51
	.DB  0x75,0x65,0x75,0x65,0x53,0x65,0x6E,0x64
	.DB  0x3E,0x73,0x74,0x61,0x74,0x75,0x73,0x28
	.DB  0x66,0x75,0x6C,0x6C,0x20,0x61,0x6E,0x64
	.DB  0x20,0x77,0x61,0x69,0x74,0x29,0xD,0xA
	.DB  0x0,0x3C,0x69,0x51,0x75,0x65,0x75,0x65
	.DB  0x53,0x65,0x6E,0x64,0x3E,0x63,0x6F,0x75
	.DB  0x6E,0x74,0x28,0x25,0x64,0x29,0xD,0xA
	.DB  0x0,0x3C,0x69,0x51,0x75,0x65,0x75,0x65
	.DB  0x52,0x65,0x63,0x65,0x69,0x76,0x65,0x3E
	.DB  0x51,0x75,0x65,0x75,0x65,0x49,0x74,0x65
	.DB  0x6D,0x20,0x69,0x73,0x20,0x65,0x6D,0x70
	.DB  0x74,0x79,0x20,0x69,0x74,0x20,0x63,0x61
	.DB  0x6E,0x20,0x6E,0x6F,0x74,0x20,0x72,0x65
	.DB  0x61,0x64,0x2E,0xD,0xA,0x0,0x3C,0x69
	.DB  0x51,0x75,0x65,0x75,0x65,0x52,0x65,0x63
	.DB  0x65,0x69,0x76,0x65,0x3E,0x51,0x75,0x65
	.DB  0x75,0x65,0x49,0x74,0x65,0x6D,0x20,0x69
	.DB  0x73,0x20,0x65,0x78,0x69,0x73,0x74,0x2E
	.DB  0xD,0xA,0x0,0x3C,0x69,0x51,0x75,0x65
	.DB  0x75,0x65,0x52,0x65,0x63,0x65,0x69,0x76
	.DB  0x65,0x3E,0x63,0x6F,0x75,0x6E,0x74,0x28
	.DB  0x25,0x64,0x29,0xD,0xA,0x0
_0x3A0000:
	.DB  0x3C,0x69,0x54,0x61,0x73,0x6B,0x43,0x72
	.DB  0x65,0x61,0x74,0x65,0x3E,0x54,0x61,0x73
	.DB  0x6B,0x20,0x63,0x61,0x6E,0x20,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x2E,0xD,0xA,0x0
	.DB  0x3C,0x69,0x54,0x61,0x73,0x6B,0x43,0x72
	.DB  0x65,0x61,0x74,0x65,0x3E,0x54,0x61,0x73
	.DB  0x6B,0x20,0x63,0x61,0x6E,0x20,0x6E,0x6F
	.DB  0x74,0x20,0x63,0x72,0x65,0x61,0x74,0x65
	.DB  0x2E,0xD,0xA,0x0
_0x3C0000:
	.DB  0x3C,0x73,0x65,0x6E,0x73,0x6F,0x72,0x54
	.DB  0x61,0x73,0x6B,0x3E,0x54,0x61,0x73,0x6B
	.DB  0x20,0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67
	.DB  0x2E,0x2E,0x2E,0xD,0xA,0x0,0x44,0x48
	.DB  0x54,0x31,0x31,0x20,0x65,0x72,0x72,0x65
	.DB  0x72,0x28,0x63,0x68,0x65,0x63,0x6B,0x20
	.DB  0x73,0x75,0x6D,0x29,0x2E,0xD,0xA,0x0
	.DB  0x44,0x48,0x54,0x31,0x31,0x20,0x65,0x72
	.DB  0x72,0x65,0x72,0x28,0x74,0x69,0x6D,0x65
	.DB  0x20,0x6F,0x75,0x74,0x29,0x2E,0xD,0xA
	.DB  0x0
_0x3E0000:
	.DB  0x3C,0x64,0x65,0x62,0x75,0x67,0x54,0x61
	.DB  0x73,0x6B,0x3E,0x54,0x61,0x73,0x6B,0x20
	.DB  0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67,0x2E
	.DB  0x2E,0x2E,0xD,0xA,0x0
_0x400000:
	.DB  0x3C,0x63,0x6F,0x6D,0x6D,0x75,0x6E,0x69
	.DB  0x63,0x61,0x74,0x65,0x54,0x61,0x73,0x6B
	.DB  0x3E,0x54,0x61,0x73,0x6B,0x20,0x52,0x75
	.DB  0x6E,0x6E,0x69,0x6E,0x67,0x2E,0x2E,0x2E
	.DB  0xD,0xA,0x0
_0x420003:
	.DB  0x7E,0x0,0x10,0x8,0x0,0x1,0x1,0x1
	.DB  0x1,0x1,0x1,0x1,0x1,0x64,0x75,0xC9
	.DB  0x55,0x0,0x0,0xD8
_0x420000:
	.DB  0x5B,0x69,0x4C,0x61,0x6E,0x52,0x65,0x61
	.DB  0x64,0x44,0x61,0x74,0x61,0x5D,0x69,0x57
	.DB  0x69,0x7A,0x52,0x65,0x61,0x64,0x3A,0x4F
	.DB  0x4B,0x2E,0xD,0xA,0x0,0x5B,0x69,0x4C
	.DB  0x61,0x6E,0x52,0x65,0x61,0x64,0x44,0x61
	.DB  0x74,0x61,0x5D,0x44,0x61,0x74,0x61,0x3A
	.DB  0x4F,0x4B,0x5B,0xD,0xA,0x0,0x5D,0xD
	.DB  0xA,0x0,0x5B,0x69,0x4C,0x61,0x6E,0x52
	.DB  0x65,0x61,0x64,0x44,0x61,0x74,0x61,0x5D
	.DB  0x69,0x57,0x69,0x7A,0x52,0x65,0x61,0x64
	.DB  0x3A,0x65,0x6D,0x70,0x74,0x79,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x4C,0x61,0x6E,0x49
	.DB  0x6E,0x69,0x74,0x5D,0x53,0x74,0x61,0x74
	.DB  0x75,0x73,0x3A,0x43,0x6F,0x6E,0x6E,0x65
	.DB  0x63,0x74,0x65,0x64,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x4C,0x61,0x6E,0x49,0x6E,0x69
	.DB  0x74,0x5D,0x53,0x74,0x61,0x74,0x75,0x73
	.DB  0x3A,0x43,0x6C,0x6F,0x73,0x65,0x2E,0xD
	.DB  0xA,0x0
_0x440003:
	.DB  0x50,0x4F,0x53,0x54,0x20,0x2F,0x73,0x6D
	.DB  0x61,0x73,0x6D,0x61,0x72,0x74,0x64,0x65
	.DB  0x76,0x69,0x63,0x65,0x20,0x48,0x54,0x54
	.DB  0x50,0x2F,0x31,0x2E,0x31,0xD,0xA,0x48
	.DB  0x6F,0x73,0x74,0x3A,0x20,0x73,0x6D,0x61
	.DB  0x73,0x6D,0x61,0x72,0x74,0x64,0x65,0x76
	.DB  0x69,0x63,0x65,0x2E,0x61,0x70,0x70,0x73
	.DB  0x70,0x6F,0x74,0x2E,0x63,0x6F,0x6D,0xD
	.DB  0xA,0x58,0x2D,0x43,0x4C,0x49,0x45,0x4E
	.DB  0x54,0x2D,0x55,0x55,0x49,0x44,0x3A,0x20
	.DB  0x30,0x30,0x31,0x31,0x30,0x30,0x31,0x31
	.DB  0x30,0x30,0x31,0x31,0xD,0xA,0x55,0x73
	.DB  0x65,0x72,0x2D,0x41,0x67,0x65,0x6E,0x74
	.DB  0x3A,0x20,0x41,0x56,0x52,0x32,0x35,0x36
	.DB  0x30,0x2D,0x4C,0x41,0x4E,0xD,0xA,0x43
	.DB  0x6F,0x6E,0x6E,0x65,0x63,0x74,0x69,0x6F
	.DB  0x6E,0x3A,0x20,0x63,0x6C,0x6F,0x73,0x65
	.DB  0xD,0xA,0x43,0x6F,0x6E,0x74,0x65,0x6E
	.DB  0x74,0x2D,0x4C,0x65,0x6E,0x67,0x74,0x68
	.DB  0x3A,0x20
_0x44001F:
	.DB  0xD,0xA,0x43,0x6F,0x6E,0x74,0x65,0x6E
	.DB  0x74,0x2D,0x4C,0x65,0x6E,0x67,0x74,0x68
	.DB  0x3A,0x20,0x0,0xD,0xA,0x43,0x6F,0x6E
	.DB  0x6E,0x65,0x63,0x74,0x69,0x6F,0x6E,0x3A
	.DB  0x20,0x63,0x6C,0x6F,0x73,0x65,0x0,0xD
	.DB  0xA,0x58,0x2D,0x43,0x4C,0x49,0x45,0x4E
	.DB  0x54,0x2D,0x55,0x55,0x49,0x44,0x3A,0x20
	.DB  0x0,0xD,0xA,0x48,0x6F,0x73,0x74,0x3A
	.DB  0x20,0x73,0x6D,0x61,0x73,0x6D,0x61,0x72
	.DB  0x74,0x64,0x65,0x76,0x69,0x63,0x65,0x2E
	.DB  0x61,0x70,0x70,0x73,0x70,0x6F,0x74,0x2E
	.DB  0x63,0x6F,0x6D,0x0,0x50,0x4F,0x53,0x54
	.DB  0x20,0x2F,0x73,0x6D,0x61,0x73,0x6D,0x61
	.DB  0x72,0x74,0x64,0x65,0x76,0x69,0x63,0x65
	.DB  0x20,0x48,0x54,0x54,0x50,0x2F,0x31,0x2E
	.DB  0x31,0x0
_0x440035:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0
_0x440053:
	.DB  0x3C,0x57,0x52,0x3E,0x0,0x3C,0x52,0x57
	.DB  0x3E,0x0,0x3C,0x52,0x54,0x3E,0x0,0x3C
	.DB  0x52,0x42,0x3E,0x0,0x3C,0x52,0x4B,0x3E
	.DB  0x0,0x3C,0x52,0x4D,0x3E,0x0,0x3C,0x52
	.DB  0x44,0x3E,0x0,0x3C,0x52,0x50,0x3E,0x0
	.DB  0x3C,0x52,0x47,0x3E,0x0,0x3C,0x52,0x53
	.DB  0x3E,0x0,0x3C,0x52,0x49,0x3E,0x0,0x3C
	.DB  0x52,0x41,0x3E,0x0,0x2B,0x2B,0x2B,0x0
_0x440000:
	.DB  0x3C,0x69,0x57,0x69,0x7A,0x52,0x58,0x54
	.DB  0x69,0x6D,0x65,0x4F,0x75,0x74,0x3E,0xD
	.DB  0xA,0x0,0x20,0x0,0x32,0x30,0x30,0x0
	.DB  0x5B,0x52,0x65,0x73,0x20,0x63,0x6F,0x64
	.DB  0x65,0x3A,0x20,0x25,0x73,0x5D,0xD,0xA
	.DB  0x0,0x43,0x6F,0x6E,0x74,0x65,0x6E,0x74
	.DB  0x2D,0x4C,0x65,0x6E,0x67,0x74,0x68,0x0
	.DB  0x5B,0x52,0x65,0x73,0x20,0x6C,0x65,0x6E
	.DB  0x3A,0x20,0x25,0x73,0x5D,0xD,0xA,0x0
	.DB  0x5B,0x52,0x65,0x73,0x20,0x6C,0x65,0x6E
	.DB  0x3A,0x20,0x25,0x64,0x5D,0xD,0xA,0x0
	.DB  0x5B,0x4E,0x6F,0x74,0x66,0x6F,0x75,0x6E
	.DB  0x64,0x20,0x52,0x65,0x73,0x20,0x6C,0x65
	.DB  0x6E,0x5D,0xD,0xA,0x0,0x5B,0x77,0x69
	.DB  0x7A,0x43,0x6F,0x6E,0x74,0x65,0x6E,0x74
	.DB  0x4C,0x65,0x6E,0x5D,0x63,0x61,0x6E,0x20
	.DB  0x27,0x74,0x20,0x61,0x6C,0x6C,0x6F,0x63
	.DB  0x61,0x74,0x65,0x20,0x6D,0x65,0x6D,0x2E
	.DB  0xD,0xA,0x0,0x3E,0x20,0x43,0x6F,0x6E
	.DB  0x6E,0x65,0x63,0x74,0x65,0x64,0x0,0x3E
	.DB  0x20,0x43,0x6C,0x6F,0x73,0x65,0x64,0x0
	.DB  0x5B,0x77,0x69,0x7A,0x53,0x74,0x61,0x74
	.DB  0x5D,0x63,0x61,0x6E,0x20,0x27,0x74,0x20
	.DB  0x61,0x6C,0x6C,0x6F,0x63,0x61,0x74,0x65
	.DB  0x20,0x6D,0x65,0x6D,0x2E,0xD,0xA,0x0
	.DB  0x25,0x64,0xD,0xA,0xD,0xA,0x0,0x5B
	.DB  0x77,0x69,0x7A,0x53,0x65,0x6E,0x64,0x5D
	.DB  0x63,0x61,0x6E,0x20,0x27,0x74,0x20,0x61
	.DB  0x6C,0x6C,0x6F,0x63,0x61,0x74,0x65,0x20
	.DB  0x6D,0x65,0x6D,0x2E,0xD,0xA,0x0,0x69
	.DB  0x6E,0x64,0x65,0x78,0x30,0x42,0x75,0x66
	.DB  0x66,0x65,0x72,0x28,0x25,0x64,0x29,0xD
	.DB  0xA,0x0,0x25,0x63,0x0,0x5B,0x69,0x57
	.DB  0x69,0x7A,0x43,0x6F,0x6E,0x6E,0x65,0x63
	.DB  0x74,0x65,0x64,0x5D,0x46,0x75,0x6E,0x63
	.DB  0x74,0x69,0x6F,0x6E,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x57,0x69,0x7A,0x43,0x6F,0x6E
	.DB  0x6E,0x65,0x63,0x74,0x65,0x64,0x20,0x6C
	.DB  0x65,0x6E,0x28,0x25,0x64,0x29,0x5D,0xD
	.DB  0xA,0x0,0x3E,0x0,0x5B,0x44,0x61,0x74
	.DB  0x61,0x20,0x73,0x70,0x6C,0x69,0x74,0x5D
	.DB  0x25,0x73,0xD,0xA,0x0,0x20,0x4C,0x69
	.DB  0x73,0x74,0x65,0x6E,0x20,0x3A,0x20,0x4F
	.DB  0x4B,0x0,0x5B,0x69,0x57,0x69,0x7A,0x52
	.DB  0x65,0x61,0x64,0x5D,0x46,0x75,0x6E,0x63
	.DB  0x74,0x69,0x6F,0x6E,0xD,0xA,0x0,0x5B
	.DB  0x48,0x54,0x54,0x50,0x5D,0x43,0x68,0x65
	.DB  0x63,0x6B,0x20,0x52,0x65,0x73,0x43,0x6F
	.DB  0x64,0x65,0xD,0xA,0x0,0x48,0x54,0x54
	.DB  0x50,0x2F,0x0,0x5B,0x48,0x54,0x54,0x50
	.DB  0x5D,0x32,0x30,0x30,0x20,0x4F,0x4B,0xD
	.DB  0xA,0x0,0x5B,0x48,0x54,0x54,0x50,0x5D
	.DB  0x43,0x68,0x65,0x63,0x6B,0x20,0x4C,0x65
	.DB  0x6E,0x67,0x74,0x68,0xD,0xA,0x0,0x5B
	.DB  0x44,0x61,0x74,0x61,0x4C,0x65,0x6E,0x5D
	.DB  0x5B,0x25,0x73,0x5D,0xD,0xA,0x0,0x5B
	.DB  0x48,0x54,0x54,0x50,0x5D,0x50,0x61,0x72
	.DB  0x73,0x65,0x72,0x20,0x44,0x61,0x74,0x61
	.DB  0xD,0xA,0x0,0x5B,0x44,0x61,0x74,0x61
	.DB  0x5D,0x5B,0xD,0xA,0x0,0x3C,0x45,0x3E
	.DB  0x0,0x5B,0x69,0x57,0x69,0x7A,0x52,0x65
	.DB  0x61,0x64,0x43,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x5D,0x63,0x61,0x6E,0x20,0x63,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x20,0x6D,0x6F,0x64,0x65
	.DB  0x28,0x52,0x65,0x61,0x64,0x29,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x57,0x69,0x7A,0x52
	.DB  0x65,0x61,0x64,0x43,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x5D,0x4D,0x41,0x43,0x3A,0x0,0x25
	.DB  0x30,0x32,0x78,0x3A,0x0,0x25,0x30,0x32
	.DB  0x78,0x0,0x5B,0x69,0x57,0x69,0x7A,0x52
	.DB  0x65,0x61,0x64,0x43,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x5D,0x49,0x50,0x3A,0x0,0x25,0x30
	.DB  0x32,0x78,0x2E,0x0,0x5B,0x69,0x57,0x69
	.DB  0x7A,0x52,0x65,0x61,0x64,0x43,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x5D,0x53,0x75,0x62,0x6E
	.DB  0x65,0x74,0x20,0x6D,0x61,0x73,0x6B,0x3A
	.DB  0x0,0x5B,0x69,0x57,0x69,0x7A,0x52,0x65
	.DB  0x61,0x64,0x43,0x6F,0x6E,0x66,0x69,0x67
	.DB  0x5D,0x47,0x61,0x74,0x65,0x77,0x61,0x79
	.DB  0x3A,0x0,0x5B,0x69,0x57,0x69,0x7A,0x52
	.DB  0x65,0x61,0x64,0x43,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x5D,0x53,0x44,0x4E,0x3A,0x25,0x73
	.DB  0xD,0xA,0x0,0x3C,0x53,0x3E,0x0,0x5B
	.DB  0x69,0x57,0x69,0x7A,0x52,0x65,0x61,0x64
	.DB  0x43,0x6F,0x6E,0x66,0x69,0x67,0x5D,0x52
	.DB  0x65,0x73,0x74,0x61,0x72,0x74,0x20,0x57
	.DB  0x69,0x7A,0x31,0x30,0x30,0x53,0x52,0x20
	.DB  0x73,0x75,0x63,0x63,0x65,0x73,0x73,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x57,0x69,0x7A
	.DB  0x52,0x65,0x61,0x64,0x43,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x5D,0x52,0x65,0x73,0x74,0x61
	.DB  0x72,0x74,0x20,0x57,0x69,0x7A,0x31,0x30
	.DB  0x30,0x53,0x52,0x20,0x75,0x6E,0x73,0x75
	.DB  0x63,0x63,0x65,0x73,0x73,0x2E,0xD,0xA
	.DB  0x0,0x3C,0x53,0x0,0x5B,0x69,0x57,0x69
	.DB  0x7A,0x52,0x65,0x61,0x64,0x43,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x5D,0x72,0x65,0x73,0x70
	.DB  0x6F,0x6E,0x73,0x65,0x20,0x64,0x61,0x74
	.DB  0x61,0x5B,0x2E,0xD,0xA,0x0,0x5D,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x57,0x69,0x7A
	.DB  0x52,0x65,0x61,0x64,0x43,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x5D,0x77,0x69,0x7A,0x20,0x69
	.DB  0x73,0x20,0x6E,0x6F,0x74,0x20,0x72,0x65
	.DB  0x73,0x70,0x6F,0x6E,0x73,0x65,0x2E,0xD
	.DB  0xA,0x0,0x25,0x73,0x0
_0x460003:
	.DB  0xFF,0xFF
_0x460004:
	.DB  0xFF,0xFF
_0x460000:
	.DB  0x3C,0x69,0x6E,0x74,0x65,0x72,0x72,0x75
	.DB  0x70,0x74,0x54,0x61,0x73,0x6B,0x3E,0x54
	.DB  0x61,0x73,0x6B,0x20,0x52,0x75,0x6E,0x6E
	.DB  0x69,0x6E,0x67,0x2E,0x2E,0x2E,0xD,0xA
	.DB  0x0,0x3C,0x69,0x6E,0x74,0x65,0x72,0x72
	.DB  0x75,0x70,0x74,0x54,0x61,0x73,0x6B,0x3E
	.DB  0x70,0x76,0x69,0x55,0x61,0x72,0x74,0x30
	.DB  0x54,0x69,0x6D,0x65,0x4F,0x75,0x74,0x28
	.DB  0x25,0x64,0x29,0x2C,0x77,0x69,0x7A,0x31
	.DB  0x30,0x30,0x73,0x72,0x53,0x65,0x74,0x54
	.DB  0x69,0x6D,0x65,0x72,0x28,0x25,0x64,0x29
	.DB  0xD,0xA,0x0,0x3C,0x69,0x6E,0x74,0x65
	.DB  0x72,0x72,0x75,0x70,0x74,0x54,0x61,0x73
	.DB  0x6B,0x3E,0x73,0x74,0x61,0x72,0x74,0x20
	.DB  0x63,0x6F,0x75,0x6E,0x74,0x20,0x70,0x76
	.DB  0x69,0x55,0x61,0x72,0x74,0x30,0x54,0x69
	.DB  0x6D,0x65,0x4F,0x75,0x74,0xD,0xA,0x0
	.DB  0x3C,0x69,0x6E,0x74,0x65,0x72,0x72,0x75
	.DB  0x70,0x74,0x54,0x61,0x73,0x6B,0x3E,0x77
	.DB  0x69,0x7A,0x31,0x30,0x30,0x73,0x72,0x53
	.DB  0x65,0x74,0x54,0x69,0x6D,0x65,0x72,0x28
	.DB  0x74,0x69,0x6D,0x65,0x6F,0x75,0x74,0x20
	.DB  0x25,0x64,0x29,0xD,0xA,0x0
_0x480000:
	.DB  0x5B,0x64,0x65,0x76,0x69,0x63,0x65,0x54
	.DB  0x61,0x73,0x6B,0x5D,0x54,0x61,0x73,0x6B
	.DB  0x20,0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67
	.DB  0x2E,0x2E,0x2E,0xD,0xA,0x0,0x5B,0x64
	.DB  0x65,0x76,0x69,0x63,0x65,0x54,0x61,0x73
	.DB  0x6B,0x5D,0x54,0x68,0x65,0x72,0x65,0x20
	.DB  0x69,0x73,0x20,0x63,0x6F,0x6E,0x66,0x69
	.DB  0x67,0x75,0x72,0x61,0x74,0x69,0x6F,0x6E
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x64,0x65,0x76
	.DB  0x69,0x63,0x65,0x54,0x61,0x73,0x6B,0x5D
	.DB  0x54,0x68,0x65,0x72,0x65,0x20,0x69,0x73
	.DB  0x20,0x6E,0x6F,0x74,0x20,0x63,0x6F,0x6E
	.DB  0x66,0x69,0x67,0x2E,0xD,0xA,0x0
_0x4C0000:
	.DB  0x5B,0x6C,0x6F,0x67,0x54,0x61,0x73,0x6B
	.DB  0x5D,0x52,0x75,0x6E,0x6E,0x69,0x6E,0x67
	.DB  0x2E,0x2E,0x2E,0xD,0xA,0x0,0x48,0x65
	.DB  0x6C,0x6C,0x6F,0x20,0x57,0x6F,0x72,0x6C
	.DB  0x64,0x21,0x2E,0xD,0xA,0x0
_0x4E0003:
	.DB  0x44,0x61,0x74,0x61
_0x4E0004:
	.DB  0x44,0x61,0x74,0x61,0x5F,0x4C,0x6F,0x67
_0x4E0005:
	.DB  0x45,0x76,0x65,0x6E,0x74
_0x4E0006:
	.DB  0x53,0x74,0x61,0x74,0x75,0x73
_0x4E0007:
	.DB  0x45,0x72,0x72,0x6F,0x72
_0x4E0008:
	.DB  0x43,0x6F,0x6E,0x66,0x69,0x67
_0x4E0009:
	.DB  0x30,0x3A,0x2F
_0x4E000A:
	.DB  0x30,0x3A,0x2F,0x44,0x41,0x54,0x41
_0x4E000B:
	.DB  0x30,0x3A,0x2F,0x44,0x41,0x54,0x41,0x5F
	.DB  0x4C,0x4F,0x47
_0x4E000C:
	.DB  0x30,0x3A,0x2F,0x45,0x56,0x45,0x4E,0x54
_0x4E000D:
	.DB  0x30,0x3A,0x2F,0x53,0x54,0x41,0x54,0x55
	.DB  0x53
_0x4E000E:
	.DB  0x30,0x3A,0x2F,0x45,0x52,0x52,0x4F,0x52
_0x4E000F:
	.DB  0x30,0x3A,0x2F,0x43,0x4F,0x4E,0x46,0x49
	.DB  0x47
_0x4E0010:
	.DB  0x30,0x3A,0x2E,0x2F,0x64,0x61,0x74,0x61
	.DB  0x31,0x2E,0x6E,0x63
_0x4E0011:
	.DB  0x30,0x3A,0x2E,0x2F,0x64,0x61,0x74,0x61
	.DB  0x4C,0x6F,0x67,0x31,0x2E,0x6E,0x63
_0x4E0012:
	.DB  0x30,0x3A,0x2E,0x2F,0x65,0x76,0x65,0x6E
	.DB  0x74,0x31,0x2E,0x6E,0x63
_0x4E0013:
	.DB  0x30,0x3A,0x2E,0x2F,0x73,0x74,0x61,0x74
	.DB  0x75,0x73,0x31,0x2E,0x6E,0x63
_0x4E0014:
	.DB  0x30,0x3A,0x2E,0x2F,0x65,0x72,0x72,0x6F
	.DB  0x72,0x31,0x2E,0x6E,0x63
_0x4E0015:
	.DB  0x30,0x3A,0x2E,0x2F,0x63,0x6F,0x6E,0x66
	.DB  0x69,0x67,0x31,0x2E,0x6E,0x63
_0x4E0000:
	.DB  0x25,0x63,0x25,0x63,0x25,0x63,0x25,0x63
	.DB  0x25,0x63,0x20,0x25,0x30,0x32,0x75,0x2F
	.DB  0x25,0x30,0x32,0x75,0x2F,0x25,0x75,0x20
	.DB  0x25,0x30,0x32,0x75,0x3A,0x25,0x30,0x32
	.DB  0x75,0x3A,0x25,0x30,0x32,0x75,0x20,0x25
	.DB  0x39,0x6C,0x75,0x20,0x20,0x25,0x73,0x2F
	.DB  0x25,0x73,0xD,0xA,0x0,0x2F,0x0,0x5B
	.DB  0x69,0x49,0x6E,0x69,0x74,0x53,0x44,0x43
	.DB  0x61,0x72,0x64,0x5D,0x44,0x61,0x74,0x61
	.DB  0x20,0x64,0x69,0x72,0x20,0x69,0x73,0x20
	.DB  0x65,0x78,0x69,0x73,0x74,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x49,0x6E,0x69,0x74,0x53
	.DB  0x44,0x43,0x61,0x72,0x64,0x5D,0x6D,0x6B
	.DB  0x64,0x69,0x72,0x20,0x44,0x61,0x74,0x61
	.DB  0x20,0x73,0x75,0x63,0x63,0x65,0x73,0x73
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x49,0x6E
	.DB  0x69,0x74,0x53,0x44,0x43,0x61,0x72,0x64
	.DB  0x5D,0x6D,0x6B,0x64,0x69,0x72,0x20,0x44
	.DB  0x61,0x74,0x61,0x20,0x65,0x72,0x72,0x6F
	.DB  0x72,0x2E,0xD,0xA,0x0,0x5B,0x69,0x49
	.DB  0x6E,0x69,0x74,0x53,0x44,0x43,0x61,0x72
	.DB  0x64,0x5D,0x44,0x61,0x74,0x61,0x4C,0x6F
	.DB  0x67,0x20,0x64,0x69,0x72,0x20,0x69,0x73
	.DB  0x20,0x65,0x78,0x69,0x73,0x74,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x49,0x6E,0x69,0x74
	.DB  0x53,0x44,0x43,0x61,0x72,0x64,0x5D,0x6D
	.DB  0x6B,0x64,0x69,0x72,0x20,0x44,0x61,0x74
	.DB  0x61,0x4C,0x6F,0x67,0x20,0x73,0x75,0x63
	.DB  0x63,0x65,0x73,0x73,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x49,0x6E,0x69,0x74,0x53,0x44
	.DB  0x43,0x61,0x72,0x64,0x5D,0x6D,0x6B,0x64
	.DB  0x69,0x72,0x20,0x44,0x61,0x74,0x61,0x4C
	.DB  0x6F,0x67,0x20,0x65,0x72,0x72,0x6F,0x72
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x49,0x6E
	.DB  0x69,0x74,0x53,0x44,0x43,0x61,0x72,0x64
	.DB  0x5D,0x45,0x76,0x65,0x6E,0x74,0x20,0x64
	.DB  0x69,0x72,0x20,0x69,0x73,0x20,0x65,0x78
	.DB  0x69,0x73,0x74,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x49,0x6E,0x69,0x74,0x53,0x44,0x43
	.DB  0x61,0x72,0x64,0x5D,0x6D,0x6B,0x64,0x69
	.DB  0x72,0x20,0x45,0x76,0x65,0x6E,0x74,0x20
	.DB  0x73,0x75,0x63,0x63,0x65,0x73,0x73,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x49,0x6E,0x69
	.DB  0x74,0x53,0x44,0x43,0x61,0x72,0x64,0x5D
	.DB  0x6D,0x6B,0x64,0x69,0x72,0x20,0x45,0x76
	.DB  0x65,0x6E,0x74,0x20,0x65,0x72,0x72,0x6F
	.DB  0x72,0x2E,0xD,0xA,0x0,0x5B,0x69,0x49
	.DB  0x6E,0x69,0x74,0x53,0x44,0x43,0x61,0x72
	.DB  0x64,0x5D,0x53,0x74,0x61,0x74,0x75,0x73
	.DB  0x20,0x64,0x69,0x72,0x20,0x69,0x73,0x20
	.DB  0x65,0x78,0x69,0x73,0x74,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x49,0x6E,0x69,0x74,0x53
	.DB  0x44,0x43,0x61,0x72,0x64,0x5D,0x6D,0x6B
	.DB  0x64,0x69,0x72,0x20,0x53,0x74,0x61,0x74
	.DB  0x75,0x73,0x20,0x73,0x75,0x63,0x63,0x65
	.DB  0x73,0x73,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x49,0x6E,0x69,0x74,0x53,0x44,0x43,0x61
	.DB  0x72,0x64,0x5D,0x6D,0x6B,0x64,0x69,0x72
	.DB  0x20,0x53,0x74,0x61,0x74,0x75,0x73,0x20
	.DB  0x65,0x72,0x72,0x6F,0x72,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x49,0x6E,0x69,0x74,0x53
	.DB  0x44,0x43,0x61,0x72,0x64,0x5D,0x45,0x72
	.DB  0x72,0x6F,0x72,0x20,0x64,0x69,0x72,0x20
	.DB  0x69,0x73,0x20,0x65,0x78,0x69,0x73,0x74
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x49,0x6E
	.DB  0x69,0x74,0x53,0x44,0x43,0x61,0x72,0x64
	.DB  0x5D,0x6D,0x6B,0x64,0x69,0x72,0x20,0x45
	.DB  0x72,0x72,0x6F,0x72,0x20,0x73,0x75,0x63
	.DB  0x63,0x65,0x73,0x73,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x49,0x6E,0x69,0x74,0x53,0x44
	.DB  0x43,0x61,0x72,0x64,0x5D,0x6D,0x6B,0x64
	.DB  0x69,0x72,0x20,0x45,0x72,0x72,0x6F,0x72
	.DB  0x20,0x65,0x72,0x72,0x6F,0x72,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x49,0x6E,0x69,0x74
	.DB  0x53,0x44,0x43,0x61,0x72,0x64,0x5D,0x43
	.DB  0x6F,0x6E,0x66,0x69,0x67,0x20,0x64,0x69
	.DB  0x72,0x20,0x69,0x73,0x20,0x65,0x78,0x69
	.DB  0x73,0x74,0x2E,0xD,0xA,0x0,0x5B,0x69
	.DB  0x49,0x6E,0x69,0x74,0x53,0x44,0x43,0x61
	.DB  0x72,0x64,0x5D,0x6D,0x6B,0x64,0x69,0x72
	.DB  0x20,0x43,0x6F,0x6E,0x66,0x69,0x67,0x20
	.DB  0x73,0x75,0x63,0x63,0x65,0x73,0x73,0x2E
	.DB  0xD,0xA,0x0,0x5B,0x69,0x49,0x6E,0x69
	.DB  0x74,0x53,0x44,0x43,0x61,0x72,0x64,0x5D
	.DB  0x6D,0x6B,0x64,0x69,0x72,0x20,0x43,0x6F
	.DB  0x6E,0x66,0x69,0x67,0x20,0x65,0x72,0x72
	.DB  0x6F,0x72,0x2E,0xD,0xA,0x0,0x63,0x6F
	.DB  0x75,0x6C,0x64,0x6E,0x27,0x74,0x20,0x66
	.DB  0x69,0x6E,0x64,0x20,0x74,0x68,0x65,0x20
	.DB  0x70,0x61,0x74,0x68,0x2E,0xD,0xA,0x0
	.DB  0x74,0x68,0x65,0x20,0x64,0x69,0x72,0x65
	.DB  0x63,0x74,0x6F,0x72,0x79,0x20,0x6E,0x61
	.DB  0x6D,0x65,0x20,0x69,0x73,0x20,0x69,0x6E
	.DB  0x76,0x61,0x6C,0x69,0x64,0x2E,0xD,0xA
	.DB  0x0,0x74,0x68,0x65,0x20,0x64,0x72,0x69
	.DB  0x76,0x65,0x20,0x6E,0x75,0x6D,0x62,0x65
	.DB  0x72,0x20,0x69,0x73,0x20,0x69,0x6E,0x76
	.DB  0x61,0x6C,0x69,0x64,0x2E,0xD,0xA,0x0
	.DB  0x6E,0x6F,0x20,0x64,0x69,0x73,0x6B,0x20
	.DB  0x61,0x63,0x63,0x65,0x73,0x73,0x20,0x77
	.DB  0x61,0x73,0x20,0x70,0x6F,0x73,0x73,0x69
	.DB  0x62,0x6C,0x65,0x20,0x64,0x75,0x65,0x20
	.DB  0x74,0x6F,0x20,0x6D,0x69,0x73,0x73,0x69
	.DB  0x6E,0x67,0x20,0x6D,0x65,0x64,0x69,0x61
	.DB  0x20,0x6F,0x72,0x20,0x6F,0x74,0x68,0x65
	.DB  0x72,0x20,0x72,0x65,0x61,0x73,0x6F,0x6E
	.DB  0x2E,0xD,0xA,0x0,0x74,0x68,0x65,0x20
	.DB  0x66,0x75,0x6E,0x63,0x74,0x69,0x6F,0x6E
	.DB  0x20,0x66,0x61,0x69,0x6C,0x65,0x64,0x20
	.DB  0x62,0x65,0x63,0x61,0x75,0x73,0x65,0x20
	.DB  0x6F,0x66,0x20,0x61,0x20,0x70,0x68,0x79
	.DB  0x73,0x69,0x63,0x61,0x6C,0x20,0x64,0x69
	.DB  0x73,0x6B,0x20,0x61,0x63,0x63,0x65,0x73
	.DB  0x73,0x20,0x66,0x75,0x6E,0x63,0x74,0x69
	.DB  0x6F,0x6E,0x20,0x66,0x61,0x69,0x6C,0x75
	.DB  0x72,0x65,0x2E,0xD,0xA,0x0,0x74,0x68
	.DB  0x65,0x20,0x66,0x75,0x6E,0x63,0x74,0x69
	.DB  0x6F,0x6E,0x20,0x66,0x61,0x69,0x6C,0x65
	.DB  0x64,0x20,0x64,0x75,0x65,0x20,0x74,0x6F
	.DB  0x20,0x61,0x20,0x77,0x72,0x6F,0x6E,0x67
	.DB  0x20,0x46,0x41,0x54,0x20,0x73,0x74,0x72
	.DB  0x75,0x63,0x74,0x75,0x72,0x65,0x20,0x6F
	.DB  0x72,0x20,0x61,0x6E,0x20,0x69,0x6E,0x74
	.DB  0x65,0x72,0x6E,0x61,0x6C,0x20,0x65,0x72
	.DB  0x72,0x6F,0x72,0x2E,0xD,0xA,0x0,0x74
	.DB  0x68,0x65,0x20,0x6C,0x6F,0x67,0x69,0x63
	.DB  0x61,0x6C,0x20,0x64,0x72,0x69,0x76,0x65
	.DB  0x20,0x77,0x61,0x73,0x20,0x6E,0x6F,0x74
	.DB  0x20,0x6D,0x6F,0x75,0x6E,0x74,0x65,0x64
	.DB  0x20,0x77,0x69,0x74,0x68,0x20,0x66,0x5F
	.DB  0x6D,0x6F,0x75,0x6E,0x74,0x2E,0xD,0xA
	.DB  0x0,0x74,0x68,0x65,0x72,0x65,0x20,0x69
	.DB  0x73,0x20,0x6E,0x6F,0x20,0x76,0x61,0x6C
	.DB  0x69,0x64,0x20,0x46,0x41,0x54,0x20,0x70
	.DB  0x61,0x72,0x74,0x69,0x74,0x69,0x6F,0x6E
	.DB  0x20,0x6F,0x6E,0x20,0x74,0x68,0x65,0x20
	.DB  0x64,0x69,0x73,0x6B,0x2E,0xD,0xA,0x0
	.DB  0x66,0x69,0x6C,0x65,0x20,0x61,0x63,0x63
	.DB  0x65,0x73,0x73,0x20,0x77,0x61,0x73,0x20
	.DB  0x64,0x65,0x6E,0x69,0x65,0x64,0x20,0x62
	.DB  0x65,0x63,0x61,0x75,0x73,0x65,0x20,0x69
	.DB  0x74,0x20,0x77,0x61,0x73,0x20,0x6F,0x70
	.DB  0x65,0x6E,0x65,0x64,0x20,0x69,0x6E,0x20
	.DB  0x72,0x65,0x61,0x64,0x2D,0x6F,0x6E,0x6C
	.DB  0x79,0x20,0x6D,0x6F,0x64,0x65,0x2E,0xD
	.DB  0xA,0x0,0x74,0x68,0x65,0x20,0x66,0x69
	.DB  0x6C,0x65,0x20,0x77,0x61,0x73,0x20,0x6E
	.DB  0x6F,0x74,0x20,0x6F,0x70,0x65,0x6E,0x65
	.DB  0x64,0x20,0x77,0x69,0x74,0x68,0x20,0x66
	.DB  0x5F,0x6F,0x70,0x65,0x6E,0x2E,0xD,0xA
	.DB  0x0,0x63,0x6F,0x75,0x6C,0x64,0x6E,0x27
	.DB  0x74,0x20,0x66,0x69,0x6E,0x64,0x20,0x74
	.DB  0x68,0x65,0x20,0x66,0x69,0x6C,0x65,0x20
	.DB  0x6F,0x72,0x20,0x64,0x69,0x72,0x65,0x63
	.DB  0x74,0x6F,0x72,0x79,0x2E,0xD,0xA,0x0
	.DB  0x74,0x68,0x65,0x20,0x6D,0x65,0x64,0x69
	.DB  0x61,0x20,0x69,0x6E,0x20,0x74,0x68,0x65
	.DB  0x20,0x64,0x72,0x69,0x76,0x65,0x20,0x69
	.DB  0x73,0x20,0x77,0x72,0x69,0x74,0x65,0x20
	.DB  0x70,0x72,0x6F,0x74,0x65,0x63,0x74,0x65
	.DB  0x64,0x2E,0xD,0xA,0x0,0x5B,0x69,0x46
	.DB  0x43,0x72,0x65,0x61,0x74,0x65,0x5D,0x43
	.DB  0x75,0x72,0x72,0x65,0x6E,0x74,0x20,0x64
	.DB  0x69,0x72,0x65,0x63,0x74,0x6F,0x72,0x79
	.DB  0x20,0x3A,0x20,0x25,0x73,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x43,0x72,0x65,0x61
	.DB  0x74,0x65,0x5D,0x46,0x69,0x6C,0x65,0x20
	.DB  0x25,0x73,0x20,0x69,0x73,0x20,0x63,0x72
	.DB  0x65,0x61,0x74,0x65,0x64,0x2E,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x43,0x72,0x65,0x61
	.DB  0x74,0x65,0x5D,0x46,0x69,0x6C,0x65,0x20
	.DB  0x25,0x73,0x20,0x3A,0x20,0x25,0x73,0x2E
	.DB  0x5B,0xD,0xA,0x0,0x5D,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x43,0x72,0x65,0x61,0x74
	.DB  0x65,0x5D,0x64,0x69,0x72,0x65,0x63,0x74
	.DB  0x6F,0x72,0x79,0x20,0x3A,0x20,0x25,0x73
	.DB  0x2E,0x5B,0xD,0xA,0x0,0x5B,0x69,0x46
	.DB  0x52,0x77,0x69,0x74,0x65,0x5D,0x43,0x75
	.DB  0x72,0x72,0x65,0x6E,0x74,0x20,0x64,0x69
	.DB  0x72,0x65,0x63,0x74,0x6F,0x72,0x79,0x20
	.DB  0x3A,0x20,0x25,0x73,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x52,0x77,0x69,0x74,0x65
	.DB  0x5D,0x46,0x69,0x6C,0x65,0x20,0x25,0x73
	.DB  0x20,0x69,0x73,0x20,0x6F,0x70,0x65,0x6E
	.DB  0x6E,0x65,0x64,0x2E,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x52,0x77,0x69,0x74,0x65,0x5D
	.DB  0x46,0x69,0x6C,0x65,0x20,0x73,0x69,0x7A
	.DB  0x65,0x28,0x25,0x6C,0x64,0x29,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x46,0x52,0x77,0x69
	.DB  0x74,0x65,0x5D,0x50,0x6F,0x69,0x6E,0x74
	.DB  0x65,0x72,0x28,0x73,0x65,0x65,0x6B,0x29
	.DB  0x20,0x6F,0x66,0x20,0x46,0x69,0x6C,0x65
	.DB  0x20,0x6D,0x6F,0x76,0x65,0x64,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x46,0x52,0x77,0x69
	.DB  0x74,0x65,0x5D,0x25,0x64,0x20,0x62,0x79
	.DB  0x74,0x65,0x73,0x20,0x77,0x72,0x69,0x74
	.DB  0x74,0x65,0x6E,0x20,0x6F,0x66,0x20,0x25
	.DB  0x64,0xD,0xA,0x0,0x5B,0x69,0x46,0x52
	.DB  0x77,0x69,0x74,0x65,0x5D,0x57,0x72,0x69
	.DB  0x74,0x65,0x20,0x65,0x72,0x72,0x6F,0x72
	.DB  0x28,0x25,0x64,0x29,0xD,0xA,0x0,0x5B
	.DB  0x69,0x46,0x52,0x77,0x69,0x74,0x65,0x5D
	.DB  0x46,0x69,0x6C,0x65,0x20,0x25,0x73,0x20
	.DB  0x3A,0x20,0x25,0x73,0x2E,0x5B,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x52,0x77,0x69,0x74
	.DB  0x65,0x5D,0x64,0x69,0x72,0x65,0x63,0x74
	.DB  0x6F,0x72,0x79,0x20,0x3A,0x20,0x25,0x73
	.DB  0x2E,0x5B,0xD,0xA,0x0,0x5B,0x69,0x46
	.DB  0x52,0x77,0x69,0x74,0x65,0x5D,0x63,0x61
	.DB  0x6E,0x27,0x74,0x20,0x61,0x6C,0x6C,0x6F
	.DB  0x63,0x61,0x74,0x65,0x20,0x6D,0x65,0x6D
	.DB  0x2E,0xD,0xA,0x0,0x5B,0x69,0x46,0x44
	.DB  0x65,0x6C,0x65,0x74,0x65,0x5D,0x43,0x75
	.DB  0x72,0x72,0x65,0x6E,0x74,0x20,0x64,0x69
	.DB  0x72,0x65,0x63,0x74,0x6F,0x72,0x79,0x20
	.DB  0x3A,0x20,0x25,0x73,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x44,0x65,0x6C,0x65,0x74
	.DB  0x65,0x5D,0x46,0x69,0x6C,0x65,0x20,0x25
	.DB  0x73,0x20,0x69,0x73,0x20,0x64,0x65,0x6C
	.DB  0x65,0x74,0x65,0x64,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x46,0x44,0x65,0x6C,0x65,0x74
	.DB  0x65,0x5D,0x46,0x69,0x6C,0x65,0x20,0x25
	.DB  0x73,0x20,0x3A,0x20,0x25,0x73,0x2E,0x20
	.DB  0x63,0x61,0x6E,0x27,0x74,0x20,0x64,0x65
	.DB  0x6C,0x65,0x74,0x65,0x2E,0x5B,0xD,0xA
	.DB  0x0,0x5B,0x69,0x46,0x44,0x65,0x6C,0x65
	.DB  0x74,0x65,0x5D,0x64,0x69,0x72,0x65,0x63
	.DB  0x74,0x6F,0x72,0x79,0x20,0x3A,0x20,0x25
	.DB  0x73,0x2E,0x5B,0xD,0xA,0x0
_0x500003:
	.DB  0xD,0xA,0x7C
_0x500006:
	.DB  0xD,0xA,0x7C
_0x500000:
	.DB  0x5B,0x69,0x44,0x61,0x74,0x61,0x4C,0x6F
	.DB  0x67,0x49,0x6E,0x73,0x65,0x72,0x74,0x5D
	.DB  0x49,0x6E,0x73,0x65,0x72,0x74,0x20,0x69
	.DB  0x73,0x20,0x73,0x75,0x63,0x63,0x65,0x73
	.DB  0x73,0x2E,0xD,0xA,0x0,0x5B,0x69,0x44
	.DB  0x61,0x74,0x61,0x4C,0x6F,0x67,0x49,0x6E
	.DB  0x73,0x65,0x72,0x74,0x5D,0x44,0x61,0x74
	.DB  0x61,0x62,0x75,0x66,0x66,0x5F,0x61,0x72
	.DB  0x67,0x20,0x63,0x61,0x6E,0x27,0x74,0x20
	.DB  0x61,0x6C,0x6C,0x6F,0x63,0x61,0x74,0x65
	.DB  0x20,0x6D,0x65,0x6D,0x2E,0xD,0xA,0x0
	.DB  0x5B,0x69,0x44,0x61,0x74,0x61,0x49,0x6E
	.DB  0x73,0x65,0x72,0x74,0x5D,0x49,0x6E,0x73
	.DB  0x65,0x72,0x74,0x20,0x69,0x73,0x20,0x73
	.DB  0x75,0x63,0x63,0x65,0x73,0x73,0x2E,0xD
	.DB  0xA,0x0,0x5B,0x69,0x44,0x61,0x74,0x61
	.DB  0x49,0x6E,0x73,0x65,0x72,0x74,0x5D,0x44
	.DB  0x61,0x74,0x61,0x62,0x75,0x66,0x66,0x5F
	.DB  0x61,0x72,0x67,0x20,0x63,0x61,0x6E,0x27
	.DB  0x74,0x20,0x61,0x6C,0x6C,0x6F,0x63,0x61
	.DB  0x74,0x65,0x20,0x6D,0x65,0x6D,0x2E,0xD
	.DB  0xA,0x0
_0x520003:
	.DB  0x10,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x20,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x30,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x40,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x50,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x60,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x70,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x80,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x81,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x82,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x83,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x84,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x85,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x86,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x87,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x90,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x91,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x92,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x93,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x94,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x95,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0x96,0x0,0x1,0xFF
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3
	.DB  0x97,0x0,0x1,0xFF,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x3,0xA0,0x0,0x1,0x2
	.DB  0x3,0x4,0x5,0x6,0xFF,0x0,0x0,0x8
	.DB  0xA1,0x0,0x1,0x2,0x3,0x4,0x5,0x6
	.DB  0xFF,0x0,0x0,0x8,0xA2,0x0,0x1,0x2
	.DB  0x3,0x4,0x5,0x6,0xFF,0x0,0x0,0x8
	.DB  0xA3,0x0,0x1,0x2,0x3,0x4,0x5,0x6
	.DB  0xFF,0x0,0x0,0x8,0xA4,0x0,0x1,0x2
	.DB  0x3,0x4,0x5,0x6,0xFF,0x0,0x0,0x8
	.DB  0xB0,0x0,0x1,0x2,0x3,0x4,0x5,0xFF
	.DB  0x0,0x0,0x0,0x7,0xB1,0x0,0x1,0x2
	.DB  0x3,0x4,0x5,0xFF,0x0,0x0,0x0,0x7
	.DB  0xB2,0x0,0x1,0x2,0x3,0x4,0x5,0xFF
	.DB  0x0,0x0,0x0,0x7,0xB3,0x0,0x1,0x2
	.DB  0x3,0x4,0x5,0xFF,0x0,0x0,0x0,0x7
	.DB  0xB4,0x0,0x1,0x2,0x3,0x4,0x5,0xFF
	.DB  0x0,0x0,0x0,0x7
_0x540000:
	.DB  0x5B,0x69,0x53,0x65,0x6E,0x73,0x6F,0x72
	.DB  0x52,0x65,0x61,0x64,0x5D,0x44,0x61,0x74
	.DB  0x61,0x3A,0x5B,0xD,0xA,0x0,0x5D,0xD
	.DB  0xA,0x0,0x5B,0x69,0x53,0x65,0x6E,0x73
	.DB  0x6F,0x72,0x52,0x65,0x61,0x64,0x42,0x79
	.DB  0x54,0x79,0x70,0x65,0x5D,0x43,0x68,0x61
	.DB  0x6E,0x6E,0x65,0x6C,0x5B,0x25,0x64,0x5D
	.DB  0x20,0x64,0x61,0x74,0x61,0x20,0x3A,0x20
	.DB  0x25,0x66,0xD,0xA,0x0
_0x560007:
	.DB  0xCD,0xCC,0x6C,0x40,0x0,0xE0,0x1E,0x44
	.DB  0x0,0x0,0x0,0x0
_0x560000:
	.DB  0x5B,0x69,0x53,0x74,0x61,0x74,0x75,0x73
	.DB  0x52,0x65,0x61,0x64,0x5D,0x44,0x61,0x74
	.DB  0x61,0x3A,0x5B,0xD,0xA,0x0,0x5D,0xD
	.DB  0xA,0x0
_0x2000003:
	.DB  0x1
_0x2040000:
	.DB  0x2D,0x4E,0x41,0x4E,0x0
_0x2060060:
	.DB  0x1
_0x2060000:
	.DB  0x2D,0x4E,0x41,0x4E,0x0,0x49,0x4E,0x46
	.DB  0x0

__GLOBAL_INI_TBL:
	.DW  0x04
	.DW  0x1914
	.DD  __HEAP_START_MARKER*2

	.DW  0x07
	.DW  _0xF
	.DD  _0x0*2+326

	.DW  0x04
	.DW  0x04
	.DD  _0x15*2

	.DW  0x2B
	.DW  _0x40009
	.DD  _0x40000*2

	.DW  0x26
	.DW  _0x40009+43
	.DD  _0x40000*2+43

	.DW  0x2B
	.DW  _0x40009+81
	.DD  _0x40000*2

	.DW  0x2B
	.DW  _0x40009+124
	.DD  _0x40000*2

	.DW  0x26
	.DW  _0x40009+167
	.DD  _0x40000*2+43

	.DW  0x2B
	.DW  _0x40009+205
	.DD  _0x40000*2

	.DW  0x2B
	.DW  _0x40009+248
	.DD  _0x40000*2

	.DW  0x26
	.DW  _0x40009+291
	.DD  _0x40000*2+43

	.DW  0x2B
	.DW  _0x40009+329
	.DD  _0x40000*2

	.DW  0x04
	.DW  0x0A
	.DD  _0x40042*2

	.DW  0x03
	.DW  _root_path
	.DD  _0x240003*2

	.DW  0x08
	.DW  _LOGFILE_DATA
	.DD  _0x260003*2

	.DW  0x09
	.DW  _LOGFILE_EVENT
	.DD  _0x260004*2

	.DW  0x09
	.DW  _LOGFILE_ERROR
	.DD  _0x260005*2

	.DW  0x10
	.DW  _LOG_INIT_STR
	.DD  _0x260006*2

	.DW  0x01
	.DW  _hwCalId
	.DD  _0x2A0003*2

	.DW  0x01
	.DW  _n
	.DD  _0x2C0003*2

	.DW  0x04
	.DW  _0x44000C
	.DD  _0x440000*2+20

	.DW  0x0F
	.DW  _0x440012
	.DD  _0x440000*2+41

	.DW  0x0C
	.DW  _0x440018
	.DD  _0x440000*2+147

	.DW  0x09
	.DW  _0x440018+12
	.DD  _0x440000*2+159

	.DW  0x0B
	.DW  _0x440030
	.DD  _0x440000*2+148

	.DW  0x0D
	.DW  _0x440030+11
	.DD  _0x440000*2+333

	.DW  0x06
	.DW  _0x440040
	.DD  _0x440000*2+389

	.DW  0x04
	.DW  _0x440040+6
	.DD  _0x440000*2+20

	.DW  0x0F
	.DW  _0x440040+10
	.DD  _0x440000*2+41

	.DW  0x05
	.DW  _0x440040+25
	.DD  _0x440000*2+202

	.DW  0x04
	.DW  _0x44005B
	.DD  _0x440000*2+477

	.DW  0x04
	.DW  _0x44005B+4
	.DD  _0x440000*2+659

	.DW  0x03
	.DW  _0x440087
	.DD  _0x440000*2+753

	.DW  0x02
	.DW  _wiz100srSetTimer
	.DD  _0x460003*2

	.DW  0x02
	.DW  _pviUart0TimeOut
	.DD  _0x460004*2

	.DW  0x04
	.DW  _viFolderDataName
	.DD  _0x4E0003*2

	.DW  0x08
	.DW  _viFolderDataLogName
	.DD  _0x4E0004*2

	.DW  0x05
	.DW  _viFolderEventName
	.DD  _0x4E0005*2

	.DW  0x06
	.DW  _viFolderStatusName
	.DD  _0x4E0006*2

	.DW  0x05
	.DW  _viFolderErrorName
	.DD  _0x4E0007*2

	.DW  0x06
	.DW  _viFolderConfigName
	.DD  _0x4E0008*2

	.DW  0x07
	.DW  _viDirDataPath
	.DD  _0x4E000A*2

	.DW  0x0B
	.DW  _viDirDataLogPath
	.DD  _0x4E000B*2

	.DW  0x08
	.DW  _viDirEventPath
	.DD  _0x4E000C*2

	.DW  0x09
	.DW  _viDirStatusPath
	.DD  _0x4E000D*2

	.DW  0x08
	.DW  _viDirErrorPath
	.DD  _0x4E000E*2

	.DW  0x09
	.DW  _viDirConfigPath
	.DD  _0x4E000F*2

	.DW  0x0C
	.DW  _viDataFName
	.DD  _0x4E0010*2

	.DW  0x0F
	.DW  _viDataLogFName
	.DD  _0x4E0011*2

	.DW  0x01
	.DW  _status_G100
	.DD  _0x2000003*2

	.DW  0x01
	.DW  __seed_G103
	.DD  _0x2060060*2

_0xFFFFFFFF:
	.DW  0

__RESET:
	CLI
	CLR  R30
	OUT  EECR,R30

;INTERRUPT VECTORS ARE PLACED
;AT THE START OF FLASH
	LDI  R31,1
	OUT  MCUCR,R31
	OUT  MCUCR,R30
	STS  XMCRA,R30
	STS  XMCRB,R30

;DISABLE WATCHDOG
	LDI  R31,0x18
	WDR
	IN   R26,MCUSR
	CBR  R26,8
	OUT  MCUSR,R26
	STS  WDTCSR,R31
	STS  WDTCSR,R30

;CLEAR R2-R14
	LDI  R24,(14-2)+1
	LDI  R26,2
	CLR  R27
__CLEAR_REG:
	ST   X+,R30
	DEC  R24
	BRNE __CLEAR_REG

;CLEAR SRAM
	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
	LDI  R26,LOW(__SRAM_START)
	LDI  R27,HIGH(__SRAM_START)
__CLEAR_SRAM:
	ST   X+,R30
	SBIW R24,1
	BRNE __CLEAR_SRAM

;GLOBAL VARIABLES INITIALIZATION
	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
	LDI  R29,BYTE3(__GLOBAL_INI_TBL*2)
__GLOBAL_INI_NEXT:
	OUT  RAMPZ,R29
	ELPM R24,Z+
	ELPM R25,Z+
	SBIW R24,0
	BREQ __GLOBAL_INI_END
	ELPM R26,Z+
	ELPM R27,Z+
	ELPM R0,Z+
	ELPM R1,Z+
	ELPM R28,Z+
	ELPM R29,Z+
	MOVW R22,R30
	IN   R29,RAMPZ
	MOVW R30,R0
	OUT  RAMPZ,R28
__GLOBAL_INI_LOOP:
	ELPM R0,Z+
	ST   X+,R0
	SBIW R24,1
	BRNE __GLOBAL_INI_LOOP
	MOVW R30,R22
	RJMP __GLOBAL_INI_NEXT
__GLOBAL_INI_END:

;GPIOR0 INITIALIZATION
	LDI  R30,__GPIOR0_INIT
	OUT  GPIOR0,R30

;HARDWARE STACK POINTER INITIALIZATION
	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
	OUT  SPL,R30
	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
	OUT  SPH,R30

;DATA STACK POINTER INITIALIZATION
	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)

	JMP  _main

	.ESEG
	.ORG 0

	.DSEG
	.ORG 0xCF0

	.CSEG
;/*****************************************************
;Project : SMA_AVR : 1
;Date    : 17/7/2012
;Author  : Nexs-Crop Team
;Company : Nexs-Crop Co.,Ltd.
;Comments:
;Version Format : 1Major.2Minor.1Edition
;
;
;Chip type               : ATmega2560
;Program type            : Application
;AVR Core Clock frequency: 8.000000 MHz
;*****************************************************/
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;//#include <stdlib.h>
;//#include <string.h>
;#include <delay.h>
;#include "main.h"
;#include "ims_eth_header.h"
;#include "debug.h"
;#include "uart.h"
;//#include "queue.h"
;#include "sensorTask.h"
;#include "managerTask.h"
;#include "debugTask.h"
;#include "communicateTask.h"
;#include "interruptTask.h"
;#include "deviceTask.h"
;#include "logTask.h"
;
;//#include "wiz100rs.h"
;#include "lan.h"
;#include "smaProtocol.h"
;
;
;#include "sdManager.h"
;#include "database.h"
;
;
;//#include "config.h"
;//#include "timer.h"
;//#include "ds1672.h"
;//#include "sensor.h"
;//#include "status.h"
;//#include "alarm.h"
;//#include "dataqueue.h"
;//#include "eventqueue.h"
;//#include "log.h"
;//#include "logqueue.h"
;//#include "io.h"
;
;//#include "gaussian.h"
;//#include "dht11.h"
;
;
;//#include <stdio.h>
;
;#define MAX(a,b)                (((a) > (b)) ? (a) : (b))
;#define MIN(a,b)                (((a) < (b)) ? (a) : (b))
;//#define RANDOM(a,b)             ((rand() % (MAX(a,b) - MIN(a,b))) + MIN(a,b))
;
;#define PERIOD_CHECK_MEMORY     300
;
;// I2C Bus functions (for INT-AVXB-00-04)
;#asm
   .equ __i2c_port=0x0B ;PORTD
   .equ __sda_bit=1
   .equ __scl_bit=0
; 0000 0045 #endasm
;
;//unsigned char FIRMWARE_VERSION[] = "COMM-ETH-0.01a";
;
;piQueueHandle_t pviQueueData1 = NULL;
;piQueueHandle_t pviQueueSensorToMang = NULL;
;piQueueHandle_t pviQueueMangToSensor = NULL;
;//piQueueHandle_t pviQueueMangToSDCard = NULL;
;
;piQueueHandle_t pviQueueMangToConfig = NULL;
;piQueueHandle_t pviQueueDeviceToMang = NULL;
;
;itaskHandel_t piDeviceTask = NULL;
;iData_t viBuffData;
;iData_t viRXData;
;iData_t viTXData;
;
;iDataMini_t viDataReport;
;iDataMini_t viStatusReport;
;
;/*============================================================*/
;void main(void){
; 0000 005A void main(void){

	.CSEG
_main:
; 0000 005B     //int a = 6;
; 0000 005C     //int b;
; 0000 005D     //unsigned int viLenData = 0;
; 0000 005E     //char *pviBufferU0;
; 0000 005F     //char *pviPointBufferU0;
; 0000 0060     //int indexReadUart0 = 0;
; 0000 0061     //char * pch;
; 0000 0062     //int viConnect = 0;
; 0000 0063     //char *b2;
; 0000 0064 
; 0000 0065     unsigned char fileNameCreate[20];
; 0000 0066     //char fileNameCreate1[] = "FileFF";
; 0000 0067     int retFile = 0;
; 0000 0068     char viPath[20]="0:/";
; 0000 0069     DIR pviDir;
; 0000 006A     FIL pviFilePtr;
; 0000 006B     iChar_t viDirectoryPath[] = "0:/DATA";
; 0000 006C     iChar_t viFileName[] = "0:./data7.txt";
; 0000 006D     iChar_t viCurrentDirect[50];
; 0000 006E     iChar_t viDataBuffTest[100] = "Data Test 11111119999999999999999999999999999";               //N=not send
; 0000 006F     //FRESULT
; 0000 0070 
; 0000 0071 
; 0000 0072     int err,i=0,k=0,res,last_status;
; 0000 0073     do{ err = initial_system();  }while(err);
	SBIW R28,16
	SUBI R29,3
	__GETWRN 24,25,760
	LDI  R26,LOW(4)
	LDI  R27,HIGH(4)
	LDI  R30,LOW(_0x3*2)
	LDI  R31,HIGH(_0x3*2)
	LDI  R22,BYTE3(_0x3*2)
	CALL __INITLOCW
;	fileNameCreate -> Y+764
;	retFile -> R16,R17
;	viPath -> Y+744
;	pviDir -> Y+722
;	pviFilePtr -> Y+178
;	viDirectoryPath -> Y+170
;	viFileName -> Y+156
;	viCurrentDirect -> Y+106
;	viDataBuffTest -> Y+6
;	err -> R18,R19
;	i -> R20,R21
;	k -> Y+4
;	res -> Y+2
;	last_status -> Y+0
	__GETWRN 16,17,0
	__GETWRN 20,21,0
_0x5:
	RCALL _initial_system
	MOVW R18,R30
	MOV  R0,R18
	OR   R0,R19
	BRNE _0x5
; 0000 0074 
; 0000 0075     printDebug("<main>Semi-RTOS-V1\r\n");
	__POINTD1FN _0x0,0
	CALL SUBOPT_0x0
; 0000 0076 
; 0000 0077 //    pviQueueData1 = iQueueCreate(10,sizeof(int));
; 0000 0078 //	printDebug("<main>pviQueueData1 adr : %p\r\n",pviQueueData1);
; 0000 0079 //
; 0000 007A //    if(iQueueSend(pviQueueData1,&a)==1){
; 0000 007B //
; 0000 007C //	}else{
; 0000 007D //		printDebug("<main>data can not sent a data(b) to pviQueueData1.\r\n");
; 0000 007E //	}
; 0000 007F //
; 0000 0080 //    if(iQueueReceive(pviQueueData1,&b)==1){
; 0000 0081 //        printDebug("<main>data : %d\r\n",b);
; 0000 0082 //	}else{
; 0000 0083 //		printDebug("<main>data can not sent a data(b) to pviQueueData1.\r\n");
; 0000 0084 //	}
; 0000 0085     delay_ms(5000);
	LDI  R26,LOW(5000)
	LDI  R27,HIGH(5000)
	CALL _delay_ms
; 0000 0086     delay_ms(5000);
	LDI  R26,LOW(5000)
	LDI  R27,HIGH(5000)
	CALL _delay_ms
; 0000 0087     //delay_ms(5000);
; 0000 0088     iWizReadConfig();
	CALL _iWizReadConfig
; 0000 0089 //    while(1){
; 0000 008A //     #asm("wdr")
; 0000 008B //     delay_ms(1000);
; 0000 008C //    }
; 0000 008D 
; 0000 008E //    ETH_switchMode((unsigned char) MODE_NORM);
; 0000 008F     if(iLanInit()){
	CALL _iLanInit
	CPI  R30,0
	BREQ _0x7
; 0000 0090         printDebug("[main]Lan Connected.\r\n");
	__POINTD1FN _0x0,21
	CALL SUBOPT_0x0
; 0000 0091     }else{
	RJMP _0x8
_0x7:
; 0000 0092         printDebug("[main]Lan Fail.\r\n");
	__POINTD1FN _0x0,44
	CALL SUBOPT_0x0
; 0000 0093         iLanInit();
	CALL _iLanInit
; 0000 0094     }
_0x8:
; 0000 0095 
; 0000 0096     iInitSDCard();
	CALL _iInitSDCard
; 0000 0097 
; 0000 0098     ///////////////create queue////////////////
; 0000 0099     pviQueueSensorToMang = iQueueCreate(2,sizeof(iSensorData_t));
	LDI  R30,LOW(2)
	LDI  R31,HIGH(2)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(18)
	CALL SUBOPT_0x1
	STS  _pviQueueSensorToMang,R30
	STS  _pviQueueSensorToMang+1,R31
; 0000 009A     if(pviQueueSensorToMang == (int *)(-1)){
	LDS  R26,_pviQueueSensorToMang
	LDS  R27,_pviQueueSensorToMang+1
	CPI  R26,LOW(0xFFFF)
	LDI  R30,HIGH(0xFFFF)
	CPC  R27,R30
	BRNE _0x9
; 0000 009B        printDebug("[main],pviQueueSensorToMang can not create.\r\n");
	__POINTD1FN _0x0,62
	RJMP _0x12
; 0000 009C     }else{
_0x9:
; 0000 009D        printDebug("[main],pviQueueSensorToMang can create.\r\n");
	__POINTD1FN _0x0,108
_0x12:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0000 009E //       printDebug("[main],Queue->Quantity(%d).\r\n",((iQueue_t *)pviQueueSensorToMang)->itemCount);
; 0000 009F     }
; 0000 00A0 
; 0000 00A1     pviQueueMangToConfig = iQueueCreate(2,sizeof(iConfigFormat_t));
	LDI  R30,LOW(2)
	LDI  R31,HIGH(2)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(7)
	CALL SUBOPT_0x1
	STS  _pviQueueMangToConfig,R30
	STS  _pviQueueMangToConfig+1,R31
; 0000 00A2     if(pviQueueMangToConfig == (int *)(-1)){
	LDS  R26,_pviQueueMangToConfig
	LDS  R27,_pviQueueMangToConfig+1
	CPI  R26,LOW(0xFFFF)
	LDI  R30,HIGH(0xFFFF)
	CPC  R27,R30
	BRNE _0xB
; 0000 00A3        printDebug("[main],pviQueueMangToConfig can not create.\r\n");
	__POINTD1FN _0x0,150
	RJMP _0x13
; 0000 00A4     }else{
_0xB:
; 0000 00A5        printDebug("[main],pviQueueMangToConfig can create.\r\n");
	__POINTD1FN _0x0,196
_0x13:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0000 00A6     }
; 0000 00A7 
; 0000 00A8     pviQueueDeviceToMang = iQueueCreate(1,sizeof(unsigned char));
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(1)
	CALL SUBOPT_0x1
	STS  _pviQueueDeviceToMang,R30
	STS  _pviQueueDeviceToMang+1,R31
; 0000 00A9     if(pviQueueDeviceToMang == (int *)(-1)){
	LDS  R26,_pviQueueDeviceToMang
	LDS  R27,_pviQueueDeviceToMang+1
	CPI  R26,LOW(0xFFFF)
	LDI  R30,HIGH(0xFFFF)
	CPC  R27,R30
	BRNE _0xD
; 0000 00AA        printDebug("[main],pviQueueDeviceToMang can not create.\r\n");
	__POINTD1FN _0x0,238
	RJMP _0x14
; 0000 00AB     }else{
_0xD:
; 0000 00AC        printDebug("[main],pviQueueDeviceToMang can create.\r\n");
	__POINTD1FN _0x0,284
_0x14:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0000 00AD     }
; 0000 00AE 
; 0000 00AF //    pviQueueMangToSensor = iQueueCreate(10,sizeof(int));
; 0000 00B0 //    if(pviQueueMangToSensor == (int *)(-1)){
; 0000 00B1 //       printDebug("<main>pviQueueSensorToMang can not create.\r\n");
; 0000 00B2 //    }
; 0000 00B3 
; 0000 00B4     ///////////////create task////////////////
; 0000 00B5     piDeviceTask = iTaskCreate(sensorTask,"sensor",5);
	__POINTD1M _sensorTask
	CALL __PUTPARD1
	__POINTW1MN _0xF,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(5)
	LDI  R27,0
	CALL _iTaskCreate
	MOVW R6,R30
; 0000 00B6     if(piDeviceTask){
	MOV  R0,R6
	OR   R0,R7
	BREQ _0x10
; 0000 00B7         printDebug("<main>sensorTask addr : %p\r\n",&piDeviceTask);
	__POINTD1FN _0x0,333
	CALL __PUTPARD1
	__GETD1N 0x6
	CALL SUBOPT_0x3
; 0000 00B8     }
; 0000 00B9 //    printDebug("[main],Queue->Quantity(%d).\r\n",((iQueue_t *)pviQueueSensorToMang)->itemCount);
; 0000 00BA //    piDeviceTask = iTaskCreate(managerTask,"mang",5);
; 0000 00BB //    if(piDeviceTask){
; 0000 00BC //        printDebug("<main>managerTask addr : %p\r\n",&piDeviceTask);
; 0000 00BD //    }
; 0000 00BE 
; 0000 00BF //    piDeviceTask = iTaskCreate(logTask,"logger",5);
; 0000 00C0 //    if(piDeviceTask){
; 0000 00C1 //        printDebug("<main>managerTask addr : %p\r\n",&piDeviceTask);
; 0000 00C2 //    }
; 0000 00C3 //
; 0000 00C4 //    piDeviceTask = iTaskCreate(debugTask,"debug",5);
; 0000 00C5 //    if(piDeviceTask){
; 0000 00C6 //        printDebug("<main>debugTask addr : %p\r\n",&piDeviceTask);
; 0000 00C7 //    }
; 0000 00C8 //
; 0000 00C9 //    piDeviceTask = iTaskCreate(communicateTask,"commu",5);
; 0000 00CA //    if(piDeviceTask){
; 0000 00CB //        printDebug("<main>communicateTask addr : %p\r\n",&piDeviceTask);
; 0000 00CC //    }
; 0000 00CD //
; 0000 00CE //    piDeviceTask = iTaskCreate(interruptTask,"intp",10);
; 0000 00CF //    if(piDeviceTask){
; 0000 00D0 //        printDebug("<main>interruptTask addr : %p\r\n",&piDeviceTask);
; 0000 00D1 //    }
; 0000 00D2 //
; 0000 00D3 //    piDeviceTask = iTaskCreate(deviceTask,"device",5);
; 0000 00D4 //    if(piDeviceTask){
; 0000 00D5 //        printDebug("<main>deviceTask addr : %p\r\n",&piDeviceTask);
; 0000 00D6 //    }
; 0000 00D7 
; 0000 00D8    startSchedulerTask();
_0x10:
	CALL _startSchedulerTask
; 0000 00D9 }
	ADIW R28,16
	SUBI R29,-3
_0x11:
	RJMP _0x11

	.DSEG
_0xF:
	.BYTE 0x7
;#include <delay.h>
;#include <stdlib.h>
;#include <i2c.h>
;#include "initial_sys.h"
;#include "uart.h"
;#include "timer.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "io.h"
;#include "ds1672.h"
;#include "config.h"
;//#include "oled.h"
;#include "adc.h"
;#include "debug.h"
;#include "log.h"
;#include "sdcard.h"
;
;/*============================================================*/
;int initial_system(void)
; 0001 0012 {

	.CSEG
_initial_system:
; 0001 0013     int res=0;
; 0001 0014 
; 0001 0015     // Crystal Oscillator division factor: 1
; 0001 0016     #pragma optsize-
; 0001 0017     CLKPR=0x80;
	ST   -Y,R17
	ST   -Y,R16
;	res -> R16,R17
	__GETWRN 16,17,0
	LDI  R30,LOW(128)
	STS  97,R30
; 0001 0018     CLKPR=0x00;
	LDI  R30,LOW(0)
	STS  97,R30
; 0001 0019     #ifdef _OPTIMIZE_SIZE_
; 0001 001A     #pragma optsize+
; 0001 001B     #endif
; 0001 001C 
; 0001 001D     init_uart();
	RCALL _init_uart
; 0001 001E 
; 0001 001F     if(MCUSR & (1<<PORF)){
	IN   R30,0x34
	SBRS R30,0
	RJMP _0x20003
; 0001 0020         printDebug("\r\nPower-on Reset\r\n");
	__POINTD1FN _0x20000,0
	CALL SUBOPT_0x0
; 0001 0021         MCUSR &= ~(1<<PORF);
	IN   R30,0x34
	ANDI R30,0xFE
	OUT  0x34,R30
; 0001 0022     }
; 0001 0023     if(MCUSR & (1<<EXTRF)){
_0x20003:
	IN   R30,0x34
	SBRS R30,1
	RJMP _0x20004
; 0001 0024         printDebug("\r\nExternal Reset\r\n");
	__POINTD1FN _0x20000,19
	CALL SUBOPT_0x0
; 0001 0025         MCUSR &= ~(1<<EXTRF);
	IN   R30,0x34
	ANDI R30,0xFD
	OUT  0x34,R30
; 0001 0026     }
; 0001 0027     if(MCUSR & (1<<BORF)){
_0x20004:
	IN   R30,0x34
	SBRS R30,2
	RJMP _0x20005
; 0001 0028         printDebug("\r\nBrown-out Reset\r\n");
	__POINTD1FN _0x20000,38
	CALL SUBOPT_0x0
; 0001 0029         MCUSR &= ~(1<<BORF);
	IN   R30,0x34
	ANDI R30,0xFB
	OUT  0x34,R30
; 0001 002A     }
; 0001 002B     if(MCUSR & (1<<WDRF)){
_0x20005:
	IN   R30,0x34
	SBRS R30,3
	RJMP _0x20006
; 0001 002C         printDebug("\r\nWatchdog Reset\r\n");
	__POINTD1FN _0x20000,58
	CALL SUBOPT_0x0
; 0001 002D         MCUSR &= ~(1<<WDRF);
	IN   R30,0x34
	ANDI R30,0XF7
	OUT  0x34,R30
; 0001 002E     }
; 0001 002F     if(MCUSR & (1<<JTRF)){
_0x20006:
	IN   R30,0x34
	SBRS R30,4
	RJMP _0x20007
; 0001 0030         printDebug("\r\nJTAG Reset\r\n");
	__POINTD1FN _0x20000,77
	CALL SUBOPT_0x0
; 0001 0031         MCUSR &= ~(1<<JTRF);
	IN   R30,0x34
	ANDI R30,0xEF
	OUT  0x34,R30
; 0001 0032     }
; 0001 0033 
; 0001 0034     // -------- Peripheral Initialize ----------- //
; 0001 0035     init_io();
_0x20007:
	CALL _init_io
; 0001 0036     init_i2c();
	RCALL _init_i2c
; 0001 0037     init_spi();
	RCALL _init_spi
; 0001 0038     init_adc();
	CALL _init_adc
; 0001 0039     init_timer();
	CALL _init_timer
; 0001 003A     init_common();
	RCALL _init_common
; 0001 003B 
; 0001 003C     enable_interrupt(2);
	CALL SUBOPT_0x4
	CALL _enable_interrupt
; 0001 003D 
; 0001 003E     delay_ms(500);
	LDI  R26,LOW(500)
	LDI  R27,HIGH(500)
	CALL _delay_ms
; 0001 003F 
; 0001 0040     // -------- Module Initialize ----------- //
; 0001 0041     BUZZER = 0;                 // BUZZER Off.
	CBI  0xE,7
; 0001 0042     init_RTC();         delay_ms(100);
	CALL _init_RTC
	CALL SUBOPT_0x5
; 0001 0043     //init_oled();        delay_ms(100);
; 0001 0044     adc_init_read();            //getting first ADC to initial
	CALL _adc_init_read
; 0001 0045 
; 0001 0046     enable_interrupt(1);        // -- adc_sampling
	LDI  R26,LOW(1)
	CALL SUBOPT_0x6
; 0001 0047     enable_interrupt(3);        // -- 1 sec timer
	LDI  R26,LOW(3)
	CALL SUBOPT_0x6
; 0001 0048     enable_interrupt(4);        // -- 0.5 sec timer
	LDI  R26,LOW(4)
	CALL SUBOPT_0x6
; 0001 0049 
; 0001 004A     //getAllConfig();
; 0001 004B 
; 0001 004C 
; 0001 004D     // -- Initialize Complete -- //
; 0001 004E     /*bongkot*/
; 0001 004F     //playBeep();
; 0001 0050     showLedInitComplete();
	RCALL _showLedInitComplete
; 0001 0051     showDebugInitComplete();
	RCALL _showDebugInitComplete
; 0001 0052 
; 0001 0053     if(SD_init() == 0)
	CALL _SD_init
	SBIW R30,0
	BRNE _0x2000A
; 0001 0054     {
; 0001 0055         if(LOG_init() < 0)
	CALL _LOG_init
	TST  R31
	BRPL _0x2000B
; 0001 0056         {
; 0001 0057             // -- log status = error -- //
; 0001 0058             printDebug("<initial_system> LOG_init() failed\r\n");
	__POINTD1FN _0x20000,92
	CALL SUBOPT_0x0
; 0001 0059         }
; 0001 005A 
; 0001 005B         // -- log status = ok -- //
; 0001 005C     }
_0x2000B:
; 0001 005D     else
	RJMP _0x2000C
_0x2000A:
; 0001 005E     {
; 0001 005F         // -- sd status = error -- //
; 0001 0060         printDebug("<initial_system> SD_init() failed\r\n");
	__POINTD1FN _0x20000,129
	CALL SUBOPT_0x0
; 0001 0061     }
_0x2000C:
; 0001 0062 
; 0001 0063     srand((unsigned int)raw_rtc + (unsigned int)(read_adc(8) * 13));        // set random seed
	LDI  R26,LOW(8)
	CALL _read_adc
	LDI  R26,LOW(13)
	LDI  R27,HIGH(13)
	CALL __MULW12U
	LDS  R26,_raw_rtc
	LDS  R27,_raw_rtc+1
	ADD  R26,R30
	ADC  R27,R31
	CALL _srand
; 0001 0064 
; 0001 0065     // -------- Configuration Initialize ----------- //
; 0001 0066 //    readConfig();
; 0001 0067 //    initAlarm();        //delay_ms(100);
; 0001 0068 //
; 0001 0069 //    if(init_logfile() < 0){
; 0001 006A //        printDebug("init_logdata() failed\r\n");
; 0001 006B //        return -1;
; 0001 006C //    }
; 0001 006D 
; 0001 006E 
; 0001 006F     return res;
	MOVW R30,R16
	LD   R16,Y+
	LD   R17,Y+
	RET
; 0001 0070 }
;/*============================================================*/
;void init_i2c(void)
; 0001 0073 {
_init_i2c:
; 0001 0074     // I2C Bus initialization
; 0001 0075     i2c_init();
	CALL _i2c_init
; 0001 0076 }
	RET
;/*============================================================*/
;void init_spi(void)
; 0001 0079 {
_init_spi:
; 0001 007A     // SPI initialization
; 0001 007B     // SPI Type: Master
; 0001 007C     // SPI Clock Rate: 2000.000 kHz
; 0001 007D     // SPI Clock Phase: Cycle Start
; 0001 007E     // SPI Clock Polarity: Low
; 0001 007F     // SPI Data Order: MSB First
; 0001 0080     SPCR=0x50;
	LDI  R30,LOW(80)
	OUT  0x2C,R30
; 0001 0081     SPSR=0x00;
	LDI  R30,LOW(0)
	OUT  0x2D,R30
; 0001 0082 }
	RET
;/*============================================================*/
;void init_common(void)
; 0001 0085 {
_init_common:
; 0001 0086     // External Interrupt(s) initialization
; 0001 0087     // INT0: Off, INT1: Off, INT2: Off, INT3: Off, INT4: Off, INT5: Off, INT6: Off, INT7: Off
; 0001 0088     EICRA=0x00;
	LDI  R30,LOW(0)
	STS  105,R30
; 0001 0089     EICRB=0x00;
	STS  106,R30
; 0001 008A     EIMSK=0x00;
	OUT  0x1D,R30
; 0001 008B 
; 0001 008C     PCMSK0=0x00;
	STS  107,R30
; 0001 008D     PCMSK1=0x00;
	STS  108,R30
; 0001 008E     PCMSK2=0x00;
	STS  109,R30
; 0001 008F     PCICR=0x00;
	STS  104,R30
; 0001 0090 
; 0001 0091     // Analog Comparator initialization
; 0001 0092     // Analog Comparator: Off
; 0001 0093     // Analog Comparator Input Capture by Timer/Counter 1: Off
; 0001 0094     ACSR=0x80;
	LDI  R30,LOW(128)
	OUT  0x30,R30
; 0001 0095     ADCSRB=0x00;
	LDI  R30,LOW(0)
	STS  123,R30
; 0001 0096     DIDR1=0x00;
	STS  127,R30
; 0001 0097 
; 0001 0098     // TWI initialization
; 0001 0099     // TWI disabled
; 0001 009A     TWCR=0x00;
	STS  188,R30
; 0001 009B }
	RET
;/*============================================================*/
;void playBeep(void)
; 0001 009E {
; 0001 009F     BUZZER = 1;                                     // Buzzer ON Starting
; 0001 00A0     delay_ms(200);
; 0001 00A1     BUZZER = 0;
; 0001 00A2 }
;/*============================================================*/
;void showDebugInitComplete(void)
; 0001 00A5 {
_showDebugInitComplete:
; 0001 00A6 //    struct rtc_structure time;
; 0001 00A7 //    struct prop_cnfg_st properties_config;
; 0001 00A8 //
; 0001 00A9 //    printDebug("Initial Device Completed at - ");
; 0001 00AA //    RTC_getDateTime(&time,properties_config.timeZone);
; 0001 00AB //    printDebug("%04d-%02d-%02d %02d:%02d:%02d\r\n",
; 0001 00AC //            time.year,time.month,time.date,time.hour,time.min,time.sec);
; 0001 00AD }
	RET
;/*============================================================*/
;void showLedInitComplete(void)
; 0001 00B0 {
_showLedInitComplete:
; 0001 00B1     LED_ON(BIT_LED_ALARM);
	LDS  R30,258
	ANDI R30,0xBF
	CALL SUBOPT_0x7
; 0001 00B2     delay_ms(200);
; 0001 00B3 
; 0001 00B4     LED_ON(BIT_LED_LINK);
	ANDI R30,0xDF
	CALL SUBOPT_0x7
; 0001 00B5     delay_ms(200);
; 0001 00B6 
; 0001 00B7     LED_ON(BIT_LED_TEMP);
	ANDI R30,0xEF
	CALL SUBOPT_0x7
; 0001 00B8     delay_ms(200);
; 0001 00B9 
; 0001 00BA     LED_ON(BIT_LED_PWR);
	ANDI R30,0XF7
	CALL SUBOPT_0x7
; 0001 00BB     delay_ms(200);
; 0001 00BC 
; 0001 00BD     LED_OFF(BIT_LED_PWR|BIT_LED_TEMP|BIT_LED_LINK|BIT_LED_ALARM);
	ORI  R30,LOW(0x78)
	CALL SUBOPT_0x7
; 0001 00BE     delay_ms(200);
; 0001 00BF 
; 0001 00C0     LED_ON(BIT_LED_PWR);
	ANDI R30,0XF7
	STS  258,R30
; 0001 00C1     delay_ms(50);
	CALL SUBOPT_0x8
; 0001 00C2 }
	RET
;/*============================================================*/
;
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <stdio.h>
;#include <string.h>
;#include <ctype.h>
;#include <delay.h>
;#include "uart.h"
;#include "io.h"
;#include "ethcomm.h"
;#include "wiz100rs.h"
;#include "interruptTask.h"
;
;/*============================================================*/
;char flag_PackageTerminate3 = 0;
;
;flash unsigned char charHeader = '$';
;flash unsigned char charTerminate = '#';
;
;bit                 flag_oled_ack      = 0;
;
;unsigned char       rxPackageIndex3;
;unsigned char       rxPackage3[64];
;unsigned char       rxPackageIndexCount3;
;/*============================================================*/
;// USART0 Receiver buffer
;//char rx_buffer0[RX_BUFFER_SIZE0];
;char rx_buffer0[2];
;
;unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
;
;// This flag is set on USART0 Receiver buffer overflow
;bit rx_buffer_overflow0;
;
;unsigned char       configRd[CONF_READ_BUFFER];      // for reading config
;int                 configLen=0;
;
;char                config_start    = 0;
;char                config_ready    = 0;    // 1 = failed, 2 = success
;char                config_end      = 0;
;char                config_response = 0;
;
;unsigned int    rxBeginCount     = 0;
;char            rxComplete  = 0;
;
;char rx0Buffer[400];
;unsigned int index0Buffer = 0;
;int flagDataUart0 = 0;
;int flagCountStart0 = 0;
;//char rx0ConnectBuff[50];
;unsigned int rx0IndexWriteConn = 0;
;//int flagConnected0 = 0;
;
;char uart0LockAccess = 0;
;
;extern piInterrupt_t pviUart0TimeOut;
;extern int (*piWizCallBack)(char *,unsigned int);
;//extern iHTTP_t iHTTPStatus;
;//iUartQueue_t iUartQueue = {0,0,0,511};
;
;// USART0 Receiver interrupt service routine
;interrupt [USART0_RXC] void usart0_rx_isr(void)
; 0002 003D {

	.CSEG
_usart0_rx_isr:
	CALL SUBOPT_0x9
; 0002 003E 
; 0002 003F     char status,data;
; 0002 0040     int iRetuen = 0;
; 0002 0041 
; 0002 0042 //    if((iUartQueue.ToWrite >= iUartQueue.ToRead) || iUartQueue.){
; 0002 0043 //
; 0002 0044 //    }
; 0002 0045     status=UCSR0A;
	CALL SUBOPT_0xA
;	status -> R17
;	data -> R16
;	iRetuen -> R18,R19
	LDS  R17,192
; 0002 0046     data=UDR0;
	LDS  R16,198
; 0002 0047 
; 0002 0048     if((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0){
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
	BREQ PC+3
	JMP _0x40003
; 0002 0049 //        if(data == '>'){
; 0002 004A //            rx0IndexWriteConn = 0;
; 0002 004B //            rx0ConnectBuff[rx0IndexWriteConn++] = data;
; 0002 004C //        }else if(rx0IndexWriteConn > 0){
; 0002 004D //            rx0ConnectBuff[rx0IndexWriteConn++] = data;
; 0002 004E //            if(rx0IndexWriteConn >=50){
; 0002 004F //               //function callback
; 0002 0050 //
; 0002 0051 //               piWizCallBack = &iWizStatusConnected;
; 0002 0052 //               piWizCallBack(rx0ConnectBuff,rx0IndexWriteConn);
; 0002 0053 //               rx0IndexWriteConn = 0;
; 0002 0054 //            }
; 0002 0055 //        }
; 0002 0056 
; 0002 0057         //iWizRXMode = 5;
; 0002 0058         //putchar3(data);
; 0002 0059         if(iWizRXMode == WIZ_RX_STAT_MODE){
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x1)
	BRNE _0x40004
; 0002 005A             if(index0Buffer == 0){
	LDS  R30,_index0Buffer
	LDS  R31,_index0Buffer+1
	SBIW R30,0
	BRNE _0x40005
; 0002 005B                  flagCountStart0 = 0;
	CLR  R10
	CLR  R11
; 0002 005C             }
; 0002 005D 
; 0002 005E             if(data == '>'){
_0x40005:
	CPI  R16,62
	BRNE _0x40006
; 0002 005F                 flagCountStart0 = 1;
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	MOVW R10,R30
; 0002 0060             }
; 0002 0061 
; 0002 0062             if(flagCountStart0 == 1){
_0x40006:
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CP   R30,R10
	CPC  R31,R11
	BRNE _0x40007
; 0002 0063                 putchar3(data);
	MOV  R26,R16
	RCALL _putchar3
; 0002 0064                 rx0Buffer[index0Buffer++] = data;
	CALL SUBOPT_0xB
; 0002 0065                 putchar3(data);
; 0002 0066                 if(index0Buffer >= 400){
	BRLO _0x40008
; 0002 0067                     //if full will disable interrupt
; 0002 0068                     //UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0069                     send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	LDI  R30,LOW(3)
	ST   -Y,R30
	__POINTW2MN _0x40009,0
	CALL SUBOPT_0xC
; 0002 006A                     send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
	__POINTW2MN _0x40009,43
	CALL SUBOPT_0xC
; 0002 006B                     send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	__POINTW2MN _0x40009,81
	CALL SUBOPT_0xD
; 0002 006C                     index0Buffer = 0;
; 0002 006D                 }
; 0002 006E             }
_0x40008:
; 0002 006F 
; 0002 0070         }else if(iWizRXMode == WIZ_RX_DATA_MODE){
_0x40007:
	RJMP _0x4000A
_0x40004:
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x2)
	BRNE _0x4000B
; 0002 0071             rx0Buffer[index0Buffer++] = data;
	CALL SUBOPT_0xB
; 0002 0072             putchar3(data);
; 0002 0073             if(index0Buffer >= 400){
	BRLO _0x4000C
; 0002 0074                 //if full will disable interrupt
; 0002 0075                 //UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0076                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	LDI  R30,LOW(3)
	ST   -Y,R30
	__POINTW2MN _0x40009,124
	CALL SUBOPT_0xC
; 0002 0077                 send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
	__POINTW2MN _0x40009,167
	CALL SUBOPT_0xC
; 0002 0078                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	__POINTW2MN _0x40009,205
	CALL SUBOPT_0xD
; 0002 0079                 index0Buffer = 0;
; 0002 007A             }
; 0002 007B 
; 0002 007C         }else if(iWizRXMode == WIZ_CONFIG_READ_MODE){
_0x4000C:
	RJMP _0x4000D
_0x4000B:
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x4)
	BRNE _0x4000E
; 0002 007D            rx0Buffer[index0Buffer++] = data;
	LDI  R26,LOW(_index0Buffer)
	LDI  R27,HIGH(_index0Buffer)
	CALL SUBOPT_0xE
	SBIW R30,1
	SUBI R30,LOW(-_rx0Buffer)
	SBCI R31,HIGH(-_rx0Buffer)
	ST   Z,R16
; 0002 007E            if(index0Buffer >= 400){
	CALL SUBOPT_0xF
	CPI  R26,LOW(0x190)
	LDI  R30,HIGH(0x190)
	CPC  R27,R30
	BRLO _0x4000F
; 0002 007F                 //if full will disable interrupt
; 0002 0080                 //UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0081                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	LDI  R30,LOW(3)
	ST   -Y,R30
	__POINTW2MN _0x40009,248
	CALL SUBOPT_0xC
; 0002 0082                 send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
	__POINTW2MN _0x40009,291
	CALL SUBOPT_0xC
; 0002 0083                 send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
	__POINTW2MN _0x40009,329
	CALL SUBOPT_0xD
; 0002 0084                 index0Buffer = 0;
; 0002 0085             }
; 0002 0086         }
_0x4000F:
; 0002 0087 
; 0002 0088 
; 0002 0089         //putchar3(data);
; 0002 008A     }
_0x4000E:
_0x4000D:
_0x4000A:
; 0002 008B 
; 0002 008C      //putchar3(data);
; 0002 008D 
; 0002 008E //    if(iWizRXMode == WIZ_RX_STAT_MODE){
; 0002 008F //        if(data == '>'){
; 0002 0090 //           //flagDataUart0 = 1;
; 0002 0091 //           iWizStatus = WIZ_STAT_UPDATE;
; 0002 0092 //        }else if(data != '>' && iWizStatus != WIZ_STAT_UPDATE){
; 0002 0093 //           putchar3(data);
; 0002 0094 //        }
; 0002 0095 //
; 0002 0096 //
; 0002 0097 //
; 0002 0098 //        if(iWizStatus == WIZ_STAT_UPDATE){
; 0002 0099 //           rx0Buffer[index0Buffer++] = data;
; 0002 009A //           if(index0Buffer == 512){
; 0002 009B //              index0Buffer = 0;
; 0002 009C //           }
; 0002 009D //           if(data == 0x0D){
; 0002 009E //                //callback check status
; 0002 009F //               //callBackChekStat();
; 0002 00A0 //               piWizCallBack = &iWizCBChekStat;
; 0002 00A1 //               piWizCallBack((char * const )rx0Buffer,index0Buffer);
; 0002 00A2 //               iWizStatus = WIZ_STAT_READ_SUCCESS;
; 0002 00A3 //               index0Buffer = 0;
; 0002 00A4 //           }
; 0002 00A5 //        }
; 0002 00A6 //    }else if(iWizRXMode == WIZ_RX_DATA_MODE){
; 0002 00A7 //        rx0Buffer[index0Buffer++] = data;
; 0002 00A8 //        if(index0Buffer == 512){
; 0002 00A9 //           index0Buffer = 0;
; 0002 00AA //        }
; 0002 00AB //        if(data == 0x0A){
; 0002 00AC //           //check http -> response code
; 0002 00AD //           if(iHTTPStatus.responseCode != WIZ_HTTP_RES_CODE_OK){
; 0002 00AE //               piWizCallBack = &iWizCBCheckHTTPResCode;
; 0002 00AF //               iRetuen = piWizCallBack((char * const )rx0Buffer,index0Buffer);
; 0002 00B0 //               if(iRetuen == WIZ_HTTP_RES_CODE_OK){
; 0002 00B1 //                   iHTTPStatus.responseCode = WIZ_HTTP_RES_CODE_OK;
; 0002 00B2 //                   //index0Buffer = 0;
; 0002 00B3 //               }else{
; 0002 00B4 //                   iHTTPStatus.responseCode = WIZ_HTTP_RES_CODE_UNKNOW;
; 0002 00B5 //                   index0Buffer = 0;
; 0002 00B6 //               }
; 0002 00B7 //           }
; 0002 00B8 ////           else if(iHTTPStatus.responseCode == WIZ_HTTP_RES_CODE_OK && iHTTPStatus.contentLength == 0){
; 0002 00B9 ////                  //iHTTPStatus.contentLength
; 0002 00BA ////                  piWizCallBack = &iWizCBCheckHTTPContextLen;
; 0002 00BB ////                  iRetuen = piWizCallBack((char * const )rx0Buffer,index0Buffer);
; 0002 00BC ////                  if(iRetuen != 1){
; 0002 00BD ////                     index0Buffer = 0;
; 0002 00BE ////                  }
; 0002 00BF //////                  if(iRetuen == WIZ_HTTP_CONTEXT_LEN_NOTFOUND){
; 0002 00C0 //////                     index0Buffer = 0;
; 0002 00C1 //////                  }
; 0002 00C2 //////                  else if((iRetuen != WIZ_HTTP_CONTEXT_LEN_LESS) && (iRetuen != WIZ_HTTP_CONTEXT_LEN_OVER)){
; 0002 00C3 //////                      iHTTPStatus.contentLength = iRetuen;
; 0002 00C4 //////                      //index0Buffer = 0;
; 0002 00C5 //////                  }else{
; 0002 00C6 //////                      //index0Buffer = 0;
; 0002 00C7 //////                  }
; 0002 00C8 ////           }
; 0002 00C9 //        }
; 0002 00CA //    }
; 0002 00CB //
; 0002 00CC 
; 0002 00CD 
; 0002 00CE 
; 0002 00CF //    if(uart0LockAccess != UART0_LOCK_ACCESS){
; 0002 00D0 //        //putchar3(data);
; 0002 00D1 //
; 0002 00D2 //        if(data=='<'){   //'<' = start config delimeter
; 0002 00D3 //          //call function pointer noti that end of data
; 0002 00D4 //          //copy data from buffer
; 0002 00D5 ////           if(rx0Buffer[(rxBeginCount-1)] == 0x0A){
; 0002 00D6 ////                  //model wiz100rs and version display
; 0002 00D7 ////                  pfiWiz100rs = &iWizRXdata;
; 0002 00D8 ////                  pfiWiz100rs();
; 0002 00D9 ////                  //rxBeginCount = 0;
; 0002 00DA ////           }else if(rx0Buffer[(rxBeginCount-1)] == 0x0D){
; 0002 00DB ////                  //model wiz100rs config data display
; 0002 00DC ////                  //rxBeginCount = 0;
; 0002 00DD ////           }
; 0002 00DE //
; 0002 00DF ////            putchar3('k');
; 0002 00E0 //            //timeout start
; 0002 00E1 //
; 0002 00E2 //
; 0002 00E3 //            rxBeginCount = 0;
; 0002 00E4 //            rx0Buffer[rxBeginCount] = data;
; 0002 00E5 //            //putchar3(data);
; 0002 00E6 //            rxBeginCount++;
; 0002 00E7 //        }
; 0002 00E8 //
; 0002 00E9 //        if(rxBeginCount > 0){
; 0002 00EA //            if(data==0x0A){
; 0002 00EB //                rx0Buffer[rxBeginCount] = data;
; 0002 00EC //               // putchar3(data);
; 0002 00ED //                pfiWiz100rs = &iWizRXdata;
; 0002 00EE //                pfiWiz100rs();
; 0002 00EF //                rxBeginCount = 0;
; 0002 00F0 //                //pviUart0TimeOut = rxBeginCount;
; 0002 00F1 //                pviUart0TimeOut = 1;
; 0002 00F2 //            }else{
; 0002 00F3 //                rx0Buffer[rxBeginCount] = data;
; 0002 00F4 //              //  putchar3(data);
; 0002 00F5 //                rxBeginCount++;
; 0002 00F6 //                //pviUart0TimeOut = rxBeginCount;
; 0002 00F7 //                pviUart0TimeOut = 1;
; 0002 00F8 //            }
; 0002 00F9 //        }
; 0002 00FA //
; 0002 00FB //
; 0002 00FC //        if(rxBeginCount==RX_BUFFER_SIZE0){
; 0002 00FD //           rxBeginCount = 0;
; 0002 00FE //           //call function pointer noti that buffer over flow
; 0002 00FF //        }
; 0002 0100 //    }
; 0002 0101 
; 0002 0102 
; 0002 0103 
; 0002 0104 
; 0002 0105 
; 0002 0106 //    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
; 0002 0107 //    {   ETH_current_mode  == MODE_CONF;
; 0002 0108 //        if(ETH_current_mode != MODE_CONF)
; 0002 0109 //        {
; 0002 010A //        //bongkot edit;
; 0002 010B //            //putchar3(data);
; 0002 010C //
; 0002 010D //
; 0002 010E //            rx_buffer0[rx_wr_index0++]  =   data;
; 0002 010F //
; 0002 0110 //            if (rx_wr_index0 == RX_BUFFER_SIZE0)
; 0002 0111 //            {
; 0002 0112 //                rx_wr_index0=0;
; 0002 0113 //            }
; 0002 0114 //            if (++rx_counter0 == RX_BUFFER_SIZE0)
; 0002 0115 //            {
; 0002 0116 //                rx_counter0=0;
; 0002 0117 //                rx_buffer_overflow0=1;
; 0002 0118 //                send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
; 0002 0119 //                send_uart(3,    "!!!!!!! Eth Buffer Overflow !!!!!!!!!"     );
; 0002 011A //                send_uart(3,"\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n" );
; 0002 011B //            }
; 0002 011C //        }
; 0002 011D //        else{
; 0002 011E //            putchar3(data);
; 0002 011F //
; 0002 0120 //            if (configLen == CONF_READ_BUFFER)
; 0002 0121 //            {
; 0002 0122 //                configLen=0;
; 0002 0123 //            }
; 0002 0124 //
; 0002 0125 //            if((data == '<') && (config_start == 0)){
; 0002 0126 //                config_start            = 1;
; 0002 0127 //                config_response         = 0;
; 0002 0128 //                config_ready            = 0;
; 0002 0129 //            }
; 0002 012A //            else if((data == 0x0D) && (config_end == 0) && (config_start == 1) && (config_response != 0)){
; 0002 012B //                config_end  = 0x0D;
; 0002 012C //            }
; 0002 012D //            else if((data == 0x0A) && (config_end == 0x0D) && (config_start == 1) && (config_response != 0)){
; 0002 012E //                config_end              = 0x0A;
; 0002 012F //                config_ready            = 1;
; 0002 0130 //            }
; 0002 0131 //            else if((data == 'E') && (config_start == 1) && (config_response == 0)){
; 0002 0132 //                config_response         = 'E';
; 0002 0133 //            }
; 0002 0134 //            else if((data == 'S') && (config_start == 1) && (config_response == 0)){
; 0002 0135 //                config_response         = 'S';
; 0002 0136 //            }
; 0002 0137 //            else if((config_start == 1) && (config_response != 0)){
; 0002 0138 //                configRd[configLen++]   =   data;
; 0002 0139 //            }
; 0002 013A //        }
; 0002 013B //    }
; 0002 013C }
_0x40003:
	CALL __LOADLOCR4
	ADIW R28,4
	RJMP _0x40040

	.DSEG
_0x40009:
	.BYTE 0x174
;
;#ifndef _DEBUG_TERMINAL_IO_
;// Get a character from the USART0 Receiver buffer
;#define _ALTERNATE_GETCHAR_
;
;#pragma used+
;char getchar(void)
; 0002 0144 {

	.CSEG
; 0002 0145     char data;
; 0002 0146     while (rx_counter0==0);
;	data -> R17
; 0002 0147     data=rx_buffer0[rx_rd_index0++];
; 0002 0148  //   #if RX_BUFFER_SIZE0 != 256
; 0002 0149     if (rx_rd_index0 == RX_BUFFER_SIZE0)
; 0002 014A         rx_rd_index0=0;
; 0002 014B //    #endif
; 0002 014C     #asm("cli")
; 0002 014D     --rx_counter0;
; 0002 014E     #asm("sei")
; 0002 014F     return data;
; 0002 0150 }
;#pragma used-
;// Write a character to the USART0 Transmitter
;#pragma used+
;void putchar0(char c)
; 0002 0155 {
_putchar0:
; 0002 0156     while ((UCSR0A & DATA_REGISTER_EMPTY)==0);
	ST   -Y,R26
;	c -> Y+0
_0x40014:
	LDS  R30,192
	ANDI R30,LOW(0x20)
	BREQ _0x40014
; 0002 0157     UDR0=c;
	LD   R30,Y
	STS  198,R30
; 0002 0158 }
	RJMP _0x20E003B
;#pragma used-
;#endif
;
;int read_uart0(char *readbuf, int maxread,int interchar)
; 0002 015D {
; 0002 015E     char data;
; 0002 015F     int len=0;
; 0002 0160 
; 0002 0161     while (rx_counter0 > 0)
;	*readbuf -> Y+8
;	maxread -> Y+6
;	interchar -> Y+4
;	data -> R17
;	len -> R18,R19
; 0002 0162     {
; 0002 0163         data=rx_buffer0[rx_rd_index0++];
; 0002 0164         if (rx_rd_index0 == RX_BUFFER_SIZE0){
; 0002 0165             rx_rd_index0=0;
; 0002 0166         }
; 0002 0167         UCSR0B &= 0x7F;          // -- disable uart0 interrupt -- //
; 0002 0168 
; 0002 0169         --rx_counter0;
; 0002 016A 
; 0002 016B         UCSR0B |= 0x80;          // -- enable uart0 interrupt -- //
; 0002 016C 
; 0002 016D         memcpy(readbuf++,&data,1);
; 0002 016E         len++;
; 0002 016F 
; 0002 0170         if(len == maxread){
; 0002 0171             break;
; 0002 0172         }
; 0002 0173         delay_ms(interchar);
; 0002 0174     }
; 0002 0175     return len;
; 0002 0176 }
;
;int write_uart0(char writebuf[], int len)
; 0002 0179 {
; 0002 017A     int i;
; 0002 017B     for(i=0;i<len;i++){
;	writebuf -> Y+4
;	len -> Y+2
;	i -> R16,R17
; 0002 017C         putchar0(writebuf[i]);
; 0002 017D     }
; 0002 017E     return i;
; 0002 017F }
;/*============================================================*/
;// USART1 Receiver interrupt service routine
;interrupt [USART1_RXC] void usart1_rx_isr(void)
; 0002 0183 {
_usart1_rx_isr:
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0002 0184     char status,data;
; 0002 0185     status=UCSR1A;
	ST   -Y,R17
	ST   -Y,R16
;	status -> R17
;	data -> R16
	LDS  R17,200
; 0002 0186     data=UDR1;
	LDS  R16,206
; 0002 0187 
; 0002 0188     if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
; 0002 0189     {
; 0002 018A         if(data);
; 0002 018B     }
; 0002 018C }
	RJMP _0x40041
;
;/*============================================================*/
;// USART2 Receiver interrupt service routine
;interrupt [USART2_RXC] void usart2_rx_isr(void)
; 0002 0191 {
_usart2_rx_isr:
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0002 0192     char status,data;
; 0002 0193     status=UCSR2A;
	ST   -Y,R17
	ST   -Y,R16
;	status -> R17
;	data -> R16
	LDS  R17,208
; 0002 0194     data=UDR2;
	LDS  R16,214
; 0002 0195     if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
	BRNE _0x40021
; 0002 0196     {
; 0002 0197         if(data=='K'){
	CPI  R16,75
	BRNE _0x40022
; 0002 0198             flag_oled_ack = 1;
	SBI  0x1E,0
; 0002 0199         }
; 0002 019A         else{
_0x40022:
; 0002 019B             //putchar3(data);
; 0002 019C         }
; 0002 019D     }
; 0002 019E }
_0x40021:
_0x40041:
	LD   R16,Y+
	LD   R17,Y+
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	RETI
;
;// Write a character to the USART2 Transmitter
;#pragma used+
;void putchar2(char c)
; 0002 01A3 {
_putchar2:
; 0002 01A4     while ((UCSR2A & DATA_REGISTER_EMPTY)==0);
	ST   -Y,R26
;	c -> Y+0
_0x40026:
	LDS  R30,208
	ANDI R30,LOW(0x20)
	BREQ _0x40026
; 0002 01A5     UDR2=c;
	LD   R30,Y
	STS  214,R30
; 0002 01A6 }
	RJMP _0x20E003B
;#pragma used-
;
;
;/*============================================================*/
;// USART3 Receiver interrupt service routine
;interrupt [USART3_RXC] void usart3_rx_isr(void)
; 0002 01AD {
_usart3_rx_isr:
	CALL SUBOPT_0x9
; 0002 01AE     char status,data;
; 0002 01AF     status=UCSR3A;
	ST   -Y,R17
	ST   -Y,R16
;	status -> R17
;	data -> R16
	LDS  R17,304
; 0002 01B0     data=UDR3;
	LDS  R16,310
; 0002 01B1 
; 0002 01B2 
; 0002 01B3     //putchar3(data);
; 0002 01B4     putchar0(data);
	MOV  R26,R16
	RCALL _putchar0
; 0002 01B5     if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
	MOV  R30,R17
	ANDI R30,LOW(0x1C)
	BRNE _0x40029
; 0002 01B6     {
; 0002 01B7         putchar3(data);
	MOV  R26,R16
	RCALL _putchar3
; 0002 01B8 //        putchar0(data);
; 0002 01B9         // Detect Package Header
; 0002 01BA         if(data == charHeader)
	CPI  R16,36
	BRNE _0x4002A
; 0002 01BB         {
; 0002 01BC             rxPackageIndex3 = 0;
	CLR  R9
; 0002 01BD         }
; 0002 01BE 
; 0002 01BF         rxPackage3[rxPackageIndex3++] = data;
_0x4002A:
	MOV  R30,R9
	INC  R9
	LDI  R31,0
	SUBI R30,LOW(-_rxPackage3)
	SBCI R31,HIGH(-_rxPackage3)
	ST   Z,R16
; 0002 01C0 
; 0002 01C1         if(rxPackageIndex3 >= 64) rxPackageIndex3 = 0;
	LDI  R30,LOW(64)
	CP   R9,R30
	BRLO _0x4002B
	CLR  R9
; 0002 01C2 
; 0002 01C3         if(data == charTerminate)
_0x4002B:
	CPI  R16,35
	BRNE _0x4002C
; 0002 01C4         {
; 0002 01C5             rxPackageIndexCount3 = rxPackageIndex3-1;
	MOV  R30,R9
	SUBI R30,LOW(1)
	MOV  R8,R30
; 0002 01C6             rxPackageIndex3 = 0;
	CLR  R9
; 0002 01C7             flag_PackageTerminate3 = 1;
	LDI  R30,LOW(1)
	STS  _flag_PackageTerminate3,R30
; 0002 01C8         }
; 0002 01C9     }
_0x4002C:
; 0002 01CA }
_0x40029:
	LD   R16,Y+
	LD   R17,Y+
_0x40040:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	OUT  EIND,R30
	LD   R30,Y+
	OUT  RAMPZ,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R24,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R15,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;
;/*============================================================*/
;// Write a character to the USART3 Transmitter
;#pragma used+
;void putchar3(char c)
; 0002 01D0 {
_putchar3:
; 0002 01D1     while ((UCSR3A & DATA_REGISTER_EMPTY)==0);
	ST   -Y,R26
;	c -> Y+0
_0x4002D:
	LDS  R30,304
	ANDI R30,LOW(0x20)
	BREQ _0x4002D
; 0002 01D2     UDR3=c;
	LD   R30,Y
	STS  310,R30
; 0002 01D3 }
_0x20E003B:
	ADIW R28,1
	RET
;#pragma used-
;
;/*============================================================*/
;void send_uart(char port,char *buffer)
; 0002 01D8 {
_send_uart:
; 0002 01D9     char i = 0;
; 0002 01DA 
; 0002 01DB     switch (port)
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
;	port -> Y+3
;	*buffer -> Y+1
;	i -> R17
	LDI  R17,0
	LDD  R30,Y+3
	LDI  R31,0
; 0002 01DC     {
; 0002 01DD         case 0: puts(buffer);
	SBIW R30,0
	BRNE _0x40033
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CALL _puts
; 0002 01DE                 break;
	RJMP _0x40032
; 0002 01DF 
; 0002 01E0         case 1: while(buffer[i] != 0)
_0x40033:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x40034
_0x40035:
	CALL SUBOPT_0x10
	BREQ _0x40037
; 0002 01E1                 {
; 0002 01E2                     //putchar1(buffer[i]);
; 0002 01E3                     i++;
	SUBI R17,-1
; 0002 01E4                 }
	RJMP _0x40035
_0x40037:
; 0002 01E5                 break;
	RJMP _0x40032
; 0002 01E6 
; 0002 01E7         case 2: while(buffer[i] != 0)
_0x40034:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x40038
_0x40039:
	CALL SUBOPT_0x10
	BREQ _0x4003B
; 0002 01E8                 {
; 0002 01E9                     putchar2(buffer[i]);
	CALL SUBOPT_0x11
	RCALL _putchar2
; 0002 01EA                     i++;
	SUBI R17,-1
; 0002 01EB                 }
	RJMP _0x40039
_0x4003B:
; 0002 01EC                 break;
	RJMP _0x40032
; 0002 01ED 
; 0002 01EE         case 3: while(buffer[i] != 0)
_0x40038:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x40032
_0x4003D:
	CALL SUBOPT_0x10
	BREQ _0x4003F
; 0002 01EF                 {
; 0002 01F0                     putchar3(buffer[i]);
	CALL SUBOPT_0x11
	RCALL _putchar3
; 0002 01F1                     i++;
	SUBI R17,-1
; 0002 01F2                 }
	RJMP _0x4003D
_0x4003F:
; 0002 01F3                 break;
; 0002 01F4     }
_0x40032:
; 0002 01F5 }
	LDD  R17,Y+0
	RJMP _0x20E003A
;
;/*============================================================*/
;void init_uart(void)
; 0002 01F9 {
_init_uart:
; 0002 01FA //    // USART0 initialization
; 0002 01FB //    // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 01FC //    // USART0 Receiver: On
; 0002 01FD //    // USART0 Transmitter: On
; 0002 01FE //    // USART0 Mode: Asynchronous
; 0002 01FF //    // USART0 Baud Rate: 38400
; 0002 0200 //    UCSR0A=0x00;
; 0002 0201 //    UCSR0B=0x98;
; 0002 0202 //    UCSR0C=0x06;
; 0002 0203 //    UBRR0H=0x00;
; 0002 0204 //    UBRR0L=0x0C;
; 0002 0205 
; 0002 0206     // USART0 initialization
; 0002 0207     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0208     // USART0 Receiver: On
; 0002 0209     // USART0 Transmitter: On
; 0002 020A     // USART0 Mode: Asynchronous
; 0002 020B     // USART0 Baud Rate: 9600
; 0002 020C 
; 0002 020D     /*bongkot comment*/
; 0002 020E     UCSR0A=0x00;
	LDI  R30,LOW(0)
	STS  192,R30
; 0002 020F     UCSR0B=0x98;
	LDI  R30,LOW(152)
	STS  193,R30
; 0002 0210     UCSR0C=0x06;
	LDI  R30,LOW(6)
	STS  194,R30
; 0002 0211     UBRR0H=0x00;
	LDI  R30,LOW(0)
	STS  197,R30
; 0002 0212     UBRR0L=0x33;
	LDI  R30,LOW(51)
	STS  196,R30
; 0002 0213 
; 0002 0214     // USART0 initialization
; 0002 0215     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0216     // USART0 Receiver: On
; 0002 0217     // USART0 Transmitter: On
; 0002 0218     // USART0 Mode: Asynchronous
; 0002 0219     // USART0 Baud Rate: 57600
; 0002 021A //    UCSR0A=0x00;
; 0002 021B //    UCSR0B=0x98;
; 0002 021C //    UCSR0C=0x06;
; 0002 021D //    UBRR0H=0x00;
; 0002 021E //    UBRR0L=0x08;
; 0002 021F 
; 0002 0220 
; 0002 0221 
; 0002 0222 
; 0002 0223 
; 0002 0224     // USART1 initialization
; 0002 0225     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0226     // USART1 Receiver: On
; 0002 0227     // USART1 Transmitter: On
; 0002 0228     // USART1 Mode: Asynchronous
; 0002 0229     // USART1 Baud Rate: 38400
; 0002 022A     UCSR1A=0x00;
	LDI  R30,LOW(0)
	STS  200,R30
; 0002 022B     UCSR1B=0x98;
	LDI  R30,LOW(152)
	STS  201,R30
; 0002 022C     UCSR1C=0x06;
	LDI  R30,LOW(6)
	STS  202,R30
; 0002 022D     UBRR1H=0x00;
	LDI  R30,LOW(0)
	STS  205,R30
; 0002 022E     UBRR1L=0x0C;
	LDI  R30,LOW(12)
	STS  204,R30
; 0002 022F 
; 0002 0230 //    // USART2 initialization
; 0002 0231 //    // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 0232 //    // USART2 Receiver: On
; 0002 0233 //    // USART2 Transmitter: On
; 0002 0234 //    // USART2 Mode: Asynchronous
; 0002 0235 //    // USART2 Baud Rate: 115200 (Double Speed Mode)
; 0002 0236 //    UCSR2A=0x02;
; 0002 0237 //    UCSR2B=0x98;
; 0002 0238 //    UCSR2C=0x06;
; 0002 0239 //    UBRR2H=0x00;
; 0002 023A //    UBRR2L=0x08;
; 0002 023B 
; 0002 023C     // USART2 initialization
; 0002 023D     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 023E     // USART2 Receiver: On
; 0002 023F     // USART2 Transmitter: On
; 0002 0240     // USART2 Mode: Asynchronous
; 0002 0241     // USART2 Baud Rate: 38400
; 0002 0242     UCSR2A=0x00;
	LDI  R30,LOW(0)
	STS  208,R30
; 0002 0243     UCSR2B=0x98;
	LDI  R30,LOW(152)
	STS  209,R30
; 0002 0244     UCSR2C=0x06;
	LDI  R30,LOW(6)
	STS  210,R30
; 0002 0245     UBRR2H=0x00;
	LDI  R30,LOW(0)
	STS  213,R30
; 0002 0246     UBRR2L=0x0C;
	LDI  R30,LOW(12)
	STS  212,R30
; 0002 0247 
; 0002 0248     // USART3 initialization
; 0002 0249     // Communication Parameters: 8 Data, 1 Stop, No Parity
; 0002 024A     // USART3 Receiver: On
; 0002 024B     // USART3 Transmitter: On
; 0002 024C     // USART3 Mode: Asynchronous
; 0002 024D     // USART3 Baud Rate: 38400
; 0002 024E     UCSR3A=0x00;
	LDI  R30,LOW(0)
	STS  304,R30
; 0002 024F     UCSR3B=0x98;
	LDI  R30,LOW(152)
	STS  305,R30
; 0002 0250     UCSR3C=0x06;
	LDI  R30,LOW(6)
	STS  306,R30
; 0002 0251     UBRR3H=0x00;
	LDI  R30,LOW(0)
	STS  309,R30
; 0002 0252     UBRR3L=0x0C;
	LDI  R30,LOW(12)
	STS  308,R30
; 0002 0253 }
	RET
;
;/*============================================================*/
;
;#include "timer.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "ds1672.h"
;#include "adc.h"
;#include "io.h"
;#include "debug.h"
;#include "memcard.h"
;
;TIMER       baseCounter         = 0;    // -- increase continually by 1 second timer. use for timer comparison -- //
;bit         timer_1sec_flag     = 0;    // -- 1 second trigger flag for main loop -- //
;
;bit         buzzer_on           = 0;    // -- buzzer control [0:1] => [on:off] -- //
;
;unsigned int countTimerIntpTask  = 0;//set count of interrupt task
;
;/**************************************************************/
;/******************* Software Timer Support *******************/
;/**************************************************************/
;/*============================================================*/
;TIMER TIMER_checkTimeLeft(TIMER time)
; 0003 0014 {

	.CSEG
; 0003 0015     if(baseCounter < time){
;	time -> Y+0
; 0003 0016         return ( time - baseCounter );
; 0003 0017     }
; 0003 0018     else{
; 0003 0019         return 0;
; 0003 001A     }
; 0003 001B }
;/*============================================================*/
;int TIMER_checkTimerExceed(TIMER keeper)
; 0003 001E {
_TIMER_checkTimerExceed:
; 0003 001F     if(keeper == 0){
	CALL SUBOPT_0x12
;	keeper -> Y+0
	CALL __CPD10
	BRNE _0x60005
; 0003 0020         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E003A
; 0003 0021     }
; 0003 0022 
; 0003 0023     if((unsigned long int)baseCounter < (unsigned long int)keeper){
_0x60005:
	CALL SUBOPT_0x13
	CALL SUBOPT_0x14
	CALL __CPD21
	BRSH _0x60006
; 0003 0024         return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E003A
; 0003 0025     }
; 0003 0026     else{                             // -- time exceed -- //
_0x60006:
; 0003 0027         return 1;
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
; 0003 0028     }
; 0003 0029 }
_0x20E003A:
	ADIW R28,4
	RET
;/*============================================================*/
;int TIMER_setTimer(TIMER *keeper, unsigned long int period)
; 0003 002C {
_TIMER_setTimer:
; 0003 002D     unsigned long int t;
; 0003 002E 
; 0003 002F     if(period == 0){
	CALL __PUTPARD2
	SBIW R28,4
;	*keeper -> Y+8
;	period -> Y+4
;	t -> Y+0
	CALL SUBOPT_0x15
	CALL __CPD10
	BRNE _0x60008
; 0003 0030         printDebug("<TIMER_setTimer> ERR: period = 0\r\n");
	__POINTD1FN _0x60000,0
	CALL SUBOPT_0x0
; 0003 0031         *keeper = 0xFFFFFFFF;
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL SUBOPT_0x16
	CALL __PUTDP1
; 0003 0032         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	JMP  _0x20E0039
; 0003 0033     }
; 0003 0034 
; 0003 0035     t = baseCounter + period;
_0x60008:
	CALL SUBOPT_0x15
	CALL SUBOPT_0x14
	CALL __ADDD12
	CALL SUBOPT_0x17
; 0003 0036 
; 0003 0037     *keeper = t;
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL __PUTDP1
; 0003 0038 
; 0003 0039     if(t <= baseCounter){
	CALL SUBOPT_0x18
	CALL SUBOPT_0x19
	CALL __CPD12
	BRLO _0x60009
; 0003 003A         printDebug("<TIMER_setTimer> baseCounter[%ld] + period[%ld] = %ld OVERFLOW!!\r\n",baseCounter,period,t);
	__POINTD1FN _0x60000,35
	CALL __PUTPARD1
	CALL SUBOPT_0x18
	CALL SUBOPT_0x1A
	CALL SUBOPT_0x1A
	CALL __PUTPARD1
	LDI  R24,12
	CALL _printDebug
	ADIW R28,16
; 0003 003B         *keeper = 0;
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL SUBOPT_0x1B
	CALL __PUTDP1
; 0003 003C         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	JMP  _0x20E0039
; 0003 003D     }
; 0003 003E     else{
_0x60009:
; 0003 003F         return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	JMP  _0x20E0039
; 0003 0040     }
; 0003 0041 }
;/*============================================================*/
;
;/**************************************************************/
;/********************** Hardware Support **********************/
;/**************************************************************/
;/*============================================================*/
;// Watchdog timeout interrupt service routine
;interrupt [WDT] void wdt_timeout_isr(void)
; 0003 004A {
_wdt_timeout_isr:
	CALL SUBOPT_0x9
; 0003 004B     // Place your code here
; 0003 004C     printDebug("<WDT> WatchDog Timer Reset!!\r\n");
	__POINTD1FN _0x60000,102
	CALL SUBOPT_0x0
; 0003 004D     return;
	RJMP _0x6002B
; 0003 004E }
;/*============================================================*/
;// Timer 0 overflow interrupt service routine
;interrupt [TIM0_OVF] void timer0_ovf_isr(void)
; 0003 0052 {
_timer0_ovf_isr:
	ST   -Y,R30
; 0003 0053     // Reinitialize Timer 0 value
; 0003 0054     TCNT0=0x64;
	LDI  R30,LOW(100)
	OUT  0x26,R30
; 0003 0055     // Place your code here
; 0003 0056 
; 0003 0057 }
	RJMP _0x6002A
;/*============================================================*/
;// Timer1 overflow interrupt service routine
;interrupt [TIM1_OVF] void timer1_ovf_isr(void)
; 0003 005B {
_timer1_ovf_isr:
	ST   -Y,R30
; 0003 005C     // Reinitialize Timer1 value
; 0003 005D //    TCNT1H=0xFF64 >> 8;
; 0003 005E //    TCNT1L=0xFF64 & 0xff;
; 0003 005F     TCNT1H=0xFE79 >> 8;
	CALL SUBOPT_0x1C
; 0003 0060     TCNT1L=0xFE79 & 0xff;
; 0003 0061 
; 0003 0062     //adc_sampling();
; 0003 0063 }
	RJMP _0x6002A
;/*============================================================*/
;// Timer2 overflow interrupt service routine    (100Hz)
;interrupt [TIM2_OVF] void timer2_ovf_isr(void)
; 0003 0067 {
_timer2_ovf_isr:
	CALL SUBOPT_0x9
; 0003 0068     // Reinitialize Timer2 value
; 0003 0069     TCNT2=0xb2;
	LDI  R30,LOW(178)
	STS  178,R30
; 0003 006A 
; 0003 006B     /* card access low level timing function */
; 0003 006C     disk_timerproc();
	CALL _disk_timerproc
; 0003 006D 
; 0003 006E }
_0x6002B:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	OUT  EIND,R30
	LD   R30,Y+
	OUT  RAMPZ,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R24,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R15,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;/*============================================================*/
;// Timer1 overflow interrupt service routine  (1 second)
;interrupt [TIM3_OVF] void timer3_ovf_isr(void)
; 0003 0072 {
_timer3_ovf_isr:
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
; 0003 0073     // Reinitialize Timer1 value
; 0003 0074     TCNT3H=0x85ED >> 8;
	CALL SUBOPT_0x1D
; 0003 0075     TCNT3L=0x85ED & 0xff;
; 0003 0076 
; 0003 0077     // Place your code here
; 0003 0078     timer_1sec_flag = 1;
	SBI  0x1E,2
; 0003 0079 
; 0003 007A     countTimerIntpTask++;
	LDI  R26,LOW(_countTimerIntpTask)
	LDI  R27,HIGH(_countTimerIntpTask)
	CALL SUBOPT_0xE
; 0003 007B     if(countTimerIntpTask==100){
	LDS  R26,_countTimerIntpTask
	LDS  R27,_countTimerIntpTask+1
	CPI  R26,LOW(0x64)
	LDI  R30,HIGH(0x64)
	CPC  R27,R30
	BRNE _0x6000D
; 0003 007C        countTimerIntpTask = 0;
	LDI  R30,LOW(0)
	STS  _countTimerIntpTask,R30
	STS  _countTimerIntpTask+1,R30
; 0003 007D     }
; 0003 007E 
; 0003 007F     baseCounter++;
_0x6000D:
	LDI  R26,LOW(_baseCounter)
	LDI  R27,HIGH(_baseCounter)
	CALL SUBOPT_0x1E
; 0003 0080 
; 0003 0081     raw_rtc++;                          // -- update backup RTC
	LDI  R26,LOW(_raw_rtc)
	LDI  R27,HIGH(_raw_rtc)
	CALL SUBOPT_0x1E
; 0003 0082 
; 0003 0083     //printDebug("<%d>\r\n",baseCounter);
; 0003 0084 }
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R23,Y+
	LD   R22,Y+
	RETI
;/*============================================================*/
;// Timer4 overflow interrupt service routine (0.5 sec)
;interrupt [TIM4_OVF] void timer4_ovf_isr(void)
; 0003 0088 {
_timer4_ovf_isr:
	ST   -Y,R30
; 0003 0089     static bit toggle = 0;
; 0003 008A     // Reinitialize Timer4 value
; 0003 008B     TCNT4H=0x85ED >> 8;
	CALL SUBOPT_0x1F
; 0003 008C     TCNT4L=0x85ED & 0xff;
; 0003 008D 
; 0003 008E     // Place your code here
; 0003 008F     toggle = !toggle;
	SBIS 0x1E,4
	RJMP _0x6000E
	CBI  0x1E,4
	RJMP _0x6000F
_0x6000E:
	SBI  0x1E,4
_0x6000F:
; 0003 0090 
; 0003 0091     if(buzzer_on){
	SBIS 0x1E,3
	RJMP _0x60010
; 0003 0092         if(toggle)  {   BUZZER = 1; }
	SBIS 0x1E,4
	RJMP _0x60011
	SBI  0xE,7
; 0003 0093         else        {   BUZZER = 0; }
	RJMP _0x60014
_0x60011:
	CBI  0xE,7
_0x60014:
; 0003 0094     }
; 0003 0095     else{
	RJMP _0x60017
_0x60010:
; 0003 0096         BUZZER = 0;
	CBI  0xE,7
; 0003 0097     }
_0x60017:
; 0003 0098 
; 0003 0099 }
_0x6002A:
	LD   R30,Y+
	RETI
;
;//// Timer5 overflow interrupt service routine
;//interrupt [TIM5_OVF] void timer5_ovf_isr(void)
;//{
;//// Place your code here
;//
;//}
;/*============================================================*/
;void init_timer(void)
; 0003 00A3 {
_init_timer:
; 0003 00A4 
; 0003 00A5     // Timer/Counter 0 initialization
; 0003 00A6     // Clock source: System Clock
; 0003 00A7     // Clock value: 7.813 kHz
; 0003 00A8     // Mode: Normal top=0xFF
; 0003 00A9     // OC0A output: Disconnected
; 0003 00AA     // OC0B output: Disconnected
; 0003 00AB     TCCR0A=0x00;
	LDI  R30,LOW(0)
	OUT  0x24,R30
; 0003 00AC     TCCR0B=0x05;
	LDI  R30,LOW(5)
	OUT  0x25,R30
; 0003 00AD     TCNT0=0x64;
	LDI  R30,LOW(100)
	OUT  0x26,R30
; 0003 00AE     OCR0A=0x00;
	LDI  R30,LOW(0)
	OUT  0x27,R30
; 0003 00AF     OCR0B=0x00;
	OUT  0x28,R30
; 0003 00B0 
; 0003 00B1     // Timer/Counter 1 initialization
; 0003 00B2     // Clock source: System Clock
; 0003 00B3     // Clock value: 7.813 kHz
; 0003 00B4     // Mode: Normal top=0xFFFF
; 0003 00B5     // OC1A output: Discon.
; 0003 00B6     // OC1B output: Discon.
; 0003 00B7     // OC1C output: Discon.
; 0003 00B8     // Noise Canceler: Off
; 0003 00B9     // Input Capture on Falling Edge
; 0003 00BA     // Timer1 Overflow Interrupt: On
; 0003 00BB     // Input Capture Interrupt: Off
; 0003 00BC     // Compare A Match Interrupt: Off
; 0003 00BD     // Compare B Match Interrupt: Off
; 0003 00BE     // Compare C Match Interrupt: Off
; 0003 00BF     TCCR1A=0x00;
	STS  128,R30
; 0003 00C0     TCCR1B=0x05;
	LDI  R30,LOW(5)
	STS  129,R30
; 0003 00C1     //TCNT1H=0xFF;
; 0003 00C2     //TCNT1L=0x64;
; 0003 00C3     TCNT1H=0xFE;
	CALL SUBOPT_0x1C
; 0003 00C4     TCNT1L=0x79;
; 0003 00C5     ICR1H=0x00;
	LDI  R30,LOW(0)
	STS  135,R30
; 0003 00C6     ICR1L=0x00;
	STS  134,R30
; 0003 00C7     OCR1AH=0x00;
	STS  137,R30
; 0003 00C8     OCR1AL=0x00;
	STS  136,R30
; 0003 00C9     OCR1BH=0x00;
	STS  139,R30
; 0003 00CA     OCR1BL=0x00;
	STS  138,R30
; 0003 00CB     OCR1CH=0x00;
	STS  141,R30
; 0003 00CC     OCR1CL=0x00;
	STS  140,R30
; 0003 00CD 
; 0003 00CE     // Timer/Counter 2 initialization
; 0003 00CF     // Clock source: System Clock
; 0003 00D0     // Clock value: 7.813 kHz
; 0003 00D1     // Mode: Normal top=0xFF
; 0003 00D2     // OC2A output: Disconnected
; 0003 00D3     // OC2B output: Disconnected
; 0003 00D4     ASSR=0x00;
	STS  182,R30
; 0003 00D5     TCCR2A=0x00;
	STS  176,R30
; 0003 00D6     TCCR2B=0x07;
	LDI  R30,LOW(7)
	STS  177,R30
; 0003 00D7     TCNT2=0xb2;
	LDI  R30,LOW(178)
	STS  178,R30
; 0003 00D8     OCR2A=0x00;
	LDI  R30,LOW(0)
	STS  179,R30
; 0003 00D9     OCR2B=0x00;
	STS  180,R30
; 0003 00DA 
; 0003 00DB     // Timer/Counter 3 initialization
; 0003 00DC     // Clock source: System Clock
; 0003 00DD     // Clock value: 31.250 kHz
; 0003 00DE     // Mode: Normal top=0xFFFF
; 0003 00DF     // OC3A output: Discon.
; 0003 00E0     // OC3B output: Discon.
; 0003 00E1     // OC3C output: Discon.
; 0003 00E2     // Noise Canceler: Off
; 0003 00E3     // Input Capture on Falling Edge
; 0003 00E4     // Timer3 Overflow Interrupt: On
; 0003 00E5     // Input Capture Interrupt: Off
; 0003 00E6     // Compare A Match Interrupt: Off
; 0003 00E7     // Compare B Match Interrupt: Off
; 0003 00E8     // Compare C Match Interrupt: Off
; 0003 00E9     TCCR3A=0x00;
	STS  144,R30
; 0003 00EA     TCCR3B=0x04;
	LDI  R30,LOW(4)
	STS  145,R30
; 0003 00EB     TCNT3H=0x85;
	CALL SUBOPT_0x1D
; 0003 00EC     TCNT3L=0xED;
; 0003 00ED     ICR3H=0x00;
	LDI  R30,LOW(0)
	STS  151,R30
; 0003 00EE     ICR3L=0x00;
	STS  150,R30
; 0003 00EF     OCR3AH=0x00;
	STS  153,R30
; 0003 00F0     OCR3AL=0x00;
	STS  152,R30
; 0003 00F1     OCR3BH=0x00;
	STS  155,R30
; 0003 00F2     OCR3BL=0x00;
	STS  154,R30
; 0003 00F3     OCR3CH=0x00;
	STS  157,R30
; 0003 00F4     OCR3CL=0x00;
	STS  156,R30
; 0003 00F5 
; 0003 00F6     // Timer/Counter 4 initialization
; 0003 00F7     // Clock source: System Clock
; 0003 00F8     // Clock value: 125.000 kHz
; 0003 00F9     // Mode: Normal top=0xFFFF
; 0003 00FA     // OC4A output: Discon.
; 0003 00FB     // OC4B output: Discon.
; 0003 00FC     // OC4C output: Discon.
; 0003 00FD     // Noise Canceler: Off
; 0003 00FE     // Input Capture on Falling Edge
; 0003 00FF     // Timer4 Overflow Interrupt: On
; 0003 0100     // Input Capture Interrupt: Off
; 0003 0101     // Compare A Match Interrupt: Off
; 0003 0102     // Compare B Match Interrupt: Off
; 0003 0103     // Compare C Match Interrupt: Off
; 0003 0104     TCCR4A=0x00;
	STS  160,R30
; 0003 0105     TCCR4B=0x03;
	LDI  R30,LOW(3)
	STS  161,R30
; 0003 0106     TCNT4H=0x85;
	CALL SUBOPT_0x1F
; 0003 0107     TCNT4L=0xED;
; 0003 0108     ICR4H=0x00;
	LDI  R30,LOW(0)
	STS  167,R30
; 0003 0109     ICR4L=0x00;
	STS  166,R30
; 0003 010A     OCR4AH=0x00;
	STS  169,R30
; 0003 010B     OCR4AL=0x00;
	STS  168,R30
; 0003 010C     OCR4BH=0x00;
	STS  171,R30
; 0003 010D     OCR4BL=0x00;
	STS  170,R30
; 0003 010E     OCR4CH=0x00;
	STS  173,R30
; 0003 010F     OCR4CL=0x00;
	STS  172,R30
; 0003 0110 
; 0003 0111     // Timer/Counter 5 initialization
; 0003 0112     // Clock source: System Clock
; 0003 0113     // Clock value: Timer5 Stopped
; 0003 0114     // Mode: Normal top=0xFFFF
; 0003 0115     // OC5A output: Discon.
; 0003 0116     // OC5B output: Discon.
; 0003 0117     // OC5C output: Discon.
; 0003 0118     // Noise Canceler: Off
; 0003 0119     // Input Capture on Falling Edge
; 0003 011A     // Timer5 Overflow Interrupt: Off
; 0003 011B     // Input Capture Interrupt: Off
; 0003 011C     // Compare A Match Interrupt: Off
; 0003 011D     // Compare B Match Interrupt: Off
; 0003 011E     // Compare C Match Interrupt: Off
; 0003 011F     TCCR5A=0x00;
	STS  288,R30
; 0003 0120     TCCR5B=0x00;
	STS  289,R30
; 0003 0121     TCNT5H=0x00;
	STS  293,R30
; 0003 0122     TCNT5L=0x00;
	STS  292,R30
; 0003 0123     ICR5H=0x00;
	STS  295,R30
; 0003 0124     ICR5L=0x00;
	STS  294,R30
; 0003 0125     OCR5AH=0x00;
	STS  297,R30
; 0003 0126     OCR5AL=0x00;
	STS  296,R30
; 0003 0127     OCR5BH=0x00;
	STS  299,R30
; 0003 0128     OCR5BL=0x00;
	STS  298,R30
; 0003 0129     OCR5CH=0x00;
	STS  301,R30
; 0003 012A     OCR5CL=0x00;
	STS  300,R30
; 0003 012B 
; 0003 012C     // Watchdog Timer initialization
; 0003 012D     // Watchdog Timer Prescaler: OSC/1024k
; 0003 012E     // Watchdog Timer interrupt: On
; 0003 012F     #pragma optsize-
; 0003 0130     #asm("wdr")
	wdr
; 0003 0131     WDTCSR=0x79;
	LDI  R30,LOW(121)
	STS  96,R30
; 0003 0132     WDTCSR=0x69;
	LDI  R30,LOW(105)
	STS  96,R30
; 0003 0133 
; 0003 0134     #ifdef _OPTIMIZE_SIZE_
; 0003 0135     #pragma optsize+
; 0003 0136     #endif
; 0003 0137 
; 0003 0138 
; 0003 0139     // Timer/Counter 0 Interrupt(s) initialization
; 0003 013A     TIMSK0=0x00;
	LDI  R30,LOW(0)
	STS  110,R30
; 0003 013B 
; 0003 013C     // Timer/Counter 1 Interrupt(s) initialization
; 0003 013D     TIMSK1=0x00;
	STS  111,R30
; 0003 013E 
; 0003 013F     // Timer/Counter 2 Interrupt(s) initialization
; 0003 0140     TIMSK2=0x00;
	STS  112,R30
; 0003 0141 
; 0003 0142     // Timer/Counter 3 Interrupt(s) initialization
; 0003 0143     TIMSK3=0x00;
	STS  113,R30
; 0003 0144 
; 0003 0145     // Timer/Counter 4 Interrupt(s) initialization
; 0003 0146     TIMSK4=0x00;
	STS  114,R30
; 0003 0147 
; 0003 0148     // Timer/Counter 5 Interrupt(s) initialization
; 0003 0149     TIMSK5=0x00;
	STS  115,R30
; 0003 014A }
	RET
;/*============================================================*/
;void enable_interrupt(int ch)
; 0003 014D {
_enable_interrupt:
; 0003 014E 
; 0003 014F     // -------------- enable timer ---------------  //
; 0003 0150 
; 0003 0151     switch(ch){
	CALL SUBOPT_0x20
;	ch -> Y+0
; 0003 0152         case 0: // Timer/Counter 0 Interrupt(s) initialization
	SBIW R30,0
	BREQ _0x6001C
; 0003 0153                 //TIMSK0=0x01;
; 0003 0154                 break;
; 0003 0155         case 1: // Timer/Counter 1 Interrupt(s) initialization
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x6001E
; 0003 0156                 TIMSK1=0x01;
	LDI  R30,LOW(1)
	STS  111,R30
; 0003 0157                 break;
	RJMP _0x6001C
; 0003 0158         case 2: // Timer/Counter 2 Interrupt(s) initialization
_0x6001E:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x6001F
; 0003 0159                 TIMSK2=0x01;
	LDI  R30,LOW(1)
	STS  112,R30
; 0003 015A                 break;
	RJMP _0x6001C
; 0003 015B         case 3: // Timer/Counter 3 Interrupt(s) initialization
_0x6001F:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x60020
; 0003 015C                 TIMSK3=0x01;
	LDI  R30,LOW(1)
	STS  113,R30
; 0003 015D                 break;
	RJMP _0x6001C
; 0003 015E         case 4: // Timer/Counter 4 Interrupt(s) initialization
_0x60020:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x6001C
; 0003 015F                 TIMSK4=0x01;
	LDI  R30,LOW(1)
	STS  114,R30
; 0003 0160                 break;
; 0003 0161     }
_0x6001C:
; 0003 0162     // Global enable interrupts
; 0003 0163     #asm("sei")
	sei
; 0003 0164 }
	ADIW R28,2
	RET
;/*============================================================*/
;void disable_interrupt(int ch)
; 0003 0167 {
; 0003 0168 
; 0003 0169     // -------------- enable timer ---------------  //
; 0003 016A 
; 0003 016B     switch(ch){
;	ch -> Y+0
; 0003 016C         case 0: // Timer/Counter 0 Interrupt(s) initialization
; 0003 016D                 //TIMSK0=0x00;
; 0003 016E                 break;
; 0003 016F         case 1: // Timer/Counter 1 Interrupt(s) initialization
; 0003 0170                 TIMSK1=0x00;
; 0003 0171                 break;
; 0003 0172         case 2: // Timer/Counter 2 Interrupt(s) initialization
; 0003 0173                 TIMSK2=0x00;
; 0003 0174                 break;
; 0003 0175         case 3: // Timer/Counter 3 Interrupt(s) initialization
; 0003 0176                 TIMSK3=0x00;
; 0003 0177                 break;
; 0003 0178         case 4: // Timer/Counter 4 Interrupt(s) initialization
; 0003 0179                 TIMSK4=0x00;
; 0003 017A                 break;
; 0003 017B     }
; 0003 017C     // Global enable interrupts
; 0003 017D     #asm("sei")
; 0003 017E }
;/*============================================================*/
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <delay.h>
;#include "io.h"
;#include "debug.h"
;
;//unsigned char   d_out[USE_DOUT] = {0xFF,0xFF};
;
;/*============================================================*/
;void init_io(void)
; 0004 000A {

	.CSEG
_init_io:
; 0004 000B     // Input/Output Ports initialization
; 0004 000C     // Port A initialization
; 0004 000D     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=Out Func1=In Func0=In
; 0004 000E     // State7=T State6=T State5=T State4=T State3=T State2=0 State1=T State0=T
; 0004 000F     PORTA=0x00;
	LDI  R30,LOW(0)
	OUT  0x2,R30
; 0004 0010     DDRA=0x04;
	LDI  R30,LOW(4)
	OUT  0x1,R30
; 0004 0011 
; 0004 0012     // Port B initialization
; 0004 0013     // Func7=Out Func6=Out Func5=Out Func4=Out Func3=In Func2=Out Func1=Out Func0=Out
; 0004 0014     // State7=1 State6=1 State5=1 State4=1 State3=P State2=1 State1=1 State0=1
; 0004 0015     PORTB=0xFF;
	LDI  R30,LOW(255)
	OUT  0x5,R30
; 0004 0016     DDRB=0xF7;
	LDI  R30,LOW(247)
	OUT  0x4,R30
; 0004 0017 
; 0004 0018     // Port C initialization
; 0004 0019     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 001A     // State7=P State6=P State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 001B     PORTC=0xC0;
	LDI  R30,LOW(192)
	OUT  0x8,R30
; 0004 001C     DDRC=0x00;
	LDI  R30,LOW(0)
	OUT  0x7,R30
; 0004 001D 
; 0004 001E     // Port C initialization
; 0004 001F     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0020     // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0021     //PORTC=0x80;
; 0004 0022     //DDRC=0x00;
; 0004 0023 
; 0004 0024     // Port D initialization
; 0004 0025     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0026     // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0027     PORTD=0x80;
	LDI  R30,LOW(128)
	OUT  0xB,R30
; 0004 0028     DDRD=0x00;
	LDI  R30,LOW(0)
	OUT  0xA,R30
; 0004 0029 
; 0004 002A     // Port E initialization
; 0004 002B     // Func7=Out Func6=Out Func5=Out Func4=Out Func3=Out Func2=Out Func1=In Func0=In
; 0004 002C     // State7=1 State6=1 State5=1 State4=1 State3=1 State2=P State1=T State0=T
; 0004 002D     PORTE=0xFC;
	LDI  R30,LOW(252)
	OUT  0xE,R30
; 0004 002E     DDRE=0xFC;
	OUT  0xD,R30
; 0004 002F 
; 0004 0030     // Port F initialization
; 0004 0031     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0032     // State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0033     PORTF=0x00;
	LDI  R30,LOW(0)
	OUT  0x11,R30
; 0004 0034     DDRF=0x00;
	OUT  0x10,R30
; 0004 0035 
; 0004 0036     // Port G initialization
; 0004 0037     // Func5=Out Func4=Out Func3=In Func2=In Func1=In Func0=In
; 0004 0038     // State5=1 State4=1 State3=T State2=T State1=T State0=T
; 0004 0039     //PORTG=0x20;
; 0004 003A     //DDRG=0x20;
; 0004 003B     PORTG=0x30;
	LDI  R30,LOW(48)
	OUT  0x14,R30
; 0004 003C     DDRG=0x30;
	OUT  0x13,R30
; 0004 003D 
; 0004 003E     // Port H initialization
; 0004 003F     // Func7=In Func6=Out Func5=Out Func4=Out Func3=Out Func2=In Func1=In Func0=In
; 0004 0040     // State7=P State6=1 State5=1 State4=1 State3=1 State2=T State1=T State0=T
; 0004 0041     PORTH=0xF8;
	LDI  R30,LOW(248)
	STS  258,R30
; 0004 0042     DDRH=0xF8;
	STS  257,R30
; 0004 0043 
; 0004 0044 //    // Port J initialization
; 0004 0045 //    // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0046 //    // State7=P State6=P State5=P State4=P State3=P State2=P State1=T State0=T
; 0004 0047 //    PORTJ=0xFC;
; 0004 0048 //    DDRJ=0x00;
; 0004 0049 
; 0004 004A     // Port J initialization
; 0004 004B     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 004C     // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 004D     PORTJ=0x80;
	LDI  R30,LOW(128)
	STS  261,R30
; 0004 004E     DDRJ=0x00;
	LDI  R30,LOW(0)
	STS  260,R30
; 0004 004F 
; 0004 0050     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
	CALL SUBOPT_0x21
	BREQ _0x80004
	CALL SUBOPT_0x21
	CPI  R30,LOW(0x3)
	BRNE _0x80003
_0x80004:
; 0004 0051         // Port K initialization
; 0004 0052         // Func7=In Func6=In Func5=In Func4=In Func3=Out Func2=Out Func1=Out Func0=In
; 0004 0053         // State7=P State6=T State5=T State4=P State3=0 State2=0 State1=0 State0=T
; 0004 0054         PORTK=0x90;
	LDI  R30,LOW(144)
	STS  264,R30
; 0004 0055         DDRK=0x0E;
	LDI  R30,LOW(14)
	RJMP _0x80032
; 0004 0056     }
; 0004 0057     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
_0x80003:
	CALL SUBOPT_0x22
	BREQ _0x80008
	CALL SUBOPT_0x21
	CPI  R30,LOW(0x2)
	BRNE _0x80007
_0x80008:
; 0004 0058         // Port K initialization
; 0004 0059         // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 005A         // State7=P State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 005B         PORTK=0x80;
	LDI  R30,LOW(128)
	STS  264,R30
; 0004 005C         DDRK=0x00;
	LDI  R30,LOW(0)
_0x80032:
	STS  263,R30
; 0004 005D     }
; 0004 005E 
; 0004 005F     // Port L initialization
; 0004 0060     // Func7=In Func6=In Func5=In Func4=In Func3=In Func2=In Func1=In Func0=In
; 0004 0061     // State7=T State6=T State5=T State4=T State3=T State2=T State1=T State0=T
; 0004 0062     PORTL=0x00;
_0x80007:
	LDI  R30,LOW(0)
	STS  267,R30
; 0004 0063     DDRL=0x00;
	STS  266,R30
; 0004 0064 
; 0004 0065 }
	RET
;/*============================================================*/
;void IO_dout(int ch, char state)
; 0004 0068 {
; 0004 0069 //    /*bongkot edit output is actived high(1)*/
; 0004 006A //    //triger state input function
; 0004 006B //    state = !state;
; 0004 006C //    /* end edit*/
; 0004 006D 
; 0004 006E //    switch(ch){
; 0004 006F //        case 0  :   DOUT1       =   !state;
; 0004 0070 //                    d_out[0]    =   state;
; 0004 0071 //                    //printDebug("<IO_dout> dout0 %d\r\n",d_out[0]);
; 0004 0072 //                    break;
; 0004 0073 //        case 1  :   DOUT2       =   !state;
; 0004 0074 //                    d_out[1]    =   state;
; 0004 0075 //                    //printDebug("<IO_dout> dout1 %d\r\n",d_out[1]);
; 0004 0076 //                    break;
; 0004 0077 //        default :   break;
; 0004 0078 //    }
; 0004 0079 }
;/*============================================================*/
;char IO_keyCheck(void)
; 0004 007C {
; 0004 007D     static char flag_hold_MODE   = 0;
; 0004 007E     static char flag_hold_UP     = 0;
; 0004 007F     static char flag_hold_DOWN   = 0;
; 0004 0080     static char flag_hold_OK     = 0;
; 0004 0081 
; 0004 0082     if( KEY_PRESS_CHK_MODE && !flag_hold_MODE )
; 0004 0083     {
; 0004 0084         delay_ms(KEY_DELAY);
; 0004 0085 
; 0004 0086         if( KEY_PRESS_CHK_MODE && !flag_hold_MODE )
; 0004 0087         {
; 0004 0088             flag_hold_MODE = 1;
; 0004 0089             return 0;
; 0004 008A         }
; 0004 008B     }
; 0004 008C     else if( KEY_RELEASE_CHK_MODE && flag_hold_MODE)
; 0004 008D     {
; 0004 008E         printDebug("<IO_keyCheck> key MODE\r\n");
; 0004 008F         flag_hold_MODE = 0;
; 0004 0090         return KEY_MODE;
; 0004 0091     }
; 0004 0092 
; 0004 0093     if( KEY_PRESS_CHK_UP && !flag_hold_UP )
; 0004 0094     {
; 0004 0095         delay_ms(KEY_DELAY);
; 0004 0096 
; 0004 0097         if( KEY_PRESS_CHK_UP && !flag_hold_UP )
; 0004 0098         {
; 0004 0099             flag_hold_UP = 1;
; 0004 009A             return 0;
; 0004 009B         }
; 0004 009C     }
; 0004 009D     else if( KEY_RELEASE_CHK_UP && flag_hold_UP)
; 0004 009E     {
; 0004 009F         printDebug("<IO_keyCheck> key UP\r\n");
; 0004 00A0         flag_hold_UP = 0;
; 0004 00A1         return KEY_UP;
; 0004 00A2     }
; 0004 00A3 
; 0004 00A4     if( KEY_PRESS_CHK_DOWN && !flag_hold_DOWN )
; 0004 00A5     {
; 0004 00A6         delay_ms(KEY_DELAY);
; 0004 00A7 
; 0004 00A8         if( KEY_PRESS_CHK_DOWN && !flag_hold_DOWN )
; 0004 00A9         {
; 0004 00AA             flag_hold_DOWN = 1;
; 0004 00AB             return 0;
; 0004 00AC         }
; 0004 00AD     }
; 0004 00AE     else if( KEY_RELEASE_CHK_DOWN && flag_hold_DOWN)
; 0004 00AF     {
; 0004 00B0         printDebug("<IO_keyCheck> key DOWN\r\n");
; 0004 00B1         flag_hold_DOWN = 0;
; 0004 00B2         return KEY_DOWN;
; 0004 00B3     }
; 0004 00B4 
; 0004 00B5     if( KEY_PRESS_CHK_OK && !flag_hold_OK )
; 0004 00B6     {
; 0004 00B7         delay_ms(KEY_DELAY);
; 0004 00B8 
; 0004 00B9         if( KEY_PRESS_CHK_OK && !flag_hold_OK )
; 0004 00BA         {
; 0004 00BB             flag_hold_OK = 1;
; 0004 00BC             return 0;
; 0004 00BD         }
; 0004 00BE     }
; 0004 00BF     else if( KEY_RELEASE_CHK_OK && flag_hold_OK)
; 0004 00C0     {
; 0004 00C1         printDebug("<IO_keyCheck> key OK\r\n");
; 0004 00C2         flag_hold_OK = 0;
; 0004 00C3         return KEY_OK;
; 0004 00C4     }
; 0004 00C5 
; 0004 00C6     return 0;
; 0004 00C7 }
;
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <delay.h>
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "adc.h"
;#include "debug.h"
;
;float           adcData[5];
;float           adcBatt;
;
;eeprom float    eep_vref_val = 2.56;
;
;/*============================================================*/
;unsigned int read_adc(unsigned char adc_input)
; 0005 0010 {

	.CSEG
_read_adc:
; 0005 0011     unsigned int adc_data = 0x0000;
; 0005 0012 
; 0005 0013     ADMUX  &= ADC_VREF_TYPE;
	ST   -Y,R26
	ST   -Y,R17
	ST   -Y,R16
;	adc_input -> Y+2
;	adc_data -> R16,R17
	__GETWRN 16,17,0
	LDS  R30,124
	ANDI R30,LOW(0x40)
	STS  124,R30
; 0005 0014     ADCSRB &= 0xf7;
	LDS  R30,123
	ANDI R30,0XF7
	STS  123,R30
; 0005 0015 
; 0005 0016     ADMUX  |= (adc_input & 0x07) | (ADC_VREF_TYPE & 0xff);
	LDI  R26,LOW(124)
	LDI  R27,HIGH(124)
	MOV  R0,R26
	LD   R26,X
	LDD  R30,Y+2
	ANDI R30,LOW(0x7)
	ORI  R30,0x40
	OR   R30,R26
	MOV  R26,R0
	ST   X,R30
; 0005 0017 
; 0005 0018     if(adc_input > 7)
	LDD  R26,Y+2
	CPI  R26,LOW(0x8)
	BRLO _0xA0003
; 0005 0019     {
; 0005 001A         ADCSRB |= 0x08;
	LDS  R30,123
	ORI  R30,8
	RJMP _0xA0020
; 0005 001B     }
; 0005 001C     else
_0xA0003:
; 0005 001D     {
; 0005 001E         ADCSRB &= 0xf7;
	LDS  R30,123
	ANDI R30,0XF7
_0xA0020:
	STS  123,R30
; 0005 001F     }
; 0005 0020 
; 0005 0021     // Delay needed for the stabilization of the ADC input voltage
; 0005 0022     delay_us(20);
	__DELAY_USB 53
; 0005 0023 
; 0005 0024     // Start the AD conversion
; 0005 0025     ADCSRA  |= 0x80; //ENABLE ADC
	LDS  R30,122
	ORI  R30,0x80
	STS  122,R30
; 0005 0026     ADCSRA  |= 0x40;
	LDS  R30,122
	ORI  R30,0x40
	STS  122,R30
; 0005 0027 
; 0005 0028     // Wait for the AD conversion to complete
; 0005 0029     //while ( ((ADCSRA & 0x10)==0) || ((ADCSRA & 0x40) == 0x40));
; 0005 002A     while ( (ADCSRA & 0x10)==0);
_0xA0005:
	LDS  R30,122
	ANDI R30,LOW(0x10)
	BREQ _0xA0005
; 0005 002B     adc_data = ADCL;
	LDS  R16,120
	CLR  R17
; 0005 002C     adc_data |= (ADCH & 0x00ff) << 8;
	LDS  R30,121
	LDI  R31,0
	ANDI R31,HIGH(0xFF)
	MOV  R31,R30
	LDI  R30,0
	__ORWRR 16,17,30,31
; 0005 002D 
; 0005 002E     ADCSRA  |=0x10;
	LDS  R30,122
	ORI  R30,0x10
	STS  122,R30
; 0005 002F 
; 0005 0030     delay_us(50);
	__DELAY_USB 133
; 0005 0031 
; 0005 0032     return adc_data;
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,3
	RET
; 0005 0033 }
;/*============================================================*/
;unsigned char adc_sampling(void)
; 0005 0036 {
; 0005 0037     static int      i = 0;
; 0005 0038     static char     batt_read_flag = 0;
; 0005 0039 
; 0005 003A     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
; 0005 003B         /*
; 0005 003C         printDebug("<%d>",i);
; 0005 003D         SENSOR_SELECT(i);
; 0005 003E         delay_ms(20);
; 0005 003F         adcData[i] = (float)((adcData[i] * 9.0) + (float)(read_adc(8) * 1.0))/10;           // Temp Sensor Low-Pass Filter
; 0005 0040         if(++i >= 5){   i = 0;  }
; 0005 0041         */
; 0005 0042     }
; 0005 0043     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
; 0005 0044 //        for( i=0 ; i<5 ; i++ ){
; 0005 0045 //            adcData[i] = (float)((adcData[i] * 9.9) + (float)(read_adc(8+i) * 0.1))/10;     // Temp Sensor Low-Pass Filter
; 0005 0046 //        }
; 0005 0047     }
; 0005 0048 
; 0005 0049 //    if(++batt_read_flag > 25){
; 0005 004A //        adcBatt = (float)((adcBatt * 9.9) + (float)(read_adc(14) * 0.1))/10;                // Battery Read
; 0005 004B //        batt_read_flag = 0;
; 0005 004C //    }
; 0005 004D 
; 0005 004E     return 0;
; 0005 004F }
;/*============================================================*/
;float readBattery(void)
; 0005 0052 {
; 0005 0053     float   vBATT;
; 0005 0054 
; 0005 0055     adcBatt = (float)((adcBatt * 9.9) + (float)(read_adc(14) * 0.1))/10;                // Battery Read
;	vBATT -> Y+0
; 0005 0056 
; 0005 0057     vBATT   = adcBatt*ADC_CONV_FAC*1.8;                                // from voltage divider 120k & 150k
; 0005 0058     //printDebug("                                                     -- volt[%f]\r\n", vBATT);    // padding line
; 0005 0059 
; 0005 005A     return vBATT;
; 0005 005B }
;/*============================================================*/
;void adc_init_read(void)
; 0005 005E {
_adc_init_read:
; 0005 005F     int i;
; 0005 0060     printDebug("Initializing ADC.. ");
	ST   -Y,R17
	ST   -Y,R16
;	i -> R16,R17
	__POINTD1FN _0xA0000,0
	CALL SUBOPT_0x0
; 0005 0061 
; 0005 0062     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
	CALL SUBOPT_0x21
	BREQ _0xA0010
	CALL SUBOPT_0x21
	CPI  R30,LOW(0x3)
	BRNE _0xA000F
_0xA0010:
; 0005 0063         for(i=0;i<5;i++){ \
; 0005 0064             SENSOR_SELECT(i);
	__GETWRN 16,17,0
_0xA0013:
	__CPWRN 16,17,5
	BRGE _0xA0014
	LDS  R30,264
	ANDI R30,LOW(0xF1)
	STS  264,R30
	LDI  R26,LOW(264)
	LDI  R27,HIGH(264)
	MOV  R0,R26
	LD   R26,X
	MOV  R30,R16
	LSL  R30
	OR   R30,R26
	MOV  R26,R0
	ST   X,R30
; 0005 0065             delay_ms(20);
	LDI  R26,LOW(20)
	LDI  R27,0
	CALL _delay_ms
; 0005 0066             adcData[i] = read_adc(8);
	MOVW R30,R16
	LDI  R26,LOW(_adcData)
	LDI  R27,HIGH(_adcData)
	CALL __LSLW2
	ADD  R30,R26
	ADC  R31,R27
	PUSH R31
	PUSH R30
	LDI  R26,LOW(8)
	RCALL _read_adc
	POP  R26
	POP  R27
	CALL SUBOPT_0x23
; 0005 0067         }
	__ADDWRN 16,17,1
	RJMP _0xA0013
_0xA0014:
; 0005 0068     }
; 0005 0069     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
	RJMP _0xA0015
_0xA000F:
	CALL SUBOPT_0x22
	BREQ _0xA0017
	CALL SUBOPT_0x21
	CPI  R30,LOW(0x2)
	BRNE _0xA0016
_0xA0017:
; 0005 006A         adcData[0] = read_adc(8);
	LDI  R26,LOW(8)
	RCALL _read_adc
	LDI  R26,LOW(_adcData)
	LDI  R27,HIGH(_adcData)
	CALL SUBOPT_0x23
; 0005 006B         adcData[1] = read_adc(9);
	LDI  R26,LOW(9)
	RCALL _read_adc
	__POINTW2MN _adcData,4
	CALL SUBOPT_0x23
; 0005 006C         adcData[2] = read_adc(10);
	LDI  R26,LOW(10)
	RCALL _read_adc
	__POINTW2MN _adcData,8
	CALL SUBOPT_0x23
; 0005 006D         adcData[3] = read_adc(11);
	LDI  R26,LOW(11)
	RCALL _read_adc
	__POINTW2MN _adcData,12
	CALL SUBOPT_0x23
; 0005 006E         adcData[4] = read_adc(12);
	LDI  R26,LOW(12)
	RCALL _read_adc
	__POINTW2MN _adcData,16
	CALL SUBOPT_0x23
; 0005 006F     }
; 0005 0070 
; 0005 0071     adcBatt = read_adc(14);
_0xA0016:
_0xA0015:
	LDI  R26,LOW(14)
	RCALL _read_adc
	LDI  R26,LOW(_adcBatt)
	LDI  R27,HIGH(_adcBatt)
	CALL SUBOPT_0x23
; 0005 0072 
; 0005 0073     printDebug("OK\r\n");
	__POINTD1FN _0xA0000,20
	CALL SUBOPT_0x0
; 0005 0074 }
	JMP  _0x20E0033
;/*============================================================*/
;void init_adc(void)
; 0005 0077 {
_init_adc:
; 0005 0078     // ADC initialization
; 0005 0079     // ADC Clock frequency: 1000.000 kHz
; 0005 007A     // ADC Voltage Reference: 2.56V, cap. on AREF
; 0005 007B     // ADC Auto Trigger Source: Free Running
; 0005 007C     // Digital input buffers on ADC0: On, ADC1: On, ADC2: On, ADC3: On
; 0005 007D     // ADC4: On, ADC5: On, ADC6: On, ADC7: On
; 0005 007E     DIDR0=0x00;
	LDI  R30,LOW(0)
	STS  126,R30
; 0005 007F 
; 0005 0080 
; 0005 0081     if((TEMP_SEL == TEMP_TYPE_K) || (TEMP_SEL == TEMP_RESERVED)){
	CALL SUBOPT_0x21
	BREQ _0xA001A
	CALL SUBOPT_0x21
	CPI  R30,LOW(0x3)
	BRNE _0xA0019
_0xA001A:
; 0005 0082         // Digital input buffers on ADC8: Off, ADC9: On, ADC10: On, ADC11: On
; 0005 0083         // ADC12: On, ADC13: Off, ADC14: Off, ADC15: On
; 0005 0084         DIDR2=0x61;
	LDI  R30,LOW(97)
	RJMP _0xA0021
; 0005 0085     }
; 0005 0086     else if((TEMP_SEL == TEMP_TMEC) || (TEMP_SEL == TEMP_PT100)){
_0xA0019:
	CALL SUBOPT_0x22
	BREQ _0xA001E
	CALL SUBOPT_0x21
	CPI  R30,LOW(0x2)
	BRNE _0xA001D
_0xA001E:
; 0005 0087         // Digital input buffers on ADC8: Off, ADC9: Off, ADC10: Off, ADC11: Off
; 0005 0088         // ADC12: Off, ADC13: Off, ADC14: Off, ADC15: On
; 0005 0089         DIDR2=0x7F;
	LDI  R30,LOW(127)
_0xA0021:
	STS  125,R30
; 0005 008A     }
; 0005 008B 
; 0005 008C     ADMUX   = ADC_VREF_TYPE;
_0xA001D:
	LDI  R30,LOW(64)
	STS  124,R30
; 0005 008D     ADCSRA  = (1<<7) |          // ADEN:    ADC enable
; 0005 008E               (0<<6) |          // ADSC:    ADC Start Conversion
; 0005 008F               (0<<5) |          // ADATE:   ADC Auto Trigger Enable
; 0005 0090               (0<<4) |          // ADIF:    ADC Interrupt Flag
; 0005 0091               (0<<3) |          // ADIE:    ADC Interrupt
; 0005 0092               (1<<2) |          //-----
; 0005 0093               (1<<1) |          //- ADPS2-0: ADC Prescaler Select Bits      (011 = clk/8) (110 = clk/64)
; 0005 0094               (0<<0);           //-----
	LDI  R30,LOW(134)
	STS  122,R30
; 0005 0095 
; 0005 0096     ADCSRB  = 0;
	LDI  R30,LOW(0)
	STS  123,R30
; 0005 0097 
; 0005 0098     //adc_init_read();
; 0005 0099 }
	RET
;/*============================================================*/
;#include <i2c.h>
;#include <delay.h>
;#include <string.h>
;#include <stdlib.h>
;#include <stdio.h>
;#include "ds1672.h"
;
;/*============================================================*/
;unsigned long raw_rtc;
;/*============================================================*/
;int DS1672_trickerChargeEnable(void) /* ----- enable the trickle-charger ------ */
; 0006 000C {

	.CSEG
_DS1672_trickerChargeEnable:
; 0006 000D     #asm("cli")
	cli
; 0006 000E     i2c_start();
	CALL SUBOPT_0x24
; 0006 000F     i2c_write(ADDRTC);
; 0006 0010     i2c_write(5);
	LDI  R26,LOW(5)
	CALL _i2c_write
; 0006 0011     i2c_write(0xA6);            /* enable the trickle-charger : No diode, 2k ohm resistor */
	LDI  R26,LOW(166)
	CALL _i2c_write
; 0006 0012     i2c_stop();
	CALL _i2c_stop
; 0006 0013     #asm("sei")
	sei
; 0006 0014 
; 0006 0015     /* 10ms delay to complete the write operation */
; 0006 0016     delay_ms(10);
	LDI  R26,LOW(10)
	LDI  R27,0
	CALL _delay_ms
; 0006 0017 
; 0006 0018     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RET
; 0006 0019 }
;/*============================================================*/
;unsigned long int DS1672_read(void)
; 0006 001C {
_DS1672_read:
; 0006 001D     unsigned long int z;
; 0006 001E     unsigned char rtc_reg1, rtc_reg2, rtc_reg3, rtc_reg4;
; 0006 001F 
; 0006 0020     #asm("cli")
	SBIW R28,4
	CALL __SAVELOCR4
;	z -> Y+4
;	rtc_reg1 -> R17
;	rtc_reg2 -> R16
;	rtc_reg3 -> R19
;	rtc_reg4 -> R18
	cli
; 0006 0021     i2c_start();
	CALL SUBOPT_0x24
; 0006 0022     i2c_write(ADDRTC);                      /* write slave address, write 1672 */
; 0006 0023     i2c_write(0x00);                        /* write register address, 1st clock register */
	LDI  R26,LOW(0)
	CALL _i2c_write
; 0006 0024     i2c_start();
	CALL _i2c_start
; 0006 0025     i2c_write(ADDRTC | 1);                  /* write slave address, read 1672 */
	LDI  R26,LOW(209)
	CALL _i2c_write
; 0006 0026     rtc_reg1 = i2c_read(ACK);                 /* starts w/last address stored in register pointer */
	LDI  R26,LOW(1)
	CALL _i2c_read
	MOV  R17,R30
; 0006 0027     rtc_reg2 = i2c_read(ACK);
	LDI  R26,LOW(1)
	CALL _i2c_read
	MOV  R16,R30
; 0006 0028     rtc_reg3 = i2c_read(ACK);
	LDI  R26,LOW(1)
	CALL _i2c_read
	MOV  R19,R30
; 0006 0029     rtc_reg4 = i2c_read(NACK);
	LDI  R26,LOW(0)
	CALL _i2c_read
	MOV  R18,R30
; 0006 002A     i2c_stop();
	CALL _i2c_stop
; 0006 002B     #asm("sei")
	sei
; 0006 002C 
; 0006 002D     z = rtc_reg4;
	MOV  R30,R18
	CLR  R31
	CLR  R22
	CLR  R23
	CALL SUBOPT_0x25
; 0006 002E     z <<= 8;
	CALL SUBOPT_0x26
	CALL SUBOPT_0x27
; 0006 002F     z += rtc_reg3;
	CALL SUBOPT_0x28
	CALL SUBOPT_0x29
; 0006 0030     z <<= 8;
; 0006 0031     z += rtc_reg2;
	CALL SUBOPT_0x2A
	CALL SUBOPT_0x29
; 0006 0032     z <<= 8;
; 0006 0033     z += rtc_reg1;
	CALL SUBOPT_0x2B
	CALL SUBOPT_0x26
	CALL SUBOPT_0x2C
	CALL SUBOPT_0x2D
; 0006 0034 
; 0006 0035     //printDebug("\r\nDS1672_read -> 0x%02X%02X%02X%02X\r\n",rtc_reg4,rtc_reg3,rtc_reg2,rtc_reg1);
; 0006 0036     //printDebug("rawtime [%ld]\r\n", z);
; 0006 0037 
; 0006 0038     return z;
	CALL __LOADLOCR4
	ADIW R28,8
	RET
; 0006 0039 }
;/*============================================================*/
;int binary_to_date(unsigned long x, struct rtc_structure *rtcCov) /* ------ convert binary time to date format ------ */
; 0006 003C {
_binary_to_date:
; 0006 003D     unsigned long yrs = 99, mon = 99, day = 99, tmp, jday, hrs, min, sec;
; 0006 003E     unsigned long j, n;
; 0006 003F     unsigned int dow;     // day of week
; 0006 0040 
; 0006 0041     j = x / 60;                             /* whole minutes since 1/1/70 */
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,40
	LDI  R24,12
	LDI  R26,LOW(28)
	LDI  R27,HIGH(28)
	LDI  R30,LOW(_0xC0003*2)
	LDI  R31,HIGH(_0xC0003*2)
	LDI  R22,BYTE3(_0xC0003*2)
	CALL __INITLOCB
	ST   -Y,R17
	ST   -Y,R16
;	x -> Y+44
;	*rtcCov -> Y+42
;	yrs -> Y+38
;	mon -> Y+34
;	day -> Y+30
;	tmp -> Y+26
;	jday -> Y+22
;	hrs -> Y+18
;	min -> Y+14
;	sec -> Y+10
;	j -> Y+6
;	n -> Y+2
;	dow -> R16,R17
	__GETD2S 44
	CALL SUBOPT_0x2E
	CALL SUBOPT_0x2F
; 0006 0042     sec = x - (60 * j);                     /* leftover seconds */
	CALL SUBOPT_0x30
	__GETD2S 44
	CALL __SUBD21
	__PUTD2S 10
; 0006 0043     n = j / 60;
	CALL SUBOPT_0x31
	CALL SUBOPT_0x2E
	CALL SUBOPT_0x32
; 0006 0044     min = j - (60 * n);
	CALL SUBOPT_0x33
	CALL SUBOPT_0x30
	CALL SUBOPT_0x31
	CALL __SUBD21
	__PUTD2S 14
; 0006 0045     j = n / 24;
	CALL SUBOPT_0x34
	__GETD1N 0x18
	CALL __DIVD21U
	CALL SUBOPT_0x2F
; 0006 0046     hrs = n - (24 * j);
	__GETD2N 0x18
	CALL __MULD12U
	CALL SUBOPT_0x34
	CALL __SUBD21
	__PUTD2S 18
; 0006 0047     j = j + (365 + 366);                    /* whole days since 1/1/68 */
	CALL SUBOPT_0x35
	__ADDD1N 731
	CALL SUBOPT_0x36
; 0006 0048 
; 0006 0049     dow = (j % 7)+1;                        /* since 1/1/68 is Monday */
	CALL SUBOPT_0x31
	__GETD1N 0x7
	CALL __MODD21U
	ADIW R30,1
	MOVW R16,R30
; 0006 004A                                             /* 1-7 => Sun - Sat */
; 0006 004B     day = j / ((4 * 365) + 1);
	CALL SUBOPT_0x37
	CALL __DIVD21U
	CALL SUBOPT_0x38
; 0006 004C     tmp = j % ((4 * 365) + 1);
	CALL SUBOPT_0x37
	CALL __MODD21U
	__PUTD1S 26
; 0006 004D     if(tmp >= (31 + 29))                    /* if past 2/29 */
	CALL SUBOPT_0x39
	CALL SUBOPT_0x3A
	BRLO _0xC0004
; 0006 004E     day++;                                  /* add a leap day */
	__GETD1S 30
	CALL SUBOPT_0x3B
	CALL SUBOPT_0x38
; 0006 004F     yrs = (j - day) / 365;                  /* whole years since 1968 */
_0xC0004:
	__GETD2S 30
	CALL SUBOPT_0x35
	CALL __SUBD12
	MOVW R26,R30
	MOVW R24,R22
	__GETD1N 0x16D
	CALL __DIVD21U
	__PUTD1S 38
; 0006 0050     jday = j - (yrs * 365) - day;           /* days since 1/1 of current year */
	CALL SUBOPT_0x3C
	__GETD2N 0x16D
	CALL __MULD12U
	CALL SUBOPT_0x31
	CALL SUBOPT_0x3D
	__GETD2S 30
	CALL __SUBD12
	CALL SUBOPT_0x3E
; 0006 0051     if(tmp <= 365 && tmp >= 60)             /* if past 2/29 and a leap year then */
	CALL SUBOPT_0x39
	__CPD2N 0x16E
	BRSH _0xC0006
	CALL SUBOPT_0x39
	CALL SUBOPT_0x3A
	BRSH _0xC0007
_0xC0006:
	RJMP _0xC0005
_0xC0007:
; 0006 0052     jday++;                                 /* add a leap day */
	__GETD1S 22
	CALL SUBOPT_0x3B
	CALL SUBOPT_0x3E
; 0006 0053     yrs += 1968;                            /* calculate year */
_0xC0005:
	CALL SUBOPT_0x3C
	__ADDD1N 1968
	__PUTD1S 38
; 0006 0054     for(mon = 12; mon > 0; mon--)
	__GETD1N 0xC
	__PUTD1S 34
_0xC0009:
	__GETD2S 34
	CALL __CPD02
	BRLO PC+3
	JMP _0xC000A
; 0006 0055     {
; 0006 0056         switch(mon)
	CALL SUBOPT_0x3F
; 0006 0057         {
; 0006 0058             case 1:     tmp = 0;
	__CPD1N 0x1
	BRNE _0xC000E
	LDI  R30,LOW(0)
	__CLRD1S 26
; 0006 0059                         break;
	RJMP _0xC000D
; 0006 005A             case 2:     tmp = 31;
_0xC000E:
	__CPD1N 0x2
	BRNE _0xC000F
	__GETD1N 0x1F
	RJMP _0xC004D
; 0006 005B                         break;
; 0006 005C             case 3:     tmp = 59;
_0xC000F:
	__CPD1N 0x3
	BRNE _0xC0010
	__GETD1N 0x3B
	RJMP _0xC004D
; 0006 005D                         break;
; 0006 005E             case 4:     tmp = 90;
_0xC0010:
	__CPD1N 0x4
	BRNE _0xC0011
	__GETD1N 0x5A
	RJMP _0xC004D
; 0006 005F                         break;
; 0006 0060             case 5:     tmp = 120;
_0xC0011:
	__CPD1N 0x5
	BRNE _0xC0012
	__GETD1N 0x78
	RJMP _0xC004D
; 0006 0061                         break;
; 0006 0062             case 6:     tmp = 151;
_0xC0012:
	__CPD1N 0x6
	BRNE _0xC0013
	__GETD1N 0x97
	RJMP _0xC004D
; 0006 0063                         break;
; 0006 0064             case 7:     tmp = 181;
_0xC0013:
	__CPD1N 0x7
	BRNE _0xC0014
	__GETD1N 0xB5
	RJMP _0xC004D
; 0006 0065                         break;
; 0006 0066             case 8:     tmp = 212;
_0xC0014:
	__CPD1N 0x8
	BRNE _0xC0015
	__GETD1N 0xD4
	RJMP _0xC004D
; 0006 0067                         break;
; 0006 0068             case 9:     tmp = 243;
_0xC0015:
	__CPD1N 0x9
	BRNE _0xC0016
	__GETD1N 0xF3
	RJMP _0xC004D
; 0006 0069                         break;
; 0006 006A             case 10:    tmp = 273;
_0xC0016:
	__CPD1N 0xA
	BRNE _0xC0017
	__GETD1N 0x111
	RJMP _0xC004D
; 0006 006B                         break;
; 0006 006C             case 11:    tmp = 304;
_0xC0017:
	__CPD1N 0xB
	BRNE _0xC0018
	__GETD1N 0x130
	RJMP _0xC004D
; 0006 006D                         break;
; 0006 006E             case 12:    tmp = 334;
_0xC0018:
	__CPD1N 0xC
	BRNE _0xC000D
	__GETD1N 0x14E
_0xC004D:
	__PUTD1S 26
; 0006 006F                         break;
; 0006 0070         }
_0xC000D:
; 0006 0071         if((mon > 2) && !(yrs % 4))         /* adjust for leap year */
	__GETD2S 34
	__CPD2N 0x3
	BRLO _0xC001B
	CALL SUBOPT_0x3C
	ANDI R30,LOW(0x3)
	BREQ _0xC001C
_0xC001B:
	RJMP _0xC001A
_0xC001C:
; 0006 0072         tmp++;
	__GETD1S 26
	CALL SUBOPT_0x3B
	__PUTD1S 26
; 0006 0073         if(jday >= tmp) break;
_0xC001A:
	__GETD1S 26
	CALL SUBOPT_0x40
	CALL __CPD21
	BRSH _0xC000A
; 0006 0074     }
	CALL SUBOPT_0x3F
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	__PUTD1S 34
	RJMP _0xC0009
_0xC000A:
; 0006 0075     day = jday - tmp + 1;                   /* calculate day in month */
	CALL SUBOPT_0x39
	__GETD1S 22
	CALL __SUBD12
	CALL SUBOPT_0x41
	CALL SUBOPT_0x38
; 0006 0076 
; 0006 0077     rtcCov->year    = yrs;
	CALL SUBOPT_0x3C
	LDD  R26,Y+42
	LDD  R27,Y+42+1
	CALL __PUTDP1
; 0006 0078     rtcCov->month   = mon;
	CALL SUBOPT_0x3F
	__PUTD1SNS 42,4
; 0006 0079     rtcCov->date    = day;
	__GETD1S 30
	__PUTD1SNS 42,8
; 0006 007A     rtcCov->hour    = hrs;
	CALL SUBOPT_0x42
	__PUTD1SNS 42,12
; 0006 007B     rtcCov->min     = min;
	CALL SUBOPT_0x43
	__PUTD1SNS 42,16
; 0006 007C     rtcCov->sec     = sec;
	CALL SUBOPT_0x44
	__PUTD1SNS 42,20
; 0006 007D     rtcCov->day     = dow;
	MOVW R30,R16
	__PUTW1SNS 42,24
; 0006 007E 
; 0006 007F     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,48
	RET
; 0006 0080 }
;/*============================================================*/
;unsigned long int date_to_binary(struct rtc_structure rtcSrc)
; 0006 0083 {
; 0006 0084     /* ---- convert date to elapsed days in binary ---- */
; 0006 0085     unsigned long x;                                        // total second
; 0006 0086 
; 0006 0087     /* the following is broken down for clarity */
; 0006 0088     x = (unsigned long)365 * (rtcSrc.year - 1970);          /* calculate number of days for previous years */
;	rtcSrc -> Y+4
;	x -> Y+0
; 0006 0089     x += ((rtcSrc.year - 1969) >> 2);                       /* add a day for each leap year */
; 0006 008A     if((rtcSrc.month > 2) && (rtcSrc.year % 4 == 0))        /* add a day if current year is leap and past Feb 29th */
; 0006 008B         x++;
; 0006 008C 
; 0006 008D     switch(rtcSrc.month)
; 0006 008E     {
; 0006 008F         case 1:     x += 0;
; 0006 0090                     break;
; 0006 0091         case 2:     x += 31;
; 0006 0092                     break;
; 0006 0093         case 3:     x += 59;
; 0006 0094                     break;
; 0006 0095         case 4:     x += 90;
; 0006 0096                     break;
; 0006 0097         case 5:     x += 120;
; 0006 0098                     break;
; 0006 0099         case 6:     x += 151;
; 0006 009A                     break;
; 0006 009B         case 7:     x += 181;
; 0006 009C                     break;
; 0006 009D         case 8:     x += 212;
; 0006 009E                     break;
; 0006 009F         case 9:     x += 243;
; 0006 00A0                     break;
; 0006 00A1         case 10:    x += 273;
; 0006 00A2                     break;
; 0006 00A3         case 11:    x += 304;
; 0006 00A4                     break;
; 0006 00A5         case 12:    x += 334;
; 0006 00A6                     break;
; 0006 00A7     }
; 0006 00A8 
; 0006 00A9     x += rtcSrc.date - 1;                       /* finally, add the days into the current month */
; 0006 00AA     x = x * 86400;                              /* and calculate the number of seconds in all those days (1 day = 86400 second)*/
; 0006 00AB     x += (unsigned long)rtcSrc.hour * 1800;     /* add the number of seconds in the hours */
; 0006 00AC     x += (unsigned long)rtcSrc.hour * 1800;     /* add the number of seconds in the hours */
; 0006 00AD     x += (unsigned long)rtcSrc.min * 60;        /* ditto the minutes */
; 0006 00AE     x += rtcSrc.sec;                            /* finally, the seconds */
; 0006 00AF 
; 0006 00B0     return(x);
; 0006 00B1 }
;/*============================================================*/
;int RTC_setBinary(unsigned long int rtc_bin)
; 0006 00B4 {
; 0006 00B5     unsigned long int rtc_current;
; 0006 00B6     unsigned long int rtc_diff;
; 0006 00B7     unsigned char a, b, c, d;
; 0006 00B8 
; 0006 00B9     rtc_current = DS1672_read();
;	rtc_bin -> Y+12
;	rtc_current -> Y+8
;	rtc_diff -> Y+4
;	a -> R17
;	b -> R16
;	c -> R19
;	d -> R18
; 0006 00BA 
; 0006 00BB     if(rtc_current > rtc_bin){
; 0006 00BC         rtc_diff = (unsigned long int) (rtc_current - rtc_bin);
; 0006 00BD     }
; 0006 00BE     else if(rtc_bin > rtc_current){
; 0006 00BF         rtc_diff = (unsigned long int) (rtc_bin - rtc_current);
; 0006 00C0     }
; 0006 00C1     else{
; 0006 00C2         // set value and current value are equal
; 0006 00C3         //printDebug("\r\nset time and current time are equal\r\n");
; 0006 00C4         rtc_diff = 0;
; 0006 00C5     }
; 0006 00C6 
; 0006 00C7     if((rtc_diff >= 0) && (rtc_diff < 10)){
; 0006 00C8         //printDebug("\r\nset time is too close to current time, not set!!!\r\n");
; 0006 00C9         //printDebug("\r\nset time is too close to current time, not set!!! c[%ld] s[%ld]\r\n", rtc_current, rtc_bin);
; 0006 00CA         return -1;
; 0006 00CB     }
; 0006 00CC 
; 0006 00CD     printDebug("c_time[%ld] & s_time[%ld] => diff[%ld]\r\n",rtc_current,rtc_bin,rtc_diff);
; 0006 00CE 
; 0006 00CF     a = (rtc_bin & 0xff);
; 0006 00D0     b = ((rtc_bin >> 8) & 0xff);
; 0006 00D1     c = ((rtc_bin >> 16) & 0xff);
; 0006 00D2     d = ((rtc_bin >> 24) & 0xff);
; 0006 00D3 
; 0006 00D4     #asm("cli")
; 0006 00D5     i2c_start();
; 0006 00D6     i2c_write(ADDRTC);          /* write slave address, write 1672 */
; 0006 00D7     i2c_write(0x00);            /* write register address, 1st clock register */
; 0006 00D8     i2c_write(a);
; 0006 00D9     i2c_write(b);
; 0006 00DA     i2c_write(c);
; 0006 00DB     i2c_write(d);
; 0006 00DC     i2c_stop();
; 0006 00DD     #asm("sei")
; 0006 00DE 
; 0006 00DF     printDebug(">> RTC_setBinary RTC Sync.\r\n");
; 0006 00E0 
; 0006 00E1     /* 10ms delay to complete the write operation */
; 0006 00E2     delay_ms(10);
; 0006 00E3 
; 0006 00E4     return 0;
; 0006 00E5 }
;/*============================================================*/
;int RTC_setDateTime(struct rtc_structure rtcSrc,int timezone)
; 0006 00E8 {
; 0006 00E9     unsigned long int rtc_bin;
; 0006 00EA     unsigned long int rtc_current;
; 0006 00EB     unsigned long int rtc_diff;
; 0006 00EC     unsigned char a, b, c, d;
; 0006 00ED 
; 0006 00EE     if((timezone > 14) || (timezone < -12)){
;	rtcSrc -> Y+18
;	timezone -> Y+16
;	rtc_bin -> Y+12
;	rtc_current -> Y+8
;	rtc_diff -> Y+4
;	a -> R17
;	b -> R16
;	c -> R19
;	d -> R18
; 0006 00EF         printDebug("<RTC_setDateTime> Timezone out of range (%+d)\r\n",timezone);
; 0006 00F0         return -2;
; 0006 00F1     }
; 0006 00F2 
; 0006 00F3     rtc_bin = date_to_binary(rtcSrc);
; 0006 00F4 
; 0006 00F5     rtc_bin = rtc_bin + (int)(timezone * 60 * 60 * -1);
; 0006 00F6 
; 0006 00F7     raw_rtc = rtc_bin;
; 0006 00F8 
; 0006 00F9     rtc_current = DS1672_read();
; 0006 00FA 
; 0006 00FB     if(rtc_current > rtc_bin){
; 0006 00FC         rtc_diff = (unsigned long int) (rtc_current - rtc_bin);
; 0006 00FD     }
; 0006 00FE     else if(rtc_bin > rtc_current){
; 0006 00FF         rtc_diff = (unsigned long int) (rtc_bin - rtc_current);
; 0006 0100     }
; 0006 0101     else{
; 0006 0102         // set value and current value are equal
; 0006 0103         rtc_diff = 0;
; 0006 0104     }
; 0006 0105 
; 0006 0106     if((rtc_diff >= 0) && (rtc_diff < 10)){
; 0006 0107         //printDebug("\r\nset time is too close to current time, not set!!! c[%ld] s[%ld]\r\n", rtc_current, rtc_bin);
; 0006 0108         return -1;
; 0006 0109     }
; 0006 010A 
; 0006 010B     printDebug("c_time[%ld] & s_time[%ld] => diff[%ld]\r\n",rtc_current,rtc_bin,rtc_diff);
; 0006 010C 
; 0006 010D     a = (rtc_bin & 0xff);
; 0006 010E     b = ((rtc_bin >> 8) & 0xff);
; 0006 010F     c = ((rtc_bin >> 16) & 0xff);
; 0006 0110     d = ((rtc_bin >> 24) & 0xff);
; 0006 0111 
; 0006 0112     #asm("cli")
; 0006 0113     i2c_start();
; 0006 0114     i2c_write(ADDRTC);          /* write slave address, write 1672 */
; 0006 0115     i2c_write(0x00);            /* write register address, 1st clock register */
; 0006 0116     i2c_write(a);
; 0006 0117     i2c_write(b);
; 0006 0118     i2c_write(c);
; 0006 0119     i2c_write(d);
; 0006 011A     i2c_stop();
; 0006 011B     #asm("sei")
; 0006 011C 
; 0006 011D     /* 10ms delay to complete the write operation */
; 0006 011E     delay_ms(10);
; 0006 011F 
; 0006 0120     return 0;
; 0006 0121 }
;/*============================================================*/
;int RTC_getDateTime(struct rtc_structure *rtcPtr, int timezone)
; 0006 0124 {
_RTC_getDateTime:
; 0006 0125     unsigned long r_rtc;
; 0006 0126     int flag;
; 0006 0127 
; 0006 0128     r_rtc = DS1672_read();
	CALL SUBOPT_0x45
	ST   -Y,R16
;	*rtcPtr -> Y+8
;	timezone -> Y+6
;	r_rtc -> Y+2
;	flag -> R16,R17
	RCALL _DS1672_read
	CALL SUBOPT_0x46
; 0006 0129     if(r_rtc == 0xFFFFFFFF){
	CALL SUBOPT_0x47
	BRNE _0xC0041
; 0006 012A         flag    = RTC_BACKUP;
	__GETWRN 16,17,1
; 0006 012B         r_rtc   = raw_rtc;
	LDS  R30,_raw_rtc
	LDS  R31,_raw_rtc+1
	LDS  R22,_raw_rtc+2
	LDS  R23,_raw_rtc+3
	CALL SUBOPT_0x32
; 0006 012C     }
; 0006 012D     else{
	RJMP _0xC0042
_0xC0041:
; 0006 012E         flag    = RTC_REAL;
	__GETWRN 16,17,0
; 0006 012F         raw_rtc = r_rtc;
	CALL SUBOPT_0x33
	STS  _raw_rtc,R30
	STS  _raw_rtc+1,R31
	STS  _raw_rtc+2,R22
	STS  _raw_rtc+3,R23
; 0006 0130     }
_0xC0042:
; 0006 0131 
; 0006 0132     r_rtc = r_rtc + (int)(timezone * 60 * 60);
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDI  R26,LOW(60)
	LDI  R27,HIGH(60)
	CALL __MULW12
	LDI  R26,LOW(60)
	LDI  R27,HIGH(60)
	CALL __MULW12
	CALL SUBOPT_0x34
	CALL SUBOPT_0x2C
	CALL SUBOPT_0x32
; 0006 0133 
; 0006 0134     binary_to_date(r_rtc,rtcPtr);
	CALL SUBOPT_0x33
	CALL __PUTPARD1
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	RCALL _binary_to_date
; 0006 0135 
; 0006 0136     return flag;
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E0039:
	ADIW R28,10
	RET
; 0006 0137 }
;/*============================================================*/
;void printRTC(struct rtc_structure time)
; 0006 013A {
_printRTC:
; 0006 013B     switch(time.day){
;	time -> Y+0
	LDD  R30,Y+24
	LDD  R31,Y+24+1
; 0006 013C         case DAY_MON: printDebug("Mon. "); break;
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0xC0046
	__POINTD1FN _0xC0000,118
	RJMP _0xC004F
; 0006 013D         case DAY_TUE: printDebug("Tue. "); break;
_0xC0046:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0xC0047
	__POINTD1FN _0xC0000,124
	RJMP _0xC004F
; 0006 013E         case DAY_WED: printDebug("Wed. "); break;
_0xC0047:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0xC0048
	__POINTD1FN _0xC0000,130
	RJMP _0xC004F
; 0006 013F         case DAY_THU: printDebug("Thu. "); break;
_0xC0048:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0xC0049
	__POINTD1FN _0xC0000,136
	RJMP _0xC004F
; 0006 0140         case DAY_FRI: printDebug("Fri. "); break;
_0xC0049:
	CPI  R30,LOW(0x5)
	LDI  R26,HIGH(0x5)
	CPC  R31,R26
	BRNE _0xC004A
	__POINTD1FN _0xC0000,142
	RJMP _0xC004F
; 0006 0141         case DAY_SAT: printDebug("Sat. "); break;
_0xC004A:
	CPI  R30,LOW(0x6)
	LDI  R26,HIGH(0x6)
	CPC  R31,R26
	BRNE _0xC004B
	__POINTD1FN _0xC0000,148
	RJMP _0xC004F
; 0006 0142         case DAY_SUN: printDebug("Sun. "); break;
_0xC004B:
	CPI  R30,LOW(0x7)
	LDI  R26,HIGH(0x7)
	CPC  R31,R26
	BRNE _0xC0045
	__POINTD1FN _0xC0000,154
_0xC004F:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0006 0143     }
_0xC0045:
; 0006 0144 
; 0006 0145     printDebug(
; 0006 0146         "[%d]%04d-%02d-%02d %02d:%02d:%02d\r\n",
; 0006 0147         time.day,
; 0006 0148         time.year,
; 0006 0149         time.month,
; 0006 014A         time.date,
; 0006 014B         time.hour,
; 0006 014C         time.min,
; 0006 014D         time.sec
; 0006 014E     );
	__POINTD1FN _0xC0000,160
	CALL __PUTPARD1
	LDD  R30,Y+28
	LDD  R31,Y+28+1
	CALL SUBOPT_0x48
	CALL SUBOPT_0x49
	CALL __PUTPARD1
	CALL SUBOPT_0x4A
	CALL __PUTPARD1
	__GETD1S 24
	CALL __PUTPARD1
	__GETD1S 32
	CALL __PUTPARD1
	__GETD1S 40
	CALL __PUTPARD1
	__GETD1S 48
	CALL __PUTPARD1
	LDI  R24,28
	CALL _printDebug
	ADIW R28,32
; 0006 014F     return;
	RJMP _0x20E0038
; 0006 0150 }
;/*============================================================*/
;void init_RTC(void)
; 0006 0153 {
_init_RTC:
; 0006 0154     struct rtc_structure rtcTest;
; 0006 0155 
; 0006 0156     raw_rtc = 0;            /* initial default time_value in RAM */
	SBIW R28,26
;	rtcTest -> Y+0
	LDI  R30,LOW(0)
	STS  _raw_rtc,R30
	STS  _raw_rtc+1,R30
	STS  _raw_rtc+2,R30
	STS  _raw_rtc+3,R30
; 0006 0157 
; 0006 0158     #asm("cli")
	cli
; 0006 0159     i2c_start();
	CALL SUBOPT_0x24
; 0006 015A     i2c_write(ADDRTC);
; 0006 015B     i2c_write(0x04);
	LDI  R26,LOW(4)
	CALL _i2c_write
; 0006 015C     i2c_write(0x00);         /* enable the oscillator */
	LDI  R26,LOW(0)
	CALL _i2c_write
; 0006 015D     i2c_stop();
	CALL _i2c_stop
; 0006 015E     #asm("sei")
	sei
; 0006 015F 
; 0006 0160     DS1672_trickerChargeEnable();
	RCALL _DS1672_trickerChargeEnable
; 0006 0161 
; 0006 0162     RTC_getDateTime(&rtcTest,0);
	MOVW R30,R28
	CALL SUBOPT_0x4B
	RCALL _RTC_getDateTime
; 0006 0163 
; 0006 0164     printDebug("Running with System Clock @ ");
	__POINTD1FN _0xC0000,196
	CALL SUBOPT_0x0
; 0006 0165 
; 0006 0166     printRTC(rtcTest);
	MOVW R30,R28
	LDI  R26,26
	CALL __PUTPARL
	RCALL _printRTC
; 0006 0167 }
_0x20E0038:
	ADIW R28,26
	RET
;#include <stdlib.h>
;#include <stdio.h>
;#include <string.h>
;#include "config.h"
;
;eeprom iDVConfig_t viDVConfigDefualt;
;eeprom iDVConfig_t viDVConfigUpdate;
;
;
;
;//#include "config.h"
;//#include "debug.h"
;//
;//char is_properties_config_update                = 1;
;//char is_operating_config_update                 = 1;
;//char is_sensor_config_update[MAX_SENS_CHANNEL]  = {1,1,1,1,1};
;//char is_din_config_update[MAX_DI_CHANNEL]       = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
;//char is_dout_config_update[MAX_DO_CHANNEL]      = {1,1,1,1,1};//,1,1,1,1,1,1,1,1,1,1,1};
;//char is_buzzer_config_update                    = 1;
;//char is_status_config_update                    = 1;
;//char is_env_config_update                       = 1;
;//
;//struct prop_cnfg_st properties_config;
;//struct oper_cnfg_st operating_config;
;//struct oper_cnfg_st operating_config;
;//struct sens_cnfg_st sensor_config[MAX_SENS_CHANNEL];
;//struct din_cnfg_st  din_config[MAX_DI_CHANNEL];
;//struct dout_cnfg_st dout_config[MAX_DO_CHANNEL];
;//struct buzz_cnfg_st buzz_config;
;//struct stat_cnfg_st status_config;
;//struct alm_cnfg_st  env_config;
;//
;////flash char FIRMWARE_VERSION[] = "iNT-ETH-0.24b";
;////iNT-ETH-DC-0.01a
;//flash char FIRMWARE_VERSION[] = "iNT-ETH-DC-0.01a";
;///*============================================================*/
;//
;///**************************************************************/
;///*************** Read Configuration from EEPROM ***************/
;///**************************************************************/
;///*============================================================*/
;//int getPropertiesConfig(struct prop_cnfg_st *readConfig)
;//{
;//    int i;
;//
;//    //printDebug("<getPropertiesConfig>..\r\n");
;//
;//    if( config_prop_flag != 0x01){
;//        printDebug("<getPropertiesConfig> no configuration, use default\r\n");
;//        memset(readConfig,0x00,sizeof(struct prop_cnfg_st));
;//        readConfig->timeZone   = 7;
;//    }
;//    else{
;//
;//        for(i=0;i<DEVTYPE_LENGTH;i++)
;//        {
;//            readConfig->deviceType[i]   = config_prop.deviceType[i];
;//        }
;//
;//        /*
;//        for(i=0;i<FW_LENGTH;i++)
;//        {
;//            //printDebug("%c",config_prop.firmwareVersion[i]);
;//            readConfig->firmwareVersion[i]   = config_prop.firmwareVersion[i];
;//        }
;//        */
;//        memcpyf(readConfig->firmwareVersion,FIRMWARE_VERSION,strlenf(FIRMWARE_VERSION));
;//
;//        for(i=0;i<NAME_LENGTH;i++)
;//        {
;//            readConfig->deviceName[i]   = config_prop.deviceName[i];
;//        }
;//
;//        for(i=0;i<ID_LENGTH;i++)
;//        {
;//            readConfig->deviceID[i]   = config_prop.deviceID[i];
;//        }
;//
;//        for(i=0;i<NAME_LENGTH;i++)
;//        {
;//            readConfig->hostName[i]   = config_prop.hostName[i];
;//        }
;//
;//        for(i=0;i<ID_LENGTH;i++)
;//        {
;//            readConfig->hostID[i]   = config_prop.hostID[i];
;//        }
;//
;//        readConfig->timeZone   = config_prop.timeZone;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int getOperatingConfig(struct oper_cnfg_st *readConfig)
;//{
;//    int i;
;//
;//    if( config_oper_flag != 0x01){
;//        printDebug("<getOperatingConfig> no configuration, use default\r\n");
;//
;//        readConfig->mode                    =   MODE_DATALOGGER;
;//        readConfig->deviceEnable            =   0x00;
;//        readConfig->alarmEnable             =   0x00;
;//
;//        for(i=0;i<MAX_SENS_CHANNEL;i++)
;//        {
;//            readConfig->sensorEnable[i]     =   0x00;
;//        }
;//
;//        /* // -- for test -- //
;//        readConfig->mode                    =   MODE_REALTIME;
;//        readConfig->deviceEnable            =   0x01;
;//        readConfig->alarmEnable             =   0x01;
;//
;//        for(i=0;i<MAX_SENS_CHANNEL;i++)
;//        {
;//            if(i==0){
;//                readConfig->sensorEnable[i]     =   0x01;
;//            }
;//            else{
;//                readConfig->sensorEnable[i]     =   0x00;
;//            }
;//        }
;//        */
;//    }
;//    else{
;//        readConfig->mode                    =   config_oper.mode;
;//        readConfig->deviceEnable            =   config_oper.deviceEnable;
;//        readConfig->alarmEnable             =   config_oper.alarmEnable;
;//
;//        for(i=0;i<MAX_SENS_CHANNEL;i++)
;//        {
;//            readConfig->sensorEnable[i]     =   config_oper.sensorEnable[i];
;//        }
;//    }
;//
;//
;//    printDebug("<getOperatingConfig> mode            >> 0x%02X\r\n",readConfig->mode);
;//    printDebug("<getOperatingConfig> deviceEnable    >> 0x%02X\r\n",readConfig->deviceEnable);
;//    printDebug("<getOperatingConfig> alarmEnable     >> 0x%02X\r\n",readConfig->alarmEnable);
;//    printDebug("<getOperatingConfig> sensorEnable    >> ");
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++)
;//    {
;//        printDebug("[0x%02X]",readConfig->sensorEnable[i]);
;//    }
;//    printDebug("\r\n");
;//
;//    return 0;
;//}
;///*============================================================*/
;//int getSensorConfig(int ch, struct sens_cnfg_st *readConfig)
;//{
;//    if((ch < 0) || (ch >= MAX_SENS_CHANNEL)){
;//        printDebug("<getSensorConfig> sensor channel out of range (%d)\r\n",ch);
;//        return -1;
;//    }
;//
;//    if( config_sens_flag[ch] != 0x01){
;//        printDebug("<getSensorConfig> no configuration, use default\r\n");
;//        readConfig->samplingRate        =   300;
;//        readConfig->reOccurrence        =   0x8000;
;//        readConfig->timeStartHour       =   0;
;//        readConfig->timeStartMin        =   0;
;//        readConfig->timeStopHour        =   0;
;//        readConfig->timeStopMin         =   0;
;//
;//        readConfig->alarmEnable         =   0x00;
;//        readConfig->lowerLimit          =   10.0;
;//        readConfig->lowerDelay          =   20;
;//        readConfig->lowerExtreme        =   0.0;
;//        readConfig->upperLimit          =   180.0;
;//        readConfig->upperDelay          =   20;
;//        readConfig->upperExtreme        =   200.0;
;//        /*
;//        readConfig->alarmEnable         =   0x00;
;//        readConfig->lowerLimit          =   0.0;
;//        readConfig->lowerDelay          =   10;
;//        readConfig->lowerExtreme        =   0.0;
;//        readConfig->upperLimit          =   0.0;
;//        readConfig->upperDelay          =   10;
;//        readConfig->upperExtreme        =   0.0;
;//        */
;//    }
;//    else{
;//        readConfig->samplingRate        =   config_sens[ch].samplingRate;
;//        readConfig->reOccurrence        =   config_sens[ch].reOccurrence;
;//        readConfig->timeStartHour       =   config_sens[ch].timeStartHour;
;//        readConfig->timeStartMin        =   config_sens[ch].timeStartMin;
;//        readConfig->timeStopHour        =   config_sens[ch].timeStopHour;
;//        readConfig->timeStopMin         =   config_sens[ch].timeStopMin;
;//
;//        readConfig->alarmEnable         =   config_sens[ch].alarmEnable;
;//        readConfig->lowerLimit          =   config_sens[ch].lowerLimit;
;//        readConfig->lowerDelay          =   config_sens[ch].lowerDelay;
;//        readConfig->lowerExtreme        =   config_sens[ch].lowerExtreme;
;//        readConfig->upperLimit          =   config_sens[ch].upperLimit;
;//        readConfig->upperDelay          =   config_sens[ch].upperDelay;
;//        readConfig->upperExtreme        =   config_sens[ch].upperExtreme;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int getAuxDinConfig(int ch, struct din_cnfg_st *readConfig)
;//{
;//    if((ch < 0) || (ch >= MAX_DI_CHANNEL)){
;//        printDebug("<getAuxDinConfig> digital input channel out of range (%d)\r\n",ch);
;//        return -1;
;//    }
;//
;//    if( config_din_flag[ch] != 0x01){
;//        printDebug("<getAuxDinConfig> no configuration, use default\r\n");
;//
;//        readConfig->channelEnable       =   0x00;
;//        readConfig->alarmDelay          =   0;
;//
;//        /* // -- for test -- //
;//        if(ch < 2)  readConfig->channelEnable       =   0x01;
;//        else        readConfig->channelEnable       =   0x00;
;//
;//        readConfig->alarmDelay          =   0;
;//        */
;//    }
;//    else{
;//        readConfig->channelEnable       =   config_din[ch].channelEnable;
;//        readConfig->alarmDelay          =   config_din[ch].alarmDelay;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int getAuxDoutConfig(int ch, struct dout_cnfg_st *readConfig)
;//{
;//    int i;
;//
;//    if((ch < 0) || (ch >= MAX_DO_CHANNEL)){
;//        printDebug("<getAuxDoutConfig> digital output channel out of range (%d)\r\n",ch);
;//        return -1;
;//    }
;//
;//    if( config_dout_flag[ch] != 0x01){
;//        printDebug("<getAuxDoutConfig> no configuration, use default\r\n");
;//        readConfig->channelEnable       =   0x00;
;//        readConfig->stateOnEvent        =   0x01;
;//        readConfig->eventSourceNumber   =   0;
;//
;//        for(i=0;i<MAX_EVENT_SOURCE;i++){
;//            readConfig->eventSource[i]  =   0x00;
;//        }
;//    }
;//    else{
;//        readConfig->channelEnable       =   config_dout[ch].channelEnable;
;//        readConfig->stateOnEvent        =   config_dout[ch].stateOnEvent;
;//        readConfig->eventSourceNumber   =   config_dout[ch].eventSourceNumber;
;//
;//        printDebug("<getAuxDoutConfig> -- CH %d -- \r\n",ch);
;//        printDebug("<getAuxDoutConfig> enable         [0x%02X]\r\n",config_dout[ch].channelEnable);
;//        printDebug("<getAuxDoutConfig> stateOnEvent   [0x%02X]\r\n",config_dout[ch].stateOnEvent);
;//        printDebug("<getAuxDoutConfig> numberEvSrc    [%d]->",config_dout[ch].eventSourceNumber);
;//        for(i=0;i<config_dout[ch].eventSourceNumber;i++){
;//            readConfig->eventSource[i]  =   config_dout[ch].eventSource[i];
;//            printDebug("[0x%02X]",readConfig->eventSource[i]);
;//        }
;//        for(i=config_dout[ch].eventSourceNumber;i<MAX_EVENT_SOURCE;i++){
;//            readConfig->eventSource[i]  =   0x00;
;//            //printDebug("[0x%02X]",readConfig->eventSource[i]);
;//        }
;//        printDebug("\r\n");
;//
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int getAuxAinConfig(int ch, struct ain_cnfg_st *readConfig)
;//{
;//    if((ch < 0) || (ch >= MAX_AI_CHANNEL)){
;//        printDebug("<getAuxAinConfig> analog input channel out of range (%d)\r\n",ch);
;//        return -1;
;//    }
;//
;//    if( config_ain_flag[ch] != 0x01){
;//        printDebug("<getAuxAinConfig> no configuration, use default\r\n");
;//        readConfig->channelEnable       =   0x00;
;//        readConfig->alarmLevel          =   0;
;//    }
;//    else{
;//        readConfig->channelEnable       =   config_ain[ch].channelEnable;
;//        readConfig->alarmLevel          =   config_ain[ch].alarmLevel;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int getAuxAoutConfig(int ch, struct aout_cnfg_st *readConfig)
;//{
;//    int i;
;//
;//    if((ch < 0) || (ch >= MAX_AO_CHANNEL)){
;//        printDebug("<getAuxAoutConfig> analog output channel out of range (%d)\r\n",ch);
;//        return -1;
;//    }
;//
;//    if( config_aout_flag[ch] != 0x01){
;//        printDebug("<getAuxAoutConfig> no configuration, use default\r\n");
;//        readConfig->channelEnable       =   0x00;
;//        readConfig->levelOnEvent        =   0.0;
;//        readConfig->eventSourceNumber   =   0;
;//
;//        for(i=0;i<MAX_EVENT_SOURCE;i++){
;//            readConfig->eventSource[i]  =   0x00;
;//        }
;//    }
;//    else{
;//        readConfig->channelEnable       =   config_aout[ch].channelEnable;
;//        readConfig->levelOnEvent        =   config_aout[ch].levelOnEvent;
;//        readConfig->eventSourceNumber   =   config_aout[ch].eventSourceNumber;
;//
;//        for(i=0;i<config_aout[ch].eventSourceNumber;i++){
;//            readConfig->eventSource[i]  =   config_aout[ch].eventSource[i];
;//        }
;//        for(i=config_aout[ch].eventSourceNumber;i<MAX_EVENT_SOURCE;i++){
;//            readConfig->eventSource[i]  =   0x00;
;//        }
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int getBuzzerConfig(struct buzz_cnfg_st *readConfig)
;//{
;//    char errSrc[4] = {0xC7,0xCF,0xD7,0xDF};
;//    int i;
;//
;//    if( config_buzz_flag != 0x01){
;//        printDebug("<getBuzzerConfig> no configuration, use default\r\n");
;//        readConfig->enable              =   0x01;
;//        readConfig->eventSourceNumber   =   sizeof(errSrc);
;//
;//        //printDebug("<getBuzzerConfig> eventSourceNumber = %d ->",readConfig->eventSourceNumber);
;//        for(i=0;i<sizeof(errSrc);i++){
;//            if(i<sizeof(errSrc)){
;//                readConfig->eventSource[i]  =   errSrc[i];
;//                //printDebug("[0x%02X]",readConfig->eventSource[i]);
;//            }
;//            else{
;//                readConfig->eventSource[i]  =   0x00;
;//            }
;//        }
;//        //printDebug("\r\n");
;//    }
;//    else{
;//        readConfig->enable              =   config_buzz.enable;
;//        readConfig->eventSourceNumber   =   config_buzz.eventSourceNumber;
;//
;//        for(i=0;i<config_buzz.eventSourceNumber;i++){
;//            readConfig->eventSource[i]  =   config_buzz.eventSource[i];
;//        }
;//        for(i=config_buzz.eventSourceNumber;i<MAX_EVENT_SOURCE;i++){
;//            readConfig->eventSource[i]  =   0x00;
;//        }
;//    }
;//
;//    printDebug("<getBuzzerConfig> enable            >>[0x%02X]\r\n",    readConfig->enable);
;//    printDebug("<getBuzzerConfig> eventSourceNumber >>[%d]\r\n",         readConfig->eventSourceNumber);
;//    printDebug("<getBuzzerConfig> eventSource       >>");
;//    for(i=0;i<MAX_EVENT_SOURCE;i++){
;//        printDebug("[0x%02X]",readConfig->eventSource[i]);
;//    }
;//    printDebug("\r\n");
;//
;//    return 0;
;//}
;///*============================================================*/
;//int getEnvAlarmConfig(struct alm_cnfg_st *readConfig)
;//{
;//    if( config_alm_flag != 0x01 ){
;//        printDebug("<getEnvAlarmConfig> no configuration, use default\r\n");
;//        readConfig->gsmRSSILevel         =   0;
;//        readConfig->gsmCreditBalance     =   0;
;//        readConfig->batteryLevel         =   0;
;//        readConfig->commSignalLevel      =   0;
;//        readConfig->commLostDelay        =   0;
;//        readConfig->memoryMin            =   0;
;//    }
;//    else{
;//        readConfig->gsmRSSILevel         =   config_alm.gsmRSSILevel;
;//        readConfig->gsmCreditBalance     =   config_alm.gsmCreditBalance;
;//        readConfig->batteryLevel         =   config_alm.batteryLevel;
;//        readConfig->commSignalLevel      =   config_alm.commSignalLevel;
;//        readConfig->commLostDelay        =   config_alm.commLostDelay;
;//        readConfig->memoryMin            =   config_alm.memoryMin;
;//    }
;//
;//    printDebug("<getEnvAlarmConfig> gsmRSSILevel         [%f]\r\n",readConfig->gsmRSSILevel);
;//    printDebug("<getEnvAlarmConfig> gsmCreditBalance     [%d]\r\n",readConfig->gsmCreditBalance);
;//    printDebug("<getEnvAlarmConfig> batteryLevel         [%f]\r\n",readConfig->batteryLevel);
;//    printDebug("<getEnvAlarmConfig> commSignalLevel      [%f]\r\n",readConfig->commSignalLevel);
;//    printDebug("<getEnvAlarmConfig> commLostDelay        [%d]\r\n",readConfig->commLostDelay);
;//    printDebug("<getEnvAlarmConfig> memoryMin            [%u]\r\n",readConfig->memoryMin,);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int getStatusReportConfig(struct stat_cnfg_st *readConfig)
;//{
;//    if( config_stat_flag != 0x01 ){
;//        printDebug("<getStatusReportConfig> no configuration, use default\r\n");
;//        readConfig->accm                =   0x30;
;//        readConfig->intv                =   60;
;//    }
;//    else{
;//        readConfig->accm                =   config_stat.accm;
;//        readConfig->intv                =   config_stat.intv;
;//    }
;//
;//    printDebug("<getStatusReportConfig> accm        [0x%02X]\r\n",readConfig->accm);
;//    printDebug("<getStatusReportConfig> intv        [%d]\r\n",readConfig->intv);
;//
;//    return 0;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///**************** Write Configuration to EEPROM ***************/
;///**************************************************************/
;///*============================================================*/
;//int setPropertiesConfig(struct prop_cnfg_st *newConfig)
;//{
;//    int i;
;//
;//    for(i=0;i<DEVTYPE_LENGTH;i++)
;//    {
;//        config_prop.deviceType[i]       = newConfig->deviceType[i];
;//    }
;//
;//    /*
;//    for(i=0;i<FW_LENGTH;i++)
;//    {
;//        config_prop.firmwareVersion[i]  = newConfig->firmwareVersion[i];    //printDebug("%c",config_prop.firmwareVersion[i]);
;//    }
;//    */
;//
;//    for(i=0;i<NAME_LENGTH;i++)
;//    {
;//        config_prop.deviceName[i]       = newConfig->deviceName[i];
;//    }
;//
;//    for(i=0;i<ID_LENGTH;i++)
;//    {
;//        config_prop.deviceID[i]         = newConfig->deviceID[i];
;//    }
;//
;//    for(i=0;i<NAME_LENGTH;i++)
;//    {
;//        config_prop.hostName[i]         = newConfig->hostName[i];
;//    }
;//
;//    for(i=0;i<ID_LENGTH;i++)
;//    {
;//        config_prop.hostID[i]           = newConfig->hostID[i];
;//    }
;//
;//    config_prop.timeZone                = newConfig->timeZone;
;//
;//    config_prop_flag                    = 0x01;
;//
;//    is_properties_config_update          = 1;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setOperatingConfig(struct oper_cnfg_st *newConfig)
;//{
;//    int i;
;//
;//    if( (newConfig->mode != MODE_REALTIME) && (newConfig->mode != MODE_DATALOGGER) ){
;//        printDebug("<setOperatingConfig> Error: operating mode invalid [0x%02X]\r\n", newConfig->mode);
;//        return -1;
;//    }
;//
;//    config_oper.mode                    =   newConfig->mode;
;//    config_oper.deviceEnable            =   newConfig->deviceEnable;
;//    config_oper.alarmEnable             =   newConfig->alarmEnable;
;//
;//    printDebug("\r\n mode            >> 0x%02X",config_oper.mode);
;//    printDebug("\r\n deviceEnable    >> 0x%02X",config_oper.deviceEnable);
;//    printDebug("\r\n alarmEnable     >> 0x%02X",config_oper.alarmEnable);
;//    printDebug("\r\n sensorEnable    >> ");
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++)
;//    {
;//        config_oper.sensorEnable[i]     =   newConfig->sensorEnable[i];
;//        printDebug("[0x%02X]",config_oper.sensorEnable[i]);
;//    }
;//    printDebug("\r\n");
;//
;//    config_oper_flag                    =   0x01;
;//
;//    is_operating_config_update          =   1;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setSensorConfig(int ch, struct sens_cnfg_st *newConfig)
;//{
;//    if((ch < 0) || (ch >= MAX_SENS_CHANNEL)){
;//        printDebug("<setSensorConfig> ERR: channel out of range\r\n");
;//        return -1;
;//    }
;//    if(newConfig->samplingRate == 0){
;//        printDebug("<setSensorConfig> ERR: samplingRate couldn't be set to 0\r\n");
;//        return -1;
;//    }
;//
;//    if(newConfig->samplingRate < 60){
;//        newConfig->samplingRate         =   60;
;//    }
;//
;//    config_sens[ch].samplingRate        =   newConfig->samplingRate;
;//    config_sens[ch].reOccurrence        =   newConfig->reOccurrence;
;//    config_sens[ch].timeStartHour       =   newConfig->timeStartHour;
;//    config_sens[ch].timeStartMin        =   newConfig->timeStartMin;
;//    config_sens[ch].timeStopHour        =   newConfig->timeStopHour;
;//    config_sens[ch].timeStopMin         =   newConfig->timeStopMin;
;//
;//    config_sens[ch].alarmEnable         =   newConfig->alarmEnable;
;//    config_sens[ch].lowerLimit          =   newConfig->lowerLimit;
;//    config_sens[ch].lowerDelay          =   newConfig->lowerDelay;
;//    config_sens[ch].lowerExtreme        =   newConfig->lowerExtreme;
;//    config_sens[ch].upperLimit          =   newConfig->upperLimit;
;//    config_sens[ch].upperDelay          =   newConfig->upperDelay;
;//    config_sens[ch].upperExtreme        =   newConfig->upperExtreme;
;//
;//    printDebug("\r\n samplingRate    >> 0x%04X",config_sens[ch].samplingRate);
;//    printDebug("\r\n reOccurrence    >> 0x%04X",config_sens[ch].reOccurrence);
;//    printDebug("\r\n timeStartHour   >> 0x%02X",config_sens[ch].timeStartHour);
;//    printDebug("\r\n timeStartMin    >> 0x%02X",config_sens[ch].timeStartMin);
;//    printDebug("\r\n timeStopHour    >> 0x%02X",config_sens[ch].timeStopHour);
;//    printDebug("\r\n timeStopMin     >> 0x%02X",config_sens[ch].timeStopMin);
;//
;//    printDebug("\r\n alarmEnable     >> 0x%02X",        config_sens[ch].alarmEnable);
;//    printDebug("\r\n lowerLimit      >> %f [%04lX]",     config_sens[ch].lowerLimit,config_sens[ch].lowerLimit);
;//    printDebug("\r\n lowerDelay      >> %d [%02X]",     config_sens[ch].lowerDelay,config_sens[ch].lowerDelay);
;//    printDebug("\r\n lowerExtreme    >> %f [%04lX]",     config_sens[ch].lowerExtreme,config_sens[ch].lowerExtreme);
;//    printDebug("\r\n upperLimit      >> %f [%04lX]",     config_sens[ch].upperLimit,config_sens[ch].upperLimit);
;//    printDebug("\r\n upperDelay      >> %d [%02X]",     config_sens[ch].upperDelay,config_sens[ch].upperDelay);
;//    printDebug("\r\n upperExtreme    >> %f [%04lX]",     config_sens[ch].upperExtreme,config_sens[ch].upperExtreme);
;//    printDebug("\r\n");
;//
;//    config_sens_flag[ch]                = 0x01;
;//    is_sensor_config_update[ch]          = 1;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setAuxDinConfig(int ch, struct din_cnfg_st *newConfig)
;//{
;//    if((ch < 0) || (ch > MAX_DI_CHANNEL)){
;//        return -1;
;//    }
;//
;//    config_din[ch].channelEnable        =   newConfig->channelEnable;
;//    config_din[ch].alarmDelay           =   newConfig->alarmDelay;
;//
;//    printDebug("\r\n channel         >> [%d]",      ch);
;//    printDebug("\r\n channelEnable   >> 0x%02X",    config_din[ch].channelEnable);
;//    printDebug("\r\n alarmDelay      >> %d",        config_din[ch].alarmDelay);
;//
;//    config_din_flag[ch]                 =   0x01;
;//    is_din_config_update[ch]            =   1;
;//    return 0;
;//}
;///*============================================================*/
;//int setAuxDoutConfig(int ch, struct dout_cnfg_st *newConfig)
;//{
;//    int i;
;//
;//    if((ch < 0) || (ch > MAX_DO_CHANNEL)){
;//        printDebug("\r\n<setAuxDoutConfig> Channel Error!!\r\n");
;//        return -1;
;//    }
;//
;//    if( (newConfig->eventSourceNumber) > MAX_EVENT_SOURCE ){
;//        printDebug("\r\n<setAuxDoutConfig> eventSourceNumber is too long (%d)!!\r\n",(newConfig->eventSourceNumber));
;//        return -1;
;//    }
;//
;//    config_dout[ch].channelEnable       =   0x01; //newConfig->channelEnable;      // Edit bug from software
;//    config_dout[ch].stateOnEvent        =   0x00; //newConfig->stateOnEvent;
;//    config_dout[ch].eventSourceNumber   =   newConfig->eventSourceNumber;
;//
;//    printDebug("\r\n channel           >> [%d]",    ch);
;//    printDebug("\r\n channelEnable     >> 0x%02X",  config_dout[ch].channelEnable);
;//    printDebug("\r\n stateOnEvent      >> 0x%02X",  config_dout[ch].stateOnEvent);
;//    printDebug("\r\n eventSourceNumber >> %d",      config_dout[ch].eventSourceNumber);
;//    printDebug("\r\n eventSource       >> ");
;//
;//    for(i=0;i<config_dout[ch].eventSourceNumber;i++){
;//
;//        config_dout[ch].eventSource[i]  =   newConfig->eventSource[i];
;//
;//        if( config_dout[ch].eventSource[i] != 0x00 ){
;//            printDebug("[0x%02X]",config_dout[ch].eventSource[i]);
;//        }
;//    }
;//    printDebug("\r\n");
;//
;//    config_dout_flag[ch]                =   0x01;
;//    is_dout_config_update[ch]           =   1;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setAuxAinConfig(int ch, struct ain_cnfg_st *newConfig)
;//{
;//    if((ch < 0) || (ch > MAX_AI_CHANNEL)){
;//        return -1;
;//    }
;//
;//    config_ain[ch].channelEnable        =   newConfig->channelEnable;
;//    config_ain[ch].alarmLevel           =   newConfig->alarmLevel;
;//
;//    printDebug("\r\n channel         >> [%d]",      ch);
;//    printDebug("\r\n channelEnable   >> 0x%02X",    config_ain[ch].channelEnable);
;//    printDebug("\r\n alarmLevel      >> %d",        config_ain[ch].alarmLevel);
;//
;//    config_ain_flag[ch]                 = 0x01;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setAuxAoutConfig(int ch, struct aout_cnfg_st *newConfig)
;//{
;//    int i;
;//
;//    if((ch < 0) || (ch > MAX_AO_CHANNEL)){
;//        printDebug("\r\n<setAuxAoutConfig> Channel Error!!\r\n");
;//        return -1;
;//    }
;//
;//    if( (newConfig->eventSourceNumber) > MAX_EVENT_SOURCE ){
;//        printDebug("\r\n<setAuxAoutConfig> eventSourceNumber is too long (%d)!!\r\n",(newConfig->eventSourceNumber));
;//        return -1;
;//    }
;//
;//    config_aout[ch].channelEnable       =   newConfig->channelEnable;
;//    config_aout[ch].levelOnEvent        =   newConfig->levelOnEvent;
;//    config_aout[ch].eventSourceNumber   =   newConfig->eventSourceNumber;
;//
;//    printDebug("\r\n channel           >> [%d]",    ch);
;//    printDebug("\r\n channelEnable     >> 0x%02X",  config_aout[ch].channelEnable);
;//    printDebug("\r\n levelOnEvent      >> %f",      config_aout[ch].levelOnEvent);
;//    printDebug("\r\n eventSourceNumber >> %d",      config_aout[ch].eventSourceNumber);
;//    printDebug("\r\n eventSource       >> ");
;//
;//    for(i=0;i<config_aout[ch].eventSourceNumber;i++){
;//
;//        config_aout[ch].eventSource[i]  =   newConfig->eventSource[i];
;//
;//        if( config_aout[ch].eventSource[i] != 0x00 ){
;//            printDebug("[0x%02X]",config_aout[ch].eventSource[i]);
;//        }
;//    }
;//    printDebug("\r\n");
;//
;//    config_aout_flag[ch]                =   0x01;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setBuzzerConfig(struct buzz_cnfg_st *newConfig)
;//{
;//    int i;
;//
;//    if( (newConfig->eventSourceNumber) > MAX_EVENT_SOURCE ){
;//        printDebug("\r\n<setBuzzerConfig> eventSourceNumber is too long (%d)!!\r\n",(newConfig->eventSourceNumber));
;//        return -1;
;//    }
;//
;//    config_buzz.enable                  =   newConfig->enable;
;//    config_buzz.eventSourceNumber       =   newConfig->eventSourceNumber;
;//
;//    printDebug("\r\n enable            >> 0x%02X",  config_buzz.enable);
;//    printDebug("\r\n eventSourceNumber >> %d",      config_buzz.eventSourceNumber);
;//    printDebug("\r\n eventSource       >>");
;//
;//    for(i=0;i<config_buzz.eventSourceNumber;i++){
;//
;//        config_buzz.eventSource[i]      =   newConfig->eventSource[i];
;//
;//        if( config_buzz.eventSource[i] != 0x00 ){
;//            printDebug("[0x%02X]",config_buzz.eventSource[i]);
;//        }
;//
;//    }
;//    printDebug("\r\n");
;//
;//    config_buzz_flag                    =   0x01;
;//
;//    is_buzzer_config_update             =   1;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setEnvAlarmConfig(struct alm_cnfg_st *newConfig)
;//{
;//    config_alm.gsmRSSILevel             =   newConfig->gsmRSSILevel;
;//    config_alm.gsmCreditBalance         =   newConfig->gsmCreditBalance;
;//    config_alm.batteryLevel             =   newConfig->batteryLevel;
;//    config_alm.commSignalLevel          =   newConfig->commSignalLevel;
;//    config_alm.commLostDelay            =   newConfig->commLostDelay;
;//    config_alm.memoryMin                =   newConfig->memoryMin;
;//
;//    printDebug("\r\n gsmRSSILevel     >> %f dB",    config_alm.gsmRSSILevel);
;//    printDebug("\r\n gsmCreditBalance >> %d Baht",  config_alm.gsmCreditBalance);
;//    printDebug("\r\n batteryLevel     >> %f Volts", config_alm.batteryLevel);
;//    printDebug("\r\n commSignalLevel  >> %f dB",    config_alm.commSignalLevel);
;//    printDebug("\r\n commLostDelay    >> %d sec",   config_alm.commLostDelay);
;//    printDebug("\r\n memoryMin        >> %d MB.",   config_alm.memoryMin);
;//
;//    config_alm_flag                 = 0x01;
;//    is_env_config_update            = 1;
;//    return 0;
;//}
;///*============================================================*/
;//int setStatusReportConfig(struct stat_cnfg_st *newConfig)
;//{
;//    config_stat.accm                    =   newConfig->accm;
;//    config_stat.intv                    =   newConfig->intv;
;//
;//    printDebug("\r\n accm     >> %f dB",    config_stat.accm);
;//    printDebug("\r\n intv     >> %d Baht",  config_stat.intv);
;//
;//    config_stat_flag                    = 0x01;
;//    is_status_config_update             = 1;
;//    return 0;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///********* Service Configuration Management Function **********/
;///**************************************************************/
;///*============================================================*/
;//int setDefaultConfig(void)
;//{
;//    int i;
;//
;//    config_prop_flag            = 0x00;
;//    config_oper_flag            = 0x00;
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++){
;//        config_sens_flag[i]     = 0x00;
;//    }
;//
;//    for(i=0;i<MAX_DI_CHANNEL;i++){
;//        config_din_flag[i]      = 0x00;
;//    }
;//
;//    for(i=0;i<MAX_DO_CHANNEL;i++){
;//        config_dout_flag[i]     = 0x00;
;//    }
;//
;//    for(i=0;i<MAX_AI_CHANNEL;i++){
;//        config_ain_flag[i]      = 0x00;
;//    }
;//
;//    for(i=0;i<MAX_AO_CHANNEL;i++){
;//        config_aout_flag[i]     = 0x00;
;//    }
;//
;//    config_buzz_flag            = 0x00;
;//    config_alm_flag             = 0x00;
;//    config_stat_flag            = 0x00;
;//
;//    return 0;
;//}
;///*============================================================*/
;//int isDeviceConfig(void)
;//{
;//    int i   = 0;
;//
;//    if( config_prop_flag || config_oper_flag || config_buzz_flag || config_alm_flag || config_stat_flag ){
;//        return 1;
;//    }
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++){
;//        if(config_sens_flag[i]){
;//            return 1;
;//        }
;//    }
;//
;//    //for(i=0;i<MAX_DI_CHANNEL;i++){
;//    for(i=0;i<2;i++){
;//        if(config_din_flag[i]){
;//            return 1;
;//        }
;//    }
;//
;//    //for(i=0;i<MAX_DO_CHANNEL;i++){
;//    for(i=0;i<2;i++){
;//        if(config_dout_flag[i]){
;//            return 1;
;//        }
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int getAllConfig(void)
;//{
;//    int i,err;
;//
;//    // -- load configuration -- //
;//    getPropertiesConfig(&properties_config);
;//    is_properties_config_update = 0;
;//
;//    getOperatingConfig(&operating_config);
;//    is_operating_config_update = 0;
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++){
;//        err = getSensorConfig(i,&sensor_config[i]);
;//        if(err < 0){
;//            printDebug("<main> getSensorConfig(%d) error\r\n",i);
;//            continue;
;//        }
;//        is_sensor_config_update[i] = 0;
;//    }
;//
;//    getBuzzerConfig(&buzz_config);
;//    is_buzzer_config_update = 0;
;//
;//    for(i=0;i<USE_DIN;i++){
;//        getAuxDinConfig(i,&din_config[i]);
;//        is_din_config_update[i] = 0;
;//    }
;//
;//    for(i=0;i<USE_DOUT;i++){
;//        getAuxDoutConfig(i,&dout_config[i]);
;//        is_dout_config_update[i] = 0;
;//    }
;//
;//    getStatusReportConfig(&status_config);
;//    is_status_config_update = 0;
;//
;//    getEnvAlarmConfig(&env_config);
;//    is_env_config_update = 0;
;//
;//    return 0;
;//}
;///*============================================================*/
;#include <stdlib.h>
;#include "configstructure.h"
;
;///**************************************************************/
;///**************** Configuration saved in EEPROM ***************/
;///**************************************************************/
;///*============================================================*/
;//eeprom struct prop_cnfg_st  config_prop                     =   {   "EndPoint",
;//                                                                    "COMM-ETH-0.01a",
;//                                                                    "TestEndPoint01",
;//                                                                    "00000000001",
;//                                                                    "iNTELENICs Company",
;//                                                                    "STRI-703",
;//                                                                    7
;//                                                                };
;//eeprom struct oper_cnfg_st  config_oper                     =   {   0x20,
;//                                                                    0x00,
;//                                                                    0x00,
;//                                                                    {0x00,0x00,0x00,0x00,0x00}
;//                                                                };
;//eeprom struct sens_cnfg_st  config_sens[MAX_SENS_CHANNEL]   =   {   {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   },
;//                                                                    {   300,0x8000,0,0,0,0,
;//                                                                        0,0.0,10,0.0,0.0,10,0.0   }
;//                                                                };
;//eeprom struct din_cnfg_st   config_din[MAX_DI_CHANNEL]      =   {   {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15},
;//                                                                    {0x00,15}
;//                                                                };
;//eeprom struct dout_cnfg_st  config_dout[MAX_DO_CHANNEL]     =   {   {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    }
;//                                                                };
;////                                                                    ,{0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    },
;////                                                                    {0x00,0x01,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;////                                                                                    0x00,0x00,0x00,0x00,0x00}
;////                                                                    }
;////                                                                };
;//eeprom struct ain_cnfg_st   config_ain[MAX_AI_CHANNEL]      =   {   {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5},
;//                                                                    {0x00,1.5}
;//                                                                };
;//eeprom struct aout_cnfg_st  config_aout[MAX_AO_CHANNEL]     =   {   {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//                                                                    {0x00,0.0,0,{  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                                    0x00,0x00,0x00,0x00,0x00}
;//                                                                    },
;//
;//                                                                };
;//eeprom struct buzz_cnfg_st  config_buzz                     =   {   0x00,
;//                                                                    0x00,
;//                                                                    {   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;//                                                                        0x00,0x00,0x00,0x00,0x00
;//                                                                    }
;//                                                                };
;//eeprom struct alm_cnfg_st   config_alm                      =   {   0x00000000,
;//                                                                    0x0000,
;//                                                                    0x00000000,
;//                                                                    0x00000000,
;//                                                                    0x0000,
;//                                                                    0x0000
;//                                                                };
;//eeprom struct stat_cnfg_st  config_stat                     =   {0x30,60};
;///*============================================================*/
;//
;///**************************************************************/
;///***************** EEPROM Configured indicator ****************/
;///**************************************************************/
;///*============================================================*/
;//eeprom char config_prop_flag                    =   0x00;
;//eeprom char config_oper_flag                    =   0x00;
;//eeprom char config_sens_flag[MAX_SENS_CHANNEL]  =   {0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_din_flag[MAX_DI_CHANNEL]     =   {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_dout_flag[MAX_DO_CHANNEL]    =   {0x00,0x00,0x00,0x00,0x00};//,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_ain_flag[MAX_AI_CHANNEL]     =   {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_aout_flag[MAX_AO_CHANNEL]    =   {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;//eeprom char config_buzz_flag                    =   0x00;
;//eeprom char config_alm_flag                     =   0x00;
;//eeprom char config_stat_flag                    =   0x00;
;///*============================================================*/
;#include <stdlib.h>
;#include <stdio.h>
;#include <string.h>
;#include <delay.h>
;#include "ethcomm.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "io.h"
;#include "log.h"
;#include "logqueue.h"
;#include "debug.h"
;
;//eeprom char     DEVICE_SERIAL[8]    = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
;eeprom char     DEVICE_SERIAL[8]    = {0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x22};
;/*bongkot edit default of serial number*/
;
;TIMER           commLostTimer       = 0;
;unsigned char   duplicateListClear  = 0;
;
;struct log_wait_st    logDataWait   = {0x00,0x00};
;struct log_wait_st    logEventWait  = {0x00,0x00};
;
;/**************************************************************/
;/***** Higher Level Communication Management (IMS_Protocol)****/
;/**************************************************************/
;/*============================================================*/
;//int ETH_sendNack(char frameID,char errCode)
;//{
;//    int     i=0,k=0;
;//    char    frameData[2+sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = PROTOERROR;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = errCode;
;//
;//    printDebug("<ETH_sendNack> sending..\r\n");
;//    //print_payload(frameData,i);
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendStatusRequestAck(char frameID,char accm,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[7+sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = STATREQA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accm;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendStatusRequestAck> sending..\r\n");
;//    //print_payload(frameData,i);
;//
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//
;//}
;///*============================================================*/
;//int ETH_sendStatusReportCmd(unsigned long int timestamp, unsigned char accm, unsigned char *paraResp, int paraLen)
;//{
;//    int     i=0,k=0;
;//    int     frameLen    = 0;
;//    char    *frameData;
;//
;//    frameLen            = 1 + sizeof(DEVICE_SERIAL) + sizeof(timestamp) + sizeof(accm) + paraLen;
;//    if(frameLen > 250){
;//        printDebug("<ETH_sendStatusReportCmd> frameLen too long (%d bytes)\r\n",frameLen);
;//        return -1;
;//    }
;//
;//    frameData           = (char *) malloc (frameLen);
;//    if(frameData == NULL){
;//        printDebug("<ETH_sendStatusReportCmd> malloc failed (%d bytes)\r\n",frameLen);
;//        return -1;
;//    }
;//
;//    frameData[i++]      = STATREPC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    memcpy(&frameData[i],&timestamp,sizeof(timestamp));
;//    i += sizeof(timestamp);
;//
;//    frameData[i++]      = accm;
;//
;//    memcpy(&frameData[i],paraResp,paraLen);
;//    i += paraLen;
;//
;//    ETH_send(frameData,i,0x00,CMD_TIMEOUT);
;//    free( frameData );
;//}
;///*============================================================*/
;//int ETH_sendEventReportCmd(char eventType, unsigned long int timestamp, char eventID, char statusCode)
;//{
;//    int     i=0,k=0,res=0;
;//    char    frameID;
;//    char    frameData[8 + sizeof(DEVICE_SERIAL)];
;//
;//    if((eventType != TYP_RLT) && (eventType != TYP_LOG) && (eventType != TYP_SAV))
;//    {
;//        printDebug("<ETH_sendEventReportCmd> Wrong eventType 0x%02X\r\n", eventType);
;//        return -1;
;//    }
;//
;//    frameData[i++]      =   EVENREPC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    memcpy(&frameData[i],&timestamp,sizeof(timestamp));
;//    i += sizeof(timestamp);
;//
;//    frameData[i++]      =   eventType;
;//    frameData[i++]      =   eventID;
;//    frameData[i++]      =   statusCode;
;//
;//    frameID             = ETH_generateId();
;//
;//    if(eventType == TYP_RLT)
;//    {
;//        res = addEventLogQueue(frameID,timestamp,eventID,statusCode);
;//        if(res < 0)
;//        {
;//            printDebug("<ETH_sendEventReportCmd> addEventLogQueue(0x%02X,%ld,0x%02X,0x%02X) failed\r\n",
;//                        frameID,timestamp,eventID,statusCode);
;//        }
;//    }
;//    else if(eventType == TYP_LOG)
;//    {
;//        logEventWait.frameID = frameID;
;//    }
;//
;//    printDebug("<ETH_sendEventReportCmd> sending..\r\n");
;//    print_payload(frameData,i);
;//
;//    res = ETH_send(frameData,i,frameID,CMD_TIMEOUT);
;//    if(res < 0){
;//        return -1;
;//    }
;//    else{
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int ETH_sendConfigManageNack(char frameID,char accd,char cnfg,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[4 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = CONFMANA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accd;
;//    frameData[i++]      = cnfg;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendConfigManageNack> sending..\r\n");
;//    //print_payload(frameData,i);
;//
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendConfigManageAck(char frameID,char accd,char cnfg,char status,char *cnfgData, int cnfgLen)
;//{
;//    int     i=0,k=0;
;//    int     frameLen    = 0;
;//    char    *frameData;
;//
;//
;//    frameLen            = 1 + sizeof(DEVICE_SERIAL) + sizeof(accd) + sizeof(cnfg) + sizeof(status) + cnfgLen;
;//    if(frameLen > 250){
;//        printDebug("<ETH_sendConfigManageAck> frameLen too long (%d bytes)\r\n",frameLen);
;//        ETH_sendConfigManageNack(frameID,accd,cnfg,ERROR);
;//        return -1;
;//    }
;//
;//    frameData           = (char *) malloc (frameLen);
;//    if(frameData == NULL){
;//        printDebug("<ETH_sendConfigManageAck> malloc failed (%d bytes)\r\n",frameLen);
;//        ETH_sendConfigManageNack(frameID,accd,cnfg,ERROR);
;//        return -1;
;//    }
;//
;//    frameData[i++]      = CONFMANA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accd;
;//    frameData[i++]      = cnfg;
;//    frameData[i++]      = status;
;//    if(cnfgLen > 0){
;//        memcpy(&frameData[i],cnfgData,cnfgLen);
;//        i += cnfgLen;
;//    }
;//
;//    printDebug("<ETH_sendConfigManageAck> sending..\r\n");
;//    print_payload(frameData,i);
;//
;//    ETH_send(frameData,i,frameID,0);
;//
;//    free( frameData );
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendDataReportCmd(char dataType, unsigned long int timestamp, unsigned int sensorID, float value)
;//{
;//    int     i=0,k=0,res=0;
;//    char    frameID;
;//    char    frameData[10 + sizeof(DEVICE_SERIAL)];
;//    char    did = 0x00;
;//
;//    if((dataType != TYP_RLT) && (dataType != TYP_LOG) && (dataType != TYP_SAV))
;//    {
;//        printDebug("<ETH_sendDataReportCmd> Wrong dataType 0x%02X\r\n", dataType);
;//        return -1;
;//    }
;//
;//    did     = ((sensorID+1) & 0xff) << 4;
;//    did    |= dataType;
;//
;//    frameData[i++]      =   DATAREPC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    memcpy(&frameData[i],&timestamp,sizeof(timestamp));
;//    i += sizeof(timestamp);
;//
;//    frameData[i++]      =   did;
;//
;//    memcpy(&frameData[i],&value,sizeof(value));
;//    i += sizeof(value);
;//
;//    frameID             = ETH_generateId();
;//
;//    if(dataType == TYP_RLT)
;//    {
;//        res = addDataLogQueue(frameID,timestamp,sensorID,value);
;//        if(res < 0)
;//        {
;//            printDebug("<ETH_sendDataReportCmd> addDataLogQueue(0x%02X,%ld,%u,%.2f) failed\r\n",frameID,timestamp,sensorID,value);
;//        }
;//    }
;//    else if(dataType == TYP_LOG)
;//    {
;//        logDataWait.frameID = frameID;
;//    }
;//
;//    printDebug("<ETH_sendDataReportCmd> sending..\r\n");
;//    //print_payload(frameData,i);
;//
;//    res = ETH_send(frameData,i,frameID,CMD_TIMEOUT);
;//    if(res < 0){
;//        return -1;
;//    }
;//    else{
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int ETH_sendLogManipulationAck(char frameID,char accd,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[3 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = LOGMANIA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = accd;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendLogManipulationAck> sending..\r\n");
;//    //print_payload(frameData,i);
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_sendNetworkMaintenanceAck(char frameID,char cmd,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[3 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = NETMAINA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = cmd;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_sendNetworkMaintenanceAck> sending..\r\n");
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_remoteDeviceControlAck(char frameID,char cmd,char status)
;//{
;//    int     i=0,k=0;
;//    char    frameData[3 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]      = RMDCTRLA;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]      = cmd;
;//    frameData[i++]      = status;
;//
;//    printDebug("<ETH_remoteDeviceControlAck> sending..\r\n");
;//    ETH_send(frameData,i,frameID,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_clearDuplicateRequestCmd(void)
;//{
;//    int     i=0,k=0;
;//    char    frameData[2 + sizeof(DEVICE_SERIAL)];
;//
;//    frameData[i++]  = CLRLISTC;
;//
;//    for(k=0;k<sizeof(DEVICE_SERIAL);k++){
;//        frameData[i++]  = DEVICE_SERIAL[k];
;//    }
;//
;//    frameData[i++]  = CLR_DUPLIST;
;//
;//    printDebug("<ETH_clearDuplicateRequestCmd> sending..\r\n");
;//    ETH_send(frameData,i,0xFF,0);
;//
;//    return 0;
;//}
;///*============================================================*/
;//void ETH_checkPushLog(unsigned char id)
;//{
;//    FIL                 file;
;//    int                 res;
;//    unsigned long int   timestamp;
;//    unsigned int        channel;
;//    float               value;
;//    unsigned char       eventID;
;//    unsigned char       eventStatus;
;//
;//    // -- check if id is in dataLogQueue -- //
;//    res = readDataLogQueue(id,&timestamp,&channel,&value);
;//    if(res != -1)
;//    {
;//        // -- found in dataLogQueue -- //
;//        if( (timestamp == 0) || (timestamp == 0xFFFFFFFF) || (channel > (MAX_SENS_CHANNEL-1)) )
;//        {
;//            printDebug("\r\n<ETH_checkPushLog> === ERROR INFOMATION IN DATA LOG QUEUE ===\r\n");
;//        }
;//        else
;//        {
;//            printDebug("<ETH_checkPushLog> DataLog time[%ld],ch[%d],val[%.2f]\r\n",timestamp,channel,value);
;//            res = LOG_openFile(&file,LOGFILE_DATA);
;//            if(res < 0)
;//            {
;//                printDebug("<ETH_checkPushLog> LOG_openFile(%s) failed, couldn't save log\r\n",LOGFILE_DATA);
;//            }
;//            else
;//            {
;//                res = LOG_insertData(&file,timestamp,channel,value);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_insertData() failed\r\n");
;//                }
;//
;//                res = LOG_closeFile(&file);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_closeFile() failed\r\n");
;//                }
;//
;//                printDebug("<ETH_checkPushLog> Inserted Data Log\r\n");
;//            }
;//        }
;//
;//        //isDataLogEmpty = 0;
;//        removeDataLogQueue(id);
;//    }
;//
;//    // -- check if id is in eventLogQueue -- //
;//    res = readEventLogQueue(id,&timestamp,&eventID,&eventStatus);
;//    if(res != -1)
;//    {
;//        // -- found in eventLogQueue -- //
;//        if( (timestamp == 0) || (timestamp == 0xFFFFFFFF) )
;//        {
;//            printDebug("\r\n<ETH_checkPushLog> === ERROR INFOMATION IN EVENT LOG QUEUE ===\r\n");
;//        }
;//        else{
;//
;//            res = LOG_openFile(&file,LOGFILE_EVENT);
;//            if(res < 0)
;//            {
;//                printDebug("<ETH_checkPushLog> LOG_openFile(%s) failed, couldn't save log\r\n",LOGFILE_EVENT);
;//            }
;//            else
;//            {
;//                printDebug("<ETH_checkPushLog> EventLog time[%ld],id[0x%02X],stat[0x%02X]\r\n",timestamp,eventID,eventStatus);
;//                res = LOG_insertEvent(&file,timestamp,eventID,eventStatus);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_insertData() failed\r\n");
;//                }
;//
;//                res = LOG_closeFile(&file);
;//                if(res < 0)
;//                {
;//                    printDebug("<ETH_checkPushLog> LOG_closeFile() failed\r\n");
;//                }
;//
;//                printDebug("<ETH_checkPushLog> Inserted Event Log\r\n");
;//            }
;//
;//        }
;//
;//        //isEventLogEmpty    = 0;
;//        removeEventLogQueue(id);
;//    }
;//
;//    return;
;//}
;///*============================================================*/
;//void ETH_retransmit(void)
;//{
;//    int i;
;//
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++)
;//    {
;//        if( TIMER_checkTimerExceed(eth_waitQueue[i].retryTime) &&
;//            (eth_waitQueue[i].packetID != 0))
;//        {
;//            if(eth_waitQueue[i].retryCount >= ETH_MAX_RETRY)
;//            {
;//                printDebug("<ETH_retransmit> packet [0x%02X] Expired\r\n",eth_waitQueue[i].packetID);
;//
;//                if(eth_waitQueue[i].packetID == logDataWait.frameID){
;//                    printDebug("<ETH_retransmit> update logData timeout\r\n");
;//                    logDataWait.frameID = 0x00;
;//                }
;//                else if(eth_waitQueue[i].packetID == logEventWait.frameID){
;//                    printDebug("<ETH_retransmit> update logEvent timeout\r\n");
;//                    logEventWait.frameID = 0x00;
;//                }
;//                else{
;//                    // ---- Push in log here ---- //
;//                    ETH_checkPushLog(eth_waitQueue[i].packetID);
;//                    // -------------------------- //
;//                }
;//
;//                ETH_removeWaitQueue(eth_waitQueue[i].packetID);
;//
;//                printDebug("<ETH_retransmit> commLostTimer = %ld(%lX)\r\n",commLostTimer,commLostTimer);
;//                if((commLostTimer == 0xFFFFFFFF) || (commLostTimer == 0)){
;//                    TIMER_setTimer(&commLostTimer,30);
;//                    printDebug("<ETH_retransmit> LostTimer time left = %ld(%lX)\r\n",(commLostTimer-baseCounter),(commLostTimer-baseCounter));
;//                }
;//            }
;//            else
;//            {
;//                TIMER_setTimer(&(eth_waitQueue[i].retryTime), eth_waitQueue[i].timeout);
;//                eth_waitQueue[i].retryCount++;      // increase retry counter
;//
;//                printDebug("\r\n<ETH_retransmit> --Retransmitting-- [0x%02X]\r\n",eth_waitQueue[i].packetID);
;//
;//                write_uart0(    eth_waitQueue[i].packetData,
;//                                eth_waitQueue[i].packetLen);
;//            }
;//        }
;//    }
;//    return;
;//}
;///*============================================================*/
;//void ETH_processPacket(unsigned char *ptr2frame,int len)
;//{
;//    FIL             file;
;//    unsigned char   frameType;
;//    int             res=0;
;//    unsigned char   frameID;
;//    int             payload;            // -- pointer to payload data extracted from a frame -- //
;//
;//    int             cnfgRd;             // -- for keeping read configuration -- //
;//    char            *cnfgWr;
;//
;//    int             i;
;//
;////    printDebug("\r\n\r\n****** processPacket ******\r\n");
;////    print_payload(ptr2frame,len);
;////    printDebug("\r\n******************\r\n");
;//    frameID         = ptr2frame[0];
;//    frameType       = ptr2frame[1];
;//
;//    commLostTimer   = 0xFFFFFFFF;                     // -- cancel communication lost timer -- //
;//    //commLostTimer   = 0;                            // -- re-initial -- //
;//
;//    switch(frameType){
;//        case STATREQC  :     // -- Status Request COMMAND
;//            if( len < (2 + sizeof(struct stat_req_st) - (sizeof(unsigned int) + sizeof(unsigned char *)) ) ){
;//                printDebug("<ETH_processPacket> status request invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (len);
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc() failed\r\n");
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = statusRequestParser(ptr2frame+2,len-2,(struct stat_req_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> statusRequestParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--statusRequestParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("accessMethod    [0x%02X]\r\n",      ((struct stat_req_st *)payload)->accm);
;//            printDebug("interval        [0x%04X] = %d\r\n", ((struct stat_req_st *)payload)->intv,((struct stat_req_st *)payload)->intv);
;//            printDebug("statusList      |");
;//
;//            for( i=0 ; i<(((struct stat_req_st *)payload)->parLen) ; i++)
;//            {
;//                printDebug("%02X|",(((struct stat_req_st *)payload)->parlst)[i++]);
;//            }
;//            printDebug("\r\n-- ..Done.. --\r\n");
;//
;//            ETH_sendStatusRequestAck(frameID,((struct stat_req_st *)payload)->accm,0x00);
;//
;//            if( ((struct stat_req_st *)payload)->accm < 0x30){
;//                free_statusRequest((struct stat_req_st *)payload);
;//            }
;//
;//            free( (void *) payload );
;//            break;
;//        case STATREPA  :     // -- Status Report ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct stat_rep_st)) ){
;//                printDebug("<ETH_processPacket> status report invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            printDebug("\r\n--statusReportParser-- ACK [0x%02X]\r\n",frameID);
;//            printDebug("unixTime        [0x%02X][0x%02X][0x%02X][0x%02X]\r\n",
;//                                    ptr2frame[10],ptr2frame[11],ptr2frame[12],ptr2frame[13]);
;//            res = setTimeSyncSchema( &ptr2frame[10] );
;//            if(res < 0){
;//                //printDebug("<ETH_processPacket> setTimeSyncSchema() failed in STATREPA\r\n");
;//            }
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case EVENREPA  :     // -- Event Report ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct event_rep_st)) ){
;//                printDebug("<ETH_processPacket> event report invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            printDebug("\r\n--eventReportParser-- ACK [0x%02X]\r\n", frameID);
;//            if( (logEventWait.frameID != 0) && (frameID == logEventWait.frameID) )
;//            {
;//                printDebug("<ETH_processPacket> got event log ack\r\n");
;//
;//                res = LOG_openFile(&file,LOGFILE_EVENT);
;//                if(res < 0){        printDebug("<logReport> LOG_openFile(%s) failed\r\n",LOGFILE_EVENT);            }
;//                else
;//                {
;//                    res = LOG_setLastSend(&file,logEventWait.logID + 1);
;//                    if(res < 0){    printDebug("<LOG_readData> LOG_setLastSend() failed\r\n");                      }
;//                    else{           printDebug("<LOG_readData> LOG_setLastSend(%s,%ld)\r\n",LOGFILE_EVENT,logEventWait.logID + 1);   }
;//
;//                    res = LOG_closeFile(&file);
;//                    if(res < 0){    printDebug("<logReport> LOG_closeFile(%s) failed\r\n",LOGFILE_EVENT);           }
;//                }
;//
;//                logEventWait.frameID    = 0;
;//                logEventWait.logID      = 0;
;//            }
;//            removeEventLogQueue(frameID);
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case CONFMANC  :     // -- Configuration Management COMMAND
;//            printDebug("<ETH_processPacket> Config Manage\r\n");
;//            print_payload(ptr2frame, len);
;//
;//            if( len < (2 + sizeof(struct conf_man_st) - (sizeof(unsigned int) + sizeof(unsigned char *)) ) ){
;//                printDebug("<ETH_processPacket> configuration management invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct conf_man_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct conf_man_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = configManageParser(ptr2frame+2,len-2,(struct conf_man_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> configManageParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--configManageParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("accd            [0x%02X]\r\n",       ((struct conf_man_st *)payload)->accd);
;//            printDebug("cnfg            [0x%02X]\r\n",       ((struct conf_man_st *)payload)->cnfg);
;//
;//            switch( ((struct conf_man_st *)payload)->accd ){
;//                case CONF_RD_CMD    :   // -- Configration Read -- //
;//                                        res = getConfigLen(((struct conf_man_st *)payload)->cnfg);
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> getConfigLen() failed\r\n");
;//                                            ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            break;
;//                                        }
;//
;//                                        cnfgRd = (int) malloc (res);
;//                                        if(cnfgRd == NULL){
;//                                            printDebug("<ETH_processPacket> cnfgRd malloc() failed\r\n");
;//                                            ETH_sendNack(frameID,NOT_READY);
;//                                            break;
;//                                        }
;//
;//                                        res = configRead(((struct conf_man_st *)payload)->cnfg,(char *) cnfgRd);
;//                                        if(res <= 0){
;//                                            printDebug("<ETH_processPacket> configRead() failed\r\n");
;//                                            if(res == -1){
;//                                                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            }
;//                                            else if((res == -2) || (res == 0)){
;//                                                ETH_sendNack(frameID,NOT_READY);
;//                                            }
;//                                            else if(res == -3){
;//                                                ETH_sendConfigManageNack(   frameID,
;//                                                                            ((struct conf_man_st *)payload)->accd,
;//                                                                            ((struct conf_man_st *)payload)->cnfg,
;//                                                                            ERROR);
;//                                            }
;//                                            else{
;//                                                ETH_sendNack(frameID,UNKNOWN_ERROR);
;//                                            }
;//
;//                                            free((void *) cnfgRd);
;//                                            break;
;//                                        }
;//
;//                                        res = ETH_sendConfigManageAck(  frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        SUCCESS,
;//                                                                        (char *)cnfgRd,
;//                                                                        res  );
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> RD_CMD : ETH_sendConfigManageAck() failed\r\n");
;//                                        }
;//
;//                                        free( (void *) cnfgRd );
;//                                        break;
;//                case CONF_WR_CMD    :   // -- Configuration Write -- //
;//                                        cnfgWr = malloc(((struct conf_man_st *)payload)->confLen);
;//                                        if(cnfgWr == NULL){
;//                                            printDebug("<ETH_processPacket> cnfgWr malloc() failed\r\n");
;//                                            ETH_sendNack(frameID,NOT_READY);
;//                                            break;
;//                                        }
;//
;//                                        memcpy(cnfgWr,((struct conf_man_st *)payload)->confSpec,((struct conf_man_st *)payload)->confLen);
;//
;//                                        res = configWrite(  (unsigned char) (((struct conf_man_st *)payload)->cnfg),
;//                                                            cnfgWr,
;//                                                            (int) (((struct conf_man_st *)payload)->confLen) );
;//
;//                                        free(cnfgWr);
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> configWrite() failed\r\n");
;//                                            ETH_sendConfigManageNack(   frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        ERROR);
;//                                            break;
;//                                        }
;//
;//
;//                                        res = ETH_sendConfigManageAck(  frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        SUCCESS,
;//                                                                        NULL,
;//                                                                        0  );
;//                                        if(res < 0){
;//                                            printDebug("WARN : <ETH_processPacket> WR_CMD : ETH_sendConfigManageAck() failed\r\n");
;//                                        }
;//
;//                                        break;
;//                case CONF_CF_CMD    :   // -- Configuration Confirm -- //
;//                                        res = configConfirm();
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> configConfirm() failed\r\n");
;//                                            ETH_sendConfigManageNack(   frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        ERROR);
;//                                            break;
;//                                        }
;//
;//                                        res = ETH_sendConfigManageAck(  frameID,
;//                                                                        ((struct conf_man_st *)payload)->accd,
;//                                                                        ((struct conf_man_st *)payload)->cnfg,
;//                                                                        SUCCESS,
;//                                                                        NULL,
;//                                                                        0  );
;//                                        if(res < 0){
;//                                            printDebug("WARN : <ETH_processPacket> WR_CMD : ETH_sendConfigManageAck() failed\r\n");
;//                                        }
;//
;//                                        break;
;//                default             :   // -- Shouldn't reach here -- //
;//                                        printDebug("<ETH_processPacket> unknown type for config->accd [0x%02X]\r\n",
;//                                                        ((struct conf_man_st *)payload)->accd );
;//                                        ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                        break;
;//            }
;//
;//            free_configManage((struct conf_man_st *)payload);
;//            free( (void *) payload );
;//
;//            break;
;//        case DATAREPA  :     // -- Data Report ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct data_rep_st)) ){
;//                printDebug("<ETH_processPacket> Data report invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            printDebug("\r\n--dataReportParser-- ACK [0x%02X]\r\n",frameID);
;//            if( (logDataWait.frameID != 0) && (frameID == logDataWait.frameID) )
;//            {
;//                printDebug("<ETH_processPacket> got data log ack\r\n");
;//
;//                res = LOG_openFile(&file,LOGFILE_DATA);
;//                if(res < 0){        printDebug("<logReport> LOG_openFile(%s) failed\r\n",LOGFILE_DATA);             }
;//                else
;//                {
;//                    res = LOG_setLastSend(&file,logDataWait.logID + 1);
;//                    if(res < 0){    printDebug("<LOG_readData> LOG_setLastSend() failed\r\n");                      }
;//                    else{           printDebug("<LOG_readData> LOG_setLastSend(%s,%ld)\r\n",LOGFILE_DATA,logDataWait.logID + 1);    }
;//
;//                    res = LOG_closeFile(&file);
;//                    if(res < 0){    printDebug("<logReport> LOG_closeFile(%s) failed\r\n",LOGFILE_DATA);            }
;//                }
;//
;//                logDataWait.frameID    = 0;
;//                logDataWait.logID      = 0;
;//            }
;//            removeDataLogQueue(frameID);
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case LOGMANIC  :     // -- Log Manipulation COMMAND
;//            if( len < (2 + sizeof(struct log_manic_st)) ){
;//                printDebug("<ETH_processPacket> log manipulation (CMD) invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct log_manic_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct log_manic_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = logManipulationCmdParser(ptr2frame+2,len-2,(struct log_manic_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> logManipulationCmdParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--logManipulationCmdParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("accd            [0x%02X]\r\n",  ((struct log_manic_st *)payload)->accd);
;//            printDebug("tStart          [%ld]\r\n",     ((struct log_manic_st *)payload)->tStart);
;//            printDebug("tStop           [%ld]\r\n",     ((struct log_manic_st *)payload)->tStop);
;//
;//            res = setLogManipulateSchema(   ((struct log_manic_st *)payload)->accd,
;//                                            ((struct log_manic_st *)payload)->tStart,
;//                                            ((struct log_manic_st *)payload)->tStop);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> setLogManipulateSchema() failed\r\n");
;//                ETH_sendLogManipulationAck(frameID,((struct log_manic_st *)payload)->accd,ERROR);
;//            }
;//
;//            ETH_sendLogManipulationAck(frameID,((struct log_manic_st *)payload)->accd,SUCCESS);
;//
;//            free( (void *) payload );
;//
;//            break;
;//        case LOGMANIA  :     // -- Log Manipulation ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct log_mania_st)) ){
;//                printDebug("<ETH_processPacket> log manipulation (ACK) invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct log_mania_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct log_mania_st));
;//                return;
;//            }
;//
;//            res = logManipulationAckParser(ptr2frame+2,(struct log_mania_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> logManipulationCmdParser() failed\r\n");
;//                free( (void *) payload );
;//                return;
;//            }
;//
;//            printDebug("\r\n--logManipulationAckParser-- ACK [0x%02X]\r\n",frameID);
;//            printDebug("accd            [0x%02X]\r\n",  ((struct log_mania_st *)payload)->accd);
;//            printDebug("status          [%ld]\r\n",     ((struct log_mania_st *)payload)->status);
;//
;//            free( (void *) payload );
;//            ETH_removeWaitQueue(frameID);
;//            break;
;//        case NETMAINC  :     // -- Network Maintenance COMMAND
;//            if( len < (2 + sizeof(struct netw_man_st) - (sizeof(unsigned int) + sizeof(unsigned char *)) + 1 ) ){
;//                printDebug("<ETH_processPacket> network maintenance invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct netw_man_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct netw_man_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = networkMaintenanceParser(ptr2frame+2,len-2,(struct netw_man_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> networkMaintenanceParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--networkMaintenanceParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("cmd             [0x%02X]\r\n",  ((struct netw_man_st *)payload)->cmd);
;//            printDebug("dataLen         [%d]\r\n",      ((struct netw_man_st *)payload)->dataLen);
;//            if( ((struct netw_man_st *)payload)->dataLen > 0 ){
;//                printDebug("data ---        \r\n");
;//                print_payload(((struct netw_man_st *)payload)->data,((struct netw_man_st *)payload)->dataLen);
;//                printDebug("--------\r\n");
;//            }
;//
;//            switch(((struct netw_man_st *)payload)->cmd){
;//                case NETW_TIME_SYNC :   res = setTimeSyncSchema( ((struct netw_man_st *)payload)->data );
;//                                        if(res < 0){
;//                                            printDebug("<ETH_processPacket> setTimeSyncSchema() failed\r\n");
;//                                            ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            free_networkMaintenance((struct netw_man_st *)payload);
;//                                            free( (void *) payload );
;//                                            return;
;//                                        }
;//
;//                                        res = ETH_sendNetworkMaintenanceAck(frameID,((struct netw_man_st *)payload)->cmd,SUCCESS);
;//
;//                                        if(res < 0){
;//                                            printDebug("WARN : <ETH_processPacket> NETW_TIME_SYNC : ETH_sendNetworkMaintenanceAck() failed\r\n");
;//                                        }
;//
;//                                        break;
;//                default :               // -- Shouldn't reach here -- //
;//                                        printDebug("<ETH_processPacket> unknown type for config->accd [0x%02X]\r\n",
;//                                                        ((struct netw_man_st *)payload)->cmd );
;//                                        ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                        break;
;//            }
;//
;//            if( ((struct netw_man_st *)payload)->dataLen > 0 ){
;//                free_networkMaintenance((struct netw_man_st *)payload);
;//            }
;//
;//            free( (void *) payload );
;//
;//            break;
;//        case RMDCTRLC  :     // -- Remote Device Control COMMAND
;//            if( len < (2 + sizeof(struct rem_dev_ctrl_st)) ){
;//                printDebug("<ETH_processPacket> remote device control invalid length (%d)\r\n",len);
;//                ETH_sendNack(frameID,INVALID_LENGTH);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct rem_dev_ctrl_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct rem_dev_ctrl_st));
;//                ETH_sendNack(frameID,NOT_READY);
;//                return;
;//            }
;//
;//            res = remoteDeviceControlParser(ptr2frame+2,(struct rem_dev_ctrl_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> remoteDeviceControlParser() failed\r\n");
;//                free( (void *) payload );
;//                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                return;
;//            }
;//
;//            printDebug("\r\n--remoteDeviceControlParser-- CMD [0x%02X]\r\n",frameID);
;//            printDebug("cmd             [0x%02X]\r\n",  ((struct rem_dev_ctrl_st *)payload)->cmd);
;//            printDebug("value           [%ld]\r\n",      ((struct rem_dev_ctrl_st *)payload)->value);
;//
;//            switch(((struct rem_dev_ctrl_st *)payload)->cmd){
;//                case DEVCTRL_MUTE_ALARM :   res = setMuteAlarm( ((struct rem_dev_ctrl_st *)payload)->value );
;//                                            if(res < 0){
;//                                                printDebug("<ETH_processPacket> setTimeSyncSchema(%ld) failed\r\n",((struct rem_dev_ctrl_st *)payload)->value);
;//                                                ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                                free( (void *) payload );
;//                                                return;
;//                                            }
;//
;//                                            res = ETH_remoteDeviceControlAck(frameID,((struct rem_dev_ctrl_st *)payload)->cmd,SUCCESS);
;//
;//                                            if(res < 0){
;//                                                printDebug("WARN : <ETH_processPacket> DEVCTRL_MUTE_ALARM : ETH_remoteDeviceControlAck() failed\r\n");
;//                                            }
;//                                            break;
;//                default :                   // -- Shouldn't reach here -- //
;//                                            printDebug("<ETH_processPacket> unknown type for config->accd [0x%02X]\r\n",
;//                                                            ((struct netw_man_st *)payload)->cmd );
;//                                            ETH_sendNack(frameID,INVALID_PARAMETER);
;//                                            break;
;//            }
;//
;//            free( (void *) payload );
;//            break;
;//        case CLRLISTA  :     // -- Clear List ACKNOWLEDGE
;//            if( len < (2 + sizeof(struct clr_lst_st)) ){
;//                printDebug("<ETH_processPacket> clear list ACK invalid length (%d)\r\n",len);
;//                return;
;//            }
;//
;//            payload = (int) malloc (sizeof(struct clr_lst_st));
;//            if(payload == NULL){
;//                printDebug("<ETH_processPacket> payload malloc(%d) failed\r\n",sizeof(struct clr_lst_st));
;//                return;
;//            }
;//
;//            res = clearListParser(ptr2frame+2,(struct clr_lst_st *)payload);
;//            if(res < 0){
;//                printDebug("<ETH_processPacket> clearListParser() failed\r\n");
;//                free( (void *) payload );
;//                return;
;//            }
;//
;//            printDebug("\r\n--clearListParser-- ACK [0x%02X]\r\n",frameID);
;//            printDebug("cmd             [0x%02X]\r\n",  ((struct clr_lst_st *)payload)->cmd);
;//            printDebug("status          [0x%02X]\r\n",  ((struct clr_lst_st *)payload)->status);
;//
;//            switch(((struct clr_lst_st *)payload)->cmd){
;//                case CLR_DUPLIST :  if(((struct clr_lst_st *)payload)->status == 0x00)
;//                                    {
;//                                        printDebug("<ETH_processPacket> clear duplicate request (ACK) SUCCESS!!\r\n");
;//                                        duplicateListClear = 1;
;//                                        free( (void *) payload );
;//                                        return;
;//                                    }
;//                                    else
;//                                    {
;//                                        printDebug("<ETH_processPacket> clear duplicate request (ACK) FAILED[0x%02X]!!\r\n",
;//                                                    ((struct clr_lst_st *)payload)->status);
;//                                    }
;//                                    break;
;//                default         :   // -- Shouldn't reach here -- //
;//                                    printDebug("<ETH_processPacket> unknown type for clr_lst_st->cmd [0x%02X]\r\n",
;//                                                    ((struct clr_lst_st *)payload)->cmd );
;//                                    break;
;//            }
;//
;//            free( (void *) payload );
;//            break;
;//        case FMWUPLDC  :     // -- Firmware Upload COMMAND (Reserved)
;//            printDebug("<ETH_processPacket> firmware upload hasn't supported yet\r\n");
;//            break;
;//        default:
;//            printDebug("\r\n<ETH_processPacket> invalid frame type ( %02X )!!\r\n",frameType);
;//            break;
;//    }
;//
;//    return;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///************* Low level Communication Management *************/
;///**************************************************************/
;///*============================================================*/
;//void ETH_receive()
;//{
;//    unsigned char   *ptr;
;//    int             size=0;
;//
;//    // -- for packet validation -- //
;//    int     offset=0;
;//    int     len = 0x0000;
;//    int     total=0;
;//
;//    // --------------- Process Xbee Data ---------------- // UART0
;//    do{
;//        ptr = (char *) malloc (RX_BUFFER_SIZE0);
;//        if(ptr == NULL){
;//            printDebug("<ETH_receive> malloc..FAILED..\r\n");
;//        }
;//    }while(ptr == NULL);
;//    size = read_uart0(ptr,RX_BUFFER_SIZE0-1,10);
;//
;//    if(size <= 0){
;//        free( ptr );
;//        return;
;//    }
;//
;//    printDebug("\r\n\r\n+++++++ Raw buffer +++++++\r\n");
;//    print_payload(ptr,size);
;//
;//    do{
;//        //printDebug("<ETH_receive> ptr");
;//        offset += strcspn(&ptr[offset],"\x7e");                                   // seach for header
;//        if(offset == size){
;////            printDebug("<ETH_receive> invalid packet 0x7E not found\r\n");    // not found Start Delimiter 0x7E
;//            break;
;//        }
;//        len = (ptr[offset+1] & 0xffff) << 8;                                    // check packet length (MSB)
;//        len |= ptr[offset+2];                                                   // check packet length (LSB)
;////        printDebug("len = [0x%04X](%d)\r\n",len,len);
;//
;//        total += len;                                                           // update total analyse
;//        if (total > size){                                                      //check length validation
;//            offset++;
;//            total = offset;                                                     // roll back total analyse
;//            printDebug("\r\ninvalid length!!\r\n");
;//            continue;
;//        }
;//
;////        printDebug("\r\n****** packet checksum ******\r\n");
;////        print_payload(&ptr[offset+3],len);
;//        if(ETH_checksum(&ptr[offset+3],len) != ptr[offset+3+len]){              // checksum error detection
;//            printDebug("<ETH_receive> checksum error\r\n");
;//            offset++;
;//            total = offset;                                                     // roll back total analyse
;//        }
;//        else{                                                                   // got a valid packet
;////            printDebug("\r\n****** checksum correct ******\r\n");
;////            print_payload(&ptr[offset+3],len);
;////            printDebug("\r\n******************\r\n");
;//
;//            ETH_processPacket(&ptr[offset+3],len);                              // analyse API-specific Structure
;//            offset += 3+len;
;//        }
;//	}while( total < size);						                                // loop if still unread byte
;//
;//
;//
;//    free( ptr );
;//}
;///*============================================================*/
;//int ETH_send(char *frameData, int frameLen, char frameID, int timeout)
;//{
;//    int     res;
;//    char    *sendPacket;
;//    int     packetLen   = 0;
;//
;//    frameLen++;     // -- + frameID (1 Byte) -- //
;//
;//    packetLen   = frameLen + 2 + 1 + 1;       // length(2 bytes) + frameID(1 byte) + header(1 byte) + sum(1 byte)
;//
;//    if(packetLen > MAX_MTU){
;//        printDebug("<ETH_send> WARNING : Packet is too long(%d bytes)\r\n",packetLen);
;//        return -1;
;//    }
;//
;//    sendPacket  = (char *) malloc ( packetLen );
;//    if(sendPacket == NULL){
;//        printDebug("<ETH_send> WARNING : ETH_send malloc failed (%d)\r\n",packetLen);
;//        return -1;
;//    }
;//
;//    memset(sendPacket,'\0',packetLen);
;//
;//    sendPacket[0] = 0x7E;
;//    sendPacket[1] = (frameLen >> 8) & 0xFF;
;//    sendPacket[2] = frameLen & 0xFF;
;//
;//    if(frameID == 0x00){
;//        frameID         = ETH_generateId();
;//        //printDebug("<ETH_send> ETH_generateId() return 0x%02X\r\n",frameID);
;//    }
;//
;//    sendPacket[3] = frameID;
;//
;//    memcpy(&sendPacket[4],frameData,frameLen);
;//    sendPacket[packetLen-1] = ETH_checksum(&sendPacket[3],frameLen);
;//
;//    //printDebug("<ETH_send> checksum = 0x%02X\r\n",sendPacket[packetLen-1]);
;//
;//    if((timeout > 0) && (frameID != 0xFF)){
;//        res = ETH_addWaitQueue(frameID, &sendPacket[0], packetLen, timeout);
;//        if(res < 0){
;//            printDebug("<ETH_send> ETH_addWaitQueue() failed [id:0x%02X]\r\n",frameID);
;//            free(sendPacket);
;//            return -1;
;//        }
;//    }
;//
;//
;////    if((commLostTimer == 0xFFFFFFFF) || (commLostTimer == 0)){
;////        TIMER_setTimer(&commLostTimer,30);
;////    }
;//
;//    printDebug("\r\n--Transmitting [0x%02X]\r\n",frameID);
;//    print_payload(sendPacket,packetLen);
;//
;//    write_uart0(sendPacket,packetLen);
;//    free(sendPacket);
;//
;//    //printDebug("-- Completed --\r\n");
;//    delay_ms(7);
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ETH_checksum(char buf[],int len)
;//{
;//    int i;
;//    char sum = 0;
;//
;//    //printDebug("<checksum> \r\n");
;//    for (i=0;i<len;i++){
;//        sum += buf[i];
;//        //printDebug("<0x%02X> -> [0x%02X]\r\n",buf[i],sum);
;//    }
;//    return (0xff - (sum & 0xff));
;//
;//}
;///*============================================================*/
;//
;/**************************************************************/
;/***************** Ethernet Hardare Management ****************/
;/**************************************************************/
;/*============================================================*/
;char ETH_current_mode;
;char ETH_switchMode(char mode)
; 0009 049F {

	.CSEG
; 0009 04A0     if(mode == MODE_CONF){
;	mode -> Y+0
; 0009 04A1         printDebug("<ETH_switchMode> switch to Config mode\r\n");
; 0009 04A2         ETH_CONF;
; 0009 04A3     }
; 0009 04A4     else{
; 0009 04A5         printDebug("<ETH_switchMode> switch to Normal mode\r\n");
; 0009 04A6         ETH_NORM;
; 0009 04A7     }
; 0009 04A8 
; 0009 04A9     delay_ms(5);
; 0009 04AA 
; 0009 04AB     ETH_current_mode = mode;
; 0009 04AC 
; 0009 04AD     delay_ms(5);
; 0009 04AE     ETH_OFF;
; 0009 04AF     delay_ms(1500);
; 0009 04B0     ETH_ON;
; 0009 04B1     #asm("wdr")
; 0009 04B2     delay_ms(2000);
; 0009 04B3 
; 0009 04B4     return ETH_MODE;
; 0009 04B5 }
;///*============================================================*/
;//int ETH_getConfig(unsigned char *ptr, unsigned int *buflen)
;//{
;//    TIMER   timeout;
;//    char    getInfoCmd[] = ">R\r";
;//    int     i=0;
;//
;//    ETH_switchMode((unsigned char) MODE_CONF);
;//    /*
;//    if(mode != MODE_CONF){
;//        printDebug("<ETH_getConfig> ETH_switchMode(MODE_CONF) failed\r\n");
;//        return -1;
;//    }
;//    */
;//
;//    for(i=0;i<CONF_READ_BUFFER;i++){
;//        configRd[i] = 0x00;
;//    }
;//    configLen       = 0;
;//    config_start    = 0;
;//    config_ready    = 0;
;//    config_end      = 0;
;//    config_response = 0;
;//
;//    printDebug("<ETH_getConfig> Write to uart 0 :");
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar3(getInfoCmd[i]);
;//    }
;//    printDebug("\r\n");
;//
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar0(getInfoCmd[i]);
;//    }
;//
;//    TIMER_setTimer(&timeout, 7);
;//
;//    while( (!config_ready) && !TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//    }
;//
;//    memcpy(ptr,&configRd[0],configLen);
;//
;//    *buflen    = configLen;
;//
;//    ETH_switchMode(MODE_NORM);
;//
;//    /*
;//    if(mode != MODE_NORM){
;//        printDebug("<ETH_getConfig> ETH_switchMode(MODE_NORM) failed\r\n");
;//        return -1;
;//    }
;//    */
;//
;//    if(config_response == 'S'){
;//        return 0;
;//    }
;//    else{
;//        return -1;
;//    }
;//}
;///*============================================================*/
;//int ETH_setConfig(char *ip, char *mask, char *gw, char *server)
;//{
;//    TIMER   timeout;
;//    char    getInfoCmd[] = ">R\r";
;//    char    setInfoCmd[] = ">W";
;//    int     i=0;
;//    char    setStr[30];
;//    int     readLen=0;
;//    char    *ptr;
;//
;//    ptr = (unsigned char *) malloc( sizeof(char) * CONF_READ_BUFFER );
;//    if(ptr == NULL){
;//        printDebug("<ETH_setConfig> malloc(CONF_READ_BUFFER) failed\r\n");
;//        return -1;
;//    }
;//
;//    ETH_switchMode((unsigned char) MODE_CONF);
;//
;//    // ------------------------- Read Old Configuration --------------------------- //
;//    for(i=0;i<CONF_READ_BUFFER;i++){
;//        configRd[i] = 0x00;
;//    }
;//    configLen       = 0;
;//    config_start    = 0;
;//    config_ready    = 0;
;//    config_end      = 0;
;//    config_response = 0;
;//
;//    printDebug("<ETH_setConfig> Write to uart 0 :");
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar3(getInfoCmd[i]);
;//    }
;//    printDebug("\r\n");
;//
;//    for(i=0;i<strlen(getInfoCmd);i++){
;//        putchar0(getInfoCmd[i]);
;//    }
;//
;//    TIMER_setTimer(&timeout, 7);
;//
;//    while( (!config_ready) && !TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//    }
;//
;//    memcpy(ptr,&configRd[0],configLen);
;//    readLen = configLen;
;//
;//    if(config_response != 'S'){
;//        printDebug("<ETH_setConfig> read config from ETH module failed\r\n");
;//        free( ptr );
;//        return -1;
;//    }
;//
;//    // ------------------------- Update Configuration --------------------------- //
;//    sprintf(setStr,"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
;//                (ip[0]    *100) + (ip[1]     *10) + ip[2],
;//                (ip[3]    *100) + (ip[4]     *10) + ip[5],
;//                (ip[6]    *100) + (ip[7]     *10) + ip[8],
;//                (ip[9]    *100) + (ip[10]    *10) + ip[11],
;//                (mask[0]  *100) + (mask[1]   *10) + mask[2],
;//                (mask[3]  *100) + (mask[4]   *10) + mask[5],
;//                (mask[6]  *100) + (mask[7]   *10) + mask[8],
;//                (mask[9]  *100) + (mask[10]  *10) + mask[11],
;//                (gw[0]    *100) + (gw[1]     *10) + gw[2],
;//                (gw[3]    *100) + (gw[4]     *10) + gw[5],
;//                (gw[6]    *100) + (gw[7]     *10) + gw[8],
;//                (gw[9]    *100) + (gw[10]    *10) + gw[11]);
;//
;//    printDebug("<ETH_setConfig> Set String [%s]\r\n",setStr);
;//
;//    memcpy((ptr+14),&setStr[0],24);
;//
;//    sprintf(setStr,"%02X%02X%02X%02X",
;//                (server[0]*100) + (server[1] *10) + server[2],
;//                (server[3]*100) + (server[4] *10) + server[5],
;//                (server[6]*100) + (server[7] *10) + server[8],
;//                (server[9]*100) + (server[10]*10) + server[11]);
;//
;//    printDebug("<ETH_setConfig> Set String [%s]\r\n",setStr);
;//
;//    memcpy((ptr+42),&setStr[0],8);
;//
;////    printDebug("<ETH_setConfig> Modified setting msg ---\r\n");
;////    for(i=0;i<configLen;i++){
;////        putchar3(ptr[i]);
;////    }
;////    printDebug("\r\n\---\r\n");
;//
;//    // ------------------------- Set New Configuration --------------------------- //
;//    for(i=0;i<CONF_READ_BUFFER;i++){
;//        configRd[i] = 0x00;
;//    }
;//    configLen       = 0;
;//    config_start    = 0;
;//    config_ready    = 0;
;//    config_end      = 0;
;//    config_response = 0;
;//
;//    printDebug("<ETH_setConfig> Setting msg ---\r\n");
;//    for(i=0;i<strlen(setInfoCmd);i++){
;//        putchar0(setInfoCmd[i]);
;//        putchar3(setInfoCmd[i]);
;//    }
;//    for(i=12;i<readLen;i++){
;//        putchar0(ptr[i]);
;//        putchar3(ptr[i]);
;//    }
;//    putchar0('\r');
;//    printDebug("\r\n\---\r\n");
;//
;//    TIMER_setTimer(&timeout, 10);
;//
;//    while( (!config_ready) && !TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//    }
;//
;//    ETH_switchMode(MODE_NORM);
;//
;//    free( ptr );
;//
;//    if(config_response == 'S'){
;//        return 0;
;//    }
;//    else{
;//        return -1;
;//    }
;//}
;///*============================================================*/
;//void ETH_reset(void)
;//{
;//    printDebug("<ETH_reset> Resetting Ethernet Module, please wait.");
;//    ETH_RESET   = 0;
;//    delay_ms(3000);
;//    ETH_RESET   = 1;
;//    delay_ms(1);
;//    printDebug("...Done\r\n");
;//}
;///*============================================================*/
;#include <stdlib.h>
;#include "ethparser.h"
;#include "debug.h"
;
;/*============================================================*/
;int statusRequestParser(unsigned char *pkt, int len, struct stat_req_st *st)
; 000A 0007 {

	.CSEG
; 000A 0008     int     i,k=0;
; 000A 0009 
; 000A 000A     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 000B         st->nid[0]  =   pkt[k++];
; 000A 000C     }
; 000A 000D 
; 000A 000E     st->accm        =   pkt[k++];
; 000A 000F 
; 000A 0010     st->intv        =   ((pkt[k++] & 0x00ff) << 8) |
; 000A 0011                         ((pkt[k++] & 0x00ff));
; 000A 0012 
; 000A 0013     if(st->accm >= 0x30){
; 000A 0014         return 0;
; 000A 0015     }
; 000A 0016 
; 000A 0017     st->parLen      =   len - k;
; 000A 0018 
; 000A 0019     st->parlst      =   malloc((st->parLen) * sizeof(char));
; 000A 001A     if(st->parlst == NULL)
; 000A 001B     {
; 000A 001C         printDebug("<statusRequestParser> malloc failed\r\n");
; 000A 001D         return -1;
; 000A 001E     }
; 000A 001F 
; 000A 0020     for( i=0 ; i<(st->parLen) ; i++ )
; 000A 0021     {
; 000A 0022         (st->parlst)[i]      = pkt[i+k];
; 000A 0023     }
; 000A 0024 
; 000A 0025     return 0;
; 000A 0026 }
;/*============================================================*/
;int statusReportParser(unsigned char *pkt, unsigned long int *time)
; 000A 0029 {
; 000A 002A     int i,k=0;
; 000A 002B 
; 000A 002C     k               +=  8;
;	*pkt -> Y+6
;	*time -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 002D 
; 000A 002E     *time           =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 002F                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 0030                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 0031                         (((long)pkt[k++] & 0x000000FF));
; 000A 0032 
; 000A 0033     return 0;
; 000A 0034 }
;/*============================================================*/
;int configManageParser(unsigned char *pkt, int len, struct conf_man_st *st)
; 000A 0037 {
; 000A 0038     int i,k=0;
; 000A 0039 
; 000A 003A     printDebug("<configManageParser>\r\n");
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 003B     print_payload(pkt,len);
; 000A 003C 
; 000A 003D     for(i=0;i<sizeof(st->nid);i++){
; 000A 003E         st->nid[0]  =   pkt[k++];
; 000A 003F     }
; 000A 0040 
; 000A 0041     st->accd        =   pkt[k++];
; 000A 0042 
; 000A 0043     st->cnfg        =   pkt[k++];
; 000A 0044 
; 000A 0045     if(st->accd == CONF_RD_CMD){
; 000A 0046         printDebug("<configManageParser> READING\r\n");
; 000A 0047         st->confLen     =   0;
; 000A 0048         st->confSpec    =   NULL;
; 000A 0049         return 0;
; 000A 004A     }
; 000A 004B     printDebug("<configManageParser> WRITING\r\n");
; 000A 004C 
; 000A 004D     st->confLen     =   len - k;
; 000A 004E 
; 000A 004F     printDebug("<configManageParser> confLen = %d\r\n",st->confLen);
; 000A 0050 
; 000A 0051 
; 000A 0052     st->confSpec    =   malloc((st->confLen) * sizeof(char));
; 000A 0053     if(st->confSpec == NULL)
; 000A 0054     {
; 000A 0055         printDebug("<configManageParser> malloc failed\r\n");
; 000A 0056         return -1;
; 000A 0057     }
; 000A 0058 
; 000A 0059     for( i=0 ; i<(st->confLen) ; i++ )
; 000A 005A     {
; 000A 005B         (st->confSpec)[i]      = pkt[i+k];
; 000A 005C     }
; 000A 005D 
; 000A 005E     return 0;
; 000A 005F 
; 000A 0060 }
;/*============================================================*/
;/*
;int dataReportParser(unsigned char *pkt, int len, unsigned char *frameID)
;{
;    *frameID        =   pkt[0];
;    return 0;
;}
;*/
;/*============================================================*/
;int logManipulationCmdParser(unsigned char *pkt, int len, struct log_manic_st *st)
; 000A 006B {
; 000A 006C     int i,k=0;
; 000A 006D 
; 000A 006E     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 006F         st->nid[0]  =   pkt[k++];
; 000A 0070     }
; 000A 0071 
; 000A 0072     st->accd        =   pkt[k++];
; 000A 0073 
; 000A 0074     if(len > 6){
; 000A 0075         st->tStart  =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 0076                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 0077                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 0078                         (((long)pkt[k++] & 0x000000FF));
; 000A 0079 
; 000A 007A         st->tStop   =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 007B                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 007C                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 007D                         (((long)pkt[k++] & 0x000000FF));
; 000A 007E     }
; 000A 007F 
; 000A 0080     return 0;
; 000A 0081 }
;/*============================================================*/
;int logManipulationAckParser(unsigned char *pkt, struct log_mania_st *st)
; 000A 0084 {
; 000A 0085     int i,k=0;
; 000A 0086 
; 000A 0087     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 0088         st->nid[0]  =   pkt[k++];
; 000A 0089     }
; 000A 008A 
; 000A 008B     st->accd        =   pkt[k++];
; 000A 008C     st->status      =   pkt[k++];
; 000A 008D 
; 000A 008E     return 0;
; 000A 008F }
;/*============================================================*/
;int networkMaintenanceParser(unsigned char *pkt, int len, struct netw_man_st *st)
; 000A 0092 {
; 000A 0093     int i,k=0;
; 000A 0094 
; 000A 0095     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+8
;	len -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 0096         st->nid[0]  =   pkt[k++];
; 000A 0097     }
; 000A 0098 
; 000A 0099     st->cmd         =   pkt[k++];
; 000A 009A 
; 000A 009B     st->dataLen     =   len - 2;
; 000A 009C 
; 000A 009D     if( st->dataLen > 0 ){
; 000A 009E 
; 000A 009F         st->data    =   malloc((st->dataLen) * sizeof(char));
; 000A 00A0         if(st->data == NULL)
; 000A 00A1         {
; 000A 00A2             printDebug("<networkMaintenanceParser> malloc failed (%d)\r\n",((st->dataLen) * sizeof(char)));
; 000A 00A3             return -1;
; 000A 00A4         }
; 000A 00A5 
; 000A 00A6         for( i=0 ; i<(st->dataLen) ; i++ )
; 000A 00A7         {
; 000A 00A8             (st->data)[i]      = pkt[i+k];
; 000A 00A9         }
; 000A 00AA 
; 000A 00AB     }
; 000A 00AC 
; 000A 00AD     return 0;
; 000A 00AE }
;/*============================================================*/
;int remoteDeviceControlParser(unsigned char *pkt, struct rem_dev_ctrl_st *st)
; 000A 00B1 {
; 000A 00B2     int i,k=0;
; 000A 00B3 
; 000A 00B4     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 00B5         st->nid[0]  =   pkt[k++];
; 000A 00B6     }
; 000A 00B7 
; 000A 00B8     st->cmd         =   pkt[k++];
; 000A 00B9 
; 000A 00BA     st->value       =   (((long)pkt[k++] & 0x000000FF) << 24) |
; 000A 00BB                         (((long)pkt[k++] & 0x000000FF) << 16) |
; 000A 00BC                         (((long)pkt[k++] & 0x000000FF) << 8)  |
; 000A 00BD                         (((long)pkt[k++] & 0x000000FF));
; 000A 00BE 
; 000A 00BF     return 0;
; 000A 00C0 }
;/*============================================================*/
;int clearListParser(unsigned char *pkt, struct clr_lst_st *st)
; 000A 00C3 {
; 000A 00C4     int i,k=0;
; 000A 00C5 
; 000A 00C6     for(i=0;i<sizeof(st->nid);i++){
;	*pkt -> Y+6
;	*st -> Y+4
;	i -> R16,R17
;	k -> R18,R19
; 000A 00C7         st->nid[0]  =   pkt[k++];
; 000A 00C8     }
; 000A 00C9 
; 000A 00CA     st->cmd         =   pkt[k++];
; 000A 00CB     st->status      =   pkt[k++];
; 000A 00CC 
; 000A 00CD     return 0;
; 000A 00CE }
;/*============================================================*/
;void free_statusRequest(struct stat_req_st *st)
; 000A 00D1 {
; 000A 00D2     free ( st->parlst );
;	*st -> Y+0
; 000A 00D3 }
;/*============================================================*/
;void free_configManage(struct conf_man_st *st)
; 000A 00D6 {
; 000A 00D7     free ( st->confSpec );
;	*st -> Y+0
; 000A 00D8 }
;/*============================================================*/
;void free_networkMaintenance(struct netw_man_st *st)
; 000A 00DB {
; 000A 00DC     free ( st->data );
;	*st -> Y+0
; 000A 00DD }
;/*============================================================*/
;
;#include <stdlib.h>
;#include <string.h>
;#include "ethservice.h"
;#include "ds1672.h"
;#include "alarm.h"
;#include "debug.h"
;
;///*============================================================*/
;//int getConfigLen(unsigned char cnfg)
;//{
;//    unsigned char   type = cnfg & 0xF0;;
;//
;//    switch( type ){
;//        case CONF_PROPERTIES    :   return sizeof(struct prop_cnfg_st);
;//        case CONF_OPERATE       :   return sizeof(struct oper_cnfg_st);
;//        case CONF_SENSOR        :   return sizeof(struct sens_cnfg_st);
;//        case CONF_AUXDI         :   return sizeof(struct din_cnfg_st);
;//        case CONF_AUXDO         :   return sizeof(struct dout_cnfg_st);
;//        case CONF_AUXAI         :   return sizeof(struct ain_cnfg_st);
;//        case CONF_AUXAO         :   return sizeof(struct aout_cnfg_st);
;//        case CONF_BUZZER        :   return sizeof(struct buzz_cnfg_st);
;//        case CONF_ENVALARM      :   return sizeof(struct alm_cnfg_st);
;//        default                 :   printDebug("<getConfigLen> unknown configuration type [0x%02X]\r\n",type);
;//                                    return -1;
;//    }
;//}
;///*============================================================*/
;//int configRead(unsigned char cnfg, unsigned char *ptr)
;//{
;//    int i = 0;
;//    int res = 0;
;//    unsigned char   type            = 0x00;
;//    int             channel         = 0;
;//    void            *cnfgStrc       = NULL;
;//
;//    type    =   cnfg & 0xF0;
;//
;//
;//    switch( type ){
;//        case CONF_PROPERTIES    :   cnfgStrc = malloc (sizeof(struct prop_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_PROPERTIES malloc1 failed (%d bytes)\r\n",sizeof(struct prop_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getPropertiesConfig((struct prop_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getPropertiesConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_PROPERTIES ---\r\n");
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->deviceType);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->firmwareVersion);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->deviceName);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->deviceID);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->hostName);
;//                                    printDebug("%s\r\n",((struct prop_cnfg_st *)cnfgStrc)->hostID);
;//                                    printDebug("%d\r\n",(signed char) (((struct prop_cnfg_st *)cnfgStrc)->timeZone));
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct prop_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct prop_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct prop_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct prop_cnfg_st);
;//
;//        case CONF_OPERATE       :   cnfgStrc = malloc (sizeof(struct oper_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_OPERATE malloc1 failed (%d bytes)\r\n",sizeof(struct oper_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getOperatingConfig((struct oper_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getOperatingConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_OPERATE ---\r\n");
;//                                    printDebug("mode            [0x%02X]\r\n",((struct oper_cnfg_st *)cnfgStrc)->mode);
;//                                    printDebug("deviceEnable    [0x%02X]\r\n",((struct oper_cnfg_st *)cnfgStrc)->deviceEnable);
;//                                    printDebug("alarmEnable     [0x%02X]\r\n",((struct oper_cnfg_st *)cnfgStrc)->alarmEnable);
;//                                    printDebug("sensorEnable    ");
;//                                    for(i=0;i<MAX_SENS_CHANNEL;i++){
;//                                        printDebug("[0x%02X]",((struct oper_cnfg_st *)cnfgStrc)->sensorEnable[i]);
;//                                        if(i == (MAX_SENS_CHANNEL-1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct oper_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct oper_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct oper_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct oper_cnfg_st);
;//
;//        case CONF_SENSOR        :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct sens_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_SENSOR malloc1 failed (%d bytes)\r\n",sizeof(struct sens_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getSensorConfig(channel, (struct sens_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getSensorConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_SENSOR [%d]---\r\n",channel);
;//                                    printDebug("samplingRate    [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->samplingRate);
;//                                    printDebug("reOccurrence    [0x%04X]\r\n",  ((struct sens_cnfg_st *)cnfgStrc)->reOccurrence);
;//                                    printDebug("timeStartHour   [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStartHour);
;//                                    printDebug("timeStartMin    [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStartMin);
;//                                    printDebug("timeStopHour    [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStopHour);
;//                                    printDebug("timeStopMin     [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->timeStopMin);
;//                                    printDebug("alarmEnable     [0x%02X]\r\n",  ((struct sens_cnfg_st *)cnfgStrc)->alarmEnable);
;//                                    printDebug("lowerLimit      [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->lowerLimit);
;//                                    printDebug("lowerDelay      [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->lowerDelay);
;//                                    printDebug("lowerExtreme    [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->lowerExtreme);
;//                                    printDebug("upperLimit      [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->upperLimit);
;//                                    printDebug("upperDelay      [%d]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->upperDelay);
;//                                    printDebug("upperExtreme    [%f]\r\n",      ((struct sens_cnfg_st *)cnfgStrc)->upperExtreme);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct sens_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct sens_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct sens_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct sens_cnfg_st);
;//
;//        case CONF_AUXDI         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct din_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXDI malloc1 failed (%d bytes)\r\n",sizeof(struct din_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxDinConfig(channel, (struct din_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxDinConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXDI [%d]---\r\n",channel);
;//                                    printDebug("channelEnable    [0x%02X]\r\n", ((struct din_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("alarmDelay       [%d]\r\n",     ((struct din_cnfg_st *)cnfgStrc)->alarmDelay);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct din_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct din_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct din_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct din_cnfg_st);
;//
;//        case CONF_AUXDO         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct dout_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXDO malloc1 failed (%d bytes)\r\n",sizeof(struct dout_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxDoutConfig(channel, (struct dout_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxDoutConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXDO [%d]---\r\n",channel);
;//                                    printDebug("channelEnable     [0x%02X]\r\n",    ((struct dout_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("stateOnEvent      [%d]\r\n",        ((struct dout_cnfg_st *)cnfgStrc)->stateOnEvent);
;//                                    printDebug("eventSourceNumber [%d]\r\n",        ((struct dout_cnfg_st *)cnfgStrc)->eventSourceNumber);
;//
;//                                    printDebug("eventSource       ");
;//                                    for(i=0;i<MAX_EVENT_SOURCE;i++){
;//                                        printDebug("[0x%02X]",((struct dout_cnfg_st *)cnfgStrc)->eventSource[i]);
;//                                        if(i == (MAX_EVENT_SOURCE-1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct dout_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct dout_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct dout_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct dout_cnfg_st);
;//
;//        case CONF_AUXAI         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct ain_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXAI malloc1 failed (%d bytes)\r\n",sizeof(struct ain_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxAinConfig(channel, (struct ain_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxAinConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXAI [%d]---\r\n",channel);
;//                                    printDebug("channelEnable    [0x%02X]\r\n", ((struct ain_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("alarmDelay       [%f]\r\n",     ((struct ain_cnfg_st *)cnfgStrc)->alarmLevel);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct ain_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct ain_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct ain_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct ain_cnfg_st);
;//
;//        case CONF_AUXAO         :   channel =   (int)cnfg & 0x000F;
;//
;//                                    cnfgStrc = malloc (sizeof(struct aout_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_AUXAO malloc1 failed (%d bytes)\r\n",sizeof(struct aout_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getAuxAoutConfig(channel, (struct aout_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getAuxAoutConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_AUXAO [%d]---\r\n",channel);
;//                                    printDebug("channelEnable     [0x%02X]\r\n",    ((struct aout_cnfg_st *)cnfgStrc)->channelEnable);
;//                                    printDebug("levelOnEvent      [%f]\r\n",        ((struct aout_cnfg_st *)cnfgStrc)->levelOnEvent);
;//                                    printDebug("eventSourceNumber [%d]\r\n",        ((struct aout_cnfg_st *)cnfgStrc)->eventSourceNumber);
;//
;//                                    printDebug("eventSource       ");
;//                                    for(i=0;i<MAX_EVENT_SOURCE;i++){
;//                                        printDebug("[0x%02X]",((struct aout_cnfg_st *)cnfgStrc)->eventSource[i]);
;//                                        if(i == (MAX_EVENT_SOURCE-1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct aout_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct aout_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct aout_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct aout_cnfg_st);
;//
;//        case CONF_BUZZER        :   cnfgStrc = malloc (sizeof(struct buzz_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_BUZZER malloc1 failed (%d bytes)\r\n",sizeof(struct buzz_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getBuzzerConfig((struct buzz_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getBuzzerConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_BUZZER ---\r\n");
;//                                    printDebug("enable            [0x%02X]\r\n",    ((struct buzz_cnfg_st *)cnfgStrc)->enable);
;//                                    printDebug("eventSourceNumber [%d]\r\n",        ((struct buzz_cnfg_st *)cnfgStrc)->eventSourceNumber);
;//
;//                                    printDebug("eventSource       ");
;//                                    for(i=0;i<MAX_EVENT_SOURCE;i++){
;//                                        printDebug("[0x%02X]",((struct buzz_cnfg_st *)cnfgStrc)->eventSource[i]);
;//                                        if(i == (MAX_EVENT_SOURCE - 1)){
;//                                            printDebug("\r\n");
;//                                        }
;//                                    }
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct buzz_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct buzz_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct buzz_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct buzz_cnfg_st);
;//
;//        case CONF_ENVALARM      :   cnfgStrc = malloc (sizeof(struct alm_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_ENVALARM malloc1 failed (%d bytes)\r\n",sizeof(struct alm_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getEnvAlarmConfig((struct alm_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getEnvAlarmConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_ENVALARM ---\r\n");
;//                                    printDebug("gsmRSSILevel      [%f]\r\n",((struct alm_cnfg_st *)cnfgStrc)->gsmRSSILevel);
;//                                    printDebug("gsmCreditBalance  [%d]\r\n",((struct alm_cnfg_st *)cnfgStrc)->gsmCreditBalance);
;//                                    printDebug("batteryLevel      [%f]\r\n",((struct alm_cnfg_st *)cnfgStrc)->batteryLevel);
;//                                    printDebug("commSignalLevel   [%f]\r\n",((struct alm_cnfg_st *)cnfgStrc)->commSignalLevel);
;//                                    printDebug("commLostDelay     [%d]\r\n",((struct alm_cnfg_st *)cnfgStrc)->commLostDelay);
;//                                    printDebug("memoryMin         [%d]\r\n",((struct alm_cnfg_st *)cnfgStrc)->memoryMin);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct alm_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct alm_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct alm_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//
;//                                    return sizeof(struct alm_cnfg_st);
;//        case CONF_STATREPORT    :   cnfgStrc = malloc (sizeof(struct stat_cnfg_st));
;//                                    if(cnfgStrc == NULL){
;//                                        printDebug("<configRead> CONF_STATREPORT malloc1 failed (%d bytes)\r\n",sizeof(struct stat_cnfg_st));
;//                                        return -2;
;//                                    }
;//
;//                                    res = getStatusReportConfig((struct stat_cnfg_st *) cnfgStrc);
;//                                    if(res < 0){
;//                                        printDebug("<configRead> getStatusReportConfig() failed\r\n");
;//                                        free ( cnfgStrc );
;//                                        return -3;
;//                                    }
;//
;//                                    printDebug("\r\n--- READ CONF_STATREPORT ---\r\n");
;//                                    printDebug("accm      [0x%02X]\r\n",((struct stat_cnfg_st *)cnfgStrc)->accm);
;//                                    printDebug("intv      [%d]\r\n",    ((struct stat_cnfg_st *)cnfgStrc)->intv);
;//
;////                                    printDebug("\r\n--- cnfgStrc ---\r\n");
;////                                    print_payload((char *)cnfgStrc, sizeof(struct stat_cnfg_st));
;//
;//                                    memcpy(ptr,(char *) cnfgStrc,sizeof(struct stat_cnfg_st));
;////                                    printDebug("\r\n--- ptr ---\r\n");
;////                                    print_payload((char *)ptr, sizeof(struct stat_cnfg_st));
;//
;//                                    free ( cnfgStrc );
;//        default                 :   printDebug("<configRead> unknown configuration type [0x%02X]\r\n",type);
;//                                    return -1;
;//    }
;//
;//    return 0;
;//
;//}
;///*============================================================*/
;//int configWrite(unsigned char cnfg, unsigned char *conf, int len)
;//{
;//    int res = 0;
;//    unsigned char   type            = 0x00;
;//    int             channel         = 0;
;//
;//    type    =   cnfg & 0xF0;
;//
;//    printDebug("\r\n --- WRITE CONFIG packet (%d)--- \r\n",len);
;//    print_payload(conf,len);
;//
;//    switch( type ){
;//        case CONF_PROPERTIES    :   printDebug("\r\n--- Write CONF_PROPERTIES ---");
;//
;//                                    res = setPropertiesConfig((struct prop_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setPropertiesConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_OPERATE       :   printDebug("\r\n--- Write CONF_OPERATE ---");
;//
;//                                    res = setOperatingConfig((struct oper_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setOperatingConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_SENSOR        :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_SENSOR (%d) ---",channel);
;//
;//                                    res = setSensorConfig(channel,(struct sens_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setSensorConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXDI         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXDI (%d) ---",channel);
;//
;//                                    res = setAuxDinConfig(channel,(struct din_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxDinConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXDO         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXDO (%d) ---",channel);
;//
;//                                    res = setAuxDoutConfig(channel,(struct dout_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxDoutConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXAI         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXAI (%d) ---",channel);
;//
;//                                    res = setAuxAinConfig(channel,(struct ain_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxAinConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_AUXAO         :   channel =   (int)cnfg & 0x000F;
;//                                    printDebug("\r\n--- Write CONF_AUXAO (%d) ---",channel);
;//
;//                                    res = setAuxAoutConfig(channel,(struct aout_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setAuxAoutConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_BUZZER        :   printDebug("\r\n--- Write CONF_BUZZER ---");
;//
;//                                    res = setBuzzerConfig((struct buzz_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setBuzzerConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_ENVALARM      :   printDebug("\r\n--- Write CONF_ENVALARM ---");
;//
;//                                    res = setEnvAlarmConfig((struct alm_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setEnvAlarmConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//                                    break;
;//        case CONF_STATREPORT    :   printDebug("\r\n--- Write CONF_STATREPORT ---");
;//
;//                                    res = setStatusReportConfig((struct stat_cnfg_st *)conf);
;//                                    if(res < 0){
;//                                        printDebug("<configWrite> setStatusReportConfig() failed\r\n");
;//                                        return -3;
;//                                    }
;//
;//        default                 :   printDebug("<configRead> unknown configuration type [0x%02X]\r\n",type);
;//                                    return -1;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//int setLogManipulateSchema(unsigned char accd, unsigned long int tStart, unsigned long int tStop)
;//{
;//    if(tStop < tStart){
;//        printDebug("<setLogManipulateSchema> time period error start[%ld] - stop[%ld]\r\n",tStart,tStop);
;//        return -1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setTimeSyncSchema(unsigned char *timeData)
;//{
;//    int res;
;//    unsigned long int unixTime = 0x00000000;
;//
;//    memcpy(&unixTime,timeData,sizeof(unixTime));
;//
;//    if(unixTime == 0){
;//        printDebug("<setTimeSyncSchema> Got 0 Unix time stamp\r\n");
;//        return -1;
;//    }
;//
;//    printDebug("<setTimeSyncSchema> Received time sync. packet %ld\r\n",unixTime);
;//
;//    res = RTC_setBinary( unixTime );
;//    if( res < 0 ){
;//        printDebug("<setTimeSyncSchema> RTC_setBinary(%ld) failed\r\n", unixTime);
;//        return -1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int setMuteAlarm(unsigned long int period)
;//{
;//    int res;
;//
;//    if(period == 0){
;//        printDebug("<setMuteAlarm> permanent mute alarm\r\n");
;//    }
;//    else if(((period < 300) || (period > 86400))){
;//        printDebug("<setMuteAlarm> invalid period (%ld)\r\n", period);
;//        return -1;
;//    }
;//    else{
;//        printDebug("<setMuteAlarm> mute alarm for %ld second\r\n",period);
;//    }
;//
;//    res = ALARM_mute( period );
;//    if( res < 0 ){
;//        printDebug("<setMuteAlarm> ALARM_mute(%ld) failed\r\n", period);
;//        return -1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int configConfirm(void)
;//{
;//    return 0;
;//}
;/*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "ethqueue.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "debug.h"
;
;#define MAX_SESS_LIST   100
;
;//struct ethqueue eth_waitQueue[ETH_MAX_WAIT_QUEUE];
;//char   ETH_waitQCount = 0;
;//
;//char   sess_list[MAX_SESS_LIST];
;//int    last_sess_id = 0;
;//
;///*============================================================*/
;//int ETH_addWaitQueue(char id, char *pktptr, int len, int timeout)
;//{
;//    int slot;
;//
;//    slot = ETH_findFreeSlotWaitQueue();
;//    if(slot < 0){
;//        printDebug("\r\n\r\n<ETH_addWaitQueue> WARNING : Wait queue FULL\r\n\r\n");
;//        return -1;
;//    }
;//
;//
;//    eth_waitQueue[slot].packetData = (char *) malloc(len);
;//    if(eth_waitQueue[slot].packetData == NULL)
;//    {
;//        printDebug("<ETH_addWaitQueue> malloc(%d) failed\r\n",len);
;//        return -1;
;//    }
;//
;//    memcpy( eth_waitQueue[slot].packetData, pktptr, len );
;//
;//    eth_waitQueue[slot].packetLen   = len;
;//    eth_waitQueue[slot].packetID    = id;
;//    eth_waitQueue[slot].retryCount  = 0;
;//    eth_waitQueue[slot].timeout     = timeout;
;//
;//    //eth_waitQueue[slot].retryTime   = 0;
;//    TIMER_setTimer(&(eth_waitQueue[slot].retryTime), eth_waitQueue[slot].timeout);
;//
;//    ETH_waitQCount++;
;//    printDebug("\r\n                                     Added (%02X) to eth_waitQueue[%d]\r\n", id, slot);
;//    //print_payload(eth_waitQueue[slot].packetData,eth_waitQueue[slot].packetLen);
;//    return ETH_waitQCount;
;//}
;///*============================================================*/
;//int ETH_removeWaitQueue(char id)
;//{
;//    char i;
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        if(id == eth_waitQueue[i].packetID){        // scan id in eth_waitQueue
;//            //printDebug("                                 Removing (%02X) from eth_waitQueue\r\n", id);
;//            //print_payload(eth_waitQueue[i].packetData,eth_waitQueue[i].packetLen);
;//            //memset( eth_waitQueue[i].packetData, '\0', ETH_MAX_PKT_LEN );
;//            free(eth_waitQueue[i].packetData);
;//            eth_waitQueue[i].packetData  = NULL;
;//            eth_waitQueue[i].packetLen   = 0;
;//            eth_waitQueue[i].packetID    = 0;
;//            eth_waitQueue[i].retryCount  = 0;
;//            eth_waitQueue[i].timeout     = 0;
;//            eth_waitQueue[i].retryTime   = 0;
;//            ETH_waitQCount--;
;//            //printDebug("Removed\r\n");
;//            printDebug("\r\n                                     Removed (%02X) to eth_waitQueue[%d]\r\n", id, i);
;//            return ETH_waitQCount;
;//        }
;//    }
;//    printDebug("\r\n\r\nWARNING : ETH_removeWaitQueue(%02X) not found!!\r\n\r\n",id);
;//    return -1;
;//}
;///*============================================================*/
;//void ETH_initWaitQueue(void)
;//{
;//    char i;
;//
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        //memset( eth_waitQueue[i].packetData, '\0', ETH_MAX_PKT_LEN );
;//        free(eth_waitQueue[i].packetData);
;//        eth_waitQueue[i].packetData  = NULL;
;//        eth_waitQueue[i].packetLen   = 0;
;//        eth_waitQueue[i].packetID    = 0;
;//        eth_waitQueue[i].retryCount  = 0;
;//        eth_waitQueue[i].timeout     = 0;
;//        eth_waitQueue[i].retryTime   = 0;
;//    }
;//    return;
;//}
;///*============================================================*/
;//char ETH_isIdExist(char id)
;//{
;//    char i;
;//
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        if(id == eth_waitQueue[i].packetID){
;//            return 1;                           // found id in eth_waitQueue
;//        }
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//char ETH_isIdUsed(char id)
;//{
;//    char i;
;//
;//    for(i=0;i<MAX_SESS_LIST;i++){
;//        if(id == sess_list[i]){
;//            return 1;                           // found id in eth_waitQueue
;//        }
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//char ETH_findFreeSlotWaitQueue(void)
;//{
;//    char i;
;//    for(i=0;i<ETH_MAX_WAIT_QUEUE;i++){
;//        if(eth_waitQueue[i].packetLen == 0){
;//            return i;
;//        }
;//    }
;//    return -1;
;//}
;///*============================================================*/
;//char ETH_generateId(void)
;//{
;//    char id;
;//
;//    do{
;//        id = (rand() % 256) & 0xFF;
;//    }while(ETH_isIdExist(id) || (id == 0) || (id == 0xFF) || ETH_isIdUsed(id));
;//    sess_list[last_sess_id] = id;
;//    last_sess_id = (last_sess_id + 1) % MAX_SESS_LIST;
;//
;//    return id;
;//}
;///*============================================================*/
;#include <stdlib.h>
;#include <string.h>
;#include <stdio.h>
;#include <delay.h>
;#include "sensor.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "config.h"
;#include "timer.h"
;#include "debug.h"
;#include "dht11.h"
;#include "calibration.h"
;
;#define MAX(x, y) (((x) > (y)) ? (x) : (y))
;
;
;//extern eeprom ST_CAL sensorCalulate;
;struct sens_val_st      sensor[5];
;extern ST_DHT11 dhtDevice;
;ST_DHT11 dhtDevice;
;//eeprom float calS1[5];//standrad point 1
;//eeprom float calS2[5];//standrad point 2
;//eeprom float calS3[5];//standrad point 3
;//eeprom float calX1[5];//input sensor point 1
;//eeprom float calX2[5];//input sensor point 2
;//eeprom float calX3[5];//input sensor point 3
;
;float sensorGetValue(unsigned int channelID){
; 000D 001A float sensorGetValue(unsigned int channelID){

	.CSEG
; 000D 001B     printDebug("Sensor ch[%d] is a raw data[%0.2f] , calProcess[%0.2f]\r\n",channelID-1,adcData[channelID-1],calProcessValue(adcData[channelID-1],channelID));
;	channelID -> Y+0
; 000D 001C     return calProcessValue(adcData[channelID-1],channelID);
; 000D 001D }
;
;int sensorRead(int ch, struct sens_val_st *sensor){
; 000D 001F int sensorRead(int ch, struct sens_val_st *sensor){
; 000D 0020     int dhtRet = 0;
; 000D 0021 
; 000D 0022     updateSensorADC(ch);
;	ch -> Y+4
;	*sensor -> Y+2
;	dhtRet -> R16,R17
; 000D 0023     if(ch==0){
; 000D 0024        sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 0025        //sensor->value = adcData[ch];
; 000D 0026     }else if(ch==3){
; 000D 0027     sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 0028        //sensor->value = adcData[ch];
; 000D 0029     }else if(ch==4){
; 000D 002A        sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 002B        //sensor->value = adcData[ch];
; 000D 002C     }else if((ch==1) || (ch==2)){
; 000D 002D         dhtRet = dhtDevice.status;
; 000D 002E         if(dhtRet == DHT11_SUCCESS){
; 000D 002F            sensor->value = calProcessValue(adcData[ch],ch+1);
; 000D 0030            //sensor->value = adcData[ch];
; 000D 0031         }else if(dhtRet == DHT11_ERROR_TIMEOUT){
; 000D 0032            sensor->status  = SENS_ERROR;
; 000D 0033            //return -2;
; 000D 0034         }else if(dhtRet == DHT11_ERROR_CHECKSUM){
; 000D 0035            sensor->status  = SENS_ERROR;
; 000D 0036            //return -2;
; 000D 0037         }
; 000D 0038     }
; 000D 0039 
; 000D 003A     sensor->status  = SENS_NORMAL;
; 000D 003B     return 0;
; 000D 003C }
;
;void updateSensorADC(int ch)
; 000D 003F {
; 000D 0040     int adc_raw = 0;
; 000D 0041     int dhtRet = 0;
; 000D 0042     float voltCutOff = 0.0;
; 000D 0043     float ACS709offset = 18.5;
; 000D 0044     float buffAmpSensor[60];
; 000D 0045     float buffVoltSensor[50];
; 000D 0046     float buff420Sensor[10];
; 000D 0047     float bufferTemp[2] = {0,0};
; 000D 0048     float bufferHumi[2] = {0,0};
; 000D 0049     int i=0,j=0;
; 000D 004A     int dht11Reread=0;
; 000D 004B     float ampValue = 0.0;
; 000D 004C     float voltValue = 0.0;
; 000D 004D     float mA420Value = 0.0;
; 000D 004E 
; 000D 004F     adc_raw     = read_adc(8+ch);
;	ch -> Y+526
;	adc_raw -> R16,R17
;	dhtRet -> R18,R19
;	voltCutOff -> Y+522
;	ACS709offset -> Y+518
;	buffAmpSensor -> Y+278
;	buffVoltSensor -> Y+78
;	buff420Sensor -> Y+38
;	bufferTemp -> Y+30
;	bufferHumi -> Y+22
;	i -> R20,R21
;	j -> Y+20
;	dht11Reread -> Y+18
;	ampValue -> Y+14
;	voltValue -> Y+10
;	mA420Value -> Y+6
; 000D 0050     if(ch==0){
; 000D 0051         //adcData[ch] =   adc_raw;
; 000D 0052         //mA420Value = ((((adcData[ch]+5.0/1023.0)*3.30)/3.30)*20.0);
; 000D 0053 
; 000D 0054         for(i=0;i<10;i++){
; 000D 0055             buff420Sensor[i] = read_adc(8+ch);
; 000D 0056             delay_us(10);
; 000D 0057         }
; 000D 0058         mA420Value = ((average(buff420Sensor,10)+5.0)/1023.0)*20.0;
; 000D 0059         //mA420Value = (((adcData[ch]+5.0/1023.0)*3.30)/165.0);     //R=165 Ohm
; 000D 005A        //printDebug("[%d]ADC: %f, mA: %f \r\n", ch, adcData[ch], mA420Value);
; 000D 005B        //adcData[ch] = (adcData[ch]+5/1023.0)*3.30;
; 000D 005C        adcData[ch] = mA420Value;
; 000D 005D     }else if(ch==3){
; 000D 005E         //adcData[ch] =   adc_raw;
; 000D 005F         //voltValue = ((((adcData[ch]+5.0)/1023.0)*3.30)/3.30)*1000.0;
; 000D 0060         for(i=0;i<50;i++){
; 000D 0061             buffVoltSensor[i] = read_adc(8+ch);
; 000D 0062             delay_us(10);
; 000D 0063         }
; 000D 0064 
; 000D 0065 
; 000D 0066         voltValue = ((average(buffVoltSensor,50)+5.0)/1023.0)*1000.0;
; 000D 0067         //printDebug("[%d]ADC: %f, Volt(raw): %f, Volt(AC): %f \r\n", ch, adcData[ch], (adcData[ch]+5.0/1023.0)*3.30, voltValue);
; 000D 0068 
; 000D 0069        adcData[ch] = voltValue;
; 000D 006A        //adcData[ch] = (adcData[ch]+5/1023)*3.30;
; 000D 006B     }else if(ch==4){
; 000D 006C         memset(buffAmpSensor,0,sizeof(buffAmpSensor));
; 000D 006D         for(i=0;i<60;i++){
; 000D 006E           buffAmpSensor[i] =  read_adc(8+ch);
; 000D 006F           delay_ms(1);
; 000D 0070         }
; 000D 0071         //adcData[ch] = average(buffAmpSensor);
; 000D 0072        // voltCutOff = fabs(((((adcData[ch]+5.0)/1023.0)*3.30)-1.65));
; 000D 0073         voltCutOff = fabs(((((voltPeak(buffAmpSensor)+5.0)/1023.0)*3.30)-1.65));
; 000D 0074         ampValue = (voltCutOff*1000.0)/18.5;
; 000D 0075         //printDebug("[%d]ADC: %f, Volt(raw): %f, Amp: %f\r\n", ch, adcData[ch], (adcData[ch]-511.0), ampValue);
; 000D 0076 
; 000D 0077        adcData[ch] =  ampValue;
; 000D 0078     }else if((ch==1) || (ch==2)){
; 000D 0079 
; 000D 007A         //dhtRet = DHT11Read(&dhtDevice);
; 000D 007B 
; 000D 007C         dht11Reread = 0;
; 000D 007D         //memset(&dhtDevice,0,sizeof(dhtDevice));
; 000D 007E         for(i=0;i<20;i++){
; 000D 007F 
; 000D 0080             dhtRet = DHT11Read(&dhtDevice);
; 000D 0081             //delay_ms(4);
; 000D 0082             //printDebug("[%d]ADC:DHT11:Return (%d). \r\n", ch,dhtRet);
; 000D 0083             if(dhtRet == DHT11_SUCCESS){
; 000D 0084 //                if(ch==1){
; 000D 0085 //                  bufferTemp[dht11Reread] = dhtDevice.temp;
; 000D 0086 //                }else if(ch==2){
; 000D 0087 //                  bufferHumi[dht11Reread] = dhtDevice.humi;
; 000D 0088 //                }
; 000D 0089 
; 000D 008A                 bufferTemp[dht11Reread] = dhtDevice.temp;
; 000D 008B                 bufferHumi[dht11Reread] = dhtDevice.humi;
; 000D 008C 
; 000D 008D                 ++dht11Reread;
; 000D 008E             }
; 000D 008F             if(dht11Reread>=2){
; 000D 0090                break;
; 000D 0091             }
; 000D 0092         }
; 000D 0093 
; 000D 0094         if(dht11Reread>=2){
; 000D 0095             if(ch==1){
; 000D 0096                adcData[ch] = average(bufferTemp,2);
; 000D 0097             }else if(ch==2){
; 000D 0098                adcData[ch] = average(bufferHumi,2);
; 000D 0099             }
; 000D 009A         }else if(dht11Reread>=1){
; 000D 009B             if(ch==1){
; 000D 009C                adcData[ch] = average(bufferTemp,1);
; 000D 009D             }else if(ch==2){
; 000D 009E                adcData[ch] = average(bufferHumi,1);
; 000D 009F             }
; 000D 00A0         }
; 000D 00A1     }
; 000D 00A2     return;
; 000D 00A3 }
;
;float voltPeak(float data[]){       //Amp value
; 000D 00A5 float voltPeak(float data[]){
; 000D 00A6      int i = 0;
; 000D 00A7      float sum=0.0;
; 000D 00A8 
; 000D 00A9      for(i=0;i<60;i++){
;	data -> Y+6
;	i -> R16,R17
;	sum -> Y+2
; 000D 00AA        sum = MAX(sum,data[i]);
; 000D 00AB      }
; 000D 00AC      return sum;
; 000D 00AD }
;float average(float data[],int count){      //Volt value
; 000D 00AE float average(float data[],int count){
; 000D 00AF      int i = 0;
; 000D 00B0      float avg = 0.0, sum=0.0;
; 000D 00B1 
; 000D 00B2      //printDebug("raw data.\r\n");
; 000D 00B3      for(i=0;i<count;i++){
;	data -> Y+12
;	count -> Y+10
;	i -> R16,R17
;	avg -> Y+6
;	sum -> Y+2
; 000D 00B4        //printDebug("%.2f ", data[i]);
; 000D 00B5        sum += data[i];
; 000D 00B6      }
; 000D 00B7      //printDebug("\r\nMax(%.2f) ", sum);
; 000D 00B8      //printDebug("\r\n");
; 000D 00B9      //return sum;
; 000D 00BA 
; 000D 00BB 
; 000D 00BC      avg =(sum/count);
; 000D 00BD      return avg;
; 000D 00BE }
;
;
;
;#include <stdlib.h>
;#include <stdio.h>
;#include "dataqueue.h"
;#include "debug.h"
;
;struct data_record_st dataQ[MAX_DATA_QUEUE];
;int last_wr_dataQ = 0;
;int last_rd_dataQ = 0;
;int dataQ_len = 0;
;
;/*============================================================*/
;int addDataQueue(unsigned long int timestamp, unsigned int channel, float value)
; 000E 000D {

	.CSEG
; 000E 000E     if(dataQ_len == MAX_DATA_QUEUE){
;	timestamp -> Y+6
;	channel -> Y+4
;	value -> Y+0
; 000E 000F         return -1;
; 000E 0010     }
; 000E 0011 
; 000E 0012     dataQ[last_wr_dataQ].timestamp      = timestamp;
; 000E 0013     dataQ[last_wr_dataQ].channel        = channel;
; 000E 0014     dataQ[last_wr_dataQ].value          = value;
; 000E 0015 
; 000E 0016     last_wr_dataQ = (last_wr_dataQ + 1) % MAX_DATA_QUEUE;
; 000E 0017 
; 000E 0018     dataQ_len++;
; 000E 0019 
; 000E 001A     return 0;
; 000E 001B }
;/*============================================================*/
;int fetchDataQueue(unsigned long int *timestamp, unsigned int *channel, float *value)
; 000E 001E {
; 000E 001F     if(dataQ_len == 0){
;	*timestamp -> Y+4
;	*channel -> Y+2
;	*value -> Y+0
; 000E 0020         return -1;
; 000E 0021     }
; 000E 0022 
; 000E 0023     *timestamp  =   dataQ[last_rd_dataQ].timestamp;
; 000E 0024     *channel    =   dataQ[last_rd_dataQ].channel;
; 000E 0025     *value      =   dataQ[last_rd_dataQ].value;
; 000E 0026 
; 000E 0027     last_rd_dataQ = (last_rd_dataQ + 1) % MAX_DATA_QUEUE;
; 000E 0028 
; 000E 0029     dataQ_len--;
; 000E 002A     return 0;
; 000E 002B }
;/*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;//#include "status.h"
;//#include "config.h"
;//#include "timer.h"
;//#include "debug.h"
;//
;///*eeprom*/ char sensorStatus[MAX_SENS_CHANNEL]                  = {SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL};
;///*eeprom*/ char dataStatus[MAX_SENS_CHANNEL]                    = {DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL};
;//char mtncStatus                                             = MTNC_NORMAL;
;//char powerSrcStatus                                         = PWR_NORMAL;
;//char batteryStatus                                          = BATT_NORMAL;
;//char dinStatus[USE_DIN]                                     = {UNKNOWN,UNKNOWN};
;//char doutStatus[USE_DIN]                                    = {UNKNOWN,UNKNOWN};
;//char serverCommStatus                                       = UNKNOWN;
;//char lanStatus                                              = 0;
;//char memoryStatus                                           = MEM_NORMAL;
;//
;//float batteryVolt                                           = 0.0;
;//
;///*
;//char dataLowerStatus[MAX_SENS_CHANNEL]           = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataLowerDelayStatus[MAX_SENS_CHANNEL]      = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataLowerExtremeStatus[MAX_SENS_CHANNEL]    = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataUpperStatus[MAX_SENS_CHANNEL]           = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataUpperDelayStatus[MAX_SENS_CHANNEL]      = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//char dataUpperExtremeStatus[MAX_SENS_CHANNEL]    = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;//*/
;//
;///****
;//*  "sensor.h" -> struct sens_val_st sensor[]
;//*
;//****/
;///*============================================================*/
;//int updateMIPStatus(void)
;//{
;//    // -- depend on menu -- //
;//    return 0;
;//}
;///*============================================================*/
;//int updateBatteryStatus(void)
;//{
;//    static TIMER    t               = 0;
;//    static char     t_flag          = 0;
;//    static char     lastCheck       = 0;
;//    char            current_status  = 0;
;//
;//    if(MAIN_POWER_CONNECT){
;//        powerSrcStatus      =   PWR_NORMAL;
;//        batteryStatus       =   BATT_NORMAL;
;//        batteryVolt         =   4.2;
;//        return 0;
;//    }
;//    else{
;//        powerSrcStatus      =   PWR_DOWN;
;//        batteryVolt         =   readBattery();
;//
;//        if(env_config.batteryLevel == 0)    // -- battery alarm disable --> always BATT_NORMAL -- //
;//        {
;//            batteryStatus = BATT_NORMAL;
;//        }
;//        else
;//        {
;//            if(batteryVolt < env_config.batteryLevel)
;//            {
;//                current_status      = BATT_LOW;
;//            }
;//            else
;//            {
;//                current_status      = BATT_NORMAL;
;//            }
;//
;//            if(lastCheck != current_status)
;//            {
;//                t_flag              = 0;
;//                lastCheck           = current_status;
;//            }
;//
;//            if(!t_flag)
;//            {
;//                TIMER_setTimer(&t,10);
;//                t_flag              = 1;
;//            }
;//            else
;//            {
;//                if(TIMER_checkTimerExceed(t))
;//                {
;//                    batteryStatus   = current_status;
;//                    t_flag          = 0;
;//                }
;//            }
;//        }// -- battery alarm enable -- //
;//        return 1;
;//    }// -- main power disconnect -- //
;//
;//    return 0;
;//}
;///*============================================================*/
;//int updateCommStatus(void)
;//{
;//    int res;
;//
;//    if(!IO_LAN_CONNECT){
;//        lanStatus                       = COMM_LAN_DISCONNECT;
;//
;//        serverCommStatus                = UNKNOWN;
;//
;//        commLostTimer                   = 0;                // -- re-initial -- //
;//        return 1;
;//    }
;//    else{
;//        lanStatus                       = COMM_LAN_CONNECT;
;//
;//        if((commLostTimer != 0xFFFFFFFF) && (commLostTimer != 0)){
;//            printDebug("<updateCommStatus> LostTimer time left = %ld(%lX)\r\n",(commLostTimer-baseCounter),(commLostTimer-baseCounter));
;//        }
;//
;//        res = TIMER_checkTimerExceed(commLostTimer);
;//        if(res < 0){
;//            serverCommStatus            = UNKNOWN;              // -- unknown -- //
;//            return 0;
;//        }
;//        else{
;//            if(res){
;//                if(serverCommStatus != COMM_LOST){
;//                    printDebug("<updateCommStatus> Server Down!!!\r\n");
;//                }
;//                serverCommStatus        = COMM_LOST;            // -- disconnect -- //
;//                return 1;
;//            }
;//            else{
;//                if(serverCommStatus != COMM_NORMAL){
;//                    printDebug("<updateCommStatus> Server Up!!!\r\n");
;//                }
;//                serverCommStatus        = COMM_NORMAL;          // -- connect -- //
;//                return 0;
;//            }
;//        }
;//    }
;//}
;///*============================================================*/
;//int updateMemoryStatus(void)
;//{
;////    if(env_config.memoryMin == 0)    // -- memory alarm disable --> always MEM_NORMAL -- //
;////    {
;////            memoryStatus        = MEM_NORMAL;
;////    }
;////    else
;////    {
;//        if(sdFreeSpace == 0)
;//        {
;//            memoryStatus    = MEM_ERROR;
;//        }
;//        else if((int)(sdFreeSpace/1024) < env_config.memoryMin)
;//        {
;//            memoryStatus    = MEM_LOW;
;//        }
;//        else
;//        {
;//            memoryStatus    = MEM_NORMAL;
;//        }
;////    }// -- memory alarm enable -- //
;//
;//    if( memoryStatus != MEM_NORMAL ){
;//        return 1;
;//    }
;//    else{
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int updateSensorStatus(int ch)
;//{
;//    if((ch<0) || (ch>=MAX_SENS_CHANNEL)){
;//        printDebug("<checkProbeAlarm> sensor channel out of range (%d)\r\n",ch);
;//        return 0;
;//    }
;//
;//    sensorStatus[ch] = sensor[ch].status;
;//
;//    if(sensorStatus[ch] == SENS_ERR_UNKNOWN){
;//        return 0;
;//    }
;//    else if(sensorStatus[ch] != SENS_NORMAL){
;//        //printDebug("<checkProbeAlarm> Channel %d ERR\r\n",ch);
;//        return 1;
;//    }
;//    else{
;//        //printDebug("<checkProbeAlarm> Channel %d OK\r\n",ch);
;//        return 0;
;//    }
;//}
;///*============================================================*/
;//int updateDataStatus(int ch)
;//{
;//    static TIMER t[MAX_SENS_CHANNEL];
;//    static char flag_lower[MAX_SENS_CHANNEL] = {0,0,0,0,0};
;//    static char flag_upper[MAX_SENS_CHANNEL] = {0,0,0,0,0};
;//    int res = 0;
;//
;//    if((ch<0) || (ch>=MAX_SENS_CHANNEL)){
;//        printDebug("<updateDataStatus> ABORT: sensor channel out of range (%d)\r\n",ch);
;//        return 0;
;//    }
;//
;//    if(sensor[ch].status != SENS_NORMAL){
;//        //printDebug("<updateDataStatus> ABORT: sensor (%d) error\r\n",ch);
;//        return 0;
;//    }
;//
;//    if(sensor[ch].value < sensor_config[ch].lowerLimit){
;//
;//        if(!flag_lower[ch])
;//        {
;//            TIMER_setTimer(&t[ch],sensor_config[ch].lowerDelay);
;//            flag_lower[ch] = 1;
;//        }
;//        else
;//        {
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dataStatus[ch]              |=  DATA_LOWER_LIMIT;
;//                //printDebug("<updateDataStatus> Probe %d lowerDelayLimit[%02X]\r\n", ch+1, dataStatus[ch]);   /////
;//            }
;//        }
;//        //dataStatus[ch]                      |=  DATA_LOWER_LIMIT;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d lowerLimit[%02X] -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,dataStatus[ch],sensor[ch].value,sensor_config[ch].lowerLimit);
;//    }
;//    else{
;//        flag_lower[ch] = 0;
;//        dataStatus[ch]                      &=  ~DATA_LOWER_LIMIT;
;//        //dataStatus[ch]                      &=  ~DATA_LOWER_DELAY;
;//    }
;//
;//    if(sensor[ch].value < sensor_config[ch].lowerExtreme)
;//    {
;//        dataStatus[ch]                      |=  DATA_LOWER_EXTREME;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d lowerExtreme[%02X] -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,dataStatus[ch],sensor[ch].value,sensor_config[ch].lowerExtreme);
;//    }
;//    else
;//    {
;//        dataStatus[ch]                      &=  ~DATA_LOWER_EXTREME;
;//    }
;//
;//    if(sensor[ch].value > sensor_config[ch].upperLimit)
;//    {
;//        if(!flag_upper[ch])
;//        {
;//            TIMER_setTimer(&t[ch],sensor_config[ch].upperDelay);
;//            flag_upper[ch] = 1;
;//        }
;//        else
;//        {
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dataStatus[ch]              |=  DATA_UPPER_LIMIT;
;//            }
;//        }
;//        //dataStatus[ch]                      |=  DATA_UPPER_LIMIT;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d upperLimit -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,sensor[ch].value,sensor_config[ch].upperLimit);
;//    }
;//    else
;//    {
;//        flag_upper[ch] = 0;
;//        dataStatus[ch]                      &=  ~DATA_UPPER_LIMIT;
;//        //dataStatus[ch]                      &=  ~DATA_UPPER_DELAY;
;//    }
;//
;//    if(sensor[ch].value > sensor_config[ch].upperExtreme)
;//    {
;//        dataStatus[ch]                      |=  DATA_UPPER_EXTREME;
;//        res |= 1;
;//
;//        //printDebug("<updateDataStatus> Probe %d upperExtreme -- sensor[%f] vs config[%f]\r\n",
;//        //                ch+1,sensor[ch].value,sensor_config[ch].upperExtreme);
;//    }
;//    else
;//    {
;//        dataStatus[ch]                      &=  ~DATA_UPPER_EXTREME;
;//    }
;//
;//    return res;
;//}
;///*============================================================*/
;//int updateDinStatus(void)
;//{
;//    static TIMER    t[USE_DIN]                  = {0,0};
;//    static char     lastDinCheck[USE_DIN]       = {UNKNOWN,UNKNOWN};   // -- initial with unuse value -- //
;//    static char     steadyState[USE_DIN]        = {0,0};
;//    char            currentState                = UNKNOWN;
;//    int             ch                          = 0;
;//    int             ret                         = 0;
;//
;//    for(ch=0;ch<USE_DIN;ch++)
;//    {
;//        if(din_config[ch].channelEnable == 0x01)
;//        {
;//            switch(ch){
;//                case 0  : currentState = DIN1;  break;
;//                case 1  : currentState = DIN2;  break;
;//                default : printDebug("<updateDinStatus> channel[%d] out of range\r\n",ch); return 0;
;//            }
;//
;//            if(currentState != lastDinCheck[ch])
;//            {
;//                TIMER_setTimer(&t[ch],1);
;//                lastDinCheck[ch]    = currentState;
;//                steadyState[ch]     = 0;
;//            }
;//            else if(!steadyState[ch])
;//            {
;//                if(TIMER_checkTimerExceed(t[ch])){
;//
;//                    steadyState[ch] = 1;
;//
;//                    if(currentState){
;//                        dinStatus[ch]   = DIN_RISING;
;//                    }
;//                    else{
;//                        dinStatus[ch]   = DIN_FALLING;
;//                    }
;//
;//                    ret += 1;
;//                }
;//                else{
;//                    steadyState[ch] = 0;
;//                }
;//            }
;//        }
;//    }
;//
;//    return ret;
;//}
;///*============================================================*/
;//int updateDoutStatus(void)
;//{
;//    if(d_out[0]){   doutStatus[0]        = DOUT_HIGH; }
;//    else{           doutStatus[0]        = DOUT_LOW; }
;//
;//    if(d_out[1]){   doutStatus[1]        = DOUT_HIGH; }
;//    else{           doutStatus[1]        = DOUT_LOW; }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int getDeviceState(unsigned short *state)
;//{
;//    int     i   = 0;
;//
;//    *state      = 0x00;
;//
;//    if(isDeviceConfig()){
;//        *state |= (1 << 15);
;//    }
;//    else{
;//        *state &= ~(1 << 15);
;//    }
;//
;//    if(operating_config.deviceEnable){
;//        *state |= (1 << 14);
;//    }
;//    else{
;//        *state &= ~(1 << 14);
;//    }
;//
;//    if(operating_config.mode == MODE_REALTIME){
;//        *state |= (2 << 10);
;//    }
;//    else{
;//        *state |= (1 << 10);
;//    }
;//
;//    if(operating_config.alarmEnable){
;//        *state |= (2 << 8);
;//    }
;//    else{
;//        *state |= (1 << 8);
;//    }
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++)
;//    {
;//        if(operating_config.sensorEnable[i]){
;//            *state |= (1 << (4-i) );
;//        }
;//        else{
;//            *state &= ~(1 << (4-i) );
;//        }
;//    }
;//
;//    printDebug("<getDeviceState> state = [0x%04X]\r\n",*state);
;//
;//    return 0;
;//}
;/*============================================================*/
;#include <stdlib.h>
;#include <stdio.h>
;#include "eventqueue.h"
;#include "debug.h"
;
;struct event_record_st eventQ[MAX_EVENT_QUEUE];
;int last_wr_eventQ = 0;
;int last_rd_eventQ = 0;
;int eventQ_len = 0;
;
;/*============================================================*/
;int addEventQueue(unsigned long int timestamp, unsigned char eventID, unsigned char eventStatus)
; 0010 000D {

	.CSEG
; 0010 000E     if(eventQ_len == MAX_EVENT_QUEUE){
;	timestamp -> Y+2
;	eventID -> Y+1
;	eventStatus -> Y+0
; 0010 000F         return -1;
; 0010 0010     }
; 0010 0011 
; 0010 0012     eventQ[last_wr_eventQ].timestamp        = timestamp;
; 0010 0013     eventQ[last_wr_eventQ].eventID          = eventID;
; 0010 0014     eventQ[last_wr_eventQ].eventStatus      = eventStatus;
; 0010 0015 
; 0010 0016     last_wr_eventQ = (last_wr_eventQ + 1) % MAX_EVENT_QUEUE;
; 0010 0017 
; 0010 0018     eventQ_len++;
; 0010 0019 
; 0010 001A     return 0;
; 0010 001B }
;/*============================================================*/
;int fetchEventQueue(unsigned long int *timestamp, unsigned char *eventID, unsigned char *eventStatus)
; 0010 001E {
; 0010 001F     if(eventQ_len == 0){
;	*timestamp -> Y+4
;	*eventID -> Y+2
;	*eventStatus -> Y+0
; 0010 0020         return -1;
; 0010 0021     }
; 0010 0022 
; 0010 0023     *timestamp      =   eventQ[last_rd_eventQ].timestamp;
; 0010 0024     *eventID        =   eventQ[last_rd_eventQ].eventID;
; 0010 0025     *eventStatus    =   eventQ[last_rd_eventQ].eventStatus;
; 0010 0026 
; 0010 0027     last_rd_eventQ  = (last_rd_eventQ + 1) % MAX_EVENT_QUEUE;
; 0010 0028 
; 0010 0029     eventQ_len--;
; 0010 002A     return 0;
; 0010 002B }
;/*============================================================*/
;#include <stdlib.h>
;#include <stdio.h>
;//#include "alarm.h"
;//#include "config.h"
;//#include "debug.h"
;//
;///*eeprom*/ char sensorAlarm[MAX_SENS_CHANNEL]   = {SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL,SENS_NORMAL};        // -- oled -- //
;///*eeprom*/ char dataAlarm[MAX_SENS_CHANNEL]     = {DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL,DATA_NORMAL};        // -- oled -- //
;///*eeprom*/ char dinAlarm[MAX_DI_CHANNEL]        = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,     // -- oled -- //
;//                                               UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;///*eeprom*/ char ainAlarm[MAX_AI_CHANNEL]        = {UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,
;//                                               UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN,UNKNOWN};
;///*eeprom*/ char muteAlarm                       = UNKNOWN;
;///*eeprom*/ char mtncAlarm                       = MTNC_NORMAL;
;///*eeprom*/ char powerSrcAlarm                   = PWR_NORMAL;
;///*eeprom*/ char batteryAlarm                    = BATT_NORMAL;                                                          // -- oled -- //
;///*eeprom*/ char communicationAlarm              = COMM_NORMAL;
;///*eeprom*/ char memoryAlarm                     = MEM_NORMAL;                                                           // -- oled -- //
;///*eeprom*/ char gsmAlarm                        = GSM_NORMAL;
;///*eeprom*/ char gsmBalanceAlarm                 = GBAL_NORMAL;
;//
;///*============================================================*/
;///**************************************************************/
;///**************** Alarm Indicating decision *******************/
;///**************************************************************/
;//int checkAlarm(char *srcList,int srcLen)
;//{
;//    int i=0, res=0, tmp=0;
;//
;//    for(i=0;i<srcLen;i++)
;//    {
;//        tmp  = checkAlarmFromSrc(srcList[i]);
;//        res |= tmp;
;//        //printDebug("<checkAlarm> SRC[0x%02X] -> %d\r\n",srcList[i],tmp);
;//    }
;//
;//    return res;
;//}
;///*============================================================*/
;//int checkAlarmFromSrc(char alarmSrc)
;//{
;//    int i   = 0;
;//    int res = 0;
;//
;//    switch(alarmSrc)
;//    {
;//        case SRC_SENS1_EVENT             :  if(((sensorStatus[0]!= SENS_NORMAL) && (sensorStatus[0] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[0]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS1_LOWER             :  if(dataStatus[0]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS1_LOWERDELAY        :  if(dataStatus[0]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS1_LOWEREXTREME      :  if(dataStatus[0]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS1_UPPER             :  if(dataStatus[0]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS1_UPPERDELAY        :  if(dataStatus[0]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS1_UPPEREXTREME      :  if(dataStatus[0]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS1_ERROR             :  if((sensorStatus[0] != SENS_NORMAL) &&
;//                                               (sensorStatus[0] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS2_EVENT             :  if(((sensorStatus[1]!= SENS_NORMAL) && (sensorStatus[1] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[1]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS2_LOWER             :  if(dataStatus[1]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS2_LOWERDELAY        :  if(dataStatus[1]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS2_LOWEREXTREME      :  if(dataStatus[1]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS2_UPPER             :  if(dataStatus[1]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS2_UPPERDELAY        :  if(dataStatus[1]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS2_UPPEREXTREME      :  if(dataStatus[1]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS2_ERROR             :  if((sensorStatus[1] != SENS_NORMAL) &&
;//                                               (sensorStatus[1] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS3_EVENT             :  if(((sensorStatus[2]!= SENS_NORMAL) && (sensorStatus[2] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[2]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS3_LOWER             :  if(dataStatus[2]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS3_LOWERDELAY        :  if(dataStatus[2]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS3_LOWEREXTREME      :  if(dataStatus[2]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS3_UPPER             :  if(dataStatus[2]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS3_UPPERDELAY        :  if(dataStatus[2]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS3_UPPEREXTREME      :  if(dataStatus[2]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS3_ERROR             :  if((sensorStatus[2] != SENS_NORMAL) &&
;//                                               (sensorStatus[2] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS4_EVENT             :  if(((sensorStatus[3]!= SENS_NORMAL) && (sensorStatus[3] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[3]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS4_LOWER             :  if(dataStatus[3]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS4_LOWERDELAY        :  if(dataStatus[3]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS4_LOWEREXTREME      :  if(dataStatus[3]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS4_UPPER             :  if(dataStatus[3]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS4_UPPERDELAY        :  if(dataStatus[3]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS4_UPPEREXTREME      :  if(dataStatus[3]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS4_ERROR             :  if((sensorStatus[3] != SENS_NORMAL) &&
;//                                               (sensorStatus[3] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_SENS5_EVENT             :  if(((sensorStatus[4]!= SENS_NORMAL) && (sensorStatus[4] != SENS_ERR_UNKNOWN)) ||
;//                                                (dataStatus[4]  != DATA_NORMAL))        res = 1;    break;
;//        case SRC_SENS5_LOWER             :  if(dataStatus[4]    &  DATA_LOWER_LIMIT)    res = 1;    break;
;//        case SRC_SENS5_LOWERDELAY        :  if(dataStatus[4]    &  DATA_LOWER_DELAY)    res = 1;    break;
;//        case SRC_SENS5_LOWEREXTREME      :  if(dataStatus[4]    &  DATA_LOWER_EXTREME)  res = 1;    break;
;//        case SRC_SENS5_UPPER             :  if(dataStatus[4]    &  DATA_UPPER_LIMIT)    res = 1;    break;
;//        case SRC_SENS5_UPPERDELAY        :  if(dataStatus[4]    &  DATA_UPPER_DELAY)    res = 1;    break;
;//        case SRC_SENS5_UPPEREXTREME      :  if(dataStatus[4]    &  DATA_UPPER_EXTREME)  res = 1;    break;
;//        case SRC_SENS5_ERROR             :  if((sensorStatus[4] != SENS_NORMAL) &&
;//                                               (sensorStatus[4] != SENS_ERR_UNKNOWN))   res = 1;    break;
;//
;//        case SRC_DI_EVENT_ANY            :  break;
;//        case SRC_DI_RISING_ANY           :  for(i=0;i<USE_DIN;i++){
;//                                                if(dinStatus[i] == DIN_RISING)          res = 1;    break;
;//                                            }
;//                                            break;
;//        case SRC_DI_FALLING_ANY          :  for(i=0;i<USE_DIN;i++){
;//                                                if(dinStatus[i] == DIN_FALLING)         res = 1;    break;
;//                                            }
;//                                            break;
;//
;//        case SRC_DI_EVENT(0)             :  break;
;//        case SRC_DI_RISING(0)            :  if(dinStatus[0] == DIN_RISING) {
;//                                                res = 1;
;////                                                printDebug("DIN1 Rising Alarm \r\n");
;//                                            }
;//                                            break;
;//        case SRC_DI_FALLING(0)           :  if(dinStatus[0]     == DIN_FALLING)         res = 1;    break;
;//
;//        case SRC_DI_EVENT(1)             :  break;
;//        case SRC_DI_RISING(1)            :  if(dinStatus[1]     == DIN_RISING)          res = 1;    break;
;//        case SRC_DI_FALLING(1)           :  if(dinStatus[1]     == DIN_FALLING)         res = 1;    break;
;//
;//        case SRC_MUTE_ALARM              :  break;
;//        case SRC_MIP                     :  // --- wait for menu MIP --- //
;//                                            break;
;//        case SRC_POWER_DOWN              :  if(powerSrcStatus   == PWR_DOWN)            res = 1;    break;
;//        case SRC_LOW_BATTERY             :  if(batteryStatus    == BATT_LOW)            res = 1;    break;
;//        case SRC_LOW_COMM_SIGNAL         :  break;
;//        case SRC_LOW_MEMORY              :  if(memoryAlarm      == MEM_LOW)             res = 1;    break;
;//        case SRC_MEMORY_ERROR            :  if(memoryAlarm      == MEM_ERROR)           res = 1;    break;
;//        case SRC_LOST_OF_COMM            :  if(serverCommStatus == COMM_LOST) {
;//                                                res = 1;
;////                                                printDebug("Comm Lost Alarm \r\n");
;//                                            }
;////                                            printDebug("Check Comm Lost \r\n");
;//                                            break;
;//        case SRC_GSM_LOW_SIGNAL          :
;//        case SRC_GSM_DATE_EXPIRED        :
;//        case SRC_GSM_NO_OPERATOR         :
;//        case SRC_GSM_TOP_UP              :
;//        case SRC_GSM_LOW_BALANCE         :
;//        case SRC_GSM_UNKNOWN_FAILURE     :  printDebug("<checkAlarmFromSrc> GSM Not support yet [0x%02X]\r\n",alarmSrc);
;//                                            break;
;//
;//        default                          :  printDebug("<checkAlarmFromSrc> alarmSrc unknown [0x%02X]\r\n",alarmSrc);
;//                                            break;
;//    }
;//
;//    return res;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///****************** Send Alarm Detection **********************/
;///**************************************************************/
;///*============================================================*/
;//int checkSendMIPAlarm(unsigned char *code)
;//{
;//    if(mtncStatus != mtncAlarm)
;//    {
;//        mtncAlarm   = mtncStatus;
;//        *code       = mtncStatus;
;//        return 1;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendPowerAlarm(unsigned char *code)
;//{
;//    static TIMER    t           = 0;
;//    static char     t_flag      = 0;
;//    static char     lastCheck   = 0x69;   // -- initial with any unuse value -- //
;//
;//    if(powerSrcStatus != powerSrcAlarm)
;//    {
;//        if(powerSrcStatus != lastCheck){
;//            t_flag      = 0;
;//            lastCheck   = powerSrcStatus;
;//        }
;//
;//        if(!t_flag){
;//            if(powerSrcStatus == PWR_DOWN){
;//                TIMER_setTimer(&t,30);
;//            }
;//            else{
;//                TIMER_setTimer(&t,3);
;//            }
;//            t_flag              = 1;
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t))
;//            {
;//                powerSrcAlarm   = powerSrcStatus;
;//
;//                *code           = powerSrcStatus;
;//
;//                t_flag          = 0;
;//                return 1;
;//            }
;//        }
;//    }
;//    else
;//    {
;//        t_flag = 0;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendBatteryAlarm(unsigned char *code)
;//{
;//    static TIMER    t           = 0;
;//    static char     t_flag      = 0;
;//    static char     lastCheck   = 0x69;   // -- initial with any unuse value -- //
;//
;//    if(env_config.batteryLevel > 0)
;//    {
;//        if(batteryStatus != batteryAlarm)
;//        {
;//            if(batteryStatus != lastCheck)
;//            {
;//                t_flag      = 0;
;//                lastCheck   = batteryStatus;
;//            }
;//
;//            if(!t_flag)
;//            {
;//                if(batteryStatus == BATT_LOW){
;//                    TIMER_setTimer(&t,10);
;//                }
;//                else{
;//                    TIMER_setTimer(&t,10);
;//                }
;//                t_flag              = 1;
;//            }
;//            else
;//            {
;//                if(TIMER_checkTimerExceed(t))
;//                {
;//                    batteryAlarm   = batteryStatus;
;//
;//                    *code           = batteryStatus;
;//
;//                    t_flag          = 0;
;//                    return 1;
;//                }
;//            }
;//        }
;//        else
;//        {
;//            t_flag = 0;
;//        }
;//    }
;//    else                                // -- battery alarm disable -- //
;//    {
;//        t           = 0;
;//        t_flag      = 0;
;//        lastCheck   = 0x69;
;//        if(batteryAlarm != BATT_NORMAL)
;//        {
;//            batteryAlarm    = BATT_NORMAL;
;//            *code           = BATT_NORMAL;
;//            return 1;
;//        }
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendMemoryAlarm(unsigned char *code)
;//{
;//    static TIMER    t      = 0;
;//    static char     t_flag = 0;
;//
;//    if(env_config.memoryMin > 0)
;//    {
;//        if(memoryStatus != memoryAlarm)
;//        {
;//            if(!t_flag){
;//                TIMER_setTimer(&t,15);
;//                t_flag          = 1;
;//            }
;//            else{
;//                if(TIMER_checkTimerExceed(t))
;//                {
;//                    memoryAlarm     = memoryStatus;
;//
;//                    *code           = memoryStatus;
;//
;//                    t_flag          = 0;
;//
;//                    return 1;
;//                }
;//            }
;//        }
;//        else{
;//            t_flag              = 0;
;//        }
;//    }
;//    else                                // -- battery alarm disable -- //
;//    {
;//        t           = 0;
;//        t_flag      = 0;
;//        if(batteryAlarm != MEM_NORMAL)
;//        {
;//            memoryAlarm     = MEM_NORMAL;
;//            *code           = MEM_NORMAL;
;//            return 1;
;//        }
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendDinAlarm(int ch, unsigned char *code)
;//{
;//    static TIMER    t[USE_DIN]         = {0,0};
;//    static char     t_flag[USE_DIN]    = {0,0};
;//    static char     lastCheck[USE_DIN] = {0x69,0x69};   // -- initial with any unuse value -- //
;//
;//    if((ch < 0) || (ch >= USE_DIN)){
;//        printDebug("<checkSendDinAlarm> channel out of range [%d]\r\n",ch);
;//        return 0;
;//    }
;//
;//    if(dinStatus[ch] != dinAlarm[ch])
;//    {
;//        if(dinStatus[ch] != lastCheck[ch]){
;//            t_flag[ch]          = 0;
;//            lastCheck[ch]       = dinStatus[ch];
;//        }
;//
;//        if(!t_flag[ch]){
;//            TIMER_setTimer(&t[ch],5);
;//            t_flag[ch]          = 1;
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dinAlarm[ch]    = dinStatus[ch];
;//                *code           = dinStatus[ch];
;//                t_flag[ch]      = 0;
;//                return 1;
;//            }
;//        }
;//    }
;//    else{
;//        t_flag[ch]              =   0;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int checkSendSensorAlarm(int ch, unsigned char *code)
;//{
;//    static TIMER    t[MAX_SENS_CHANNEL]         = {0,0,0,0,0};
;//    static char     t_flag[MAX_SENS_CHANNEL]    = {0,0,0,0,0};
;//    static char     lastCheck[MAX_SENS_CHANNEL] = {0x69,0x69,0x69,0x69,0x69};   // -- initial with any unuse value -- //
;//
;//    if(sensorStatus[ch] != sensorAlarm[ch])
;//    {
;//        if(sensorStatus[ch] != lastCheck[ch]){
;//            t_flag[ch]          = 0;
;//            lastCheck[ch]       = sensorStatus[ch];
;//        }
;//
;//        if(!t_flag[ch]){
;//            if(sensorStatus[ch] == SENS_ERR_UNKNOWN){
;//                TIMER_setTimer(&t[ch],30);
;//            }
;//            else{
;//                TIMER_setTimer(&t[ch],3);
;//            }
;//            t_flag[ch]          = 1;
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                sensorAlarm[ch] = sensorStatus[ch];
;//
;//                *code           = sensorStatus[ch];
;//
;//                t_flag[ch]      = 0;
;//                return 1;
;//            }
;//        }
;//    }
;//    else{
;//        t_flag[ch]              =   0;
;//    }
;//
;//    return 0;
;//
;//    /*
;//    if(sensorStatus[ch] != sensorAlarm[ch])
;//    {
;//        sensorAlarm[ch] = sensorStatus[ch];
;//
;//        *code           = sensorStatus[ch];
;//
;//        return 1;
;//    }
;//    */
;//
;//    /*
;//    // -- mask for an error and compare with reported alarm -- //
;//    if((sensorStatus[ch] & SENS_ERR_LOWER_BOUND) != (sensorAlarm[ch] & SENS_ERR_LOWER_BOUND))
;//    {
;//        // -- check if it's an error or recover -- //
;//        if( (sensorStatus[ch] & SENS_ERR_LOWER_BOUND) == SENS_ERR_LOWER_BOUND )     // -- error -- //
;//        {
;//
;//        }
;//        else                                                                        // -- recover -- //
;//        {
;//
;//        }
;//        sensorAlarm[ch] = sensorStatus[ch];
;//
;//        *code           = sensorStatus[ch];
;//
;//        return 1;
;//    }
;//
;//    return 0;
;//    */
;//}
;///*============================================================*/
;//int checkSendDataAlarm(int ch, unsigned char *code)
;//{
;//    static TIMER    t[MAX_SENS_CHANNEL]      = {0,0,0,0,0};
;//    static char     t_flag[MAX_SENS_CHANNEL] = {0,0,0,0,0};
;//
;//    if(dataStatus[ch] != dataAlarm[ch])
;//    {
;//        if(!t_flag[ch]){
;//            TIMER_setTimer(&t[ch],3);
;//            t_flag[ch]          = 1;
;////            printDebug("<checkSendDataAlarm> Probe %d dataAlarm[0x%02X] != dataStatus[0x%02X]\r\n",ch+1,dataAlarm[ch],dataStatus[ch]);
;//        }
;//        else{
;//            if(TIMER_checkTimerExceed(t[ch]))
;//            {
;//                dataAlarm[ch]   = dataStatus[ch];
;//
;//                *code           = dataStatus[ch];
;//
;//                t_flag[ch]      = 0;
;//
;//                printDebug("<checkSendDataAlarm> Probe %d dataAlarm[0x%02X]\r\n",ch+1,dataAlarm[ch]);
;//
;//                return 1;
;//            }
;//        }
;//    }
;//    else{
;//        t_flag[ch]              = 0;
;//    }
;//
;//    return 0;
;//
;//    /*
;//    if(dataStatus[ch] != dataAlarm[ch])
;//    {
;//        dataAlarm[ch]   = dataStatus[ch];
;//
;//        *code           = dataStatus[ch];
;//
;//        return 1;
;//    }
;//    */
;//
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///****************** Alarm Mute Management *********************/
;///**************************************************************/
;//char muteMode   = 0;
;//TIMER muteAlarmExpired  = 0xFFFFFFFF;       // -- initial with maximum TIMER value -- //
;///*============================================================*/
;//int ALARM_mute(unsigned long int period)
;//{
;//    if(period == 0){
;//        muteAlarmExpired    = 0xFFFFFFFF;
;//        muteMode            = MUTE_PERMAMENT;
;//    }
;//    else{
;//        TIMER_setTimer(&muteAlarmExpired,period);
;//        muteMode            = MUTE_TEMPORARY;
;//    }
;//
;//    return 0;
;//}
;///*============================================================*/
;//int ALARM_checkMuteExpired(void)
;//{
;//    switch(muteMode){
;//        case MUTE_PERMAMENT :   return 0;
;//                                break;
;//        case MUTE_TEMPORARY :   if( TIMER_checkTimerExceed(muteAlarmExpired) ){
;//                                    return 1;
;//                                }
;//                                else{
;//                                    return 0;
;//                                }
;//                                break;
;//        default :               printDebug("<ALARM_checkMuteExpired> invalid muteMode (%d)\r\n", muteMode);
;//                                return 1;
;//    }
;//    return 0;
;//}
;///*============================================================*/
;//
;///**************************************************************/
;///****************** Sevice Alarm Function *********************/
;///**************************************************************/
;///*============================================================*/
;//void resetAlarm(void)
;//{
;//    int i;
;//
;//    for(i=0;i<MAX_SENS_CHANNEL;i++){
;//        sensorAlarm[i]      =   SENS_NORMAL;
;//        dataAlarm[i]        =   DATA_NORMAL;
;//    }
;//    for(i=0;i<MAX_DI_CHANNEL;i++){
;//        dinAlarm[i]         =   UNKNOWN;
;//    }
;//    for(i=0;i<MAX_AI_CHANNEL;i++){
;//        ainAlarm[i]         =   UNKNOWN;
;//    }
;//    muteAlarm                       = UNKNOWN;
;//    mtncAlarm                       = MTNC_NORMAL;
;//    powerSrcAlarm                   = PWR_NORMAL;
;//    batteryAlarm                    = BATT_NORMAL;
;//    communicationAlarm              = COMM_NORMAL;
;//    memoryAlarm                     = MEM_NORMAL;
;//    gsmAlarm                        = GSM_NORMAL;
;//    gsmBalanceAlarm                 = GBAL_NORMAL;
;//
;//}
;///*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <delay.h>
;#include "memcard.h"
;#include "debug.h"
;
;unsigned long int sdFreeSpace = 0;
;
;/*============================================================*/
;/* will hold the information for logical drive 0: */
;FATFS fat;
;/* pointer to the FATFS type structure */
;FATFS *pfat;
;/* root path */
;char root_path[] = "0:/";

	.DSEG
;/*============================================================*/        /* error message list */
;flash char * flash error_msg[]= {   "", /* not used */
;                                    "FR_DISK_ERR",
;                                    "FR_INT_ERR",
;                                    "FR_NOT_READY",
;                                    "FR_NO_FILE",
;                                    "FR_NO_PATH",
;                                    "FR_INVALID_NAME",
;                                    "FR_DENIED",
;                                    "FR_EXIST",
;                                    "FR_INVALID_OBJECT",
;                                    "FR_WRITE_PROTECTED",
;                                    "FR_INVALID_DRIVE",
;                                    "FR_NOT_ENABLED",
;                                    "FR_NO_FILESYSTEM",
;                                    "FR_MKFS_ABORTED",
;                                    "FR_TIMEOUT"  };
;/*============================================================*/        /* display error message and stop */
;void error(FRESULT res)
; 0012 0023 {

	.CSEG
_error:
; 0012 0024     if ((res>=FR_DISK_ERR) && (res<=FR_TIMEOUT))        printDebug("<ERR> %p.\r\n",error_msg[res]);     return;
	ST   -Y,R26
;	res -> Y+0
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRLO _0x240005
	CPI  R26,LOW(0x10)
	BRLO _0x240006
_0x240005:
	RJMP _0x240004
_0x240006:
	__POINTD1FN _0x240000,207
	CALL __PUTPARD1
	LDD  R30,Y+4
	LDI  R26,LOW(_error_msg*2)
	LDI  R27,HIGH(_error_msg*2)
	LDI  R24,BYTE3(_error_msg*2)
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __LSLD1
	CALL __LSLD1
	CALL __ADDD12
	CALL __GETD1PF
	CALL SUBOPT_0x3
_0x240004:
	ADIW R28,1
	RET
; 0012 0025 }
;/*============================================================*/
;int SD_writeData(FIL *file, unsigned long int start, unsigned char *data, unsigned int len)
; 0012 0028 {
_SD_writeData:
; 0012 0029     FRESULT         res;
; 0012 002A     unsigned int    actual_write;
; 0012 002B 
; 0012 002C     if(sdFreeSpace == 0){ printDebug("<SD_writeData> SD Card not ready\r\n");       return -1;}
	CALL SUBOPT_0x4C
;	*file -> Y+12
;	start -> Y+8
;	*data -> Y+6
;	len -> Y+4
;	res -> R17
;	actual_write -> R18,R19
	CALL SUBOPT_0x4D
	BRNE _0x240007
	__POINTD1FN _0x240000,219
	CALL SUBOPT_0x0
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0037
; 0012 002D 
; 0012 002E     res = f_lseek(file,start);
_0x240007:
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x4F
	CALL _f_lseek
	MOV  R17,R30
; 0012 002F     if(res != FR_OK){
	CPI  R17,0
	BREQ _0x240008
; 0012 0030         printDebug("<SD_writeData> f_lseek(%u) failed!!\r\n", start);
	__POINTD1FN _0x240000,254
	CALL SUBOPT_0x1A
	CALL SUBOPT_0x3
; 0012 0031         error(res);
	CALL SUBOPT_0x50
; 0012 0032         return -1;
	RJMP _0x20E0037
; 0012 0033     }
; 0012 0034 
; 0012 0035     res = f_write(file,data,len,&actual_write);
_0x240008:
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x51
	CALL SUBOPT_0x51
	IN   R26,SPL
	IN   R27,SPH
	SBIW R26,1
	PUSH R19
	PUSH R18
	CALL _f_write
	POP  R18
	POP  R19
	MOV  R17,R30
; 0012 0036     if(res != FR_OK){
	CPI  R17,0
	BREQ _0x240009
; 0012 0037         printDebug("<SD_writeData> f_write() failed\r\n");
	__POINTD1FN _0x240000,292
	CALL SUBOPT_0x0
; 0012 0038         print_payload(data,len);
	CALL SUBOPT_0x52
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	RCALL _print_payload
; 0012 0039         error(res);
	MOV  R26,R17
	RCALL _error
; 0012 003A         return -2;
	LDI  R30,LOW(65534)
	LDI  R31,HIGH(65534)
	RJMP _0x20E0037
; 0012 003B     }
; 0012 003C 
; 0012 003D     if(actual_write != len){
_0x240009:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CP   R30,R18
	CPC  R31,R19
	BREQ _0x24000A
; 0012 003E         printDebug("<SD_writeData> actual_write[%u] != len[%u]\r\n",actual_write,len);
	__POINTD1FN _0x240000,326
	CALL __PUTPARD1
	MOVW R30,R18
	CALL SUBOPT_0x48
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	CALL SUBOPT_0x48
	LDI  R24,8
	RCALL _printDebug
	ADIW R28,12
; 0012 003F         return -3; // -- the caller should roll back the last data -- //
	LDI  R30,LOW(65533)
	LDI  R31,HIGH(65533)
	RJMP _0x20E0037
; 0012 0040     }
; 0012 0041 
; 0012 0042     return 0;
_0x24000A:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0037:
	CALL __LOADLOCR4
	ADIW R28,14
	RET
; 0012 0043 }
;/*============================================================*/
;int SD_readData(FIL *file, unsigned long int start, unsigned char *data, unsigned int len)
; 0012 0046 {
; 0012 0047     FRESULT         res;
; 0012 0048     unsigned int    actual_read;
; 0012 0049 
; 0012 004A     if(sdFreeSpace == 0){ printDebug("<SD_readData> SD Card not ready\r\n");       return -1;}
;	*file -> Y+12
;	start -> Y+8
;	*data -> Y+6
;	len -> Y+4
;	res -> R17
;	actual_read -> R18,R19
; 0012 004B 
; 0012 004C     res = f_lseek(file,start);
; 0012 004D     if(res != FR_OK){
; 0012 004E         printDebug("<SD_readData> f_lseek(%u) failed!!\r\n", start);
; 0012 004F         error(res);
; 0012 0050         return -1;
; 0012 0051     }
; 0012 0052 
; 0012 0053     res = f_read(file,data,len,&actual_read);
; 0012 0054     if(res != FR_OK){
; 0012 0055         printDebug("<SD_readData> f_read() failed\r\n");
; 0012 0056         error(res);
; 0012 0057         return -2;
; 0012 0058     }
; 0012 0059 
; 0012 005A     if(actual_read != len){
; 0012 005B         printDebug("<SD_writeData> actual_read[%u] != len[%u]\r\n",actual_read,len);
; 0012 005C         return -3; // -- the caller should roll back the last data -- //
; 0012 005D     }
; 0012 005E 
; 0012 005F     return 0;
; 0012 0060 }
;/*============================================================*/
;int SD_readMemoryRemain(unsigned long *free_kbytes)
; 0012 0063 {
_SD_readMemoryRemain:
; 0012 0064     FRESULT         res;
; 0012 0065     unsigned long   free_clusters;
; 0012 0066 
; 0012 0067     // ------ read available memory space ------- //
; 0012 0068     // return as percentage!!! //
; 0012 0069 
; 0012 006A     /* get the number of free clusters */
; 0012 006B     res = f_getfree(root_path,&free_clusters,&pfat);
	CALL SUBOPT_0x45
;	*free_kbytes -> Y+5
;	res -> R17
;	free_clusters -> Y+1
	LDI  R30,LOW(_root_path)
	LDI  R31,HIGH(_root_path)
	CALL SUBOPT_0x53
	LDI  R26,LOW(_pfat)
	LDI  R27,HIGH(_pfat)
	CALL _f_getfree
	MOV  R17,R30
; 0012 006C     if ( res != FR_OK){
	CPI  R17,0
	BREQ _0x24000F
; 0012 006D        /* an error occured, display it and stop */
; 0012 006E        printDebug("<SD_readMemoryRemain> f_getfree(%s) error!!\r\n",root_path);
	__POINTD1FN _0x240000,518
	CALL SUBOPT_0x54
	CALL SUBOPT_0x55
; 0012 006F        error(res);
	MOV  R26,R17
	CALL SUBOPT_0x56
; 0012 0070        sdFreeSpace = 0;
; 0012 0071        return -1;
	RJMP _0x20E0036
; 0012 0072     }
; 0012 0073 
; 0012 0074     /* calculate the number of free bytes */
; 0012 0075     *free_kbytes = free_clusters * pfat->csize / 2;
_0x24000F:
	LDS  R30,_pfat
	LDS  R31,_pfat+1
	CALL SUBOPT_0x57
	CALL SUBOPT_0x58
	CALL SUBOPT_0x59
	CALL __LSRD1
	LDD  R26,Y+5
	LDD  R27,Y+5+1
	CALL __PUTDP1
; 0012 0076 
; 0012 0077     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0036:
	LDD  R17,Y+0
	ADIW R28,7
	RET
; 0012 0078 }
;/*============================================================*/
;int SD_mount(void)
; 0012 007B {
_SD_mount:
; 0012 007C     FRESULT         res;
; 0012 007D 
; 0012 007E     /* mount logical drive 0: */
; 0012 007F     res = f_mount(0,&fat);
	ST   -Y,R17
;	res -> R17
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R26,LOW(_fat)
	LDI  R27,HIGH(_fat)
	CALL _f_mount
	MOV  R17,R30
; 0012 0080     if( res != FR_OK ){
	CPI  R17,0
	BREQ _0x240010
; 0012 0081         printDebug("Logical drive 0: mounted ERROR\r\n");
	__POINTD1FN _0x240000,564
	CALL SUBOPT_0x0
; 0012 0082         error(res);
	CALL SUBOPT_0x50
; 0012 0083         return -1;
	JMP  _0x20E002E
; 0012 0084     }
; 0012 0085 
; 0012 0086     printDebug("Logical drive 0: mounted OK\r\n");
_0x240010:
	__POINTD1FN _0x240000,597
	CALL SUBOPT_0x0
; 0012 0087     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	JMP  _0x20E002E
; 0012 0088 }
;/*============================================================*/
;int SD_unmount(void)
; 0012 008B {
; 0012 008C     FRESULT         res;
; 0012 008D 
; 0012 008E     /* unmount logical drive 0: */
; 0012 008F     res = f_mount(0,NULL);
;	res -> R17
; 0012 0090     if( res != FR_OK ){
; 0012 0091         printDebug("Logical drive 0: unmounted ERROR\r\n");
; 0012 0092         error(res);
; 0012 0093         return -1;
; 0012 0094     }
; 0012 0095 
; 0012 0096     printDebug("Logical drive 0: unmounted OK\r\n");
; 0012 0097     return 0;
; 0012 0098 }
;/*============================================================*/
;int SD_remount(void)
; 0012 009B {
; 0012 009C     int res;
; 0012 009D 
; 0012 009E     res = SD_unmount();
;	res -> R16,R17
; 0012 009F     if(res < 0){
; 0012 00A0         printDebug("<SD_remount> SD_unmount() failed\r\n");
; 0012 00A1         return -1;
; 0012 00A2     }
; 0012 00A3     delay_ms(250);
; 0012 00A4     res = SD_mount();
; 0012 00A5     if(res < 0){
; 0012 00A6         printDebug("<SD_remount> SD_mount() failed\r\n");
; 0012 00A7         return -1;
; 0012 00A8     }
; 0012 00A9     delay_ms(250);
; 0012 00AA //
; 0012 00AB //    if(SD_createFile(LOG_PROTOCOL) < 0){
; 0012 00AC //        printDebug("Error creating new log file (Remount failed)\r\n");
; 0012 00AD //        return -1;
; 0012 00AE //    }
; 0012 00AF 
; 0012 00B0     return 0;
; 0012 00B1 }
;/*============================================================*/
;int SD_createFile(char *filename, unsigned char mode)
; 0012 00B4 {
_SD_createFile:
; 0012 00B5     FIL          file;
; 0012 00B6     FRESULT      res;
; 0012 00B7     char         filepath[50];
; 0012 00B8 
; 0012 00B9     if(sdFreeSpace == 0){ printDebug("<SD_createFile> SD Card not ready\r\n");      return -1;}
	ST   -Y,R26
	SBIW R28,63
	SBIW R28,19
	SUBI R29,2
	ST   -Y,R17
;	*filename -> Y+596
;	mode -> Y+595
;	file -> Y+51
;	res -> R17
;	filepath -> Y+1
	CALL SUBOPT_0x4D
	BRNE _0x240014
	__POINTD1FN _0x240000,762
	CALL SUBOPT_0x0
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0035
; 0012 00BA 
; 0012 00BB     sprintf(filepath,"%s%s",root_path,filename);
_0x240014:
	CALL SUBOPT_0x5A
	CALL SUBOPT_0x5B
	CALL SUBOPT_0x48
	__GETW1SX 606
	CALL SUBOPT_0x48
	LDI  R24,8
	CALL _sprintf
	ADIW R28,14
; 0012 00BC 
; 0012 00BD     if(mode == SD_FORCE)        // -- replace old file if exist -- //
	__GETB2SX 595
	CPI  R26,LOW(0x1)
	BRNE _0x240015
; 0012 00BE     {
; 0012 00BF         //printDebug("<SD_createFile> Force re-creating file %s.\r\n",filename);
; 0012 00C0         res = f_open(   &file,
; 0012 00C1                         filepath,
; 0012 00C2                         FA_CREATE_ALWAYS | FA_WRITE );
	MOVW R30,R28
	ADIW R30,51
	CALL SUBOPT_0x53
	LDI  R26,LOW(10)
	RJMP _0x240021
; 0012 00C3     }
; 0012 00C4     else                        // -- keep old file if exist -- //
_0x240015:
; 0012 00C5     {
; 0012 00C6         //printDebug("<SD_createFile> Try to creating file %s.\r\n",filename);
; 0012 00C7         res = f_open(   &file,
; 0012 00C8                         filepath,
; 0012 00C9                         FA_CREATE_NEW | FA_WRITE );
	MOVW R30,R28
	ADIW R30,51
	CALL SUBOPT_0x53
	LDI  R26,LOW(6)
_0x240021:
	CALL _f_open
	MOV  R17,R30
; 0012 00CA     }
; 0012 00CB 
; 0012 00CC     if( res == FR_EXIST){
	CPI  R17,8
	BRNE _0x240017
; 0012 00CD         //printDebug("<SD_createFile> %s already exist\r\n", filename);
; 0012 00CE 
; 0012 00CF //        res = f_close( &file );
; 0012 00D0 //        if( res != FR_OK ){
; 0012 00D1 //            printDebug("<SD_createFile> f_close() failed\r\n");
; 0012 00D2 //            error(res);
; 0012 00D3 //            return -1;
; 0012 00D4 //        }
; 0012 00D5 
; 0012 00D6         return 0;       // -- return 0 indicated that a file is already exist -- //
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E0035
; 0012 00D7     }
; 0012 00D8     else if( res != FR_OK){
_0x240017:
	CPI  R17,0
	BREQ _0x240019
; 0012 00D9         printDebug("<SD_createFile> f_open() failed\r\n");
	__POINTD1FN _0x240000,803
	CALL SUBOPT_0x0
; 0012 00DA         error(res);
	CALL SUBOPT_0x50
; 0012 00DB         return -1;
	RJMP _0x20E0035
; 0012 00DC     }
; 0012 00DD 
; 0012 00DE     //printDebug("<SD_createFile> '%s' created!!\r\n",filename);
; 0012 00DF 
; 0012 00E0     res = f_close( &file );
_0x240019:
	MOVW R26,R28
	ADIW R26,51
	CALL _f_close
	MOV  R17,R30
; 0012 00E1     if( res != FR_OK ){
	CPI  R17,0
	BREQ _0x24001A
; 0012 00E2         printDebug("<SD_createFile> f_close() failed\r\n");
	__POINTD1FN _0x240000,837
	CALL SUBOPT_0x0
; 0012 00E3         error(res);
	CALL SUBOPT_0x50
; 0012 00E4         return -1;
	RJMP _0x20E0035
; 0012 00E5     }
; 0012 00E6 
; 0012 00E7     return 1;   // -- return 1 indicated that it's a new file -- //
_0x24001A:
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
_0x20E0035:
	LDD  R17,Y+0
	ADIW R28,63
	ADIW R28,23
	SUBI R29,-2
	RET
; 0012 00E8 }
;/*============================================================*/
;int SD_openFile(FIL *file, unsigned char *filename)
; 0012 00EB {
_SD_openFile:
; 0012 00EC     int     res;
; 0012 00ED     char    filepath[50];
; 0012 00EE 
; 0012 00EF     if(sdFreeSpace == 0){ printDebug("<SD_openFile> SD Card not ready\r\n");    return -1;}
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,50
	ST   -Y,R17
	ST   -Y,R16
;	*file -> Y+54
;	*filename -> Y+52
;	res -> R16,R17
;	filepath -> Y+2
	CALL SUBOPT_0x4D
	BRNE _0x24001B
	__POINTD1FN _0x240000,872
	CALL SUBOPT_0x0
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0034
; 0012 00F0 
; 0012 00F1     sprintf(filepath,"%s%s",root_path,filename);
_0x24001B:
	CALL SUBOPT_0x5C
	CALL SUBOPT_0x5B
	CALL SUBOPT_0x48
	LDD  R30,Y+62
	LDD  R31,Y+62+1
	CALL SUBOPT_0x48
	LDI  R24,8
	CALL _sprintf
	ADIW R28,14
; 0012 00F2 
; 0012 00F3     res = f_open( file, filepath, FA_WRITE | FA_READ | FA_OPEN_EXISTING);
	LDD  R30,Y+54
	LDD  R31,Y+54+1
	CALL SUBOPT_0x5D
	LDI  R26,LOW(3)
	CALL _f_open
	MOV  R16,R30
	CLR  R17
; 0012 00F4     if( res != FR_OK){
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x24001C
; 0012 00F5         printDebug("<SD_openFile> f_open() [%s] failed\r\n", filename);
	__POINTD1FN _0x240000,906
	CALL __PUTPARD1
	LDD  R30,Y+56
	LDD  R31,Y+56+1
	CALL SUBOPT_0x55
; 0012 00F6         error(res);
	MOV  R26,R16
	CALL SUBOPT_0x56
; 0012 00F7         sdFreeSpace = 0;
; 0012 00F8         return -1;
	RJMP _0x20E0034
; 0012 00F9     }
; 0012 00FA 
; 0012 00FB     return 0;
_0x24001C:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0034:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,56
	RET
; 0012 00FC }
;/*============================================================*/
;int SD_closeFile(FIL *file)
; 0012 00FF {
_SD_closeFile:
; 0012 0100     int res;
; 0012 0101 
; 0012 0102     if(sdFreeSpace == 0){ printDebug("<SD_closeFile> SD Card not ready\r\n");       return -1;}
	CALL SUBOPT_0x5E
;	*file -> Y+2
;	res -> R16,R17
	CALL SUBOPT_0x4D
	BRNE _0x24001D
	__POINTD1FN _0x240000,943
	CALL SUBOPT_0x0
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0030
; 0012 0103 
; 0012 0104     res = f_close( file );
_0x24001D:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	CALL _f_close
	MOV  R16,R30
	CLR  R17
; 0012 0105     if( res != FR_OK ){
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x24001E
; 0012 0106         printDebug("<SD_closeFile> f_close() failed\r\n");
	__POINTD1FN _0x240000,978
	CALL SUBOPT_0x0
; 0012 0107         error(res);
	MOV  R26,R16
	RCALL _error
; 0012 0108         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0030
; 0012 0109     }
; 0012 010A 
; 0012 010B     return 0;
_0x24001E:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0030
; 0012 010C }
;/*============================================================*/
;int SD_init(void)
; 0012 010F {
_SD_init:
; 0012 0110     int                 err;
; 0012 0111 
; 0012 0112     printDebug("<SD_init> Start initial memory card\r\n");
	ST   -Y,R17
	ST   -Y,R16
;	err -> R16,R17
	__POINTD1FN _0x240000,1012
	CALL SUBOPT_0x0
; 0012 0113 
; 0012 0114     /* point to the FATFS structure that holds
; 0012 0115     information for the logical drive 0: */
; 0012 0116     pfat=&fat;
	LDI  R30,LOW(_fat)
	LDI  R31,HIGH(_fat)
	STS  _pfat,R30
	STS  _pfat+1,R31
; 0012 0117 
; 0012 0118     delay_ms(1000);
	CALL SUBOPT_0x5F
; 0012 0119     printDebug("\r\n<SD_init> Mounting SD Card...");
	__POINTD1FN _0x240000,1050
	CALL SUBOPT_0x0
; 0012 011A     err = SD_mount();
	RCALL _SD_mount
	MOVW R16,R30
; 0012 011B     if(err < 0){
	TST  R17
	BRPL _0x24001F
; 0012 011C         printDebug("<SD_init> SD_mount() failed\r\n");
	__POINTD1FN _0x240000,1082
	CALL SUBOPT_0x0
; 0012 011D         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0033
; 0012 011E     }
; 0012 011F 
; 0012 0120 
; 0012 0121     printDebug("\r\n<SD_init> Check Card Size...");
_0x24001F:
	__POINTD1FN _0x240000,1112
	CALL SUBOPT_0x0
; 0012 0122 
; 0012 0123     delay_ms(1000);
	CALL SUBOPT_0x5F
; 0012 0124 
; 0012 0125     err = SD_readMemoryRemain(&sdFreeSpace);
	LDI  R26,LOW(_sdFreeSpace)
	LDI  R27,HIGH(_sdFreeSpace)
	RCALL _SD_readMemoryRemain
	MOVW R16,R30
; 0012 0126     if(err < 0){
	TST  R17
	BRPL _0x240020
; 0012 0127         printDebug("<SD_init> SD_readMemoryRemain() failed\r\n");
	__POINTD1FN _0x240000,1143
	CALL SUBOPT_0x0
; 0012 0128         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0033
; 0012 0129     }
; 0012 012A 
; 0012 012B     /* display the number of free kbytes */
; 0012 012C     printDebug("<SD_init> Free space on logical drive 0: %lu kbytes\r\n",sdFreeSpace);
_0x240020:
	__POINTD1FN _0x240000,1184
	CALL __PUTPARD1
	LDS  R30,_sdFreeSpace
	LDS  R31,_sdFreeSpace+1
	LDS  R22,_sdFreeSpace+2
	LDS  R23,_sdFreeSpace+3
	CALL SUBOPT_0x3
; 0012 012D 
; 0012 012E     return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0033:
	LD   R16,Y+
	LD   R17,Y+
	RET
; 0012 012F }
;/*============================================================*/
;
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "log.h"
;#include "debug.h"
;
;unsigned char LOGFILE_DATA[]            = "data.log";           // -- data log file name -- //

	.DSEG
;unsigned char LOGFILE_EVENT[]           = "event.log";          // -- event log file name -- //
;unsigned char LOGFILE_ERROR[]           = "error.log";          // -- error log file name -- //
;unsigned char LOG_INIT_STR[SIZE_RECORD] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
;/*============================================================*/
;
;/**************************************************************/
;/************** Function Pointer to memcard.h *****************/
;/**************************************************************/
;/*============================================================*/
;int (*LOG_openFile)(FIL *, unsigned char *) = &SD_openFile;
;int (*LOG_closeFile)(FIL *)                 = &SD_closeFile;
;/*============================================================*/
;
;/**************************************************************/
;/******************* Data Log Management **********************/
;/**************************************************************/
;char isDataLogEmpty     = 0;
;/*============================================================*/
;int LOG_insertData(FIL *file, unsigned long int timestamp, unsigned int channel, float value)
; 0013 001B {

	.CSEG
; 0013 001C     int                 res;
; 0013 001D     unsigned long int   index;
; 0013 001E     unsigned long int   startAddr;
; 0013 001F     unsigned char       flag;
; 0013 0020 
; 0013 0021     res             = LOG_getLastInsert(file, &index);
;	*file -> Y+22
;	timestamp -> Y+18
;	channel -> Y+16
;	value -> Y+12
;	res -> R16,R17
;	index -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 0022     if(res < 0){    printDebug("<LOG_insertData> LOG_getLastInsert() failed\r\n");      return -1;  }
; 0013 0023 
; 0013 0024     flag            = 'P';
; 0013 0025 
; 0013 0026     startAddr       = index2Addr(index,SIZE_LOG_DATA);
; 0013 0027 
; 0013 0028     res             = SD_writeData(file, startAddr+OFFSET_FLAG,         (unsigned char *) &flag,        SIZE_FLAG);
; 0013 0029     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(flag) failed\r\n");       return -1;  }
; 0013 002A 
; 0013 002B     res             = SD_writeData(file, startAddr+OFFSET_TIMESTAMP,    (unsigned char *) &timestamp,   SIZE_TIMESTAMP);
; 0013 002C     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(timestamp) failed\r\n");  return -1;  }
; 0013 002D 
; 0013 002E     res             = SD_writeData(file, startAddr+OFFSET_DATA_CHANNEL, (unsigned char *) &channel,     SIZE_CHANNEL);
; 0013 002F     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(channel) failed\r\n");    return -1;  }
; 0013 0030 
; 0013 0031     res             = SD_writeData(file, startAddr+OFFSET_DATA_VALUE,   (unsigned char *) &value,       SIZE_VALUE);
; 0013 0032     if(res < 0){    printDebug("<LOG_insertData> SD_writeData(value) failed\r\n");      return -1;  }
; 0013 0033 
; 0013 0034     res = LOG_setLastInsert(file,++index);
; 0013 0035     if(res < 0){    printDebug("<LOG_insertData> LOG_setLastInsert(%ld) failed\r\n",index);      return -1;  }
; 0013 0036 
; 0013 0037     isDataLogEmpty  = 0;
; 0013 0038     return index;
; 0013 0039 }
;/*============================================================*/
;int LOG_readData(FIL *file, unsigned long int *timestamp, unsigned int *channel, float *value, unsigned long int *index)
; 0013 003C {
; 0013 003D     int                 res;
; 0013 003E     unsigned long int   lastLogInsert;
; 0013 003F     unsigned long int   lastLogSend;
; 0013 0040     unsigned long int   startAddr;
; 0013 0041     unsigned char       flag;
; 0013 0042 
; 0013 0043 
; 0013 0044     res             = LOG_getLastInsert(file, &lastLogInsert);
;	*file -> Y+24
;	*timestamp -> Y+22
;	*channel -> Y+20
;	*value -> Y+18
;	*index -> Y+16
;	res -> R16,R17
;	lastLogInsert -> Y+12
;	lastLogSend -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 0045     if(res < 0){    printDebug("<LOG_readData> LOG_getLastInsert() failed\r\n");        return -1;  }
; 0013 0046     res             = LOG_getLastSend(file, &lastLogSend);
; 0013 0047     if(res < 0){    printDebug("<LOG_readData> LOG_getLastSend() failed\r\n");          return -1;  }
; 0013 0048 
; 0013 0049     printDebug("<LOG_readEvent> lastSend/lastInsert  --> %ld/%ld\r\n",lastLogSend,lastLogInsert);
; 0013 004A 
; 0013 004B     if(lastLogSend >= lastLogInsert)
; 0013 004C     {
; 0013 004D         printDebug("<LOG_readData> Log empty..!!\r\n");
; 0013 004E 
; 0013 004F         res = LOG_createFile(LOGFILE_DATA,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0013 0050         if(res < 0)
; 0013 0051         {
; 0013 0052             printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_DATA);
; 0013 0053         }
; 0013 0054 
; 0013 0055         isDataLogEmpty  = 1;
; 0013 0056         return 0;
; 0013 0057     }
; 0013 0058 
; 0013 0059     startAddr       = index2Addr(lastLogSend,SIZE_LOG_DATA);
; 0013 005A 
; 0013 005B     res             = SD_readData(file, startAddr+OFFSET_FLAG,          (unsigned char *) &flag,        SIZE_FLAG);
; 0013 005C     if(res < 0){    printDebug("<LOG_readData> SD_readData(flag) failed\r\n");          return -1;  }
; 0013 005D 
; 0013 005E     res             = SD_readData(file, startAddr+OFFSET_TIMESTAMP,     (unsigned char *) timestamp,    SIZE_TIMESTAMP);
; 0013 005F     if(res < 0){    printDebug("<LOG_readData> SD_readData(timestamp) failed\r\n");     return -1;  }
; 0013 0060 
; 0013 0061     res             = SD_readData(file, startAddr+OFFSET_DATA_CHANNEL, (unsigned char *) channel,       SIZE_CHANNEL);
; 0013 0062     if(res < 0){    printDebug("<LOG_readData> SD_readData(channel) failed\r\n");       return -1;  }
; 0013 0063 
; 0013 0064     res             = SD_readData(file, startAddr+OFFSET_DATA_VALUE,    (unsigned char *) value,        SIZE_VALUE);
; 0013 0065     if(res < 0){    printDebug("<LOG_readData> SD_readData(value) failed\r\n");         return -1;  }
; 0013 0066 
; 0013 0067     *index          = lastLogSend;
; 0013 0068 
; 0013 0069     return 1;
; 0013 006A }
;/*============================================================*/
;
;/**************************************************************/
;/******************* Event Log Management *********************/
;/**************************************************************/
;char isEventLogEmpty    = 0;
;/*============================================================*/
;int LOG_insertEvent(FIL *file, unsigned long int timestamp, unsigned char id, unsigned char status)
; 0013 0073 {
; 0013 0074     int                 res;
; 0013 0075     unsigned long int   index;
; 0013 0076     unsigned long int   startAddr;
; 0013 0077     unsigned char       flag;
; 0013 0078 
; 0013 0079     res = LOG_getLastInsert(file, &index);
;	*file -> Y+18
;	timestamp -> Y+14
;	id -> Y+13
;	status -> Y+12
;	res -> R16,R17
;	index -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 007A     if(res < 0){    printDebug("<LOG_insertEvent> LOG_getLastInsert() failed\r\n");     return -1;  }
; 0013 007B 
; 0013 007C     flag            = 'P';
; 0013 007D 
; 0013 007E     startAddr       = index2Addr(index,SIZE_LOG_EVENT);
; 0013 007F 
; 0013 0080     res             = SD_writeData(file, startAddr+OFFSET_FLAG,         (unsigned char *) &flag,        SIZE_FLAG);
; 0013 0081     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(flag) failed\r\n");      return -1;  }
; 0013 0082 
; 0013 0083     res             = SD_writeData(file, startAddr+OFFSET_TIMESTAMP,    (unsigned char *) &timestamp,   SIZE_TIMESTAMP);
; 0013 0084     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(timestamp) failed\r\n"); return -1;  }
; 0013 0085 
; 0013 0086     res             = SD_writeData(file, startAddr+OFFSET_EVENT_ID,     (unsigned char *) &id,          SIZE_ID);
; 0013 0087     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(id) failed\r\n");        return -1;  }
; 0013 0088 
; 0013 0089     res             = SD_writeData(file, startAddr+OFFSET_EVENT_STATUS, (unsigned char *) &status,      SIZE_STATUS);
; 0013 008A     if(res < 0){    printDebug("<LOG_insertEvent> SD_writeData(status) failed\r\n");    return -1;  }
; 0013 008B 
; 0013 008C     res = LOG_setLastInsert(file,++index);
; 0013 008D     if(res < 0){    printDebug("<LOG_insertEvent> LOG_setLastInsert(%ld) failed\r\n",index);     return -1;  }
; 0013 008E 
; 0013 008F     isEventLogEmpty = 0;
; 0013 0090 
; 0013 0091     return index;
; 0013 0092 }
;/*============================================================*/
;int LOG_readEvent(FIL *file, unsigned long int *timestamp, unsigned char *id, unsigned char *status, unsigned long int *index)
; 0013 0095 {
; 0013 0096     int                 res;
; 0013 0097     unsigned long int   lastLogInsert;
; 0013 0098     unsigned long int   lastLogSend;
; 0013 0099     unsigned long int   startAddr;
; 0013 009A     unsigned char       flag;
; 0013 009B 
; 0013 009C 
; 0013 009D     res             = LOG_getLastInsert(file, &lastLogInsert);
;	*file -> Y+24
;	*timestamp -> Y+22
;	*id -> Y+20
;	*status -> Y+18
;	*index -> Y+16
;	res -> R16,R17
;	lastLogInsert -> Y+12
;	lastLogSend -> Y+8
;	startAddr -> Y+4
;	flag -> R19
; 0013 009E     if(res < 0){    printDebug("<LOG_readEvent> LOG_getLastInsert() failed\r\n");       return -1;  }
; 0013 009F     res             = LOG_getLastSend(file, &lastLogSend);
; 0013 00A0     if(res < 0){    printDebug("<LOG_readEvent> LOG_getLastSend() failed\r\n");         return -1;  }
; 0013 00A1 
; 0013 00A2     printDebug("<LOG_readEvent> lastSend/lastInsert  --> %ld/%ld\r\n",lastLogSend,lastLogInsert);
; 0013 00A3 
; 0013 00A4     if(lastLogSend >= lastLogInsert)
; 0013 00A5     {
; 0013 00A6         printDebug("<LOG_readEvent> Log empty..!!\r\n");
; 0013 00A7 
; 0013 00A8         res = LOG_createFile(LOGFILE_EVENT,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0013 00A9         if(res < 0)
; 0013 00AA         {
; 0013 00AB             printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_EVENT);
; 0013 00AC         }
; 0013 00AD 
; 0013 00AE         isEventLogEmpty     = 1;
; 0013 00AF         return 0;
; 0013 00B0     }
; 0013 00B1 
; 0013 00B2     startAddr       = index2Addr(lastLogSend,SIZE_LOG_EVENT);
; 0013 00B3 
; 0013 00B4     res             = SD_readData(file, startAddr+OFFSET_FLAG,          (unsigned char *) &flag,        SIZE_FLAG);
; 0013 00B5     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(flag) failed\r\n");         return -1;  }
; 0013 00B6 
; 0013 00B7     res             = SD_readData(file, startAddr+OFFSET_TIMESTAMP,     (unsigned char *) timestamp,    SIZE_TIMESTAMP);
; 0013 00B8     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(timestamp) failed\r\n");    return -1;  }
; 0013 00B9 
; 0013 00BA     res             = SD_readData(file, startAddr+OFFSET_EVENT_ID,      (unsigned char *) id,           SIZE_ID);
; 0013 00BB     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(id) failed\r\n");           return -1;  }
; 0013 00BC 
; 0013 00BD     res             = SD_readData(file, startAddr+OFFSET_EVENT_STATUS,  (unsigned char *) status,       SIZE_STATUS);
; 0013 00BE     if(res < 0){    printDebug("<LOG_readEvent> SD_readData(status) failed\r\n");       return -1;  }
; 0013 00BF 
; 0013 00C0     *index  = lastLogSend;
; 0013 00C1     return 1;
; 0013 00C2 }
;/*============================================================*/
;
;/**************************************************************/
;/******************* Log Indexing Function ********************/
;/**************************************************************/
;/*============================================================*/
;int LOG_getLastInsert(FIL *file, unsigned long int *index)
; 0013 00CA {
; 0013 00CB     int             res;
; 0013 00CC 
; 0013 00CD     res = SD_readData(file, 0, (unsigned char *) index, sizeof(unsigned long int));
;	*file -> Y+4
;	*index -> Y+2
;	res -> R16,R17
; 0013 00CE     if(res < 0)
; 0013 00CF     {
; 0013 00D0         printDebug("<LOG_getLastInsert> SD_readData() failed\r\n");
; 0013 00D1         return -1;
; 0013 00D2     }
; 0013 00D3 
; 0013 00D4     printDebug("<LOG_getLastInsert> got %ld\r\n", *index);
; 0013 00D5 
; 0013 00D6     return 0;
; 0013 00D7 }
;/*============================================================*/
;int LOG_setLastInsert(FIL *file, unsigned long int index)
; 0013 00DA {
; 0013 00DB     int             res;
; 0013 00DC 
; 0013 00DD     printDebug("<LOG_setLastInsert> writing %ld\r\n", index);
;	*file -> Y+6
;	index -> Y+2
;	res -> R16,R17
; 0013 00DE     print_payload((unsigned char *) &index, sizeof(unsigned long int));
; 0013 00DF 
; 0013 00E0     res = SD_writeData(file, 0, (unsigned char *) &index, sizeof(unsigned long int));
; 0013 00E1     if(res < 0)
; 0013 00E2     {
; 0013 00E3         printDebug("<LOG_setLastInsert> SD_readData() failed\r\n");
; 0013 00E4         return -1;
; 0013 00E5     }
; 0013 00E6 
; 0013 00E7     return 0;
; 0013 00E8 }
;/*============================================================*/
;int LOG_getLastSend(FIL *file, unsigned long int *index)
; 0013 00EB {
; 0013 00EC     int             res;
; 0013 00ED 
; 0013 00EE     res = SD_readData(file, 4, (unsigned char *) index, sizeof(unsigned long int));
;	*file -> Y+4
;	*index -> Y+2
;	res -> R16,R17
; 0013 00EF     if(res < 0)
; 0013 00F0     {
; 0013 00F1         printDebug("<LOG_getLastSend> SD_readData() failed\r\n");
; 0013 00F2         return -1;
; 0013 00F3     }
; 0013 00F4 
; 0013 00F5     printDebug("<LOG_getLastSend> got %ld\r\n", *index);
; 0013 00F6 
; 0013 00F7     return 0;
; 0013 00F8 }
;/*============================================================*/
;int LOG_setLastSend(FIL *file, unsigned long int index)
; 0013 00FB {
; 0013 00FC     int             res;
; 0013 00FD 
; 0013 00FE     printDebug("<LOG_setLastSend> writing %ld\r\n", index);
;	*file -> Y+6
;	index -> Y+2
;	res -> R16,R17
; 0013 00FF     print_payload((unsigned char *) &index, sizeof(unsigned long int));
; 0013 0100 
; 0013 0101     res = SD_writeData(file, 4, (unsigned char *) &index, sizeof(unsigned long int));
; 0013 0102     if(res < 0)
; 0013 0103     {
; 0013 0104         printDebug("<LOG_setLastSend> SD_readData() failed\r\n");
; 0013 0105         return -1;
; 0013 0106     }
; 0013 0107 
; 0013 0108     return 0;
; 0013 0109 }
;/*============================================================*/
;
;/**************************************************************/
;/********************* Support Function ***********************/
;/**************************************************************/
;/*============================================================*/
;unsigned long int index2Addr(unsigned long int index,int recordSize)
; 0013 0111 {
; 0013 0112     unsigned long int address=0;
; 0013 0113 
; 0013 0114     address = ( index * recordSize ) + SIZE_LAST_LOG_INDEX + SIZE_LAST_LOG_SENT + SIZE_PADDING;
;	index -> Y+6
;	recordSize -> Y+4
;	address -> Y+0
; 0013 0115 
; 0013 0116     return address;
; 0013 0117 }
;/*============================================================*/
;int LOG_createFile(unsigned char *filename, unsigned char mode, unsigned char *initString, unsigned int len)
; 0013 011A {
_LOG_createFile:
; 0013 011B     FIL         file;
; 0013 011C     int         res;
; 0013 011D 
; 0013 011E     res = SD_createFile(filename,mode);
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,32
	SUBI R29,2
	ST   -Y,R17
	ST   -Y,R16
;	*filename -> Y+551
;	mode -> Y+550
;	*initString -> Y+548
;	len -> Y+546
;	file -> Y+2
;	res -> R16,R17
	__GETW1SX 551
	ST   -Y,R31
	ST   -Y,R30
	__GETB2SX 552
	RCALL _SD_createFile
	MOVW R16,R30
; 0013 011F     if(res < 0){
	TST  R17
	BRPL _0x260029
; 0013 0120         printDebug("<LOG_createFile> SD_createFile(%s) failed\r\n",filename);
	__POINTD1FN _0x260000,1553
	CALL SUBOPT_0x60
; 0013 0121         return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0031
; 0013 0122     }
; 0013 0123     else if(res == 0)
_0x260029:
	MOV  R0,R16
	OR   R0,R17
	BRNE _0x26002B
; 0013 0124     {
; 0013 0125         printDebug("<LOG_createFile> %s already exist\r\n", filename);
	__POINTD1FN _0x260000,1597
	CALL SUBOPT_0x60
; 0013 0126         return 0;
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E0031
; 0013 0127     }
; 0013 0128     else
_0x26002B:
; 0013 0129     {
; 0013 012A         printDebug("<LOG_createFile> %s created\r\n", filename);
	__POINTD1FN _0x260000,1633
	CALL SUBOPT_0x60
; 0013 012B         if(len == 0) // -- no initial data -- //
	__GETW1SX 546
	SBIW R30,0
	BRNE _0x26002D
; 0013 012C         {
; 0013 012D             printDebug("<LOG_createFile> %s contained no initial data\r\n");
	__POINTD1FN _0x260000,1663
	CALL SUBOPT_0x0
; 0013 012E             return 1;
	RJMP _0x20E0032
; 0013 012F         }
; 0013 0130 
; 0013 0131         // -- write the file initial data -- //
; 0013 0132         res = SD_openFile(&file,filename);
_0x26002D:
	CALL SUBOPT_0x5C
	__GETW2SX 553
	RCALL _SD_openFile
	MOVW R16,R30
; 0013 0133         if(res < 0)
	TST  R17
	BRPL _0x26002E
; 0013 0134         {
; 0013 0135             printDebug("<LOG_createFile> SD_openFile(%s) failed\r\n",filename);
	__POINTD1FN _0x260000,1711
	CALL SUBOPT_0x60
; 0013 0136             return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0031
; 0013 0137         }
; 0013 0138         else
_0x26002E:
; 0013 0139         {
; 0013 013A             printDebug("<LOG_createFile> writing initial data\r\n");
	__POINTD1FN _0x260000,1753
	CALL SUBOPT_0x0
; 0013 013B             print_payload(initString,len);
	CALL SUBOPT_0x61
; 0013 013C             res = SD_writeData(&file,0,initString,len);
	CALL SUBOPT_0x5C
	CALL SUBOPT_0x1B
	CALL __PUTPARD1
	__GETW1SX 554
	ST   -Y,R31
	ST   -Y,R30
	__GETW2SX 554
	RCALL _SD_writeData
	MOVW R16,R30
; 0013 013D             if(res < 0)
	TST  R17
	BRPL _0x260030
; 0013 013E             {
; 0013 013F                 printDebug("<LOG_createFile> SD_writeData() failed Writing.. \r\n");
	__POINTD1FN _0x260000,1793
	CALL SUBOPT_0x0
; 0013 0140                 print_payload(initString,len);
	CALL SUBOPT_0x61
; 0013 0141                 return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0031
; 0013 0142             }
; 0013 0143 
; 0013 0144             res = SD_closeFile(&file);
_0x260030:
	MOVW R26,R28
	ADIW R26,2
	RCALL _SD_closeFile
	MOVW R16,R30
; 0013 0145             if(res < 0)
	TST  R17
	BRPL _0x260031
; 0013 0146             {
; 0013 0147                 printDebug("<LOG_createFile> SD_closeFile() failed\r\n");
	__POINTD1FN _0x260000,1845
	CALL SUBOPT_0x0
; 0013 0148                 return -1;
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0031
; 0013 0149             }
; 0013 014A         }
_0x260031:
; 0013 014B     }
; 0013 014C 
; 0013 014D 
; 0013 014E     return 1;
_0x20E0032:
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
_0x20E0031:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,41
	SUBI R29,-2
	RET
; 0013 014F }
;/*============================================================*/
;int LOG_init(void)
; 0013 0152 {
_LOG_init:
; 0013 0153     int         res,ret = 0;
; 0013 0154 
; 0013 0155     printDebug("<LOG_init> Initial log file\r\n");
	CALL SUBOPT_0xA
;	res -> R16,R17
;	ret -> R18,R19
	__POINTD1FN _0x260000,1886
	CALL SUBOPT_0x0
; 0013 0156 
; 0013 0157 
; 0013 0158     res = LOG_createFile(LOGFILE_DATA,0,LOG_INIT_STR,sizeof(LOG_INIT_STR));
	LDI  R30,LOW(_LOGFILE_DATA)
	LDI  R31,HIGH(_LOGFILE_DATA)
	CALL SUBOPT_0x62
; 0013 0159     if(res < 0)
	BRPL _0x260032
; 0013 015A     {
; 0013 015B         printDebug("<LOG_init> LOG_createFile(%s) failed\r\n",LOGFILE_DATA);
	CALL SUBOPT_0x63
	LDI  R30,LOW(_LOGFILE_DATA)
	LDI  R31,HIGH(_LOGFILE_DATA)
	CALL SUBOPT_0x55
; 0013 015C         ret = ret-1;
	__SUBWRN 18,19,1
; 0013 015D     }
; 0013 015E 
; 0013 015F     res = LOG_createFile(LOGFILE_EVENT,0,LOG_INIT_STR,sizeof(LOG_INIT_STR));
_0x260032:
	LDI  R30,LOW(_LOGFILE_EVENT)
	LDI  R31,HIGH(_LOGFILE_EVENT)
	CALL SUBOPT_0x62
; 0013 0160     if(res < 0)
	BRPL _0x260033
; 0013 0161     {
; 0013 0162         printDebug("<LOG_init> LOG_createFile(%s) failed\r\n",LOGFILE_EVENT);
	CALL SUBOPT_0x63
	LDI  R30,LOW(_LOGFILE_EVENT)
	LDI  R31,HIGH(_LOGFILE_EVENT)
	CALL SUBOPT_0x55
; 0013 0163         ret = ret-1;
	__SUBWRN 18,19,1
; 0013 0164     }
; 0013 0165 
; 0013 0166     res = LOG_createFile(LOGFILE_ERROR,0,NULL,0);
_0x260033:
	LDI  R30,LOW(_LOGFILE_ERROR)
	LDI  R31,HIGH(_LOGFILE_ERROR)
	CALL SUBOPT_0x64
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	CALL SUBOPT_0x4B
	RCALL _LOG_createFile
	MOVW R16,R30
; 0013 0167     if(res < 0)
	TST  R17
	BRPL _0x260034
; 0013 0168     {
; 0013 0169         printDebug("<LOG_init> LOG_createFile(%s) failed\r\n",LOGFILE_ERROR);
	CALL SUBOPT_0x63
	LDI  R30,LOW(_LOGFILE_ERROR)
	LDI  R31,HIGH(_LOGFILE_ERROR)
	CALL SUBOPT_0x55
; 0013 016A         ret = ret-1;
	__SUBWRN 18,19,1
; 0013 016B     }
; 0013 016C 
; 0013 016D     return ret;
_0x260034:
	MOVW R30,R18
	CALL __LOADLOCR4
_0x20E0030:
	ADIW R28,4
	RET
; 0013 016E }
;/*============================================================*/
;
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "logqueue.h"
;#include "debug.h"
;
;struct event_log_st     eventLogQueue[MAX_EVENT_QUEUE];
;char                    eventLogQCount  = 0;
;
;struct data_log_st      dataLogQueue[MAX_DATA_QUEUE];
;char                    dataLogQCount   = 0;
;/*============================================================*/
;/* Data Log Queue */
;/*============================================================*/
;int addDataLogQueue(unsigned char id, unsigned long int timestamp, unsigned int channel, float value)
; 0014 0010 {

	.CSEG
; 0014 0011     int slot;
; 0014 0012 
; 0014 0013     slot = findFreeSlotDataLogQueue();
;	id -> Y+12
;	timestamp -> Y+8
;	channel -> Y+6
;	value -> Y+2
;	slot -> R16,R17
; 0014 0014     if(slot < 0)
; 0014 0015     {
; 0014 0016         printDebug("\r\n\r\n<addDataLogQueue> WARNING : dataLogQueue FULL\r\n\r\n");
; 0014 0017         return -1;
; 0014 0018     }
; 0014 0019 
; 0014 001A     dataLogQueue[slot].id                    = id;
; 0014 001B     dataLogQueue[slot].data.timestamp        = timestamp;
; 0014 001C     dataLogQueue[slot].data.channel          = channel;
; 0014 001D     dataLogQueue[slot].data.value            = value;
; 0014 001E 
; 0014 001F     dataLogQCount++;
; 0014 0020     printDebug("\r\n<addDataLogQueue>                           Added (%02X) to dataLogQueue[%d] Count = %d\r\n",id,slot,dataLogQCount);
; 0014 0021     return dataLogQCount;
; 0014 0022 }
;/*============================================================*/
;int readDataLogQueue(unsigned char id, unsigned long int *timestamp, unsigned int *channel, float *value)
; 0014 0025 {
; 0014 0026     int i;
; 0014 0027 
; 0014 0028     if(dataLogQCount == 0){
;	id -> Y+8
;	*timestamp -> Y+6
;	*channel -> Y+4
;	*value -> Y+2
;	i -> R16,R17
; 0014 0029         printDebug("<readDataLogQueue> WARN: dataLogQueue empty!!\r\n");
; 0014 002A         return -1;
; 0014 002B     }
; 0014 002C 
; 0014 002D     for(i=0;i<MAX_DATA_QUEUE;i++)
; 0014 002E     {
; 0014 002F         if(id == dataLogQueue[i].id)                       // -- scan id in dataLogQueue
; 0014 0030         {
; 0014 0031             *timestamp      =   dataLogQueue[i].data.timestamp;
; 0014 0032             *channel        =   dataLogQueue[i].data.channel;
; 0014 0033             *value          =   dataLogQueue[i].data.value;
; 0014 0034 
; 0014 0035             return i;
; 0014 0036         }
; 0014 0037     }
; 0014 0038 
; 0014 0039     printDebug("<readDataLogQueue> WARN: not found id[0x%02X] in dataLogQueue\r\n", id);
; 0014 003A     return -1;
; 0014 003B }
;/*============================================================*/
;int removeDataLogQueue(unsigned char id)
; 0014 003E {
; 0014 003F     char i;
; 0014 0040     for(i=0;i<MAX_DATA_QUEUE;i++)
;	id -> Y+1
;	i -> R17
; 0014 0041     {
; 0014 0042         if(id == dataLogQueue[i].id)                       // -- scan id in dataLogQueue
; 0014 0043         {
; 0014 0044             dataLogQueue[i].id                  = 0x00;
; 0014 0045             dataLogQueue[i].data.timestamp      = 0;
; 0014 0046             dataLogQueue[i].data.channel        = 0;
; 0014 0047             dataLogQueue[i].data.value          = 0;
; 0014 0048             dataLogQCount--;
; 0014 0049 
; 0014 004A             printDebug("\r\n<removeDataLogQueue>                        Removed (%02X) from dataLogQueue[%d]\r\n", id, i);
; 0014 004B             return dataLogQCount;
; 0014 004C         }
; 0014 004D     }
; 0014 004E     printDebug("<removeDataLogQueue> WARN: not found id[0x%02X] in dataLogQueue\r\n", id);
; 0014 004F     return -1;
; 0014 0050 }
;/*============================================================*/
;char findFreeSlotDataLogQueue(void)
; 0014 0053 {
; 0014 0054     char i;
; 0014 0055     for(i=0;i<MAX_DATA_QUEUE;i++){
;	i -> R17
; 0014 0056         if(dataLogQueue[i].id == 0x00){
; 0014 0057             return i;
; 0014 0058         }
; 0014 0059     }
; 0014 005A     return -1;
; 0014 005B }
;/*============================================================*/
;void initDataLogQueue(void)
; 0014 005E {
; 0014 005F     char i;
; 0014 0060 
; 0014 0061     for(i=0;i<MAX_DATA_QUEUE;i++){
;	i -> R17
; 0014 0062         dataLogQueue[i].id                  = 0x00;
; 0014 0063         dataLogQueue[i].data.timestamp      = 0;
; 0014 0064         dataLogQueue[i].data.channel        = 0;
; 0014 0065         dataLogQueue[i].data.value          = 0;
; 0014 0066     }
; 0014 0067     return;
; 0014 0068 }
;/*============================================================*/
;
;/*============================================================*/
;/* Event Log Queue */
;/*============================================================*/
;int addEventLogQueue(unsigned char id, unsigned long int timestamp, unsigned char eventID, unsigned char eventStatus)
; 0014 006F {
; 0014 0070     int slot;
; 0014 0071 
; 0014 0072     slot = findFreeSlotEventLogQueue();
;	id -> Y+8
;	timestamp -> Y+4
;	eventID -> Y+3
;	eventStatus -> Y+2
;	slot -> R16,R17
; 0014 0073     if(slot < 0)
; 0014 0074     {
; 0014 0075         printDebug("\r\n\r\n<addEventLogQueue> WARNING : eventLogQueue FULL\r\n\r\n");
; 0014 0076         return -1;
; 0014 0077     }
; 0014 0078 
; 0014 0079     eventLogQueue[slot].id                  = id;
; 0014 007A     eventLogQueue[slot].event.timestamp     = timestamp;
; 0014 007B     eventLogQueue[slot].event.eventID       = eventID;
; 0014 007C     eventLogQueue[slot].event.eventStatus   = eventStatus;
; 0014 007D 
; 0014 007E     eventLogQCount++;
; 0014 007F     printDebug("\r\n<addEventLogQueue>                         Added (%02X) to eventLogQueue[%d] Count = %d\r\n",id,slot,eventLogQCount);
; 0014 0080     return eventLogQCount;
; 0014 0081 }
;/*============================================================*/
;int readEventLogQueue(unsigned char id, unsigned long int *timestamp, unsigned char *eventID, unsigned char *eventStatus)
; 0014 0084 {
; 0014 0085     int i;
; 0014 0086 
; 0014 0087     if(eventLogQCount == 0){
;	id -> Y+8
;	*timestamp -> Y+6
;	*eventID -> Y+4
;	*eventStatus -> Y+2
;	i -> R16,R17
; 0014 0088         printDebug("<readEventLogQueue> WARN: eventLogQueue empty!!\r\n");
; 0014 0089         return -1;
; 0014 008A     }
; 0014 008B 
; 0014 008C     for(i=0;i<MAX_EVENT_QUEUE;i++)
; 0014 008D     {
; 0014 008E         if(id == eventLogQueue[i].id)                       // -- scan id in eventLogQueue
; 0014 008F         {
; 0014 0090             *timestamp      =   eventLogQueue[i].event.timestamp;
; 0014 0091             *eventID        =   eventLogQueue[i].event.eventID;
; 0014 0092             *eventStatus    =   eventLogQueue[i].event.eventStatus;
; 0014 0093 
; 0014 0094             return i;
; 0014 0095         }
; 0014 0096     }
; 0014 0097 
; 0014 0098     printDebug("<readEventLogQueue> WARN: not found id[0x%02X] in eventLogQueue\r\n", id);
; 0014 0099     return -1;
; 0014 009A }
;/*============================================================*/
;int removeEventLogQueue(unsigned char id)
; 0014 009D {
; 0014 009E     char i;
; 0014 009F     for(i=0;i<MAX_EVENT_QUEUE;i++)
;	id -> Y+1
;	i -> R17
; 0014 00A0     {
; 0014 00A1         if(id == eventLogQueue[i].id)                       // -- scan id in eventLogQueue
; 0014 00A2         {
; 0014 00A3             eventLogQueue[i].id                  = 0x00;
; 0014 00A4             eventLogQueue[i].event.timestamp     = 0;
; 0014 00A5             eventLogQueue[i].event.eventID       = 0;
; 0014 00A6             eventLogQueue[i].event.eventStatus   = 0;
; 0014 00A7             eventLogQCount--;
; 0014 00A8 
; 0014 00A9             printDebug("\r\n<removeEventLogQueue>                      Removed (%02X) from eventLogQueue[%d]\r\n", id, i);
; 0014 00AA             return eventLogQCount;
; 0014 00AB         }
; 0014 00AC     }
; 0014 00AD     printDebug("<removeEventLogQueue> WARN: not found id[0x%02X] in eventLogQueue\r\n", id);
; 0014 00AE     return -1;
; 0014 00AF }
;/*============================================================*/
;char findFreeSlotEventLogQueue(void)
; 0014 00B2 {
; 0014 00B3     char i;
; 0014 00B4     for(i=0;i<MAX_EVENT_QUEUE;i++){
;	i -> R17
; 0014 00B5         if(eventLogQueue[i].id == 0x00){
; 0014 00B6             return i;
; 0014 00B7         }
; 0014 00B8     }
; 0014 00B9     return -1;
; 0014 00BA }
;/*============================================================*/
;void initEventLogQueue(void)
; 0014 00BD {
; 0014 00BE     char i;
; 0014 00BF 
; 0014 00C0     for(i=0;i<MAX_EVENT_QUEUE;i++){
;	i -> R17
; 0014 00C1         eventLogQueue[i].id                  = 0x00;
; 0014 00C2         eventLogQueue[i].event.timestamp     = 0;
; 0014 00C3         eventLogQueue[i].event.eventID       = 0;
; 0014 00C4         eventLogQueue[i].event.eventStatus   = 0;
; 0014 00C5     }
; 0014 00C6     return;
; 0014 00C7 }
;/*============================================================*/
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include <stdarg.h>
;#include <delay.h>
;#include <ctype.h>
;#include "debug.h"
;#include "adc.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "ds1672.h"
;#include "alarm.h"
;#include "log.h"
;#include "io.h"
;#include "ethcomm.h"
;#include "calibration.h"
;#include "sensor.h"
;//sensorGetValue(u int)
;extern ST_CAL_CONFIG sensorCalConfig;
;extern eeprom  ST_CAL sensorCalulate;          //improtance    extern from  calibration.h
;extern void (*pfCalibrate) (ST_CAL_CONFIG calConfig);   //pointer function of calibation set  extern from  calibration.h
;
;flash unsigned char cmdSetRTCDateTime[]     = "$CMDSDT";        // -- Set Date/Time -- //
;flash unsigned char cmdResetAlarmStatus[]   = "$CMDRAS";        // -- Re-initiate all alarm flag -- //
;flash unsigned char cmdClearLogFile[]       = "$CMDCLF";        // -- Re-initiate log file -- //
;flash unsigned char cmdSetVref[]            = "$CMDSVR";        // -- Set Vref measure from multimeter -- //
;flash unsigned char cmdSensorSelect[]       = "$CMDSNS";        // -- Select Sensor for Hardware Calibration [Disable mode require] -- //
;flash unsigned char cmdDeviceEnable[]       = "$CMDDEN";        // -- Enable Device -- //
;flash unsigned char cmdDeviceDisable[]      = "$CMDDDS";        // -- Disable Device -- //
;flash unsigned char cmdSetSerialNumber[]    = "$CMDSSN";        // -- Set Serial Number -- //
;flash unsigned char cmdReadSerialNumber[]   = "$CMDRSN";        // -- Read Serial Number -- //
;
;flash unsigned char cmdGetCal[]             = "$CMDGCL";         // -- Get calibrate value -- //      $CMDRCL,1#        ,chID(1)
;flash unsigned char cmdSetCal[]             = "$CMDSCL";         // -- Set calibrate value -- //      $CMDSCL,1,1,29.20     ,chID(1),pointID(1),std1Value(29.20)#
;flash unsigned char cmdConfirmCal[]         = "$CMDCCL";         // -- Confirm calibrate type -- //   ,chID(1),calType(1) 0:defualt-1:offset-2:linear-3:polynomail
;flash unsigned char cmdGetCurSensor[]       = "$CMDGCS";         // -- Get current sensor value -- //   ,chID(1)
;/*============================================================*/
;
;unsigned int hwCalId    = 9;

	.DSEG
;
;/**************************************************************/
;/************* Service Debug Command Function *****************/
;/**************************************************************/
;/*============================================================*/
;int debugGetCurSensor(){
; 0015 002B int debugGetCurSensor(){

	.CSEG
; 0015 002C     unsigned char i=0;
; 0015 002D     unsigned char buffer[2];
; 0015 002E     unsigned int channelID;
; 0015 002F 
; 0015 0030     printDebug("\r\n<Debug>GetCurSensor: \r\n");
;	i -> R17
;	buffer -> Y+4
;	channelID -> R18,R19
; 0015 0031     memset(buffer,0,sizeof(buffer));
; 0015 0032     for(i=0;i<1;i++){
; 0015 0033        buffer[i] = rxPackage3[i+8];
; 0015 0034     }
; 0015 0035     channelID = atoi(buffer);
; 0015 0036     printDebug("Channel ID:%d \r\n",channelID);
; 0015 0037     printDebug("\r\n");
; 0015 0038 
; 0015 0039     if( channelID>0 && channelID<6 ){           //max 5 ch
; 0015 003A        printDebug("current sensor ch[%d] , value:%0.2f\r\n",channelID,sensorGetValue(channelID));
; 0015 003B     }else{
; 0015 003C         printDebug("Channel ID is in range.\r\n");
; 0015 003D     }
; 0015 003E 
; 0015 003F     return 0;
; 0015 0040 }
;int debugGetCal(){
; 0015 0041 int debugGetCal(){
; 0015 0042     unsigned char i=0;
; 0015 0043     unsigned char buffer[4];
; 0015 0044     unsigned int channelID;
; 0015 0045 
; 0015 0046     printDebug("\r\n<Debug>GetCal: \r\n");
;	i -> R17
;	buffer -> Y+4
;	channelID -> R18,R19
; 0015 0047     memset(buffer,0,sizeof(buffer));
; 0015 0048     for(i=0;i<1;i++){
; 0015 0049        buffer[i] = rxPackage3[i+8];
; 0015 004A     }
; 0015 004B     channelID = atoi(buffer);
; 0015 004C     printDebug("Channel ID:%d \r\n",channelID);
; 0015 004D     printDebug("\r\n");
; 0015 004E 
; 0015 004F     if( channelID>0 && channelID<6 ){           //max 5 ch
; 0015 0050        for(i=0;i<3;i++){
; 0015 0051            printDebug("stdRef[%d] : %0.2f , ",i+1,sensorCalulate.sChennel[channelID-1].stdRef[i]);
; 0015 0052            printDebug("sensorRef[%d] : %0.2f\r\n",i+1,sensorCalulate.sChennel[channelID-1].sensorRef[i]);
; 0015 0053        }
; 0015 0054        switch(sensorCalulate.sChennel[channelID-1].calType){
; 0015 0055             case CAL_DEFAULT:{               //0
; 0015 0056                 printDebug("CalType : CAL_DEFAULT");
; 0015 0057                 break;
; 0015 0058             }
; 0015 0059             case CAL_EXTOFFSET:{             //1
; 0015 005A                 printDebug("CalType : CAL_EXTOFFSET");
; 0015 005B                 break;
; 0015 005C             }
; 0015 005D             case CAL_EXTLINEAR:{             //2
; 0015 005E                 printDebug("CalType : CAL_EXTLINEAR");
; 0015 005F                 break;
; 0015 0060             }
; 0015 0061             case CAL_EXTPOLYNOMIAL:{         //3
; 0015 0062                 printDebug("CalType : CAL_EXTPOLYNOMIAL");
; 0015 0063                 break;
; 0015 0064             }
; 0015 0065        }
; 0015 0066        printDebug("\r\n");
; 0015 0067     }else{
; 0015 0068         printDebug("Channel ID is in range.\r\n");
; 0015 0069     }
; 0015 006A 
; 0015 006B     return 0;
; 0015 006C }
;int debugSetCal(){
; 0015 006D int debugSetCal(){
; 0015 006E     unsigned char i=0;
; 0015 006F     unsigned char buffer[6];
; 0015 0070     unsigned int channelID;
; 0015 0071     unsigned int pointID;
; 0015 0072     float pointValue;         //std value
; 0015 0073 
; 0015 0074     //void (*pfnCalibrate) (ST_CAL_CONFIG calConfig);
; 0015 0075 
; 0015 0076     pfCalibrate = &calSet;
;	i -> R17
;	buffer -> Y+10
;	channelID -> R18,R19
;	pointID -> R20,R21
;	pointValue -> Y+6
; 0015 0077 
; 0015 0078     printDebug("\r\n<Debug>SetCal: \r\n");
; 0015 0079     memset(buffer,0,sizeof(buffer));
; 0015 007A     for(i=0;i<1;i++){
; 0015 007B        buffer[i] = rxPackage3[i+8];
; 0015 007C     }
; 0015 007D     channelID = atoi(buffer);
; 0015 007E     sensorCalConfig.channelID =  channelID;
; 0015 007F     printDebug("Channel ID:%d \r\n",channelID);
; 0015 0080 
; 0015 0081     memset(buffer,0,sizeof(buffer));
; 0015 0082     for(i=0;i<1;i++){
; 0015 0083        buffer[i] = rxPackage3[i+10];
; 0015 0084     }
; 0015 0085     pointID = atoi(buffer);
; 0015 0086     sensorCalConfig.pointID =  pointID;
; 0015 0087     printDebug("Point ID:%d \r\n",pointID);
; 0015 0088 
; 0015 0089     memset(buffer,0,sizeof(buffer));
; 0015 008A     for(i=0;i<5;i++){
; 0015 008B        buffer[i] = rxPackage3[i+12];
; 0015 008C     }
; 0015 008D     pointValue = atof(buffer);
; 0015 008E     sensorCalConfig.pointValue =  pointValue;     //std value for meter
; 0015 008F     printDebug("pointValue(meterRef) :%0.2f \r\n",pointValue);
; 0015 0090     printDebug("\r\n");
; 0015 0091 
; 0015 0092     pfCalibrate(sensorCalConfig);
; 0015 0093 
; 0015 0094     return 0;
; 0015 0095 }
;int debugConfirmCal(){
; 0015 0096 int debugConfirmCal(){
; 0015 0097     unsigned char i=0;
; 0015 0098     unsigned char buffer[6];
; 0015 0099     unsigned int channelID;
; 0015 009A     unsigned int calType;
; 0015 009B 
; 0015 009C     pfCalibrate = &calSetConfirm;
;	i -> R17
;	buffer -> Y+6
;	channelID -> R18,R19
;	calType -> R20,R21
; 0015 009D 
; 0015 009E     printDebug("\r\n<Debug>ConfirmCal: \r\n");
; 0015 009F     memset(buffer,0,sizeof(buffer));
; 0015 00A0     for(i=0;i<1;i++){
; 0015 00A1        buffer[i] = rxPackage3[i+8];
; 0015 00A2     }
; 0015 00A3     channelID = atoi(buffer);
; 0015 00A4     sensorCalConfig.channelID =  channelID;
; 0015 00A5     printDebug("Channel ID:%d \r\n",channelID);
; 0015 00A6 
; 0015 00A7     memset(buffer,0,sizeof(buffer));
; 0015 00A8     for(i=0;i<1;i++){
; 0015 00A9        buffer[i] = rxPackage3[i+10];
; 0015 00AA     }
; 0015 00AB     calType = atoi(buffer);
; 0015 00AC     sensorCalConfig.calType =  calType;
; 0015 00AD     //printDebug("calType :%d \r\n",calType);
; 0015 00AE     switch(sensorCalConfig.calType){
; 0015 00AF         case CAL_DEFAULT:{               //0
; 0015 00B0             printDebug("CalType : CAL_DEFAULT");
; 0015 00B1             break;
; 0015 00B2         }
; 0015 00B3         case CAL_EXTOFFSET:{             //2
; 0015 00B4             printDebug("CalType : CAL_EXTOFFSET");
; 0015 00B5             break;
; 0015 00B6         }
; 0015 00B7         case CAL_EXTLINEAR:{             //3
; 0015 00B8             printDebug("CalType : CAL_EXTLINEAR");
; 0015 00B9             break;
; 0015 00BA         }
; 0015 00BB         case CAL_EXTPOLYNOMIAL:{         //4
; 0015 00BC             printDebug("CalType : CAL_EXTPOLYNOMIAL");
; 0015 00BD             break;
; 0015 00BE         }
; 0015 00BF     }
; 0015 00C0     printDebug("\r\n");
; 0015 00C1 
; 0015 00C2     pfCalibrate(sensorCalConfig);
; 0015 00C3 
; 0015 00C4     return 0;
; 0015 00C5 }
;
;int DEBUG_setDateTime(void)
; 0015 00C8 {
; 0015 00C9     unsigned char   i;
; 0015 00CA     unsigned char   buffer[32];
; 0015 00CB     int             tz;
; 0015 00CC 
; 0015 00CD     struct rtc_structure rtcSet;
; 0015 00CE 
; 0015 00CF     for(i=0;i<4;i++)
;	i -> R17
;	buffer -> Y+30
;	tz -> R18,R19
;	rtcSet -> Y+4
; 0015 00D0     {
; 0015 00D1         buffer[i] = rxPackage3[i+8];
; 0015 00D2     }
; 0015 00D3     buffer[4] = 0;
; 0015 00D4 
; 0015 00D5     rtcSet.year = atol(buffer);
; 0015 00D6 
; 0015 00D7     printDebug("get year = %d\r\n",rtcSet.year);
; 0015 00D8 
; 0015 00D9     for(i=0;i<2;i++)
; 0015 00DA     {
; 0015 00DB         buffer[i] = rxPackage3[i+13];
; 0015 00DC     }
; 0015 00DD     buffer[2] = 0;
; 0015 00DE 
; 0015 00DF     rtcSet.month = atol(buffer);
; 0015 00E0 
; 0015 00E1     printDebug("get month = %d\r\n",rtcSet.month);
; 0015 00E2 
; 0015 00E3     for(i=0;i<2;i++)
; 0015 00E4     {
; 0015 00E5         buffer[i] = rxPackage3[i+16];
; 0015 00E6     }
; 0015 00E7     buffer[2] = 0;
; 0015 00E8 
; 0015 00E9     rtcSet.date = atol(buffer);
; 0015 00EA 
; 0015 00EB     printDebug("get date = %d\r\n",rtcSet.date);
; 0015 00EC 
; 0015 00ED     for(i=0;i<2;i++)
; 0015 00EE     {
; 0015 00EF         buffer[i] = rxPackage3[i+19];
; 0015 00F0     }
; 0015 00F1     buffer[2] = 0;
; 0015 00F2 
; 0015 00F3     rtcSet.hour = atol(buffer);
; 0015 00F4 
; 0015 00F5     printDebug("get hour = %d\r\n",rtcSet.hour);
; 0015 00F6 
; 0015 00F7     for(i=0;i<2;i++)
; 0015 00F8     {
; 0015 00F9         buffer[i] = rxPackage3[i+22];
; 0015 00FA     }
; 0015 00FB     buffer[2] = 0;
; 0015 00FC 
; 0015 00FD     rtcSet.min = atol(buffer);
; 0015 00FE 
; 0015 00FF     printDebug("get min = %d\r\n",rtcSet.min);
; 0015 0100 
; 0015 0101     for(i=0;i<2;i++)
; 0015 0102     {
; 0015 0103         buffer[i] = rxPackage3[i+25];
; 0015 0104     }
; 0015 0105     buffer[2] = 0;
; 0015 0106 
; 0015 0107     rtcSet.sec = atol(buffer);
; 0015 0108 
; 0015 0109     printDebug("get sec = %d\r\n",rtcSet.sec);
; 0015 010A 
; 0015 010B     for(i=0;i<3;i++)
; 0015 010C     {
; 0015 010D         buffer[i] = rxPackage3[i+28];
; 0015 010E     }
; 0015 010F     buffer[4] = 0;
; 0015 0110 
; 0015 0111     tz = atol(buffer);
; 0015 0112 
; 0015 0113     printDebug("get timezone = %+d\r\n",tz);
; 0015 0114 
; 0015 0115     RTC_setDateTime(rtcSet,tz);
; 0015 0116 
; 0015 0117     return 0;
; 0015 0118 }
;/*============================================================*/
;void DEBUG_resetAlarm(void)
; 0015 011B {
; 0015 011C //    resetAlarm();
; 0015 011D 
; 0015 011E     printDebug("\r\n<DEBUG> Alarm Status Reset..!!\r\n");
; 0015 011F }
;/*============================================================*/
;void DEBUG_ClearLogFile(void)
; 0015 0122 {
; 0015 0123     int         res;
; 0015 0124 
; 0015 0125     printDebug("<DEBUG_ClearLogFile> Re-initiate log file\r\n");
;	res -> R16,R17
; 0015 0126 
; 0015 0127     res = LOG_createFile(LOGFILE_DATA,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0015 0128     if(res < 0)
; 0015 0129     {
; 0015 012A         printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_DATA);
; 0015 012B     }
; 0015 012C 
; 0015 012D     res = LOG_createFile(LOGFILE_EVENT,SD_FORCE,LOG_INIT_STR,SIZE_RECORD);
; 0015 012E     if(res < 0)
; 0015 012F     {
; 0015 0130         printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_EVENT);
; 0015 0131     }
; 0015 0132 
; 0015 0133     res = LOG_createFile(LOGFILE_ERROR,1,NULL,0);
; 0015 0134     if(res < 0)
; 0015 0135     {
; 0015 0136         printDebug("<DEBUG_ClearLogFile> LOG_createFile(%s) failed\r\n",LOGFILE_ERROR);
; 0015 0137     }
; 0015 0138 
; 0015 0139     return;
; 0015 013A }
;/*============================================================*/
;void DEBUG_setRealVref(void)
; 0015 013D {
; 0015 013E     unsigned char i;
; 0015 013F     unsigned char rxStrSetVREF[6];
; 0015 0140 
; 0015 0141     for(i=0;i<=5;i++)
;	i -> R17
;	rxStrSetVREF -> Y+1
; 0015 0142     {
; 0015 0143         rxStrSetVREF[i] = rxPackage3[i+8];
; 0015 0144     }
; 0015 0145     rxStrSetVREF[5] = '\0';
; 0015 0146     printDebug("<DEBUG_setRealVref> get set Vref<string> %s\r\n",rxStrSetVREF);
; 0015 0147     eep_vref_val = (atof(rxStrSetVREF));
; 0015 0148     printDebug("<DEBUG_setRealVref> After convert = %f\r\n",eep_vref_val);
; 0015 0149 }
;/*============================================================*/
;void DEBUG_sensorSelect(void)
; 0015 014C {
; 0015 014D     unsigned char ch[2];
; 0015 014E 
; 0015 014F     if(TEMP_SEL != TEMP_TYPE_K){
;	ch -> Y+0
; 0015 0150         printDebug("<DEBUG_sensorSelect> This TEMP_SEL not support\r\n\r\n");
; 0015 0151         return;
; 0015 0152     }
; 0015 0153 
; 0015 0154     if(rxPackage3[8] == 'N'){
; 0015 0155         hwCalId     = 9;
; 0015 0156         printDebug("<DEBUG_sensorSelect> Deselect sensor\r\n\r\n");
; 0015 0157     }
; 0015 0158     else if(isdigit(rxPackage3[8])){
; 0015 0159         ch[0]       = rxPackage3[8];
; 0015 015A         ch[1]       = '\0';
; 0015 015B         hwCalId     = atoi(ch);
; 0015 015C 
; 0015 015D         SENSOR_SELECT(hwCalId);
; 0015 015E         delay_ms(50);           // -- for multiplex stable -- //
; 0015 015F 
; 0015 0160         printDebug("<DEBUG_sensorSelect> Selected sensor %d\r\n\r\n",hwCalId);
; 0015 0161     }
; 0015 0162     else{
; 0015 0163         hwCalId     = 9;
; 0015 0164         printDebug("<DEBUG_sensorSelect> ERROR : Selecting sensor [%c][0x%02X]\r\n\r\n",rxPackage3[8],rxPackage3[8]);
; 0015 0165     }
; 0015 0166 
; 0015 0167     return;
; 0015 0168 }
;/*============================================================*/
;void DEBUG_setDeviceEnable(char flag)
; 0015 016B {
; 0015 016C //    if(flag){
; 0015 016D //        config_oper.deviceEnable        =   0x01;
; 0015 016E //    }
; 0015 016F //    else{
; 0015 0170 //        config_oper.deviceEnable        =   0x00;
; 0015 0171 //    }
; 0015 0172 //
; 0015 0173 //    config_oper_flag                    =   0x01;
; 0015 0174 //    is_operating_config_update          =   1;
; 0015 0175 //
; 0015 0176 //    return;
; 0015 0177 }
;/*============================================================*/
;void DEBUG_setSerialNumber(void)
; 0015 017A {
; 0015 017B     // -- assume input is "$CMDSSN,01,02,03,04,05,06,07,08#" -- //
; 0015 017C     unsigned char i;
; 0015 017D     unsigned char set_str[24];
; 0015 017E 
; 0015 017F     for(i=0;i<24;i++){
;	i -> R17
;	set_str -> Y+1
; 0015 0180         if( ( rxPackage3[i+7] != ',') && !isxdigit(rxPackage3[i+7])){
; 0015 0181             printDebug("<DEBUG_setSerialNumber> invalid setting string (%c)[0x%02]\r\n",rxPackage3[i+7],rxPackage3[i+7]);
; 0015 0182             return;
; 0015 0183         }
; 0015 0184         set_str[i] = tolower(rxPackage3[i+7]);           // -- copy only ",01,02,03,04,05,06,07,08" -- //
; 0015 0185     }
; 0015 0186 
; 0015 0187     printDebug("<DEBUG_setSerialNumber> Replacing DEVICE_SERIAL..\r\n");
; 0015 0188 
; 0015 0189     printDebug("<DEBUG_setSerialNumber> Set String --> ");
; 0015 018A     for(i=0;i<24;i++){
; 0015 018B         if((i%3) == 0)      {   continue;                       }
; 0015 018C         else if((i%3) == 1) {
; 0015 018D 
; 0015 018E             printDebug("[%c",set_str[i]);
; 0015 018F 
; 0015 0190             DEVICE_SERIAL[i/3]      = 0x00;
; 0015 0191 
; 0015 0192             if(isdigit(set_str[i])){
; 0015 0193                 DEVICE_SERIAL[i/3]  = (set_str[i] - 48) << 4;
; 0015 0194             }
; 0015 0195             else{
; 0015 0196                 DEVICE_SERIAL[i/3]  = (set_str[i] - 87) << 4;
; 0015 0197             }
; 0015 0198         }
; 0015 0199         else if((i%3) == 2) {
; 0015 019A 
; 0015 019B             printDebug("%c]",set_str[i]);
; 0015 019C 
; 0015 019D             if(isdigit(set_str[i])){
; 0015 019E                 DEVICE_SERIAL[i/3]  |= (set_str[i] - 48);
; 0015 019F             }
; 0015 01A0             else{
; 0015 01A1                 DEVICE_SERIAL[i/3]  |= (set_str[i] - 87);
; 0015 01A2             }
; 0015 01A3         }
; 0015 01A4     }
; 0015 01A5 
; 0015 01A6     printDebug("<DEBUG_setSerialNumber> Success!! DEV_SERIAL ==> ");
; 0015 01A7     for(i=0;i<8;i++){
; 0015 01A8         printDebug("[%02X]",DEVICE_SERIAL[i]);
; 0015 01A9     }
; 0015 01AA     printDebug("\r\n");
; 0015 01AB 
; 0015 01AC     return;
; 0015 01AD }
;/*============================================================*/
;void DEBUG_readSerialNumber(void)
; 0015 01B0 {
; 0015 01B1     unsigned char i;
; 0015 01B2 
; 0015 01B3     printDebug("<DEBUG_readSerialNumber> DEV_SERIAL ==> ");
;	i -> R17
; 0015 01B4     for(i=0;i<8;i++){
; 0015 01B5         printDebug("[%02X]",DEVICE_SERIAL[i]);
; 0015 01B6     }
; 0015 01B7     printDebug("\r\n");
; 0015 01B8 
; 0015 01B9     return;
; 0015 01BA }
;/*============================================================*/
;
;/**************************************************************/
;/****************** Debug Support Function ********************/
;/**************************************************************/
;/*============================================================*/
;void debug_req(void)
; 0015 01C2 {
; 0015 01C3     flag_PackageTerminate3 = 0;
; 0015 01C4 
; 0015 01C5     printDebug("Get Debug Req.:");
; 0015 01C6 
; 0015 01C7 
; 0015 01C8     if(!strncmpf(rxPackage3,cmdSetRTCDateTime,7)){
; 0015 01C9         DEBUG_setDateTime();
; 0015 01CA     }
; 0015 01CB     else if(!strncmpf(rxPackage3,cmdResetAlarmStatus,7)){
; 0015 01CC         DEBUG_resetAlarm();
; 0015 01CD     }
; 0015 01CE     else if(!strncmpf(rxPackage3,cmdClearLogFile,7)){
; 0015 01CF         DEBUG_ClearLogFile();
; 0015 01D0     }
; 0015 01D1     else if(!strncmpf(rxPackage3,cmdSetVref,7)){
; 0015 01D2         DEBUG_setRealVref();
; 0015 01D3     }
; 0015 01D4     else if(!strncmpf(rxPackage3,cmdSensorSelect,7)){
; 0015 01D5         DEBUG_sensorSelect();
; 0015 01D6     }
; 0015 01D7     else if(!strncmpf(rxPackage3,cmdDeviceEnable,7)){
; 0015 01D8         DEBUG_setDeviceEnable(1);
; 0015 01D9     }
; 0015 01DA     else if(!strncmpf(rxPackage3,cmdDeviceDisable,7)){
; 0015 01DB         DEBUG_setDeviceEnable(0);
; 0015 01DC     }
; 0015 01DD     else if(!strncmpf(rxPackage3,cmdSetSerialNumber,7)){
; 0015 01DE         DEBUG_setSerialNumber();
; 0015 01DF     }
; 0015 01E0     else if(!strncmpf(rxPackage3,cmdReadSerialNumber,7)){
; 0015 01E1         DEBUG_readSerialNumber();
; 0015 01E2     }else if(!strncmpf(rxPackage3,cmdGetCal,7)){
; 0015 01E3         debugGetCal();
; 0015 01E4     }else if(!strncmpf(rxPackage3,cmdSetCal,7)){
; 0015 01E5         debugSetCal();
; 0015 01E6     }else if(!strncmpf(rxPackage3,cmdConfirmCal,7)){
; 0015 01E7         debugConfirmCal();
; 0015 01E8     }else if(!strncmpf(rxPackage3,cmdGetCurSensor,7)){
; 0015 01E9         debugGetCurSensor();
; 0015 01EA     }
; 0015 01EB     return;
; 0015 01EC }
;/*============================================================*/
;void printDebug(flash char *fmtstr, ...)
; 0015 01EF {
_printDebug:
	PUSH R15
	MOV  R15,R24
; 0015 01F0     char textBuffer[256];
; 0015 01F1     va_list argptr;
; 0015 01F2 
; 0015 01F3     va_start(argptr, fmtstr);
	SUBI R29,1
	ST   -Y,R17
	ST   -Y,R16
;	*fmtstr -> Y+258
;	textBuffer -> Y+2
;	*argptr -> R16,R17
	MOVW R26,R28
	SUBI R26,LOW(-(254))
	SBCI R27,HIGH(-(254))
	CALL __ADDW2R15
	MOVW R16,R26
; 0015 01F4     vsprintf(textBuffer,fmtstr,argptr);
	CALL SUBOPT_0x5C
	MOVW R26,R28
	SUBI R26,LOW(-(260))
	SBCI R27,HIGH(-(260))
	CALL SUBOPT_0x65
	MOVW R26,R16
	CALL _vsprintf
; 0015 01F5     send_uart(3,textBuffer);
	LDI  R30,LOW(3)
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,3
	CALL _send_uart
; 0015 01F6     va_end(argptr);
; 0015 01F7 
; 0015 01F8     return;
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,2
	SUBI R29,-1
	POP  R15
	RET
; 0015 01F9 }
;/*============================================================*/
;void print_hex_ascii_line(const unsigned char *payload, int len, int offset)
; 0015 01FC {
_print_hex_ascii_line:
; 0015 01FD 
; 0015 01FE     int i;
; 0015 01FF     int gap;
; 0015 0200     const unsigned char *ch;
; 0015 0201 
; 0015 0202     // offset //
; 0015 0203     printDebug("%05d   ", offset);
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR6
;	*payload -> Y+10
;	len -> Y+8
;	offset -> Y+6
;	i -> R16,R17
;	gap -> R18,R19
;	*ch -> R20,R21
	__POINTD1FN _0x2A0000,1166
	CALL __PUTPARD1
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL __CWD1
	CALL SUBOPT_0x3
; 0015 0204 
; 0015 0205 
; 0015 0206     // hex //
; 0015 0207     ch = payload;
	__GETWRS 20,21,10
; 0015 0208     for(i = 0; i < len; i++) {
	__GETWRN 16,17,0
_0x2A0084:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CP   R16,R30
	CPC  R17,R31
	BRGE _0x2A0085
; 0015 0209         printDebug("%02x ", *ch);
	__POINTD1FN _0x2A0000,1174
	CALL SUBOPT_0x66
; 0015 020A 
; 0015 020B         ch++;
	__ADDWRN 20,21,1
; 0015 020C         // print extra space after 8th byte for visual aid //
; 0015 020D         if (i == 7){
	LDI  R30,LOW(7)
	LDI  R31,HIGH(7)
	CP   R30,R16
	CPC  R31,R17
	BRNE _0x2A0086
; 0015 020E             printDebug(" ");
	CALL SUBOPT_0x67
; 0015 020F 
; 0015 0210         }
; 0015 0211     }
_0x2A0086:
	__ADDWRN 16,17,1
	RJMP _0x2A0084
_0x2A0085:
; 0015 0212     // print space to handle line less than 8 bytes //
; 0015 0213     if (len < 8){
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,8
	BRGE _0x2A0087
; 0015 0214         printDebug(" ");
	CALL SUBOPT_0x67
; 0015 0215 
; 0015 0216     }
; 0015 0217 
; 0015 0218     // fill hex gap with spaces if not full line //
; 0015 0219     if (len < 16) {
_0x2A0087:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,16
	BRGE _0x2A0088
; 0015 021A         gap = 16 - len;
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(16)
	LDI  R31,HIGH(16)
	SUB  R30,R26
	SBC  R31,R27
	MOVW R18,R30
; 0015 021B         for (i = 0; i < gap; i++) {
	__GETWRN 16,17,0
_0x2A008A:
	__CPWRR 16,17,18,19
	BRGE _0x2A008B
; 0015 021C             printDebug("   ");
	CALL SUBOPT_0x68
; 0015 021D 
; 0015 021E         }
	__ADDWRN 16,17,1
	RJMP _0x2A008A
_0x2A008B:
; 0015 021F     }
; 0015 0220     printDebug("   ");
_0x2A0088:
	CALL SUBOPT_0x68
; 0015 0221 
; 0015 0222 
; 0015 0223     // ascii (if printable) //
; 0015 0224     ch = payload;
	__GETWRS 20,21,10
; 0015 0225     for(i = 0; i < len; i++) {
	__GETWRN 16,17,0
_0x2A008D:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CP   R16,R30
	CPC  R17,R31
	BRGE _0x2A008E
; 0015 0226         if (isprint(*ch)){
	MOVW R26,R20
	LD   R26,X
	CALL _isprint
	CPI  R30,0
	BREQ _0x2A008F
; 0015 0227             printDebug("%c", *ch);
	__POINTD1FN _0x2A0000,1045
	CALL SUBOPT_0x66
; 0015 0228 
; 0015 0229         }
; 0015 022A         else{
	RJMP _0x2A0090
_0x2A008F:
; 0015 022B             printDebug(".");
	__POINTD1FN _0x2A0000,1180
	CALL SUBOPT_0x0
; 0015 022C 
; 0015 022D         }
_0x2A0090:
; 0015 022E         ch++;
	__ADDWRN 20,21,1
; 0015 022F     }
	__ADDWRN 16,17,1
	RJMP _0x2A008D
_0x2A008E:
; 0015 0230 
; 0015 0231     printDebug("\r\n");
	__POINTD1FN _0x2A0000,23
	CALL SUBOPT_0x0
; 0015 0232 
; 0015 0233 
; 0015 0234 return;
	CALL __LOADLOCR6
	JMP  _0x20E002D
; 0015 0235 }
;/*============================================================*/
;void print_payload(const unsigned char *payload, int len)
; 0015 0238 {
_print_payload:
; 0015 0239 
; 0015 023A     int len_rem = len;
; 0015 023B     int line_width = 16;            // number of bytes per line //
; 0015 023C     int line_len;
; 0015 023D     int offset = 0;                    // zero-based offset counter //
; 0015 023E     const unsigned char *ch = payload;
; 0015 023F 
; 0015 0240     if (len <= 0)
	CALL SUBOPT_0x69
	STD  Y+2,R30
	LDI  R30,LOW(0)
	STD  Y+3,R30
	CALL __SAVELOCR6
;	*payload -> Y+12
;	len -> Y+10
;	len_rem -> R16,R17
;	line_width -> R18,R19
;	line_len -> R20,R21
;	offset -> Y+8
;	*ch -> Y+6
	__GETWRS 16,17,10
	__GETWRN 18,19,16
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL __CPW02
	BRLT _0x2A0091
; 0015 0241         return;
	JMP  _0x20E002C
; 0015 0242 
; 0015 0243     // data fits on one line //
; 0015 0244     if (len <= line_width) {
_0x2A0091:
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CP   R18,R26
	CPC  R19,R27
	BRLT _0x2A0092
; 0015 0245         print_hex_ascii_line(ch, len, offset);
	CALL SUBOPT_0x52
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x6A
; 0015 0246         return;
	JMP  _0x20E002C
; 0015 0247     }
; 0015 0248     // data spans multiple lines //
; 0015 0249     for ( ;; ) {
_0x2A0092:
_0x2A0094:
; 0015 024A         // compute current line length //
; 0015 024B         line_len = line_width % len_rem;
	MOVW R30,R16
	MOVW R26,R18
	CALL __MODW21
	MOVW R20,R30
; 0015 024C         // print line //
; 0015 024D         print_hex_ascii_line(ch, line_len, offset);
	CALL SUBOPT_0x52
	ST   -Y,R21
	ST   -Y,R20
	CALL SUBOPT_0x6A
; 0015 024E         // compute total remaining //
; 0015 024F         len_rem = len_rem - line_len;
	__SUBWRR 16,17,20,21
; 0015 0250         // shift pointer to remaining bytes to print //
; 0015 0251         ch = ch + line_len;
	MOVW R30,R20
	CALL SUBOPT_0x6B
	STD  Y+6,R30
	STD  Y+6+1,R31
; 0015 0252         // add offset //
; 0015 0253         offset = offset + line_width;
	MOVW R30,R18
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADD  R30,R26
	ADC  R31,R27
	STD  Y+8,R30
	STD  Y+8+1,R31
; 0015 0254         // check if we have line width chars or less //
; 0015 0255         if (len_rem <= line_width) {
	__CPWRR 18,19,16,17
	BRLT _0x2A0096
; 0015 0256             // print last line and get out //
; 0015 0257             print_hex_ascii_line(ch, len_rem, offset);
	CALL SUBOPT_0x52
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x6A
; 0015 0258             break;
	RJMP _0x2A0095
; 0015 0259         }
; 0015 025A     }
_0x2A0096:
	RJMP _0x2A0094
_0x2A0095:
; 0015 025B 
; 0015 025C     return;
	JMP  _0x20E002C
; 0015 025D }
;/*============================================================*/
;void debugConfWiz100sr(){
; 0015 025F void debugConfWiz100sr(){
; 0015 0260 
; 0015 0261 }
;#include <stdlib.h>
;#include "debug.h"
;
;// -- for polynomial interpolation by gaussian elimination -- //
;int n = 3;

	.DSEG
;float a[3][4];
;
;/*============================================================*/
;void forwardSubstitution()
; 0016 000A {

	.CSEG
; 0016 000B     int i, j, k, max;
; 0016 000C     float t;
; 0016 000D     for (i = 0; i < n; ++i) {
;	i -> R16,R17
;	j -> R18,R19
;	k -> R20,R21
;	max -> Y+10
;	t -> Y+6
; 0016 000E 
; 0016 000F         max = i;
; 0016 0010         for (j = i + 1; j < n; ++j)
; 0016 0011             if (a[j][i] > a[max][i])
; 0016 0012                 max = j;
; 0016 0013 
; 0016 0014         for (j = 0; j < n + 1; ++j) {
; 0016 0015             t = a[max][j];
; 0016 0016             a[max][j] = a[i][j];
; 0016 0017             a[i][j] = t;
; 0016 0018         }
; 0016 0019 
; 0016 001A         /*
; 0016 001B         printDebug("\r\n-- fw_sub_swap(%d) --\r\n",i);
; 0016 001C         for (k = 0; k < n; ++k) {
; 0016 001D             printDebug("\t\t\t");
; 0016 001E             for (j = 0; j < n + 1; ++j)
; 0016 001F                 printDebug("%.2f\t", a[k][j]);
; 0016 0020             printDebug("\r\n");
; 0016 0021         }
; 0016 0022         printDebug("\r\n");
; 0016 0023         */
; 0016 0024 
; 0016 0025         //printDebug("\r\n-- fw_sub_calculate(%d) --\r\n",i);
; 0016 0026         for (j = n; j >= i; --j){
; 0016 0027             for (k = i + 1; k < n; ++k){
; 0016 0028                 a[k][j] -= a[k][i]/a[i][i] * a[i][j];
; 0016 0029                 //printDebug("\t\t\t\t\t\t%f (%f/%f * %f)\r\n",a[k][j],a[k][i],a[i][i],a[i][j]);
; 0016 002A             }
; 0016 002B         }
; 0016 002C         //printDebug("\r\n");
; 0016 002D 
; 0016 002E 
; 0016 002F         /*
; 0016 0030         printDebug("\r\n-- fw_sub_res(%d) --\r\n",i);
; 0016 0031         for (k = 0; k < n; ++k) {
; 0016 0032             printDebug("\t\t");
; 0016 0033             for (j = 0; j < n + 1; ++j)
; 0016 0034                 printDebug("%.2f\t", a[k][j]);
; 0016 0035             printDebug("\r\n");
; 0016 0036         }
; 0016 0037         printDebug("\r\n");
; 0016 0038         */
; 0016 0039     }
; 0016 003A }
;
;void reverseElimination()
; 0016 003D {
; 0016 003E     int i, j, k;
; 0016 003F     for (i = n - 1; i >= 0; --i) {
;	i -> R16,R17
;	j -> R18,R19
;	k -> R20,R21
; 0016 0040         a[i][n] = a[i][n] / a[i][i];
; 0016 0041         a[i][i] = 1;
; 0016 0042         for (j = i - 1; j >= 0; --j) {
; 0016 0043             a[j][n] -= a[j][i] * a[i][n];
; 0016 0044             a[j][i] = 0;
; 0016 0045         }
; 0016 0046 
; 0016 0047         /*
; 0016 0048         printDebug("\r\n-- rev_Eli(%d) --\r\n",i);
; 0016 0049         for (k = 0; k < n; ++k) {
; 0016 004A             printDebug("\t\t");
; 0016 004B             for (j = 0; j < n + 1; ++j)
; 0016 004C                 printDebug("%.2f\t", a[k][j]);
; 0016 004D             printDebug("\r\n");
; 0016 004E         }
; 0016 004F         printDebug("\r\n");
; 0016 0050         */
; 0016 0051     }
; 0016 0052 }
;
;void gaussian(float factor1, float factor2, float factor3, float ref1, float ref2, float ref3, float *resA, float *resB, float *resC)
; 0016 0055 {
; 0016 0056     int i, j;
; 0016 0057 
; 0016 0058     // -- form matrix -- //
; 0016 0059     a[0][0] = 1.0;      a[0][1] = factor1;     a[0][2] = factor1 * factor1;  a[0][3] = ref1;
;	factor1 -> Y+30
;	factor2 -> Y+26
;	factor3 -> Y+22
;	ref1 -> Y+18
;	ref2 -> Y+14
;	ref3 -> Y+10
;	*resA -> Y+8
;	*resB -> Y+6
;	*resC -> Y+4
;	i -> R16,R17
;	j -> R18,R19
; 0016 005A     a[1][0] = 1.0;      a[1][1] = factor2;     a[1][2] = factor2 * factor2;  a[1][3] = ref2;
; 0016 005B     a[2][0] = 1.0;      a[2][1] = factor3;     a[2][2] = factor3 * factor3;  a[2][3] = ref3;
; 0016 005C 
; 0016 005D 
; 0016 005E //    printDebug("\r\n<gaussian> --- start ---\r\n");
; 0016 005F //    for (i = 0; i < n; ++i) {
; 0016 0060 //        printDebug("\t\t");
; 0016 0061 //        for (j = 0; j < n + 1; ++j)
; 0016 0062 //            printDebug("%.2f\t", a[i][j]);
; 0016 0063 //        printDebug("\r\n");
; 0016 0064 //    }
; 0016 0065 
; 0016 0066     forwardSubstitution();
; 0016 0067     reverseElimination();
; 0016 0068 
; 0016 0069 //    printDebug("\r\n<gaussian> --- finish ---\r\n");
; 0016 006A //    for (i = 0; i < n; ++i) {
; 0016 006B //        printDebug("\t\t");
; 0016 006C //        for (j = 0; j < n + 1; ++j)
; 0016 006D //            printDebug("%.2f\t", a[i][j]);
; 0016 006E //        printDebug("\r\n");
; 0016 006F //    }
; 0016 0070 
; 0016 0071     *resA = a[2][3];
; 0016 0072     *resB = a[1][3];
; 0016 0073     *resC = a[0][3];
; 0016 0074 
; 0016 0075    // printDebug("\r\n<gaussian> y = %f(x^2) + %f(x) + %f\r\n",*resA,*resB,*resC);
; 0016 0076 
; 0016 0077     return;
; 0016 0078 }
;#include <mega2560.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include <delay.h>
;#include <stdio.h>
;#include <stdlib.h>
;#include <string.h>
;#include "dht11.h"
;#include "timer.h"
;#include "debug.h"
;
;/**
;*
;//Brif use timer5
;**/
;void MCUSignalOut(int status){
; 0017 000E void MCUSignalOut(int status){

	.CSEG
; 0017 000F //    DDRL.0  = 1;   //set output
; 0017 0010     char tempRegister = 0;
; 0017 0011     DDRJ |= 0x04;    //oboooo o10o
;	status -> Y+1
;	tempRegister -> R17
; 0017 0012     if(status==1){
; 0017 0013        PORTJ |= 0x04; //0b0000 0100
; 0017 0014     }else{
; 0017 0015         PORTJ &= 0xFB;//0b1111 1011
; 0017 0016     }
; 0017 0017 }
;int DHT11SignalIn(){
; 0017 0018 int DHT11SignalIn(){
; 0017 0019 //    DDRL.0   = 0;   //set input
; 0017 001A //    return DHT11_TO_MCU_PIN;
; 0017 001B     DDRJ &= 0xFB;
; 0017 001C     if((PINJ & 0x04)==0x04){
; 0017 001D        return 0x01;
; 0017 001E     }else{
; 0017 001F        return 0x00;
; 0017 0020     }
; 0017 0021 
; 0017 0022 }
;int DHT11Read(ST_DHT11 *dhtDevice){
; 0017 0023 int DHT11Read(ST_DHT11 *dhtDevice){
; 0017 0024     int i, j, temp;
; 0017 0025     int buffer = 0;
; 0017 0026     int count = 0;
; 0017 0027 	int data[5] = {0x00, 0x00, 0x00, 0x00, 0x00};
; 0017 0028 
; 0017 0029     /*start condition*/
; 0017 002A     dhtDevice->status = DHT11_ERROR_TIMEOUT;
;	*dhtDevice -> Y+20
;	i -> R16,R17
;	j -> R18,R19
;	temp -> R20,R21
;	buffer -> Y+18
;	count -> Y+16
;	data -> Y+6
; 0017 002B //    MCUSignalOut(MCU_SIGNAL_LOW);
; 0017 002C //    delay_ms(10);
; 0017 002D     MCUSignalOut(MCU_SIGNAL_HIGH);
; 0017 002E     delay_ms(4);
; 0017 002F 
; 0017 0030 //    TCCR5A=0x00;
; 0017 0031 //    TCCR5B=0x05;     //count = 128 microsec , 128 * 7812 = about 1sec
; 0017 0032 //
; 0017 0033 //    TCNT5H=0x00;     //timer count clearing
; 0017 0034 //    TCNT5L=0x00;
; 0017 0035 
; 0017 0036     MCUSignalOut(MCU_SIGNAL_LOW);
; 0017 0037     //while((TCNT5H <<8 | TCNT5L)<160);           //about 20 ms
; 0017 0038     delay_ms(20);
; 0017 0039 
; 0017 003A     /*set clk/8
; 0017 003B     *clk@8Mhz/prescaling 8
; 0017 003C     *get count every 1 us
; 0017 003D     */
; 0017 003E //    TCCR5A=0x00;
; 0017 003F //    TCCR5B=0x02;     //count = 1 microsec
; 0017 0040 //
; 0017 0041 //    TCNT5H=0x00;     //timer count clearing
; 0017 0042 //    TCNT5L=0x00;
; 0017 0043 
; 0017 0044     MCUSignalOut(MCU_SIGNAL_HIGH);
; 0017 0045     delay_us(40);
; 0017 0046     /*end start condition*/
; 0017 0047    // printDebug("DHT11: end Condition \r\n");
; 0017 0048 
; 0017 0049     TCCR5A=0x00;
; 0017 004A     TCCR5B=0x02;     //count = 1 microsec
; 0017 004B     TCNT5H=0x00;     //timer count clearing
; 0017 004C     TCNT5L=0x00;
; 0017 004D     while(DHT11SignalIn()==0){
; 0017 004E         if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us      //if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us
; 0017 004F             dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0050            return DHT11_ERROR_TIMEOUT;
; 0017 0051         }
; 0017 0052     }
; 0017 0053 
; 0017 0054     TCNT5H=0x00;     //timer count clearing
; 0017 0055     TCNT5L=0x00;
; 0017 0056     while(DHT11SignalIn()==1){
; 0017 0057         if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us        //if((TCNT5H <<8 | TCNT5L)>100){       //about 80 us
; 0017 0058             dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0059            return DHT11_ERROR_TIMEOUT;
; 0017 005A         }
; 0017 005B     }
; 0017 005C 
; 0017 005D     //Read 40 bits (8*5)
; 0017 005E 	for(j = 0; j < 5; ++j) {
; 0017 005F 		for(i = 0; i < 8; ++i) {
; 0017 0060 
; 0017 0061 			//LOW for 50us
; 0017 0062 			TCNT5H=0x00;     //timer count clearing
; 0017 0063             TCNT5L=0x00;
; 0017 0064             while(DHT11SignalIn()==0){
; 0017 0065                 if((TCNT5H <<8 | TCNT5L)>70){       //about 50 us            //if((TCNT5H <<8 | TCNT5L)>70){
; 0017 0066                     dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0067                    return DHT11_ERROR_TIMEOUT;
; 0017 0068                 }
; 0017 0069             }
; 0017 006A 
; 0017 006B 			//Start counter
; 0017 006C 			//buffer = 0;
; 0017 006D 			//HIGH for 26-28us = 0 / 70us = 1
; 0017 006E 
; 0017 006F 			TCNT5H=0x00;     //timer count clearing
; 0017 0070             TCNT5L=0x00;
; 0017 0071             while(DHT11SignalIn()==1){
; 0017 0072                 count = (TCNT5H <<8 | TCNT5L);
; 0017 0073                 if(count>90){       //about 70 us                //if(count>90){
; 0017 0074                     dhtDevice->status = DHT11_ERROR_TIMEOUT;
; 0017 0075                    return DHT11_ERROR_TIMEOUT;
; 0017 0076                 }
; 0017 0077 
; 0017 0078             }
; 0017 0079 
; 0017 007A //            if(count > 40){
; 0017 007B //               buffer = 1;
; 0017 007C //            }
; 0017 007D 			//Calc amount of time passed
; 0017 007E 			temp = count;
; 0017 007F 
; 0017 0080 			//shift 0
; 0017 0081 			data[j] = data[j] << 1;
; 0017 0082 
; 0017 0083 			//if > 30us it's 1
; 0017 0084 			if(temp > 40)
; 0017 0085 				data[j] = data[j]+1;
; 0017 0086 		}
; 0017 0087 	}
; 0017 0088 
; 0017 0089     //MCUSignalOut(MCU_SIGNAL_HIGH);
; 0017 008A 
; 0017 008B     //verify the Checksum
; 0017 008C 	if(data[4] != (data[0] + data[2])){
; 0017 008D         dhtDevice->status = DHT11_ERROR_CHECKSUM;
; 0017 008E         return DHT11_ERROR_CHECKSUM;
; 0017 008F     }
; 0017 0090 
; 0017 0091 
; 0017 0092 
; 0017 0093     dhtDevice->temp = (float)data[2];
; 0017 0094     dhtDevice->humi = (float)data[0];
; 0017 0095     dhtDevice->status = DHT11_SUCCESS;
; 0017 0096     return DHT11_SUCCESS;
; 0017 0097 }
;#include <stdlib.h>
;#include <string.h>
;#include <stdio.h>
;#include <delay.h>
;#include "calibration.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "timer.h"
;#include "gaussian.h"
;#include "debug.h"
;//#include "sensor.h"
;
;//typedef struct{
;//   ST_CAL_CHANNEL sChennel[5];
;//}ST_CAL;
;//
;
;ST_CAL_CONFIG sensorCalConfig;
;eeprom  ST_CAL sensorCalulate = {
;  {
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0},
;    {{0.0,0.0,0.0},{0.0,0.0,0.0},0}
;  }
;};          //improtance
;
;//eeprom float calOffset = 0.0;
;
;void (*pfCalibrate) (ST_CAL_CONFIG calConfig);   //pointer function of calibation set
;
;
;/**
;**@fn name   calGet
;**@header   name        type            des
;**@param    channelID   unsigned int    channel of sensor = 5(max)
;**@return   none        void
;**/
;void calGet(ST_CAL_CONFIG calConfig){
; 0018 0026 void calGet(ST_CAL_CONFIG calConfig){

	.CSEG
; 0018 0027     unsigned int i=0;
; 0018 0028     unsigned int offsetMember       = 1;     //use 1 point
; 0018 0029     unsigned int linearMember       = 2;     //use 2 point
; 0018 002A     unsigned int polynomailMember   = 3;     //use 3 point
; 0018 002B     if(calConfig.prop=CAL_GET){
;	calConfig -> Y+8
;	i -> R16,R17
;	offsetMember -> R18,R19
;	linearMember -> R20,R21
;	polynomailMember -> Y+6
; 0018 002C         printDebug("<Cal Std ref>ch[%d],formatType:%0.2f\r\n",calConfig.channelID,calConfig.calType);
; 0018 002D         switch(calConfig.calType){
; 0018 002E             case CAL_EXTOFFSET :{
; 0018 002F                 for(i=0;i<offsetMember;i++){
; 0018 0030                    printDebug("stdRef:%0.2f,sensorRef:%0.2f\r\n",sensorCalulate.sChennel[calConfig.channelID-1].stdRef[i],sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[i]);
; 0018 0031                 }
; 0018 0032                 break;
; 0018 0033             }
; 0018 0034             case CAL_EXTLINEAR :{
; 0018 0035                 for(i=0;i<linearMember;i++){
; 0018 0036                    printDebug("stdRef:%0.2f,sensorRef:%0.2f\r\n",sensorCalulate.sChennel[calConfig.channelID-1].stdRef[i],sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[i]);
; 0018 0037                 }
; 0018 0038                 break;
; 0018 0039             }
; 0018 003A             case CAL_EXTPOLYNOMIAL :{
; 0018 003B                 for(i=0;i<polynomailMember;i++){
; 0018 003C                    printDebug("stdRef:%0.2f,sensorRef:%0.2f\r\n",sensorCalulate.sChennel[calConfig.channelID-1].stdRef[i],sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[i]);
; 0018 003D                 }
; 0018 003E                 break;
; 0018 003F             }
; 0018 0040             defualt:{
; 0018 0041                 break;
; 0018 0042             }
; 0018 0043         }
; 0018 0044     }else{
; 0018 0045        printDebug("<calibration>Cal properties:set can not get value.");
; 0018 0046     }
; 0018 0047 }
;void calSet(ST_CAL_CONFIG calConfig){
; 0018 0048 void calSet(ST_CAL_CONFIG calConfig){
; 0018 0049     if(calConfig.prop=CAL_SET){
;	calConfig -> Y+0
; 0018 004A         sensorCalulate.sChennel[calConfig.channelID-1].stdRef[calConfig.pointID-1] =  calConfig.pointValue;
; 0018 004B         sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[calConfig.pointID-1] = adcData[calConfig.channelID-1];
; 0018 004C     }else{
; 0018 004D        printDebug("<calibration>Cal properties:get can not set value.");
; 0018 004E     }
; 0018 004F }
;void calSetConfirm(ST_CAL_CONFIG calConfig){
; 0018 0050 void calSetConfirm(ST_CAL_CONFIG calConfig){
; 0018 0051     if(calConfig.prop=CAL_SET){
;	calConfig -> Y+0
; 0018 0052         printDebug("<Cal Std ref>ch[%d],formatType:%d\r\n",calConfig.channelID,calConfig.calType);
; 0018 0053         switch(calConfig.calType){
; 0018 0054             case CAL_EXTOFFSET :{
; 0018 0055                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_EXTOFFSET;
; 0018 0056                 break;
; 0018 0057             }
; 0018 0058             case CAL_EXTLINEAR :{
; 0018 0059                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_EXTLINEAR;
; 0018 005A                 break;
; 0018 005B             }
; 0018 005C             case CAL_EXTPOLYNOMIAL :{
; 0018 005D                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_EXTPOLYNOMIAL;
; 0018 005E                 break;
; 0018 005F             }
; 0018 0060             case CAL_DEFAULT:{
; 0018 0061                 sensorCalulate.sChennel[calConfig.channelID-1].calType = CAL_DEFAULT;
; 0018 0062                 break;
; 0018 0063             }
; 0018 0064         }
; 0018 0065     }else{
; 0018 0066        printDebug("<calibration>Cal properties:get can not set value.");
; 0018 0067     }
; 0018 0068 }
;void calSetClearPoint(ST_CAL_CONFIG calConfig){
; 0018 0069 void calSetClearPoint(ST_CAL_CONFIG calConfig){
; 0018 006A    if(calConfig.prop=CAL_SET){
;	calConfig -> Y+0
; 0018 006B       sensorCalulate.sChennel[calConfig.channelID-1].stdRef[calConfig.pointID] =  0;
; 0018 006C       sensorCalulate.sChennel[calConfig.channelID-1].sensorRef[calConfig.pointID] = 0;
; 0018 006D    }else{
; 0018 006E       printDebug("<calibration>Cal properties:get can not set value.");
; 0018 006F    }
; 0018 0070 }
;
;float calProcessValue(float sensorValue,unsigned int channelID){
; 0018 0072 float calProcessValue(float sensorValue,unsigned int channelID){
; 0018 0073     float offset = 0.0;
; 0018 0074     float sensorRef1 = 0.0,sensorRef2 = 0.0,sensorRef3 = 0.0;
; 0018 0075     float stdMeter1 = 0.0,stdMeter2 = 0.0,stdMeter3 = 0.0;        //standrad  meter
; 0018 0076     float lowRange = 0.0;
; 0018 0077     float stdMeterRange = 0.0;
; 0018 0078     float factorA = 0.0,factorB = 0.0,factorC = 0.0;
; 0018 0079 
; 0018 007A     switch(sensorCalulate.sChennel[channelID-1].calType){
;	sensorValue -> Y+50
;	channelID -> Y+48
;	offset -> Y+44
;	sensorRef1 -> Y+40
;	sensorRef2 -> Y+36
;	sensorRef3 -> Y+32
;	stdMeter1 -> Y+28
;	stdMeter2 -> Y+24
;	stdMeter3 -> Y+20
;	lowRange -> Y+16
;	stdMeterRange -> Y+12
;	factorA -> Y+8
;	factorB -> Y+4
;	factorC -> Y+0
; 0018 007B         case CAL_EXTOFFSET :{
; 0018 007C             offset =  sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT1] - sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT1];
; 0018 007D             sensorValue += offset;
; 0018 007E             break;
; 0018 007F         }
; 0018 0080         case CAL_EXTLINEAR :{
; 0018 0081             //sensorValue = (((H28-$B$28)*$E$28)/$F$28)+$A$28;
; 0018 0082             sensorRef1 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT1];
; 0018 0083             sensorRef2 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT2];
; 0018 0084             stdMeter1  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT1];
; 0018 0085             stdMeter2  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT2];
; 0018 0086             lowRange   =  sensorRef2 - sensorRef1;
; 0018 0087             stdMeterRange = stdMeter2 - stdMeter1;
; 0018 0088             sensorValue = (((sensorValue-sensorRef1)*stdMeterRange)/lowRange)+stdMeter1;
; 0018 0089             break;
; 0018 008A         }
; 0018 008B         case CAL_EXTPOLYNOMIAL :{
; 0018 008C             sensorRef1 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT1];
; 0018 008D             sensorRef2 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT2];
; 0018 008E             sensorRef3 = sensorCalulate.sChennel[channelID-1].sensorRef[CAL_POINT3];
; 0018 008F             stdMeter1  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT1];
; 0018 0090             stdMeter2  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT2];
; 0018 0091             stdMeter3  = sensorCalulate.sChennel[channelID-1].stdRef[CAL_POINT3];
; 0018 0092 
; 0018 0093             gaussian(sensorRef1,  sensorRef2,  sensorRef3, stdMeter1, stdMeter2, stdMeter3, &factorA, &factorB, &factorC);
; 0018 0094             sensorValue = (factorA*sensorValue*sensorValue) + (factorB*sensorValue) + factorC;      //polynomail formula
; 0018 0095 
; 0018 0096             break;
; 0018 0097         }
; 0018 0098         case CAL_DEFAULT:{
; 0018 0099             break;
; 0018 009A         }
; 0018 009B     }
; 0018 009C     return sensorValue;
; 0018 009D }
;#include "io.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "ds1672.h"
;#include "smaProtocol.h"
;#include "debug.h"
;#include "sensorTask.h"
;
;extern iData_t viRXData;
;extern iData_t viTXData;
;
;iPTC_t iPTC_RX;
;iPTC_t iPTC_TX;
;
;//iChar_t * pviPTCData;
;
;iChar_t iPTCParser(iData_t *pviOutData_arg){
; 0019 000F iChar_t iPTCParser(iData_t *pviOutData_arg){

	.CSEG
; 0019 0010      char *pviCheck;
; 0019 0011      iChar_t viReturn = PTC_INVALID;
; 0019 0012      iInt_t indexParser = 0;
; 0019 0013      iUInt_t viDataLen = 0;
; 0019 0014      iInt_t viCheckSD = 0;
; 0019 0015      iInt_t viCheckSum = 0;
; 0019 0016      iInt_t viCheckLen = 0;
; 0019 0017      int i = 0;
; 0019 0018 
; 0019 0019 
; 0019 001A      //Prepair data that correct
; 0019 001B      pviCheck = viRXData.value;
;	*pviOutData_arg -> Y+16
;	*pviCheck -> R16,R17
;	viReturn -> R19
;	indexParser -> R20,R21
;	viDataLen -> Y+14
;	viCheckSD -> Y+12
;	viCheckSum -> Y+10
;	viCheckLen -> Y+8
;	i -> Y+6
; 0019 001C      if(*pviCheck == 0x7e){
; 0019 001D         printDebug("[iPTCparser]Start Delimiter OK(%02x).\r\n",*pviCheck);
; 0019 001E         viCheckSD = PTC_DS_SUCCESS;
; 0019 001F      }else{
; 0019 0020         viCheckSD = PTC_DS_INVALID;
; 0019 0021      }
; 0019 0022 
; 0019 0023      viDataLen = (viRXData.value[1]<<8) | viRXData.value[2];
; 0019 0024      if(viDataLen>4 && viDataLen<512){
; 0019 0025         viCheckLen = PTC_LEN_SUCCESS;
; 0019 0026         printDebug("[iPTCparser]Length (%d).\r\n",viDataLen);
; 0019 0027      }else{
; 0019 0028         viCheckLen = PTC_LEN_INVALID;
; 0019 0029      }
; 0019 002A 
; 0019 002B 
; 0019 002C      pviCheck += (3 + viDataLen);         //3= SD(1)+Length(2)
; 0019 002D      viCheckSum = *pviCheck;
; 0019 002E      printDebug("[iPTCparser]Check sum (%02x).\r\n",viCheckSum);
; 0019 002F      viCheckSum = iCheckSum(&viRXData.value[3],(viRXData.length+1));
; 0019 0030      if(viCheckSum == 0){
; 0019 0031          printDebug("[iPTCparser]Check sum correct(%d).\r\n",viCheckSum);
; 0019 0032          viCheckSum = PTC_CS_SUCCESS;
; 0019 0033      }else{
; 0019 0034          printDebug("[iPTCparser]Check sum incorrect(%d).\r\n",viCheckSum);
; 0019 0035          viCheckSum = PTC_CS_INVALID;
; 0019 0036      }
; 0019 0037 
; 0019 0038      if((viCheckSD == PTC_DS_SUCCESS) && (viCheckLen == PTC_LEN_SUCCESS) && (viCheckSum == PTC_CS_SUCCESS)){
; 0019 0039          memcpy(&iPTC_RX.hd,&viRXData.value[1],sizeof(iPTC_RX.hd));
; 0019 003A          indexParser += sizeof(iPTC_RX.hd);
; 0019 003B          iPTC_RX.dat.value = &viRXData.value[19];        //sd(1),len(2),mti(2),tid(8),tim(4),fid(2)   = 1+2+2+8+4+2 = 19
; 0019 003C          iPTC_RX.dat.len = (viDataLen + 3)-19;                               //(viDataLen) + sd(3) - 19
; 0019 003D          //printDebug("[iPTCParser]Data will process(%d).[\r\n",iPTC_RX.dat.len);
; 0019 003E          //print_payload(iPTC_RX.dat.value, iPTC_RX.dat.len);
; 0019 003F 
; 0019 0040          pviOutData_arg->length = iPTC_RX.dat.len;
; 0019 0041          memcpy(&pviOutData_arg->value[0],&viRXData.value[19],iPTC_RX.dat.len);
; 0019 0042 
; 0019 0043          viReturn = PTC_SUCCESS;
; 0019 0044      }else{
; 0019 0045          viReturn = PTC_INVALID;
; 0019 0046      }
; 0019 0047      return viReturn;
; 0019 0048 }
;
;
;
;iUChar_t iPTCCheckHostReq(iData_t *pviData_arg){
; 0019 004C iUChar_t iPTCCheckHostReq(iData_t *pviData_arg){
; 0019 004D    iUChar_t iReturn = PTC_HOST_NOT_REQ;
; 0019 004E    printDebug("[iPTCCheckHostReq]MTI(%02x%02x)",iPTC_RX.hd.mti[0],iPTC_RX.hd.mti[1]);
;	*pviData_arg -> Y+1
;	iReturn -> R17
; 0019 004F    if((iPTC_RX.hd.mti[1] & 0x01) == 1){
; 0019 0050       printDebug("[iPTCCheckHostReq]Host Request.\r\n");
; 0019 0051       iReturn = PTC_HOST_REQ;
; 0019 0052    }else{
; 0019 0053       printDebug("[iPTCCheckHostReq]Host is not Request.\r\n");
; 0019 0054    }
; 0019 0055    return iReturn;
; 0019 0056 }
;
;iInt_t iCheckSum(iChar_t buf_ags[], iInt_t len_ags) {
; 0019 0058 iInt_t iCheckSum(iChar_t buf_ags[], iInt_t len_ags) {
; 0019 0059     iUInt_t 	i = 0;
; 0019 005A     iUInt_t 	sum = 0;
; 0019 005B 
; 0019 005C     for (i = 0; i < len_ags; i++) {
;	buf_ags -> Y+6
;	len_ags -> Y+4
;	i -> R16,R17
;	sum -> R18,R19
; 0019 005D         sum += buf_ags[i];
; 0019 005E     }
; 0019 005F     return (0xFF - (sum & 0xFF));
; 0019 0060 }
;
;void iHostResponse(){}
; 0019 0062 void iHostResponse(){}
;
;iInt_t iGenFID(){
; 0019 0064 iInt_t iGenFID(){
; 0019 0065    iInt_t viFID = 0;
; 0019 0066    do{
;	viFID -> R16,R17
; 0019 0067       viFID = rand();
; 0019 0068    }while((viFID == 0) && (viFID == 0xffff));
; 0019 0069    return viFID;
; 0019 006A }
;
;
;void iAckHostReq(){
; 0019 006D void iAckHostReq(){
; 0019 006E     //7E0014080005050505050505055173C95524224B024A0010
; 0019 006F     //7E001008000505050505050505D072C95500006F
; 0019 0070 
; 0019 0071 //    iChat_t mit[2] = {0x80,0x00};
; 0019 0072 //    iInt_t viFrameID = 0;
; 0019 0073 //    viFrameID = iGenFID();
; 0019 0074 //    iPTCPack(iData_t *pviOutData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg)
; 0019 0075 }
;
;void iPTCPack(iData_t *pviOutData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg){
; 0019 0077 void iPTCPack(iData_t *pviOutData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg){
; 0019 0078     //iChar_t * pviPTCData;
; 0019 0079     iUInt_t viIndexWrite = 0;
; 0019 007A     iUInt_t viLength = 0;
; 0019 007B     iUChar_t viCharLength[2];
; 0019 007C     iChar_t viCharMTI[2];
; 0019 007D     iChar_t viSD = 0x7e;
; 0019 007E     iUInt_t viCheckSum;
; 0019 007F     iUInt_t viFrameCSLen = 0;
; 0019 0080     iInt_t viFrameID = 0;
; 0019 0081     unsigned long int timestamp;
; 0019 0082 
; 0019 0083     viFrameCSLen = 2 + 8 + 4 + 2 + viLength_arg + 1;     //2(mti) + 8(tid) + 4(tim) + 2(fid) + ?(data) +1(cs)
;	*pviOutData_arg -> Y+28
;	*pviData_arg -> Y+26
;	viLength_arg -> Y+24
;	*pviMTI_arg -> Y+22
;	*pviTID_arg -> Y+20
;	viIndexWrite -> R16,R17
;	viLength -> R18,R19
;	viCharLength -> Y+18
;	viCharMTI -> Y+16
;	viSD -> R21
;	viCheckSum -> Y+14
;	viFrameCSLen -> Y+12
;	viFrameID -> Y+10
;	timestamp -> Y+6
; 0019 0084     //pviPTCData = (iChar_t *)malloc((viLength+20)); //sd(1),len(2),mti(2),tid(8),tim(4),fid(2),cs(1)
; 0019 0085 
; 0019 0086     //if(pviPTCData != NULL){
; 0019 0087         //sd
; 0019 0088         memcpy(&pviOutData_arg->value[viIndexWrite],&viSD,1);
; 0019 0089         viIndexWrite += 1;
; 0019 008A 
; 0019 008B         //len
; 0019 008C         viLength = viLength_arg+16;
; 0019 008D         viCharLength[0] = (viLength<<8);
; 0019 008E         viCharLength[1] = viLength;
; 0019 008F         memcpy(&pviOutData_arg->value[viIndexWrite],&viCharLength[0],2);
; 0019 0090         viIndexWrite += 2;
; 0019 0091 
; 0019 0092         //mti
; 0019 0093         memcpy(&pviOutData_arg->value[viIndexWrite],&pviMTI_arg[0],2);
; 0019 0094         viIndexWrite += 2;
; 0019 0095 
; 0019 0096         //tid
; 0019 0097         memcpy(&pviOutData_arg->value[viIndexWrite],&pviTID_arg[0],8);
; 0019 0098         viIndexWrite += 8;
; 0019 0099 
; 0019 009A         //tim
; 0019 009B         timestamp = DS1672_read();
; 0019 009C         memcpy(&pviOutData_arg->value[viIndexWrite],&timestamp,sizeof(timestamp));
; 0019 009D         viIndexWrite += sizeof(timestamp);
; 0019 009E 
; 0019 009F         memcpy(&viCharMTI[0],&pviMTI_arg[0],2);
; 0019 00A0         if((viCharMTI[0] == 0x08) && (viCharMTI[1] == 0x00)){
; 0019 00A1             //fid
; 0019 00A2             if(viLength_arg==0){
; 0019 00A3                 viFrameID = 0;
; 0019 00A4                 memcpy(&pviOutData_arg->value[viIndexWrite],&viFrameID,2);
; 0019 00A5                 viIndexWrite += 2;
; 0019 00A6             }else{
; 0019 00A7                 //fid
; 0019 00A8                 viFrameID = iGenFID();
; 0019 00A9                 memcpy(&pviOutData_arg->value[viIndexWrite],&viFrameID,2);
; 0019 00AA                 viIndexWrite += 2;
; 0019 00AB             }
; 0019 00AC         }else{
; 0019 00AD             //fid
; 0019 00AE             viFrameID = iGenFID();
; 0019 00AF             memcpy(&pviOutData_arg->value[viIndexWrite],&viFrameID,2);
; 0019 00B0             viIndexWrite += 2;
; 0019 00B1         }
; 0019 00B2 
; 0019 00B3 
; 0019 00B4 
; 0019 00B5         if(viLength_arg != 0 ){
; 0019 00B6             //data
; 0019 00B7             memcpy(&pviOutData_arg->value[viIndexWrite],&pviData_arg[0],viLength_arg);
; 0019 00B8             viIndexWrite += viLength_arg;
; 0019 00B9         }
; 0019 00BA 
; 0019 00BB 
; 0019 00BC         //cs
; 0019 00BD         viCheckSum = iCheckSum(&pviOutData_arg->value[3],viFrameCSLen);
; 0019 00BE         memcpy(&pviOutData_arg->value[viIndexWrite],&viCheckSum,1);
; 0019 00BF         viIndexWrite += 1;
; 0019 00C0 
; 0019 00C1         pviOutData_arg->length = viLength_arg+20;
; 0019 00C2 
; 0019 00C3         //printDebug("[iPTCPack]Print:\r\n");
; 0019 00C4         //print_payload(pviOutData_arg->value, (viLength_arg+20));
; 0019 00C5 
; 0019 00C6 //    }else{
; 0019 00C7 //        printDebug("[iPTCPack]can 't allocate mem.\r\n");
; 0019 00C8 //        //pviPTCData = 0;
; 0019 00C9 //    }
; 0019 00CA     //free(pviPTCData);
; 0019 00CB     //return pviPTCData;
; 0019 00CC }
;
;//iChar_t * iPTCPack(iData_t *pviData_arg, iChar_t *pviData_arg, iUInt_t viLength_arg, iChar_t *pviMTI_arg, iChar_t *pviTID_arg){
;//    //iChar_t * pviPTCData;
;//    iUInt_t viIndexWrite = 0;
;//    iUInt_t viLength = 0;
;//    iUChar_t viCharLength[2];
;//    iChar_t viSD = 0x7e;
;//    iUInt_t viCheckSum;
;//    iUInt_t viFrameCSLen = 0;
;//    iInt_t viFrameID = 0;
;//    unsigned long int timestamp;
;//
;//    viFrameCSLen = 2 + 8 + 4 + 2 + viLength_arg + 1;     //2(mti) + 8(tid) + 4(tim) + 2(fid) + ?(data) +1(cs)
;//    pviPTCData = (iChar_t *)malloc((viLength+20)); //sd(1),len(2),mti(2),tid(8),tim(4),fid(2),cs(1)
;//
;//    if(pviPTCData != NULL){
;//        //sd
;//        memcpy(&pviPTCData[viIndexWrite],&viSD,1);
;//        viIndexWrite += 1;
;//
;//        //len
;//        viLength = viLength_arg+16;
;//        viCharLength[0] = (viLength<<8);
;//        viCharLength[1] = viLength;
;//        memcpy(&pviPTCData[viIndexWrite],&viCharLength[0],2);
;//        viIndexWrite += 2;
;//
;//        //mti
;//        memcpy(&pviPTCData[viIndexWrite],&pviMTI_arg[0],2);
;//        viIndexWrite += 2;
;//
;//        //tid
;//        memcpy(&pviPTCData[viIndexWrite],&pviTID_arg[0],8);
;//        viIndexWrite += 8;
;//
;//        //tim
;//        timestamp = DS1672_read();
;//        memcpy(&pviPTCData[viIndexWrite],&timestamp,sizeof(timestamp));
;//        viIndexWrite += sizeof(timestamp);
;//
;//        //fid
;//        viFrameID = iGenFID();
;//        memcpy(&pviPTCData[viIndexWrite],&viFrameID,2);
;//        viIndexWrite += 2;
;//
;//        //data
;//        memcpy(&pviPTCData[viIndexWrite],&pviData_arg[0],viLength_arg);
;//        viIndexWrite += viLength_arg;
;//
;//        //cs
;//        viCheckSum = iCheckSum(&pviPTCData[3],viFrameCSLen);
;//        memcpy(&pviPTCData[viIndexWrite],&viCheckSum,1);
;//        viIndexWrite += 1;
;//
;//        pviData_arg.length = viLength_arg+20;
;//
;//        printDebug("[iPTCPack]Print:\r\n");
;//        print_payload(pviPTCData, (viLength_arg+20));
;//
;//    }else{
;//        printDebug("[iPTCPack]can 't allocate mem.\r\n");
;//        pviPTCData = 0;
;//    }
;//    //free(pviPTCData);
;//    return pviPTCData;
;//}
;
;//void iDataReportPack(iChar_t *pviOutData,iDataReport_t *pviInData){
;//
;//}
;#include "io.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "timer.h"
;#include "managerTask.h"
;#include "sensorTask.h"
;#include "smaProtocol.h"
;#include "lan.h"
;#include "database.h"
;
;extern piQueueHandle_t pviQueueTaskAToTaskB;
;extern piQueueHandle_t pviQueueSensorToMang;
;extern piQueueHandle_t pviQueueDeviceToMang;
;
;extern iUChar_t viFlagTerInit;           //Terminal initial frist
;
;iMangQueue_t viMangQueue[MANG_QUEUE_MAX];
;
;iSensorData_t pviRXReceiveSensor;
;//iUChar_t de
;
;//iData_t viTXDataBuff;
;//iData_t viRXDataBuff;
;
;void managerTask(void *pviParameter){
; 001A 0017 void managerTask(void *pviParameter){

	.CSEG
; 001A 0018      int i;
; 001A 0019      iData_t viTXDataBuff;
; 001A 001A      iData_t viRXDataBuff;
; 001A 001B      iUChar_t viHostRetransmit = 3;
; 001A 001C 
; 001A 001D //     char viGenDataElem[80] = {
; 001A 001E //         0x7e,
; 001A 001F //         0x00,0x4c,
; 001A 0020 //         0x02,0x00,
; 001A 0021 //         0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
; 001A 0022 //         0x50,0x72,0xC9,0x55,
; 001A 0023 //         0x00,0x01,
; 001A 0024 //         0x2A,0x06,0x11,0x04,0xCD,0xCC,0xC7,0x42,
; 001A 0025 //         0x2A,0x06,0x12,0x04,0x00,0x00,0x00,0x00,
; 001A 0026 //         0x2A,0x06,0x13,0x04,0x00,0x00,0xE0,0x41,
; 001A 0027 //         0x5A,0x07,0x31,0x0c,0x0d,0x00,0x00,0x00,0x00,
; 001A 0028 //         0x5A,0x07,0x32,0x0d,0x0d,0x01,0x0f,0xf0,0x3b,
; 001A 0029 //         0x5A,0x07,0x41,0x0a,0x09,0x00,0x0f,0xe0,0x41,
; 001A 002A //         0x5A,0x07,0x42,0x0a,0x0b,0x00,0x0f,0x08,0x42,
; 001A 002B //         0x70
; 001A 002C //    } ;
; 001A 002D 
; 001A 002E     char viGenDataElem[60] = {
; 001A 002F          0x2A,0x06,0x11,0x04,0xCD,0xCC,0xC7,0x42,
; 001A 0030          0x2A,0x06,0x12,0x04,0x00,0x00,0x00,0x00,
; 001A 0031          0x2A,0x06,0x13,0x04,0x00,0x00,0xE0,0x41,
; 001A 0032          0x5A,0x07,0x31,0x0c,0x0d,0x00,0x00,0x00,0x00,
; 001A 0033          0x5A,0x07,0x32,0x0d,0x0d,0x01,0x0f,0xf0,0x3b,
; 001A 0034          0x5A,0x07,0x41,0x0a,0x09,0x00,0x0f,0xe0,0x41,
; 001A 0035          0x5A,0x07,0x42,0x0a,0x0b,0x00,0x0f,0x08,0x42
; 001A 0036     } ;
; 001A 0037      char mti[2] = {0x02,0x00};
; 001A 0038      char tid[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
; 001A 0039      TIMER   viDelay_s;
; 001A 003A      iUChar_t viCommuInterface = 0;
; 001A 003B      iUChar_t modeOperate = REALTIME_MODE;
; 001A 003C      iUChar_t deviceStatus = DEVICE_ENABLE;
; 001A 003D 
; 001A 003E     #asm("wdr")
;	*pviParameter -> Y+684
;	i -> R16,R17
;	viTXDataBuff -> Y+382
;	viRXDataBuff -> Y+80
;	viHostRetransmit -> R19
;	viGenDataElem -> Y+20
;	mti -> Y+18
;	tid -> Y+10
;	viDelay_s -> Y+6
;	viCommuInterface -> R18
;	modeOperate -> R21
;	deviceStatus -> R20
; 001A 003F 
; 001A 0040      printDebug("<managerTask>Task Running...\r\n");
; 001A 0041 
; 001A 0042 
; 001A 0043 //    if(iQueueReceive(pviQueueSensorToMang,&pviRXReceiveSensor)==1){
; 001A 0044 //        printDebug("<managerTask>ACD");
; 001A 0045 //        for(i=0;i<SENSER_ADC_MAX_SIZE;i++){
; 001A 0046 //            printDebug("[%d]:%d | ",(i+1),pviRXReceiveSensor.adc[i]);
; 001A 0047 //        }
; 001A 0048 //        printDebug("\r\n");
; 001A 0049 //        printDebug("<managerTask>DHT11 Temp-c(%f), Humidity(%f)\r\n",pviRXReceiveSensor.dht11Temp,pviRXReceiveSensor.dht11Humi);
; 001A 004A //	}else{
; 001A 004B //		printDebug("<managerTask>data can not sent a data to pviQueueSensorToMang.\r\n");
; 001A 004C //	}
; 001A 004D 
; 001A 004E //
; 001A 004F //    if(iQueueReceive(pviQueueDeviceToMang,&pviRXReceiveSensor)==1){
; 001A 0050 //        printDebug("<managerTask>ACD");
; 001A 0051 //        for(i=0;i<SENSER_ADC_MAX_SIZE;i++){
; 001A 0052 //            printDebug("[%d]:%d | ",(i+1),pviRXReceiveSensor.adc[i]);
; 001A 0053 //        }
; 001A 0054 //        printDebug("\r\n");
; 001A 0055 //        printDebug("<managerTask>DHT11 Temp-c(%f), Humidity(%f)\r\n",pviRXReceiveSensor.dht11Temp,pviRXReceiveSensor.dht11Humi);
; 001A 0056 //	}else{
; 001A 0057 //		printDebug("<managerTask>data can not sent a data to pviQueueSensorToMang.\r\n");
; 001A 0058 //	}
; 001A 0059 
; 001A 005A     if(viFlagTerInit==0){
; 001A 005B         mti[0] = 0x08;
; 001A 005C         mti[1] = 0x00;
; 001A 005D         iPTCPack(&viTXDataBuff,(char *)"",0,mti,tid);
; 001A 005E         if(iLanWriteData(&viTXDataBuff)){
; 001A 005F             if(iLanReadData(&viRXDataBuff)){
; 001A 0060                 if(iPTCParser(&viRXDataBuff)){
; 001A 0061                     viFlagTerInit = 1;
; 001A 0062                     iTagParser(&viRXDataBuff);      //tag process  othor do..
; 001A 0063                     if(iPTCCheckHostReq(&viRXDataBuff)){
; 001A 0064 
; 001A 0065                     }
; 001A 0066                 }
; 001A 0067                 //iHostReqProcess(&viTXDataBuff,&viRXDataBuff);
; 001A 0068             }
; 001A 0069         }
; 001A 006A     }else{
; 001A 006B 
; 001A 006C         //deviceStatus = DEVICE_DISABLE;
; 001A 006D         deviceStatus = DEVICE_ENABLE;
; 001A 006E 
; 001A 006F         if(deviceStatus == DEVICE_ENABLE){
; 001A 0070             TIMER_setTimer(&viDelay_s, 5);
; 001A 0071             while(!TIMER_checkTimerExceed(viDelay_s)){
; 001A 0072                #asm("wdr")
; 001A 0073             }
; 001A 0074 //
; 001A 0075 //
; 001A 0076 //            if(){
; 001A 0077 //
; 001A 0078 //            }
; 001A 0079 
; 001A 007A 
; 001A 007B             if(modeOperate == REALTIME_MODE){
; 001A 007C                  mti[0] = 0x02;
; 001A 007D                  mti[1] = 0x00;
; 001A 007E             }else if(modeOperate == LOGGER_MODE){
; 001A 007F                  mti[0] = 0x03;
; 001A 0080                  mti[1] = 0x00;
; 001A 0081             }
; 001A 0082 
; 001A 0083             iPTCPack(&viTXDataBuff,viGenDataElem,sizeof(viGenDataElem),mti,tid);
; 001A 0084             iMangQueueAddItem(&viTXDataBuff,&viTXDataBuff.value[17]); //add protocol in mang queue
; 001A 0085             iMangQueueDisplay();//display mang queue
; 001A 0086             delay_ms(1000);
; 001A 0087             iDataInsert(viTXDataBuff.value,viTXDataBuff.length);
; 001A 0088             #asm("wdr")
; 001A 0089 
; 001A 008A             //print_payload(viTXDataBuff.value, (sizeof(viGenDataElem)+20));               //20 = header + check sum
; 001A 008B             while(iMangCheckRetransmit(&viTXDataBuff.value[17])!=0){
; 001A 008C                 if(iLanWriteData(&viTXDataBuff)){
; 001A 008D                       if(iLanReadData(&viRXDataBuff)){
; 001A 008E                             iMangQueueDelItem(&viRXDataBuff.value[17]);       //del queue with fid
; 001A 008F                             if(iPTCParser(&viRXDataBuff)){    //report success
; 001A 0090                                   printDebug("[managerTask]Print.[\r\n");
; 001A 0091                                   print_payload(viRXDataBuff.value,viRXDataBuff.length);
; 001A 0092                                   printDebug("]\r\n");
; 001A 0093 
; 001A 0094                                   iTagParser(&viRXDataBuff);      //tag process  othor do..
; 001A 0095 
; 001A 0096 
; 001A 0097                                   if(iPTCCheckHostReq(&viRXDataBuff)){
; 001A 0098                                      mti[0] = 0x08;
; 001A 0099                                      mti[1] = 0x00;
; 001A 009A                                      iPTCPack(&viTXDataBuff,(char *)"",0,mti,tid);
; 001A 009B                                      while(viHostRetransmit!=0){
; 001A 009C                                         if(iLanWriteData(&viTXDataBuff)){
; 001A 009D                                             if(iLanReadData(&viRXDataBuff)){
; 001A 009E                                                 iHostReqProcess(&viTXDataBuff,&viRXDataBuff);
; 001A 009F                                             }
; 001A 00A0                                             break;
; 001A 00A1                                         }
; 001A 00A2                                         viHostRetransmit--;
; 001A 00A3                                      }
; 001A 00A4                                   }
; 001A 00A5                             }
; 001A 00A6                             break;
; 001A 00A7                        }else{
; 001A 00A8                             //iMangQueueDelItem(&viRXDataBuff.value[17]);       //del queue with fid
; 001A 00A9                        }
; 001A 00AA                 }
; 001A 00AB                 if(iMangCheckRetransmit(&viTXDataBuff.value[17])==0){
; 001A 00AC                      iDataLogInsert(viTXDataBuff.value,viTXDataBuff.length);
; 001A 00AD                      iMangQueueDelItem(&viTXDataBuff.value[17]);       //del queue with fid  due over retransmit
; 001A 00AE                 }
; 001A 00AF             }
; 001A 00B0 
; 001A 00B1 
; 001A 00B2         }
; 001A 00B3 
; 001A 00B4     }
; 001A 00B5 
; 001A 00B6 
; 001A 00B7 
; 001A 00B8 }
;
;iUInt_t iHostReqProcess(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
; 001A 00BA iUInt_t iHostReqProcess(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
; 001A 00BB     char mti[2] = {0x08,0x00};
; 001A 00BC     char tid[8] = {0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};
; 001A 00BD     iUInt_t viReturn = 0;
; 001A 00BE     iUChar_t viRetransmit = 1;
; 001A 00BF     iChar_t viHostNeedFlag = 0;
; 001A 00C0 
; 001A 00C1 //    iPTCPack(pviTXDataBuff_arg,(char *)"",0,mti,tid);
; 001A 00C2 //    iMangQueueAddItem(pviTXDataBuff_arg,&pviTXDataBuff_arg->value[17]); //add protocol in mang queue
; 001A 00C3 //    iMangQueueDisplay();//display mang queue
; 001A 00C4 //    iDataInsert(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 00C5     printDebug("[iHostReqProcess]TX Print 1.[\r\n");
;	*pviTXDataBuff_arg -> Y+16
;	*pviRXDataBuff_arg -> Y+14
;	mti -> Y+12
;	tid -> Y+4
;	viReturn -> R16,R17
;	viRetransmit -> R19
;	viHostNeedFlag -> R18
; 001A 00C6     print_payload(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 00C7     printDebug("]\r\n");
; 001A 00C8 
; 001A 00C9     printDebug("[iHostReqProcess]RX Print 2.[\r\n");
; 001A 00CA     print_payload(pviRXDataBuff_arg->value,pviRXDataBuff_arg->length);
; 001A 00CB     printDebug("]\r\n");
; 001A 00CC 
; 001A 00CD     if(iPTCParser(pviRXDataBuff_arg)){    //report success
; 001A 00CE         printDebug("[iHostReqProcess]Print.[\r\n");
; 001A 00CF         print_payload(pviRXDataBuff_arg->value,pviRXDataBuff_arg->length);
; 001A 00D0         printDebug("]\r\n");
; 001A 00D1 
; 001A 00D2         iTagParser(pviRXDataBuff_arg);      //tag process  othor do..
; 001A 00D3     }
; 001A 00D4 //
; 001A 00D5 //    printDebug("[iHostReqProcess]FID(%02x%02x).\r\n",*(pviTXDataBuff_arg->value+17),*(pviTXDataBuff_arg->value+18));
; 001A 00D6 
; 001A 00D7 //        if(iLanReadData(pviRXDataBuff_arg)){
; 001A 00D8 //            iMangQueueDelItem((pviTXDataBuff_arg->value+17));       //del queue with fid
; 001A 00D9 //            if(iPTCParser(pviRXDataBuff_arg)){    report success
; 001A 00DA //                printDebug("[iHostReqProcess]Print 1-1.[\r\n");
; 001A 00DB //                print_payload(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 00DC //                printDebug("]\r\n");
; 001A 00DD //            }
; 001A 00DE //        }
; 001A 00DF //
; 001A 00E0 //    while(iMangCheckRetransmit((pviTXDataBuff_arg->value+17))!=0){
; 001A 00E1 //        if(iLanWriteData(pviTXDataBuff_arg)){
; 001A 00E2 //            if(iLanReadData(pviRXDataBuff_arg)){
; 001A 00E3 //                iMangQueueDelItem((pviTXDataBuff_arg->value+17));       //del queue with fid
; 001A 00E4 //                if(iPTCParser(pviRXDataBuff_arg)){    report success
; 001A 00E5 //                    printDebug("[iHostReqProcess]Print 1-1.[\r\n");
; 001A 00E6 //                    print_payload(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 00E7 //                    printDebug("]\r\n");
; 001A 00E8 //                }
; 001A 00E9 //            }
; 001A 00EA //        }
; 001A 00EB //        if(iMangCheckRetransmit((pviTXDataBuff_arg->value+17))==0){
; 001A 00EC //             iDataLogInsert(pviTXDataBuff_arg->value,pviTXDataBuff_arg->length);
; 001A 00ED //             iMangQueueDelItem((pviTXDataBuff_arg->value+17));       //del queue with fid  due over retransmit
; 001A 00EE //        }
; 001A 00EF //    }
; 001A 00F0 
; 001A 00F1 
; 001A 00F2     return viReturn;
; 001A 00F3 }
;
;void iDataReportTX(){
; 001A 00F5 void iDataReportTX(){
; 001A 00F6 
; 001A 00F7 }
;
;void iStatusReportTX(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
; 001A 00F9 void iStatusReportTX(iData_t * pviTXDataBuff_arg,iData_t * pviRXDataBuff_arg){
; 001A 00FA 
; 001A 00FB }
;
;void iEventReportTX(){
; 001A 00FD void iEventReportTX(){
; 001A 00FE 
; 001A 00FF }
;
;void iTerAckByTagB(iChar_t viTagName, iChar_t viPropNumber){              //host requst = A , terminal ack = B
; 001A 0101 void iTerAckByTagB(iChar_t viTagName, iChar_t viPropNumber){
; 001A 0102      iChar_t viMTI[2] = {0x08,0x00};
; 001A 0103      iChar_t viTID[8];
; 001A 0104      iChar_t viAckData[4] = {0x4b,0x02,0x10,0x00};
; 001A 0105      iData_t * pviDataTX;
; 001A 0106      iData_t * pviDataRX;
; 001A 0107 
; 001A 0108      pviDataTX = (iData_t*)malloc(sizeof(iData_t));
;	viTagName -> Y+19
;	viPropNumber -> Y+18
;	viMTI -> Y+16
;	viTID -> Y+8
;	viAckData -> Y+4
;	*pviDataTX -> R16,R17
;	*pviDataRX -> R18,R19
; 001A 0109      pviDataRX = (iData_t*)malloc(sizeof(iData_t));
; 001A 010A      if(pviDataTX!=NULL && pviDataRX!=NULL){
; 001A 010B          //memcpy(viTID,&viDVConfigUpdate.viProperties.viDeviceID[0],8);
; 001A 010C          printConfig(&viDVConfigUpdate.viProperties.viDeviceID[0],sizeof(viDVConfigUpdate.viProperties.viDeviceID));
; 001A 010D          memcpyd(viTID,(char eeprom  *)&viDVConfigUpdate.viProperties.viDeviceID[0],8);
; 001A 010E          print_payload(viTID,8);
; 001A 010F          if(viTagName==TAG_4A){
; 001A 0110             if(viPropNumber==CONF_PROPERTIES){
; 001A 0111                 iPTCPack(pviDataTX,viAckData,sizeof(viAckData),viMTI,viTID);
; 001A 0112                 if(iLanWriteData(pviDataTX)){
; 001A 0113                     if(iLanReadData(pviDataRX)){
; 001A 0114                         if(iPTCParser(pviDataRX)){
; 001A 0115                             viFlagTerInit = 1;
; 001A 0116                             iTagParser(pviDataRX);      //tag process  othor do..
; 001A 0117                             if(iPTCCheckHostReq(pviDataRX)){
; 001A 0118 
; 001A 0119                             }
; 001A 011A                         }
; 001A 011B                     }
; 001A 011C                 }
; 001A 011D             }
; 001A 011E 
; 001A 011F          }
; 001A 0120          free(pviDataTX);
; 001A 0121          free(pviDataRX);
; 001A 0122      }else{
; 001A 0123         printDebug("[iTerAckByTagB]Not allocate memory.\r\n");
; 001A 0124      }
; 001A 0125 }
;
;void iTagParser(iData_t *pviData_arg){
; 001A 0127 void iTagParser(iData_t *pviData_arg){
; 001A 0128     int i,j;
; 001A 0129     iUInt_t viDataLen = 0;
; 001A 012A 
; 001A 012B     printDebug("[iTagParser]Host response\r\n");
;	*pviData_arg -> Y+6
;	i -> R16,R17
;	j -> R18,R19
;	viDataLen -> R20,R21
; 001A 012C     viDataLen = pviData_arg->value[1];
; 001A 012D     printDebug("[iTagParser]Len(%d)\r\n",viDataLen);
; 001A 012E 
; 001A 012F     if(pviData_arg->value[0] == 0x00){
; 001A 0130         for(i=2;i<(viDataLen);i+=2){
; 001A 0131              //printDebug("[iTagParser]Loop:%02x(%d)",iPTC_RX.dat.value[i],iPTC_RX.dat.value[(i+1)]);
; 001A 0132              switch(pviData_arg->value[i]){
; 001A 0133                 case TAG_2A:{
; 001A 0134                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
; 001A 0135                    break;
; 001A 0136                 }
; 001A 0137                 case TAG_3A:{
; 001A 0138                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
; 001A 0139                    break;
; 001A 013A                 }
; 001A 013B                 case TAG_4A:{
; 001A 013C                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
; 001A 013D                    break;
; 001A 013E                 }
; 001A 013F                 case TAG_5A:{
; 001A 0140                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
; 001A 0141                    break;
; 001A 0142                 }
; 001A 0143                 case TAG_6A:{
; 001A 0144                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
; 001A 0145                    break;
; 001A 0146                 }
; 001A 0147                 case TAG_7A:{
; 001A 0148                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
; 001A 0149                    break;
; 001A 014A                 }
; 001A 014B                 case TAG_8A:{
; 001A 014C                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",pviData_arg->value[i],pviData_arg->value[(i+1)]);
; 001A 014D                    break;
; 001A 014E                 }
; 001A 014F                 case TAG_9A:{
; 001A 0150                    printDebug("[iTagParser]Tag:%02x(%d)\r\n",&pviData_arg->value[i],&pviData_arg->value[(i+1)]);
; 001A 0151                    break;
; 001A 0152                 }
; 001A 0153              }
; 001A 0154         }
; 001A 0155     }else if(pviData_arg->value[0] == TAG_4A){
; 001A 0156         switch(pviData_arg->value[2]){
; 001A 0157              case CONF_PROPERTIES:{      //config properties
; 001A 0158                 printDebug("[iTagParser]Host need to config(Properties)\r\n");
; 001A 0159                 memcpye((char eeprom *)&viDVConfigUpdate.viProperties,&pviData_arg->value[3],viDataLen);
; 001A 015A                 printConfig((char eeprom *)&viDVConfigUpdate.viProperties,sizeof(viDVConfigUpdate.viProperties));
; 001A 015B                 iTerAckByTagB(TAG_4A,CONF_PROPERTIES);
; 001A 015C                 break;
; 001A 015D              }
; 001A 015E              case CONF_OPERATEING:{      //config properties
; 001A 015F                 printDebug("[iTagParser]Host need to config(Operating)\r\n");
; 001A 0160                 memcpye((char eeprom *)&viDVConfigUpdate.viOperate,&pviData_arg->value[3],viDataLen);
; 001A 0161                 printConfig((char eeprom *)&viDVConfigUpdate.viOperate,sizeof(viDVConfigUpdate.viOperate));
; 001A 0162                 break;
; 001A 0163              }
; 001A 0164              case CONF_BUZZER:{      //config properties
; 001A 0165                 printDebug("[iTagParser]Host need to config(Buzzer)\r\n");
; 001A 0166                 break;
; 001A 0167              }
; 001A 0168              case CONF_ENVIRON_COND:{      //config properties
; 001A 0169                 printDebug("[iTagParser]Host need to config(Environment Alarm Condition)\r\n");
; 001A 016A                 break;
; 001A 016B              }
; 001A 016C         }
; 001A 016D 
; 001A 016E         if((pviData_arg->value[2]&0xf0) == CONF_DIGI_IN){
; 001A 016F              printDebug("[iTagParser]Host need to config(Digital Input)\r\n");
; 001A 0170         }else if((pviData_arg->value[2]&0xf0) == CONF_DIGI_OUT){
; 001A 0171              printDebug("[iTagParser]Host need to config(Digital Output)\r\n");
; 001A 0172         }else if((pviData_arg->value[2]&0xf0) == CONF_ANA_IN){
; 001A 0173              printDebug("[iTagParser]Host need to config(Analog Input)\r\n");
; 001A 0174         }else if((pviData_arg->value[2]&0xf0) == CONF_ANA_OUT){
; 001A 0175              printDebug("[iTagParser]Host need to config(Analog Output)\r\n");
; 001A 0176         }
; 001A 0177 
; 001A 0178     }else{
; 001A 0179        printDebug("[iTagParser]Host response unknow(%02x).\r\n",pviData_arg->value[0]);
; 001A 017A     }
; 001A 017B 
; 001A 017C 
; 001A 017D }
;
;
;iInt_t iMangQueueAddItem(iData_t *pviDataItem_arg,iChar_t *pviFid_arg){
; 001A 0180 iInt_t iMangQueueAddItem(iData_t *pviDataItem_arg,iChar_t *pviFid_arg){
; 001A 0181     iInt_t viReturn = -1;
; 001A 0182     iInt_t i;
; 001A 0183     iChar_t viFid[2];
; 001A 0184 
; 001A 0185     memcpy(viFid,&pviFid_arg[0],2);
;	*pviDataItem_arg -> Y+8
;	*pviFid_arg -> Y+6
;	viReturn -> R16,R17
;	i -> R18,R19
;	viFid -> Y+4
; 001A 0186     for(i=0;i<MANG_QUEUE_MAX;i++){
; 001A 0187         if(viMangQueue[i].value == NULL){
; 001A 0188             viMangQueue[i].value = (iChar_t * const)malloc(pviDataItem_arg->length);
; 001A 0189             if(viMangQueue[i].value != NULL){
; 001A 018A                 viMangQueue[i].length = pviDataItem_arg->length;
; 001A 018B                 memcpy(viMangQueue[i].value,&pviDataItem_arg->value[0],pviDataItem_arg->length);
; 001A 018C                 memcpy(&viMangQueue[i].fid[0],&viFid[0],2);
; 001A 018D                 viMangQueue[i].reTransmit = MANG_RETRANSMIT;
; 001A 018E                 printDebug("[iMangQueueAddItem]Add by FID(%02x%02x).\r\n",viFid[0],viFid[1]);
; 001A 018F                 viReturn = 1;
; 001A 0190                 break;
; 001A 0191             }else{
; 001A 0192                printDebug("[iMangQueueAddItem]can't allocate mem.\r\n");
; 001A 0193                viReturn = -1;
; 001A 0194             }
; 001A 0195         }else{
; 001A 0196            viReturn = 0;
; 001A 0197         }
; 001A 0198     }
; 001A 0199     if(viReturn == 0){
; 001A 019A         printDebug("[iMangQueueAddItem]MangQueue Full.\r\n");
; 001A 019B     }
; 001A 019C     return viReturn;
; 001A 019D }
;iInt_t iMangQueueDelItem(iChar_t *pviFid_arg){
; 001A 019E iInt_t iMangQueueDelItem(iChar_t *pviFid_arg){
; 001A 019F     iInt_t viReturn = -1;
; 001A 01A0     iInt_t i;
; 001A 01A1     iChar_t viFid[2];
; 001A 01A2 
; 001A 01A3     memcpy(viFid,&pviFid_arg[0],2);
;	*pviFid_arg -> Y+6
;	viReturn -> R16,R17
;	i -> R18,R19
;	viFid -> Y+4
; 001A 01A4     printDebug("[iMangQueueDelItem]Del by FID(%02x%02x).\r\n",viFid[0],viFid[1]);
; 001A 01A5     for(i=0;i<MANG_QUEUE_MAX;i++){
; 001A 01A6         if(viMangQueue[i].value != NULL){
; 001A 01A7             if(memcmp(viMangQueue[i].fid,&viFid[0],2)==0){
; 001A 01A8                 free(viMangQueue[i].value);
; 001A 01A9                 viMangQueue[i].value = NULL;
; 001A 01AA                 memset(viMangQueue[i].fid,0,2);
; 001A 01AB                 viMangQueue[i].length = 0;
; 001A 01AC                 viReturn = 1;
; 001A 01AD                 break;
; 001A 01AE             }else{
; 001A 01AF                 viReturn = -1;
; 001A 01B0             }
; 001A 01B1         }else{
; 001A 01B2             viReturn = 0;
; 001A 01B3         }
; 001A 01B4     }
; 001A 01B5     if(viReturn == 0){
; 001A 01B6         printDebug("[iMangQueueDelItem]Queue is empty.\r\n");
; 001A 01B7     }else if(viReturn == -1){
; 001A 01B8         printDebug("[iMangQueueDelItem]FID invalid.\r\n");
; 001A 01B9     }
; 001A 01BA     return viReturn;
; 001A 01BB }
;
;void iMangQueueDisplay(){
; 001A 01BD void iMangQueueDisplay(){
; 001A 01BE     iInt_t viReturn = -1;
; 001A 01BF     iInt_t i;
; 001A 01C0 
; 001A 01C1     for(i=0;i<MANG_QUEUE_MAX;i++){
;	viReturn -> R16,R17
;	i -> R18,R19
; 001A 01C2         printDebug("[iMangQueueDisplay]Queue %d.[\r\n",i+1);
; 001A 01C3         if(viMangQueue[i].value != NULL){
; 001A 01C4            print_payload(viMangQueue[i].value,viMangQueue[i].length);
; 001A 01C5         }else{
; 001A 01C6            printDebug("Empty\r\n");
; 001A 01C7         }
; 001A 01C8         printDebug("]\r\n");
; 001A 01C9     }
; 001A 01CA }
;
;iChar_t iMangCheckRetransmit(iChar_t *pviFid_arg){
; 001A 01CC iChar_t iMangCheckRetransmit(iChar_t *pviFid_arg){
; 001A 01CD     iInt_t viReturn = -1;
; 001A 01CE     iInt_t i;
; 001A 01CF     iChar_t viFid[2];
; 001A 01D0 
; 001A 01D1     memcpy(viFid,&pviFid_arg[0],2);
;	*pviFid_arg -> Y+6
;	viReturn -> R16,R17
;	i -> R18,R19
;	viFid -> Y+4
; 001A 01D2     for(i=0;i<MANG_QUEUE_MAX;i++){
; 001A 01D3         if(viMangQueue[i].value != NULL){
; 001A 01D4            if(memcmp(viMangQueue[i].fid,&viFid[0],2)==0){
; 001A 01D5                 printDebug("[iMangCheckRetransmit]Retransmit remain %d.\r\n",viMangQueue[i].reTransmit);
; 001A 01D6                 viMangQueue[i].reTransmit--;
; 001A 01D7                 viReturn = viMangQueue[i].reTransmit;
; 001A 01D8                 if(viReturn<0){
; 001A 01D9                    viReturn = 0;
; 001A 01DA                 }
; 001A 01DB                 break;
; 001A 01DC             }else{
; 001A 01DD                 viReturn = -1;
; 001A 01DE             }
; 001A 01DF         }else{
; 001A 01E0            printDebug("There is no FID(%02x%02x) in queue.\r\n",viFid[0],viFid[1]);
; 001A 01E1         }
; 001A 01E2         printDebug("]\r\n");
; 001A 01E3     }
; 001A 01E4     return viReturn;
; 001A 01E5 }
;
;iChar_t mangInitDevice(){
; 001A 01E7 iChar_t mangInitDevice(){
; 001A 01E8 
; 001A 01E9 }
;
;void memcpye(char eeprom *eptr, char *dptr, int len)
; 001A 01EC {
; 001A 01ED    int i=0;
; 001A 01EE    for(i=0;i<len;i++) {
;	*eptr -> Y+6
;	*dptr -> Y+4
;	len -> Y+2
;	i -> R16,R17
; 001A 01EF       *eptr++ = *dptr;
; 001A 01F0       dptr++;
; 001A 01F1    }
; 001A 01F2    return;
; 001A 01F3 }
;
;void memcpyd(char *dptr, char eeprom *eptr,  int len)
; 001A 01F6 {
; 001A 01F7    int i=0;
; 001A 01F8    for(i=0;i<len;i++) {
;	*dptr -> Y+6
;	*eptr -> Y+4
;	len -> Y+2
;	i -> R16,R17
; 001A 01F9       *dptr++ = *eptr;
; 001A 01FA       eptr++;
; 001A 01FB    }
; 001A 01FC    return;
; 001A 01FD }
;
;void printConfig(char eeprom *eptr,unsigned int len)
; 001A 0200 {
; 001A 0201    int i=0,j=0;
; 001A 0202    printDebug("[printConfig]Data:[\r\n");
;	*eptr -> Y+6
;	len -> Y+4
;	i -> R16,R17
;	j -> R18,R19
; 001A 0203    printDebug("%04d\t\t",0);
; 001A 0204    for(i=0,j=1;i<len;i++,j++) {
; 001A 0205       printDebug("%02x",*(eptr++));
; 001A 0206       if(j==8){
; 001A 0207          printDebug("\t\t");
; 001A 0208       }else if(j==16){
; 001A 0209          printDebug("\r\n");
; 001A 020A          printDebug("%04d\t\t",i+1);
; 001A 020B          j=0;
; 001A 020C       }
; 001A 020D    }
; 001A 020E    printDebug("\r\n]\r\n");
; 001A 020F    return;
; 001A 0210 }
;#include "queue.h"
;
;piQueueHandle_t iQueueCreate(const unsigned int iItemQuantity_p,const unsigned int iItemLength_p){
; 001B 0003 piQueueHandle_t iQueueCreate(const unsigned int iItemQuantity_p,const unsigned int iItemLength_p){

	.CSEG
_iQueueCreate:
; 001B 0004 	iQueue_t * pviQueue;
; 001B 0005 
; 001B 0006 	piQueueHandle_t ipvReturnQueueHandle = NULL;
; 001B 0007 	pviQueue = (iQueue_t *)malloc(sizeof(iQueue_t));
	ST   -Y,R27
	ST   -Y,R26
	CALL SUBOPT_0xA
;	iItemQuantity_p -> Y+6
;	iItemLength_p -> Y+4
;	*pviQueue -> R16,R17
;	*ipvReturnQueueHandle -> R18,R19
	LDI  R26,LOW(16)
	LDI  R27,0
	CALL _malloc
	MOVW R16,R30
; 001B 0008     if(pviQueue != NULL){
	MOV  R0,R16
	OR   R0,R17
	BRNE PC+3
	JMP _0x360003
; 001B 0009         pviQueue->head = (void *)malloc((iItemQuantity_p*iItemLength_p));
	CALL SUBOPT_0x6C
	MOVW R26,R30
	CALL _malloc
	__PUTW1RNS 16,8
; 001B 000A         if(pviQueue->head != NULL){
	CALL SUBOPT_0x6D
	SBIW R30,0
	BREQ _0x360004
; 001B 000B             pviQueue->itemCount = 0;  //Empty
	MOVW R26,R16
	ADIW R26,2
	CALL SUBOPT_0x6E
; 001B 000C             pviQueue->writeTo = pviQueue->head;
	CALL SUBOPT_0x6D
	__PUTW1RNS 16,12
; 001B 000D             pviQueue->readDataFrom = pviQueue->head;
	CALL SUBOPT_0x6D
	__PUTW1RNS 16,14
; 001B 000E             pviQueue->tail = pviQueue->head+((iItemQuantity_p*iItemLength_p)-iItemLength_p);
	MOVW R30,R16
	__GETWRZ 22,23,8
	CALL SUBOPT_0x6C
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	SUB  R30,R26
	SBC  R31,R27
	MOVW R26,R22
	CALL SUBOPT_0x6F
	__PUTW1RNS 16,10
; 001B 000F             pviQueue->itemLength = iItemLength_p;  //size of type
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	__PUTW1RNS 16,4
; 001B 0010             pviQueue->itemQuantity = iItemQuantity_p; //Quantity of item
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	MOVW R26,R16
	ST   X+,R30
	ST   X,R31
; 001B 0011             ipvReturnQueueHandle = pviQueue;
	MOVW R18,R16
; 001B 0012             printDebug("[iQueueCreate],itemCount(%d)\r\n",pviQueue->itemCount);
	__POINTD1FN _0x360000,0
	CALL __PUTPARD1
	MOVW R26,R16
	ADIW R26,2
	CALL __GETW1P
	CALL __CWD1
	CALL SUBOPT_0x3
; 001B 0013             //printDebug("[iQueueCreate],itemCount2(%d)\r\n",((iQueue_t *)ipvReturnQueueHandle)->itemCount);
; 001B 0014         }else{
	RJMP _0x360005
_0x360004:
; 001B 0015             ipvReturnQueueHandle = (int *)(-1); //fail malloc
	__GETWRN 18,19,-1
; 001B 0016             printDebug("[iQueueCreate],Queue(Elen size) is not created!.\r\n");
	__POINTD1FN _0x360000,31
	CALL SUBOPT_0x0
; 001B 0017         }
_0x360005:
; 001B 0018     }else{
	RJMP _0x360006
_0x360003:
; 001B 0019        ipvReturnQueueHandle = (int *)(-1); //fail malloc
	__GETWRN 18,19,-1
; 001B 001A        printDebug("[iQueueCreate],Queue is not created!.\r\n");
	__POINTD1FN _0x360000,82
	CALL SUBOPT_0x0
; 001B 001B     }
_0x360006:
; 001B 001C     return ipvReturnQueueHandle;
	MOVW R30,R18
	CALL __LOADLOCR4
	RJMP _0x20E002F
; 001B 001D }
;
;int iQueueSend(piQueueHandle_t const iQueue_p,const void* const piItem_p){
; 001B 001F int iQueueSend(piQueueHandle_t const iQueue_p,const void* const piItem_p){
; 001B 0020     int ivReturn;
; 001B 0021     //int buffTest;
; 001B 0022     //iSTData_t idata;
; 001B 0023     iQueue_t * const piQueue = (iQueue_t *)iQueue_p;
; 001B 0024     //printDebug("[iQueueSend],itemCount(%d)\r\n",((iQueue_t * const)iQueue_p)->itemCount);
; 001B 0025     if(piQueue != NULL){
;	*iQueue_p -> Y+6
;	*piItem_p -> Y+4
;	ivReturn -> R16,R17
;	*piQueue -> R18,R19
; 001B 0026         if(piQueue->itemCount == 0){
; 001B 0027             printDebug("<iQueueSend>status(empty)\r\n");
; 001B 0028             piQueue->writeTo = piQueue->head;
; 001B 0029             piQueue->readDataFrom = piQueue->head;
; 001B 002A 
; 001B 002B             piQueue->itemCount++;
; 001B 002C             memcpy((void*)piQueue->writeTo,piItem_p,piQueue->itemLength);
; 001B 002D 
; 001B 002E 
; 001B 002F             //test read
; 001B 0030 //            memcpy(&buffTest,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 0031 //            printf("<iQueueSend>data = %d\r\n",buffTest);
; 001B 0032 //            memcpy(&idata,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 0033 //            printf("<iQueueSend>data len(%d)\r\n",idata.length);
; 001B 0034 
; 001B 0035             piQueue->writeTo += piQueue->itemLength; //address will write data a next.
; 001B 0036             ivReturn = 1;
; 001B 0037         }else if((piQueue->itemCount > 0) && (piQueue->itemCount < piQueue->itemQuantity) ){
; 001B 0038             piQueue->itemCount++;
; 001B 0039             memcpy((void*)piQueue->writeTo,piItem_p,piQueue->itemLength);
; 001B 003A 
; 001B 003B             //test read
; 001B 003C //            memcpy(&buffTest,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 003D //            printf("<iQueueSend>data = %d\r\n",buffTest);
; 001B 003E //            memcpy(&idata,(void*)piQueue->writeTo,piQueue->itemLength);
; 001B 003F //            printf("<iQueueSend>data len(%d)\r\n",idata.length);
; 001B 0040 
; 001B 0041             piQueue->writeTo += piQueue->itemLength; //address will write data a next.
; 001B 0042             ivReturn = 1;
; 001B 0043         }else if((piQueue->itemCount) < 0 || (piQueue->itemCount > piQueue->itemQuantity)){
; 001B 0044             printDebug("<iQueueSend>status(item count is not range)\r\n)");
; 001B 0045             ivReturn = -1;
; 001B 0046             //while(1); //reset wdt
; 001B 0047         }else if(piQueue->itemCount == piQueue->itemQuantity){
; 001B 0048             piQueue->writeTo = piQueue->head;
; 001B 0049             printDebug("<iQueueSend>status(full and wait)\r\n");
; 001B 004A             ivReturn = -1;
; 001B 004B         }
; 001B 004C         //printf("<iQueueSend>item count(%d)\r\n",piQueue->itemCount);
; 001B 004D     }else{
; 001B 004E         ivReturn = -1; //fail malloc ref = NULL
; 001B 004F     }
; 001B 0050     //printf("<iQueueSend>count(%d)\r\n",piQueue->itemCount);
; 001B 0051     printDebug("<iQueueSend>count(%d)\r\n",piQueue->itemCount);
; 001B 0052     return ivReturn;
; 001B 0053 }
;
;int iQueueReceive(piQueueHandle_t iQueue_p,void* const piItem_p){
; 001B 0055 int iQueueReceive(piQueueHandle_t iQueue_p,void* const piItem_p){
; 001B 0056     int ivReturn;
; 001B 0057     //int buffTest;
; 001B 0058     iQueue_t * const piQueue = (iQueue_t *)iQueue_p;
; 001B 0059 
; 001B 005A     if(piQueue != NULL){
;	*iQueue_p -> Y+6
;	*piItem_p -> Y+4
;	ivReturn -> R16,R17
;	*piQueue -> R18,R19
; 001B 005B         if(piQueue->itemCount == 0){
; 001B 005C             //printf("<iQueueReceive>QueueItem is empty it can not read.\r\n");
; 001B 005D             printDebug("<iQueueReceive>QueueItem is empty it can not read.\r\n");
; 001B 005E             ivReturn = -1;
; 001B 005F         }else if(piQueue->itemCount > 0){
; 001B 0060             //printf("<iQueueReceive>QueueItem is exist.\r\n");
; 001B 0061             printDebug("<iQueueReceive>QueueItem is exist.\r\n");
; 001B 0062             if(piQueue->readDataFrom < piQueue->tail){
; 001B 0063 
; 001B 0064                 piQueue->itemCount--;
; 001B 0065                 memcpy(piItem_p,(void*)piQueue->readDataFrom,piQueue->itemLength);
; 001B 0066                 //memcpy((void*)piQueue->writeTo,piItem_p,piQueue->itemLength);
; 001B 0067 
; 001B 0068 //                memcpy(&buffTest,(void*)piQueue->readDataFrom,piQueue->itemLength);
; 001B 0069 //                printf("<iQueueReceive>data = %d\r\n",buffTest);
; 001B 006A 
; 001B 006B                 piQueue->readDataFrom += piQueue->itemLength;
; 001B 006C                 ivReturn = 1;
; 001B 006D             }else if(piQueue->readDataFrom == piQueue->tail){
; 001B 006E                 piQueue->itemCount--;
; 001B 006F                 piQueue->readDataFrom = piQueue->head;
; 001B 0070             }
; 001B 0071         }
; 001B 0072     }else{
; 001B 0073         ivReturn = -1; //fail malloc ref = NULL
; 001B 0074     }
; 001B 0075     //printf("<iQueueReceive>count(%d)\r\n",piQueue->itemCount);
; 001B 0076     printDebug("<iQueueReceive>count(%d)\r\n",piQueue->itemCount);
; 001B 0077     return ivReturn;
; 001B 0078 }
;#include "transmitInitial.h"
;
;
;#include "schedulerTask.h"
;
;int task_count_g = 0;
;
;iTask_t *pviTaskList[MAX_TASK];
;
;itaskHandel_t iTaskCreate(piTaskFunction piTaskCode_p,const char * const name_p,uint_t priority_p){
; 001D 0007 itaskHandel_t iTaskCreate(piTaskFunction piTaskCode_p,const char * const name_p,uint_t priority_p){

	.CSEG
_iTaskCreate:
; 001D 0008     itaskHandel_t pvTaskHandleReturn;
; 001D 0009     iTask_t *pviTaskNew;
; 001D 000A     void * vp;
; 001D 000B     int i = 0;
; 001D 000C     vp = &i;
	ST   -Y,R27
	ST   -Y,R26
	CALL SUBOPT_0x70
;	*piTaskCode_p -> Y+12
;	*name_p -> Y+10
;	priority_p -> Y+8
;	*pvTaskHandleReturn -> R16,R17
;	*pviTaskNew -> R18,R19
;	*vp -> R20,R21
;	i -> Y+6
	MOVW R30,R28
	ADIW R30,6
	MOVW R20,R30
; 001D 000D 
; 001D 000E     if(task_count_g < MAX_TASK){
	LDS  R26,_task_count_g
	LDS  R27,_task_count_g+1
	SBIW R26,6
	BRLT PC+3
	JMP _0x3A0003
; 001D 000F         pviTaskNew = (iTask_t *)malloc(sizeof(iTask_t));
	LDI  R26,LOW(24)
	LDI  R27,0
	CALL _malloc
	MOVW R18,R30
; 001D 0010         if(pviTaskNew != NULL){
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x3A0004
; 001D 0011             printDebug("<iTaskCreate>Task can create.\r\n");
	__POINTD1FN _0x3A0000,0
	CALL SUBOPT_0x0
; 001D 0012             pviTaskNew->id = 0;
	MOVW R26,R18
	CALL SUBOPT_0x6E
; 001D 0013             pviTaskNew->hookFunction = piTaskCode_p;
	CALL SUBOPT_0x71
	__PUTD1RNS 18,2
; 001D 0014             memcpy(pviTaskNew->name,name_p,MAX_TASK_NAME);
	MOVW R30,R18
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x4E
	LDI  R26,LOW(16)
	CALL SUBOPT_0x72
; 001D 0015             pviTaskNew->priority = priority_p;
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	__PUTW1RNS 18,22
; 001D 0016 
; 001D 0017             pviTaskList[task_count_g] = pviTaskNew;
	CALL SUBOPT_0x73
	LDI  R26,LOW(_pviTaskList)
	LDI  R27,HIGH(_pviTaskList)
	CALL SUBOPT_0x6F
	ST   Z,R18
	STD  Z+1,R19
; 001D 0018             task_count_g++;
	LDI  R26,LOW(_task_count_g)
	LDI  R27,HIGH(_task_count_g)
	CALL SUBOPT_0xE
; 001D 0019 
; 001D 001A         }else{
	RJMP _0x3A0005
_0x3A0004:
; 001D 001B             printDebug("<iTaskCreate>Task can not create.\r\n");
	__POINTD1FN _0x3A0000,32
	CALL SUBOPT_0x0
; 001D 001C             pvTaskHandleReturn = (int *)(-1);
	__GETWRN 16,17,-1
; 001D 001D         }
_0x3A0005:
; 001D 001E     }else if(task_count_g == MAX_TASK){
	RJMP _0x3A0006
_0x3A0003:
	LDS  R26,_task_count_g
	LDS  R27,_task_count_g+1
	SBIW R26,6
	BRNE _0x3A0007
; 001D 001F         pvTaskHandleReturn = (void *)(-1);
	__GETWRN 16,17,-1
; 001D 0020     }
; 001D 0021 
; 001D 0022 
; 001D 0023 //    if(task_count_g == 0){
; 001D 0024 //        piTaskList_p->taskValue = pviTaskNew;
; 001D 0025 //        piTaskList_p->next = NULL;
; 001D 0026 //        task_count_g ++;
; 001D 0027 //        piTaskList_p->taskValue->hookFunction(vp);
; 001D 0028 //    }else if(task_count_g > 0){
; 001D 0029 ////        piTaskList_p->taskValue = pviTaskNew;
; 001D 002A ////        piTaskList_p->next = NULL;
; 001D 002B ////        task_count_g ++;
; 001D 002C //    }
; 001D 002D     //pviTaskNew->hookFunction(vp);
; 001D 002E     //piTaskCode_p(vp);
; 001D 002F     //free(pviTaskNew);
; 001D 0030     return pvTaskHandleReturn;
_0x3A0007:
_0x3A0006:
	MOVW R30,R16
	CALL __LOADLOCR6
	ADIW R28,16
	RET
; 001D 0031 }
;
;void startSchedulerTask(){
; 001D 0033 void startSchedulerTask(){
_startSchedulerTask:
; 001D 0034     itaskHandel_t pvTaskRunHandle;
; 001D 0035     void * vp;       //parameter
; 001D 0036     int i=0;
; 001D 0037     int j=0;
; 001D 0038     //pvTaskRunHandle = iTaskCreate(task_a_print,"TaskAP",5);
; 001D 0039     for(;;){
	CALL SUBOPT_0x70
;	*pvTaskRunHandle -> R16,R17
;	*vp -> R18,R19
;	i -> R20,R21
;	j -> Y+6
	__GETWRN 20,21,0
_0x3A0009:
; 001D 003A         #asm("wdr")
	wdr
; 001D 003B         for(i=0;i<task_count_g;i++){
	__GETWRN 20,21,0
_0x3A000C:
	CALL SUBOPT_0x73
	CP   R20,R30
	CPC  R21,R31
	BRLT PC+3
	JMP _0x3A000D
; 001D 003C             for(j=0;j<task_count_g;j++){
	LDI  R30,LOW(0)
	STD  Y+6,R30
	STD  Y+6+1,R30
_0x3A000F:
	CALL SUBOPT_0x73
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R30
	CPC  R27,R31
	BRGE _0x3A0010
; 001D 003D                 if(pviTaskList[j]->priority == 10){
	CALL SUBOPT_0x74
	ADIW R30,22
	MOVW R26,R30
	CALL __GETW1P
	CPI  R30,LOW(0xA)
	LDI  R26,HIGH(0xA)
	CPC  R31,R26
	BRNE _0x3A0011
; 001D 003E                     pviTaskList[j]->hookFunction(vp);
	CALL SUBOPT_0x74
	ADIW R30,2
	MOVW R26,R30
	CALL __GETD1P
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R18
	POP  R30
	POP  R31
	POP  R22
	POP  R23
	OUT  EIND,R22
	EICALL
; 001D 003F                 }
; 001D 0040             }
_0x3A0011:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	RJMP _0x3A000F
_0x3A0010:
; 001D 0041             pviTaskList[i]->hookFunction(vp);
	MOVW R30,R20
	LDI  R26,LOW(_pviTaskList)
	LDI  R27,HIGH(_pviTaskList)
	CALL SUBOPT_0x75
	ADIW R30,2
	MOVW R26,R30
	CALL __GETD1P
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R18
	POP  R30
	POP  R31
	POP  R22
	POP  R23
	OUT  EIND,R22
	EICALL
; 001D 0042         }
	__ADDWRN 20,21,1
	RJMP _0x3A000C
_0x3A000D:
; 001D 0043     }
	RJMP _0x3A0009
; 001D 0044 //    for(i=0;i<task_count_g;i++){
; 001D 0045 //        pviTaskList[i]->hookFunction(vp);
; 001D 0046 //    }
; 001D 0047 }
_0x20E002F:
	ADIW R28,8
	RET
;#include <delay.h>
;#include "sensorTask.h"
;#include "sensorManager.h"
;#include "statusManager.h"
;#include "sensor.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "dht11.h"
;
;unsigned int viSwitchContextSensor;
;
;extern piQueueHandle_t pviQueueTaskAToTaskB;
;
;extern piQueueHandle_t pviQueueSensorToMang;
;extern piQueueHandle_t pviQueueMangToSensor;
;
;extern iDataMini_t viDataReport;
;extern iDataMini_t viStatusReport;
;
;iSensorData_t pviSensorData;
;
;//void task_a(void *pviParameter){
;//    pTaskHandle pviReturn;
;//    char buffferQueue[10] = "bongkot";
;//    char buffferQueue2[10] = "chaiwaree";
;//    iData_t data;
;//
;//    memcpy(data.value,buffferQueue,sizeof(buffferQueue));
;//    data.length = sizeof(buffferQueue);
;//
;//    if(iQueueSend(pviQueueTaskAToTaskB,&data)==1){
;//        printDebug("<main>pviQueueTaskAToTaskB can sent a data.\r\n");
;//    }else{
;//        printDebug("<main>data can not sent a data(a) to pviQueueData1.\r\n");
;//    }
;//
;//    memcpy(data.value,buffferQueue2,sizeof(buffferQueue));
;//    data.length = sizeof(buffferQueue2);
;//
;//    if(iQueueSend(pviQueueTaskAToTaskB,&data)==1){
;//        iQueueReadMyself(pviQueueTaskAToTaskB);
;//        printDebug("<main>pviQueueTaskAToTaskB can sent a data.\r\n");
;//    }else{
;//        printDebug("<main>data can not sent a data(a) to pviQueueData1.\r\n");
;//    }
;//}
;void sensorTask(void *pviParameter){
; 001E 002D void sensorTask(void *pviParameter){

	.CSEG
_sensorTask:
; 001E 002E     printDebug("<sensorTask>Task Running...\r\n");
	ST   -Y,R27
	ST   -Y,R26
;	*pviParameter -> Y+0
	__POINTD1FN _0x3C0000,0
	CALL SUBOPT_0x0
; 001E 002F 
; 001E 0030 //    swContextSensor();
; 001E 0031 //    swContextSensor();
; 001E 0032 
; 001E 0033     //printDebug("[sensorTask],Queue->Quantity(%d).\r\n",((iQueue_t *)pviQueueSensorToMang)->itemCount);
; 001E 0034 //    if(iQueueSend(pviQueueSensorToMang,&pviSensorData)==1){
; 001E 0035 //        printDebug("<sensorTask>pviQueueSensorToMang can sent a data.\r\n");
; 001E 0036 //    }else{
; 001E 0037 //        printDebug("<sensorTask>data can not sent a data to pviQueueSensorToMang.\r\n");
; 001E 0038 //    }
; 001E 0039 
; 001E 003A     iSensorRead(&viDataReport);
	LDI  R26,LOW(_viDataReport)
	LDI  R27,HIGH(_viDataReport)
	CALL _iSensorRead
; 001E 003B     iStatusRead(&viStatusReport);
	LDI  R26,LOW(_viStatusReport)
	LDI  R27,HIGH(_viStatusReport)
	CALL _iStatusRead
; 001E 003C     delay_ms(1000);
	CALL SUBOPT_0x5F
; 001E 003D }
	JMP  _0x20E002B
;
;void swContextSensor(){
; 001E 003F void swContextSensor(){
; 001E 0040      unsigned int i;
; 001E 0041      ST_DHT11 *dhtDevice;
; 001E 0042      int viReturn;
; 001E 0043      //pviSensorData_t  pviSensorData;
; 001E 0044      #asm("wdr")
;	i -> R16,R17
;	*dhtDevice -> R18,R19
;	viReturn -> R20,R21
; 001E 0045      if(viSwitchContextSensor == SENSER_MAX_TYPE){
; 001E 0046           viSwitchContextSensor = 0;
; 001E 0047      }
; 001E 0048      switch(viSwitchContextSensor){
; 001E 0049          case SENSOR_ADC:{
; 001E 004A             for(i=0;i<SENSER_ADC_MAX_SIZE;i++){
; 001E 004B                 //printDebug("ACD[%d] : %d\r\n",(i+1),read_adc(8+i));
; 001E 004C                 pviSensorData.adc[i] =  read_adc(8+i);
; 001E 004D             }
; 001E 004E             break;
; 001E 004F          }
; 001E 0050          case SENSOR_DIGI:{
; 001E 0051             delay_ms(300);
; 001E 0052             viReturn =DHT11Read(dhtDevice);
; 001E 0053             if(viReturn==DHT11_SUCCESS){
; 001E 0054                //printDebug("DHT11 Temp-c(%f), Humidity(%f)\r\n",dhtDevice->temp,dhtDevice->humi);
; 001E 0055                pviSensorData.dht11Temp = dhtDevice->temp;
; 001E 0056                pviSensorData.dht11Humi = dhtDevice->humi;
; 001E 0057             }else if(viReturn==DHT11_ERROR_CHECKSUM){
; 001E 0058                printDebug("DHT11 errer(check sum).\r\n");
; 001E 0059             }else if(viReturn==DHT11_ERROR_TIMEOUT){
; 001E 005A                printDebug("DHT11 errer(time out).\r\n");
; 001E 005B             }
; 001E 005C             break;
; 001E 005D          }
; 001E 005E          default:{
; 001E 005F             break;
; 001E 0060          }
; 001E 0061      }
; 001E 0062      ++ viSwitchContextSensor;
; 001E 0063 }
;#include "debugTask.h"
;
;
;void debugTask(void * pviParameter){
; 001F 0004 void debugTask(void * pviParameter){

	.CSEG
; 001F 0005     printDebug("<debugTask>Task Running...\r\n");
;	*pviParameter -> Y+0
; 001F 0006 }
;#include <delay.h>
;#include "communicateTask.h"
;#include "interruptTask.h"
;#include "wiz100rs.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;
;
;void communicateTask(void * pviParameter){
; 0020 0007 void communicateTask(void * pviParameter){

	.CSEG
; 0020 0008     printDebug("<communicateTask>Task Running...\r\n");
;	*pviParameter -> Y+0
; 0020 0009 //
; 0020 000A //    if(pviUart0TimeOut == 0){
; 0020 000B //        pviUart0TimeOut   = 1;
; 0020 000C //    }
; 0020 000D     //delay_ms(1000);
; 0020 000E     iWizGetConf();
; 0020 000F 
; 0020 0010 }
;#include "lan.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "timer.h"
;#include "io.h"
;#include "debug.h"
;
;extern iData_t viRXData;
;extern iData_t viTXData;
;
;
;char AckHostData[20] = {
;    0x7E,
;    0x00,0x10,
;    0x08,0x00,
;    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
;    0x64,0x75,0xC9,0x55,
;    0x00,0x00,
;    0xD8
;};

	.DSEG
;
;iUChar_t iLanReadData(iData_t * pviData_agr){
; 0021 0014 iUChar_t iLanReadData(iData_t * pviData_agr){

	.CSEG
; 0021 0015     iUChar_t viReturn;
; 0021 0016     TIMER   timeout;
; 0021 0017     iUChar_t viModeConnect = 0;     //0= no check connect  ,1 == check connect
; 0021 0018 
; 0021 0019    viReturn = LEN_DATA_EMPTY;
;	*pviData_agr -> Y+6
;	viReturn -> R17
;	timeout -> Y+2
;	viModeConnect -> R16
; 0021 001A    TIMER_setTimer(&timeout, 7);
; 0021 001B 
; 0021 001C    iWizRXMode = WIZ_RX_DATA_MODE;
; 0021 001D   // delay_ms(1000);
; 0021 001E    while(!TIMER_checkTimerExceed(timeout)){
; 0021 001F       delay_ms(50);
; 0021 0020       #asm("wdr")
; 0021 0021       if(iWizRead()){
; 0021 0022         printDebug("[iLanReadData]iWizRead:OK.\r\n");
; 0021 0023         viReturn = LEN_DATA_AVAILABLE;
; 0021 0024         if(viRXData.length>0){
; 0021 0025             pviData_agr->length = viRXData.length;
; 0021 0026             memcpy(&pviData_agr->value[0],&viRXData.value[0],viRXData.length);
; 0021 0027             printDebug("[iLanReadData]Data:OK[\r\n");
; 0021 0028             print_payload(&viRXData.value[0], viRXData.length);
; 0021 0029             printDebug("]\r\n");
; 0021 002A         }else{
; 0021 002B 
; 0021 002C         }
; 0021 002D         break;
; 0021 002E       }else{
; 0021 002F         printDebug("[iLanReadData]iWizRead:empty.\r\n");
; 0021 0030         viReturn = LEN_DATA_EMPTY;
; 0021 0031       }
; 0021 0032    }
; 0021 0033     return viReturn;
; 0021 0034 }
;
;//iUChar_t iLanWriteData(){
;//    iUChar_t viReturn;
;//    TIMER   timeout;
;//
;//    iWizRXMode = WIZ_RX_STAT_MODE;
;//    viReturn = LEN_DATA_WRITE_FAIL;
;//    TIMER_setTimer(&timeout, 20);
;//
;//    while(!TIMER_checkTimerExceed(timeout)){
;//       delay_ms(50);
;//       #asm("wdr")
;//       if(iWizConnected()){
;//            printDebug("[iLanWriteData]Status:Connected.\r\n");
;//            iWizRXMode = WIZ_RX_DATA_MODE;
;//            iWizSend(viGenDataElem,sizeof(viGenDataElem));
;//            viReturn = LEN_DATA_WRITE_SUCCESS;
;//            break;
;//       } else{
;//            viReturn = LEN_DATA_WRITE_FAIL;
;//            printDebug("[iLanWriteData]Status:Close.\r\n");
;//       }
;//    }
;//    return viReturn;
;//}
;
;iUChar_t iLanWriteData(iData_t * pviData_agr){
; 0021 004F iUChar_t iLanWriteData(iData_t * pviData_agr){
; 0021 0050     iUChar_t viReturn;
; 0021 0051     TIMER   timeout;
; 0021 0052     iUChar_t viModeConnect = 0;     //0= no check connect  ,1 == check connect
; 0021 0053 
; 0021 0054     iWizRXMode = WIZ_RX_STAT_MODE;
;	*pviData_agr -> Y+6
;	viReturn -> R17
;	timeout -> Y+2
;	viModeConnect -> R16
; 0021 0055     viReturn = LEN_DATA_WRITE_FAIL;
; 0021 0056     //TIMER_setTimer(&timeout, 20);
; 0021 0057 
; 0021 0058 //       if(iWizConnected()){
; 0021 0059 //            printDebug("[iLanWriteData]Status:Connected.\r\n");
; 0021 005A //            iWizRXMode = WIZ_RX_DATA_MODE;
; 0021 005B //            iWizSend(pviData_agr->value,pviData_agr->length);
; 0021 005C //            iWizRXMode = WIZ_RX_DATA_MODE;
; 0021 005D //            viReturn = LEN_DATA_WRITE_SUCCESS;
; 0021 005E //       } else{
; 0021 005F //            viReturn = LEN_DATA_WRITE_FAIL;
; 0021 0060 //            printDebug("[iLanWriteData]Status:Close.\r\n");
; 0021 0061 //       }
; 0021 0062 
; 0021 0063        if(viModeConnect==0){
; 0021 0064            iWizRXMode = WIZ_RX_DATA_MODE;
; 0021 0065            iWizSend(pviData_agr->value,pviData_agr->length);
; 0021 0066            viReturn = LEN_DATA_WRITE_SUCCESS;
; 0021 0067        }
; 0021 0068 
; 0021 0069 
; 0021 006A     return viReturn;
; 0021 006B }
;
;iChar_t iLanInit(){
; 0021 006D iChar_t iLanInit(){
_iLanInit:
; 0021 006E        iChar_t viReturn;
; 0021 006F 
; 0021 0070        iWizRXMode = WIZ_RX_STAT_MODE;
	ST   -Y,R17
;	viReturn -> R17
	LDI  R30,LOW(1)
	STS  _iWizRXMode,R30
; 0021 0071        if(iWizConnected()){
	RCALL _iWizConnected
	SBIW R30,0
	BREQ _0x42000C
; 0021 0072             printDebug("[iLanInit]Status:Connected.\r\n");
	__POINTD1FN _0x420000,90
	CALL SUBOPT_0x0
; 0021 0073             iWizRXMode = WIZ_RX_DATA_MODE;
	LDI  R30,LOW(2)
	STS  _iWizRXMode,R30
; 0021 0074             viReturn = LEN_DATA_WRITE_SUCCESS;
	LDI  R17,LOW(1)
; 0021 0075        } else{
	RJMP _0x42000D
_0x42000C:
; 0021 0076             viReturn = LEN_DATA_WRITE_FAIL;
	LDI  R17,LOW(0)
; 0021 0077             printDebug("[iLanInit]Status:Close.\r\n");
	__POINTD1FN _0x420000,120
	CALL SUBOPT_0x0
; 0021 0078        }
_0x42000D:
; 0021 0079        return viReturn;
	MOV  R30,R17
_0x20E002E:
	LD   R17,Y+
	RET
; 0021 007A }
;#include <delay.h>
;#include "interruptTask.h"
;#include "wiz100rs.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "uart.h"
;#include "debug.h"
;#include "ethcomm.h"
;#include "io.h"
;#include "timer.h"
;
;int flagConnect = 0;
;
;iWiz100srConfig_t iWiz100srConfig;
;//char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nUser-Agent: AVR2560-LAN\r\nConnection: close\r\nContent-Length: ";
;char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nX-CLIENT-UUID: 001100110011\r\nUser-Agent: AVR2560-LAN\r\nConnection: close\r\nContent-Length: ";

	.DSEG
;
;
;//iWiz100srData_t iWiz100srData;
;
;void (*pfiWiz100rs)(void);
;int (*piWizCallBack)(char *,unsigned int);
;
;extern unsigned int rxBeginCount;
;extern piInterrupt_t pviUart0TimeOut;
;extern char rx0Buffer[];
;extern unsigned int index0Buffer;
;//char *pviValue;
;//char pviValue[RX_BUFFER_SIZE0];
;unsigned char iWizStatus = 0;
;unsigned char iWizRXMode = 0;
;//iWiz100srConnection iWizStatus;
;iWiz100srConnection iWizData;
;iHTTP_t iHTTPStatus;
;
;//iWizStatus.status = 0;
;
;void iWizGetConf(){
; 0022 0024 void iWizGetConf(){

	.CSEG
; 0022 0025     int i;
; 0022 0026     char    readCmd[] = ">R\r";
; 0022 0027     WIZ100RS_CONF_MODE;        //change to configure mode
;	i -> R16,R17
;	readCmd -> Y+2
; 0022 0028 
; 0022 0029 
; 0022 002A     ETH_CONF;
; 0022 002B 
; 0022 002C     //module off then on
; 0022 002D     WIZ100RS_OFF;
; 0022 002E     delay_ms(10);
; 0022 002F     WIZ100RS_ON;
; 0022 0030     delay_ms(1000);
; 0022 0031 
; 0022 0032     for(i=0;i<strlen(readCmd);i++){
; 0022 0033         putchar0(readCmd[i]);
; 0022 0034     }
; 0022 0035 }
;void iWizSetConf(){}
; 0022 0036 void iWizSetConf(){}
;
;
;void iWizTXdata(){}
; 0022 0039 void iWizTXdata(){}
;
;
;void iWizRXTimeOut(){
; 0022 003C void iWizRXTimeOut(){
; 0022 003D      rxBeginCount = 0;
; 0022 003E      pviUart0TimeOut = -1;
; 0022 003F      wiz100srSetTimer = -1;
; 0022 0040      printDebug("<iWizRXTimeOut>\r\n");
; 0022 0041 }
;
;int iWizCBCheckHTTPResCode(char *const data_p,unsigned int const len_p){
; 0022 0043 int iWizCBCheckHTTPResCode(char *const data_p,unsigned int const len_p){
; 0022 0044      char *iWizCheckHTTPResCode;
; 0022 0045      int i;
; 0022 0046      char * pch;
; 0022 0047      int iReturn = 0;
; 0022 0048      iWizCheckHTTPResCode = (char *)malloc(len_p);
;	*data_p -> Y+10
;	len_p -> Y+8
;	*iWizCheckHTTPResCode -> R16,R17
;	i -> R18,R19
;	*pch -> R20,R21
;	iReturn -> Y+6
; 0022 0049      if(iWizCheckHTTPResCode != NULL){
; 0022 004A         memcpy(&iWizCheckHTTPResCode[0],&data_p[0],len_p);
; 0022 004B         pch = strtok (iWizCheckHTTPResCode," ");
; 0022 004C         while(pch != NULL){
; 0022 004D             //printDebug("%s\r\n",pch);
; 0022 004E             if (strncmp (pch,"200",3) == 0)
; 0022 004F             {
; 0022 0050                 printDebug("[Res code: %s]\r\n",pch);
; 0022 0051                 iReturn = 1;
; 0022 0052                 break;
; 0022 0053             }
; 0022 0054             pch = strtok (NULL, " ");
; 0022 0055         }
; 0022 0056      }
; 0022 0057      free(iWizCheckHTTPResCode);
; 0022 0058      return iReturn;
; 0022 0059 }

	.DSEG
_0x44000C:
	.BYTE 0x4
;int iWizCBCheckHTTPContextLen(char *const data_p,unsigned int const len_p){
; 0022 005A int iWizCBCheckHTTPContextLen(char *const data_p,unsigned int const len_p){

	.CSEG
; 0022 005B      char *iWizCheckHTTPContextLen;
; 0022 005C      int i;
; 0022 005D      char * pch;
; 0022 005E      int iReturn = 0;
; 0022 005F      iWizCheckHTTPContextLen = (char *)malloc(len_p);
;	*data_p -> Y+10
;	len_p -> Y+8
;	*iWizCheckHTTPContextLen -> R16,R17
;	i -> R18,R19
;	*pch -> R20,R21
;	iReturn -> Y+6
; 0022 0060      if(iWizCheckHTTPContextLen != NULL){
; 0022 0061         memcpy(&iWizCheckHTTPContextLen[0],&data_p[0],len_p);
; 0022 0062         pch = strtok (iWizCheckHTTPContextLen," ");
; 0022 0063         while(pch != NULL){
; 0022 0064             if (strncmp (pch,"Content-Length",14) == 0)
; 0022 0065             {
; 0022 0066                 pch = strtok (NULL, " ");
; 0022 0067                 if(pch != NULL){
; 0022 0068                     //if (strncmp (pch,"Content-Length",14) == 0){
; 0022 0069                         printDebug("[Res len: %s]\r\n",pch);
; 0022 006A                         //iReturn = atoi(pch);
; 0022 006B                         iHTTPStatus.contentLength = atoi(pch);
; 0022 006C                         iReturn = 1;
; 0022 006D                         printDebug("[Res len: %d]\r\n",iReturn);
; 0022 006E                     //    if(iReturn <= 0){
; 0022 006F                     //         iReturn = WIZ_HTTP_CONTEXT_LEN_LESS;         //< 0
; 0022 0070                     //    }else if(iReturn > 400){
; 0022 0071                     //        iReturn = WIZ_HTTP_CONTEXT_LEN_OVER;          // > 400
; 0022 0072                     //    }
; 0022 0073                         break;
; 0022 0074                     //}
; 0022 0075                 }
; 0022 0076             }else{
; 0022 0077                 printDebug("[Notfound Res len]\r\n");
; 0022 0078                 break;
; 0022 0079             }
; 0022 007A             //pch = strtok (NULL, " ");
; 0022 007B         }
; 0022 007C      }else{
; 0022 007D         printDebug("[wizContentLen]can 't allocate mem.\r\n");
; 0022 007E      }
; 0022 007F      free(iWizCheckHTTPContextLen);
; 0022 0080      return iReturn;
; 0022 0081 }

	.DSEG
_0x440012:
	.BYTE 0xF
;
;int iWizCBChekStat(char *const data_p,unsigned int const len_p){
; 0022 0083 int iWizCBChekStat(char *const data_p,unsigned int const len_p){

	.CSEG
; 0022 0084      char *iWizCheckStat;
; 0022 0085      int i;
; 0022 0086      iWizCheckStat = (char *)malloc(len_p);
;	*data_p -> Y+6
;	len_p -> Y+4
;	*iWizCheckStat -> R16,R17
;	i -> R18,R19
; 0022 0087      if(iWizCheckStat != NULL){
; 0022 0088          memcpy(&iWizCheckStat[0],&data_p[0],len_p);
; 0022 0089          //printDebug("stat[%d](%s)\r\n",len_p,iWizCheckStat);
; 0022 008A //         printDebug("status[%d][",len_p);
; 0022 008B //         for(i=0;i<len_p;i++){
; 0022 008C //            printDebug("%c",*(iWizCheckStat++));
; 0022 008D //         }
; 0022 008E //         printDebug("]\r\n");
; 0022 008F          iWizData.status = WIZ_UNKNOW;
; 0022 0090          if (strncmp (iWizCheckStat,"> Connected",11) == 0)
; 0022 0091          {
; 0022 0092             iWizData.status = WIZ_CONNECTED;
; 0022 0093          }else if(strncmp (iWizCheckStat,"> Closed",8) == 0){
; 0022 0094             iWizData.status = WIZ_CLOSE;
; 0022 0095          }else{
; 0022 0096             iWizData.status = WIZ_UNKNOW;
; 0022 0097          }
; 0022 0098      }else{
; 0022 0099         printDebug("[wizStat]can 't allocate mem.\r\n");
; 0022 009A      }
; 0022 009B      free(iWizCheckStat);
; 0022 009C      return 0;
; 0022 009D }

	.DSEG
_0x440018:
	.BYTE 0x15
;int iWizCBReadData(char *const data_p,unsigned int const len_p){
; 0022 009E int iWizCBReadData(char *const data_p,unsigned int const len_p){

	.CSEG
; 0022 009F      char *iWizReadData;
; 0022 00A0      int i;
; 0022 00A1      iWizReadData = (char *)malloc(len_p);
;	*data_p -> Y+6
;	len_p -> Y+4
;	*iWizReadData -> R16,R17
;	i -> R18,R19
; 0022 00A2      if(iWizReadData != NULL){
; 0022 00A3          memcpy(&iWizReadData[0],&data_p[0],len_p);
; 0022 00A4          //printDebug("stat[%d](%s)\r\n",len_p,iWizCheckStat);
; 0022 00A5 //         printDebug("status[%d][",len_p);
; 0022 00A6 //         for(i=0;i<len_p;i++){
; 0022 00A7 //            printDebug("%c",*(iWizCheckStat++));
; 0022 00A8 //         }
; 0022 00A9 //         printDebug("]\r\n");
; 0022 00AA          //iWizData.status = WIZ_UNKNOW;
; 0022 00AB //         if (strncmp (iWizReadData,"> Connected",11) == 0)
; 0022 00AC //         {
; 0022 00AD //            iWizData.status = WIZ_CONNECTED;
; 0022 00AE //         }else if(strncmp (iWizReadData,"> Closed",8) == 0){
; 0022 00AF //            iWizData.status = WIZ_CLOSE;
; 0022 00B0 //         }else{
; 0022 00B1 //            iWizData.status = WIZ_UNKNOW;
; 0022 00B2 //         }
; 0022 00B3      }else{
; 0022 00B4         printDebug("[wizStat]can 't allocate mem.\r\n");
; 0022 00B5      }
; 0022 00B6      free(iWizReadData);
; 0022 00B7      return 0;
; 0022 00B8 }
;
;void iWizSend(const char * data_p,int len_p){
; 0022 00BA void iWizSend(const char * data_p,int len_p){
; 0022 00BB      //char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nUser-Agent: IMS_Test\r\nConnection: close\r\nContent-Length: ";
; 0022 00BC      //char httpPostHeader[] = "POST /smasmartdevice HTTP/1.1\r\nHost: smasmartdevice.appspot.com\r\nUser-Agent: AVR2560-LAN\r\nConnection: close\r\nContent-Length: ";
; 0022 00BD      char *pviWizBuff;
; 0022 00BE      char lenData[10];
; 0022 00BF      int indexWrite = 0;
; 0022 00C0      char ivHTTPHeaderMethod[] = "POST /smasmartdevice HTTP/1.1";               //29
; 0022 00C1      char ivHTTPHeaderHost[]  = "\r\nHost: smasmartdevice.appspot.com";    //34
; 0022 00C2      char ivHTTPHeaderMac[]   = "\r\nX-CLIENT-UUID: ";                     //18
; 0022 00C3      //char ivHTTPHeaderUser[]  = "\r\nUser-Agent: AVR2560-LAN";             //23
; 0022 00C4      char ivHTTPHeaderConn[]  = "\r\nConnection: close";                   //17
; 0022 00C5      char ivHTTPHeaderLen[]   = "\r\nContent-Length: ";                    //16
; 0022 00C6 
; 0022 00C7      //char
; 0022 00C8 
; 0022 00C9 //     printDebug("[wizSend]Print-1.[\r\n");
; 0022 00CA //     print_payload(data_p, len_p);
; 0022 00CB //     printDebug("]\r\n");
; 0022 00CC 
; 0022 00CD      pviWizBuff = (char *)malloc(400);              //4(length unknow) = xx\r\n
;	*data_p -> Y+138
;	len_p -> Y+136
;	*pviWizBuff -> R16,R17
;	lenData -> Y+126
;	indexWrite -> R18,R19
;	ivHTTPHeaderMethod -> Y+96
;	ivHTTPHeaderHost -> Y+61
;	ivHTTPHeaderMac -> Y+43
;	ivHTTPHeaderConn -> Y+23
;	ivHTTPHeaderLen -> Y+4
; 0022 00CE //     printDebug("[wizSend]Print-2.[\r\n");
; 0022 00CF //     print_payload(data_p, len_p);
; 0022 00D0 //     printDebug("]\r\n");
; 0022 00D1 
; 0022 00D2      if(pviWizBuff != NULL){
; 0022 00D3         sprintf(lenData,"%d\r\n\r\n",len_p);
; 0022 00D4 
; 0022 00D5 //        memcpy(&pviWizBuff[indexWrite],&httpPostHeader[0],strlen(httpPostHeader));
; 0022 00D6 //        indexWrite += strlen(httpPostHeader);
; 0022 00D7 //        memcpy(&pviWizBuff[indexWrite],&lenData[0],strlen(lenData));
; 0022 00D8 //        indexWrite += strlen(lenData);
; 0022 00D9 //        memcpy(&pviWizBuff[indexWrite],&data_p[0],len_p);
; 0022 00DA //        indexWrite += len_p;
; 0022 00DB         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderMethod[0],strlen(ivHTTPHeaderMethod));
; 0022 00DC         indexWrite += strlen(ivHTTPHeaderMethod);
; 0022 00DD 
; 0022 00DE         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderHost[0],strlen(ivHTTPHeaderHost));
; 0022 00DF         indexWrite += strlen(ivHTTPHeaderHost);
; 0022 00E0 
; 0022 00E1         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderMac[0],strlen(ivHTTPHeaderMac));
; 0022 00E2         indexWrite += strlen(ivHTTPHeaderMac);
; 0022 00E3         memcpy(&pviWizBuff[indexWrite],&iWiz100srConfig.macAddress[0],sizeof(iWiz100srConfig.macAddress));
; 0022 00E4         indexWrite += sizeof(iWiz100srConfig.macAddress);
; 0022 00E5 
; 0022 00E6 //        memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderUser[0],strlen(ivHTTPHeaderUser));
; 0022 00E7 //        indexWrite += strlen(ivHTTPHeaderUser);
; 0022 00E8 
; 0022 00E9         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderConn[0],strlen(ivHTTPHeaderConn));
; 0022 00EA         indexWrite += strlen(ivHTTPHeaderConn);
; 0022 00EB 
; 0022 00EC         memcpy(&pviWizBuff[indexWrite],&ivHTTPHeaderLen[0],strlen(ivHTTPHeaderLen));
; 0022 00ED         indexWrite += strlen(ivHTTPHeaderLen);
; 0022 00EE         memcpy(&pviWizBuff[indexWrite],&lenData[0],strlen(lenData));
; 0022 00EF         indexWrite += strlen(lenData);
; 0022 00F0 
; 0022 00F1         memcpy(&pviWizBuff[indexWrite],&data_p[0],len_p);
; 0022 00F2         indexWrite += len_p;
; 0022 00F3 
; 0022 00F4         print_payload(pviWizBuff, indexWrite);
; 0022 00F5         write_uart0(pviWizBuff, indexWrite);
; 0022 00F6         index0Buffer = 0;
; 0022 00F7         iWizRXMode = WIZ_RX_DATA_MODE;
; 0022 00F8         free(pviWizBuff);
; 0022 00F9 
; 0022 00FA      }else{
; 0022 00FB         printDebug("[wizSend]can 't allocate mem.\r\n");
; 0022 00FC      }
; 0022 00FD      free(pviWizBuff);
; 0022 00FE 
; 0022 00FF }
;void iWizReceive(){
; 0022 0100 void iWizReceive(){
; 0022 0101      int i;
; 0022 0102      //free();
; 0022 0103 //     if(iHTTPStatus.connStatus == WIZ_HTTP_RES_CODE_OK && iHTTPStatus.contentLength >3){
; 0022 0104 //        print_payload(rx0Buffer, index0Buffer);
; 0022 0105 //     }
; 0022 0106 
; 0022 0107      printDebug("index0Buffer(%d)\r\n",index0Buffer);
;	i -> R16,R17
; 0022 0108      //printDebug("iHTTPStatusLen(%d)\r\n",iHTTPStatus.contentLength);
; 0022 0109      if(index0Buffer > 0){
; 0022 010A          for(i=0;i<index0Buffer;i++){
; 0022 010B               printDebug("%c",rx0Buffer[i]);
; 0022 010C          }
; 0022 010D      }
; 0022 010E 
; 0022 010F 
; 0022 0110      //print_payload(rx0Buffer, iHTTPStatus.contentLength);
; 0022 0111 }
;
;int iWizConnected(){
; 0022 0113 int iWizConnected(){
_iWizConnected:
; 0022 0114     //char *pviCheckWizConn;
; 0022 0115     int iReturn =  WIZ_CONN_FAIL;
; 0022 0116     char * pch;
; 0022 0117     TIMER   timeout;
; 0022 0118     char  pviCheckWizConn[200];
; 0022 0119 
; 0022 011A     TIMER_setTimer(&timeout, 20);
	SBIW R28,63
	SBIW R28,63
	SBIW R28,63
	SBIW R28,15
	CALL __SAVELOCR4
;	iReturn -> R16,R17
;	*pch -> R18,R19
;	timeout -> Y+204
;	pviCheckWizConn -> Y+4
	__GETWRN 16,17,0
	MOVW R30,R28
	SUBI R30,LOW(-(204))
	SBCI R31,HIGH(-(204))
	ST   -Y,R31
	ST   -Y,R30
	__GETD2N 0x14
	CALL _TIMER_setTimer
; 0022 011B     memset(pviCheckWizConn,0,sizeof(pviCheckWizConn));
	MOVW R30,R28
	ADIW R30,4
	CALL SUBOPT_0x64
	LDI  R26,LOW(200)
	CALL SUBOPT_0x76
; 0022 011C     index0Buffer = 0;
	CALL SUBOPT_0x77
; 0022 011D #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 011E     printDebug("[iWizConnected]Function.\r\n");
	__POINTD1FN _0x440000,261
	CALL SUBOPT_0x0
; 0022 011F #endif
; 0022 0120     while(!TIMER_checkTimerExceed(timeout)){
_0x440026:
	__GETD2SX 204
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	BREQ PC+3
	JMP _0x440028
; 0022 0121         #asm("wdr")
	wdr
; 0022 0122         delay_ms(50);
	CALL SUBOPT_0x8
; 0022 0123         //printDebug("[iWizConnected len(%d)]\r\n",index0Buffer);
; 0022 0124 
; 0022 0125         if((index0Buffer >= 11) && (index0Buffer <200) && (iWizRXMode == WIZ_RX_STAT_MODE)){        //11= >  Connected
	CALL SUBOPT_0xF
	SBIW R26,11
	BRLO _0x44002A
	CALL SUBOPT_0xF
	CPI  R26,LOW(0xC8)
	LDI  R30,HIGH(0xC8)
	CPC  R27,R30
	BRSH _0x44002A
	LDS  R26,_iWizRXMode
	CPI  R26,LOW(0x1)
	BREQ _0x44002B
_0x44002A:
	RJMP _0x440029
_0x44002B:
; 0022 0126             //pviCheckWizConn = (char *)malloc(index0Buffer);
; 0022 0127             //pviCheckWizConn = (char *)malloc(400);
; 0022 0128             //if(pviCheckWizConn != NULL){
; 0022 0129                printDebug("[iWizConnected len(%d)]\r\n",index0Buffer);
	__POINTD1FN _0x440000,288
	CALL __PUTPARD1
	LDS  R30,_index0Buffer
	LDS  R31,_index0Buffer+1
	CALL SUBOPT_0x55
; 0022 012A                memcpy(&pviCheckWizConn[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0x78
	CALL SUBOPT_0x79
; 0022 012B                pch = strtok (pviCheckWizConn,">");
	CALL SUBOPT_0x78
	CALL SUBOPT_0x7A
; 0022 012C                //pch = strtok (pviCheckWizConn,"> ");
; 0022 012D                while(pch != NULL){
_0x44002C:
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x44002E
; 0022 012E                    //printDebug("[Data split]%s\r\n",pch);
; 0022 012F                    if(strncmp (pch," Connected",9)==0){
	ST   -Y,R19
	ST   -Y,R18
	__POINTW1MN _0x440030,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(9)
	CALL _strncmp
	CPI  R30,0
	BRNE _0x44002F
; 0022 0130                         printDebug("[Data split]%s\r\n",pch);
	CALL SUBOPT_0x7B
; 0022 0131                         iReturn =  WIZ_CONNECTED;
	__GETWRN 16,17,1
; 0022 0132                         break;
	RJMP _0x44002E
; 0022 0133                    }else if(strncmp (pch," Listen : OK",11)==0){
_0x44002F:
	ST   -Y,R19
	ST   -Y,R18
	__POINTW1MN _0x440030,11
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(11)
	CALL _strncmp
	CPI  R30,0
	BRNE _0x440032
; 0022 0134                         printDebug("[Data split]%s\r\n",pch);
	CALL SUBOPT_0x7B
; 0022 0135                         iReturn =  WIZ_CONNECTED;
	__GETWRN 16,17,1
; 0022 0136                         break;
	RJMP _0x44002E
; 0022 0137                    }
; 0022 0138                    pch = strtok (NULL, ">");
_0x440032:
	CALL SUBOPT_0x7C
	CALL SUBOPT_0x7A
; 0022 0139                    //pch = strtok (NULL, "> ");
; 0022 013A                }
	RJMP _0x44002C
_0x44002E:
; 0022 013B 
; 0022 013C                //free(pviCheckWizConn);
; 0022 013D                if(iReturn ==  WIZ_CONNECTED){
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CP   R30,R16
	CPC  R31,R17
	BREQ _0x440028
; 0022 013E                    break;
; 0022 013F                }
; 0022 0140 //            }else{
; 0022 0141 //               printDebug("[iWizConnected]can 't allocate mem(%d).\r\n",index0Buffer);
; 0022 0142 //               iReturn =  WIZ_CONN_FAIL;
; 0022 0143 //            }
; 0022 0144         }else{
	RJMP _0x440034
_0x440029:
; 0022 0145            iReturn =  WIZ_CONN_FAIL;
	__GETWRN 16,17,0
; 0022 0146         }
_0x440034:
; 0022 0147     }
	RJMP _0x440026
_0x440028:
; 0022 0148     index0Buffer = 0;
	CALL SUBOPT_0x77
; 0022 0149 
; 0022 014A     return iReturn;
	MOVW R30,R16
	CALL __LOADLOCR4
	ADIW R28,63
	ADIW R28,63
	ADIW R28,63
	ADIW R28,19
	RET
; 0022 014B }

	.DSEG
_0x440030:
	.BYTE 0x18
;
;int iWizRead(){
; 0022 014D int iWizRead(){

	.CSEG
; 0022 014E     //char * pviWizRead;
; 0022 014F     int iReturn = WIZ_DATA_EMPTY;
; 0022 0150     char * pch;
; 0022 0151     char * pviHttpResCode;
; 0022 0152     char * pviHttpLen;
; 0022 0153     char * pviHttpData;
; 0022 0154     int i = 0;
; 0022 0155     char *pviReadLine;
; 0022 0156     unsigned int viHtteDetaLen = 0;
; 0022 0157     unsigned char viFlagHttpResCode;
; 0022 0158     unsigned char viFlagHttpLen;
; 0022 0159     char pviWizRead[400];
; 0022 015A 
; 0022 015B     TIMER   timeout;
; 0022 015C     TIMER_setTimer(&timeout, 3);
;	iReturn -> R16,R17
;	*pch -> R18,R19
;	*pviHttpResCode -> R20,R21
;	*pviHttpLen -> Y+420
;	*pviHttpData -> Y+418
;	i -> Y+416
;	*pviReadLine -> Y+414
;	viHtteDetaLen -> Y+412
;	viFlagHttpResCode -> Y+411
;	viFlagHttpLen -> Y+410
;	pviWizRead -> Y+10
;	timeout -> Y+6
; 0022 015D     while(!TIMER_checkTimerExceed(timeout)){
; 0022 015E        #asm("wdr")
; 0022 015F     }
; 0022 0160     //delay_ms(1000);
; 0022 0161 
; 0022 0162     memset(&pviWizRead,0,sizeof(pviWizRead));
; 0022 0163 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 0164     printDebug("[iWizRead]Function\r\n");
; 0022 0165 #endif
; 0022 0166     if((index0Buffer > 0) && (iWizRXMode == WIZ_RX_DATA_MODE)){
; 0022 0167         //pviWizRead = (char *)malloc(index0Buffer);
; 0022 0168         //if(pviWizRead != NULL){
; 0022 0169            memcpy(&pviWizRead[0],&rx0Buffer[0],index0Buffer);
; 0022 016A //           for(i=0;i<index0Buffer;i++){
; 0022 016B //                printDebug("%c",*(pviReadDisplay++));
; 0022 016C //           }
; 0022 016D            //printDebug("[HTTP]Raw Data\r\n");
; 0022 016E            print_payload(pviWizRead, index0Buffer);
; 0022 016F 
; 0022 0170 
; 0022 0171             pviReadLine = strtok(pviWizRead,"\r\n");
; 0022 0172 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 0173             printDebug("[HTTP]Check ResCode\r\n");
; 0022 0174 #endif
; 0022 0175             while(pviReadLine != NULL){
; 0022 0176                 #asm("wdr")
; 0022 0177                 if(strncmp(pviReadLine,"HTTP/",5)==0){
; 0022 0178                     pviHttpResCode = strtok (pviReadLine," ");
; 0022 0179                     while(pviHttpResCode != NULL){
; 0022 017A                          #asm("wdr")
; 0022 017B                          if(strncmp(pviHttpResCode,"200",3)==0){
; 0022 017C     #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 017D                               printDebug("[HTTP]200 OK\r\n");
; 0022 017E     #endif
; 0022 017F                               viFlagHttpResCode = WIZ_HTTP_RES_CODE_OK;
; 0022 0180                               //free(pviHttpResCode);
; 0022 0181                               break;
; 0022 0182                          }else{
; 0022 0183                               viFlagHttpResCode = WIZ_HTTP_RES_CODE_ERROR;
; 0022 0184                          }
; 0022 0185                          pviHttpResCode = strtok (NULL," ");
; 0022 0186                     }
; 0022 0187                     if(viFlagHttpResCode == WIZ_HTTP_RES_CODE_OK){
; 0022 0188                          break;
; 0022 0189                     }
; 0022 018A                     //pviReadLine = strtok(NULL,"\r\n");
; 0022 018B                 }
; 0022 018C                 pviReadLine = strtok(NULL,"\r\n");
; 0022 018D             }
; 0022 018E             //free(pviReadLine);
; 0022 018F 
; 0022 0190             memset(&pviWizRead,0,sizeof(pviWizRead));
; 0022 0191             memcpy(&pviWizRead[0],&rx0Buffer[0],index0Buffer);
; 0022 0192 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 0193             printDebug("[HTTP]Check Length\r\n");
; 0022 0194 #endif
; 0022 0195             pviReadLine = strtok(pviWizRead,"\r\n");
; 0022 0196             while(pviReadLine != NULL){
; 0022 0197                #asm("wdr")
; 0022 0198                if(strncmp(pviReadLine,"Content-Length",14)==0){
; 0022 0199                   pviHttpLen = strtok(pviReadLine," ");
; 0022 019A                   if(pviHttpLen != NULL){
; 0022 019B                       pviHttpLen = strtok(NULL," ");
; 0022 019C #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 019D                       printDebug("[DataLen][%s]\r\n",pviHttpLen);
; 0022 019E #endif
; 0022 019F                       viHtteDetaLen = atoi(pviHttpLen);
; 0022 01A0                       viFlagHttpLen = WIZ_HTTP_CONTEXT_LEN_OK;
; 0022 01A1                       break;
; 0022 01A2                   }else{
; 0022 01A3                       viFlagHttpLen = WIZ_HTTP_CONTEXT_LEN_NOTFOUND;
; 0022 01A4                   }
; 0022 01A5                }
; 0022 01A6                if(viFlagHttpLen == WIZ_HTTP_CONTEXT_LEN_OK){
; 0022 01A7                   break;
; 0022 01A8                }
; 0022 01A9                pviReadLine = strtok(NULL,"\r\n");
; 0022 01AA             }
; 0022 01AB 
; 0022 01AC             memset(&pviWizRead,0,sizeof(pviWizRead));
; 0022 01AD             memcpy(&pviWizRead[0],&rx0Buffer[0],index0Buffer);
; 0022 01AE #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 01AF             printDebug("[HTTP]Parser Data\r\n");
; 0022 01B0 #endif
; 0022 01B1             pviHttpData = strstr (pviWizRead,"\r\n\r\n");
; 0022 01B2             if(pviHttpData){
; 0022 01B3 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 01B4                 printDebug("[Data][\r\n");
; 0022 01B5 #endif
; 0022 01B6 //                for(i=0;i<(pviHttpData+4);i++){
; 0022 01B7 //                    //printDebug("%c",*(pviHttpData++));
; 0022 01B8 //                    putchar3(*(pviHttpData++));
; 0022 01B9 //                }
; 0022 01BA 
; 0022 01BB                 //printDebug("[Data][%s]\r\n",pviHttpData);
; 0022 01BC                 print_payload(pviHttpData+4, viHtteDetaLen);
; 0022 01BD #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 01BE                 printDebug("]\r\n");
; 0022 01BF #endif
; 0022 01C0                 viRXData.length = viHtteDetaLen;
; 0022 01C1                 memcpy(&viRXData.value[0],pviHttpData+4,viHtteDetaLen);
; 0022 01C2 
; 0022 01C3 //                memset(&pviWizRead,0,sizeof(pviWizRead));
; 0022 01C4 //                memcpy(&pviWizRead[0],pviHttpData+4,viHtteDetaLen);
; 0022 01C5             }
; 0022 01C6 
; 0022 01C7             if(viFlagHttpResCode==WIZ_HTTP_RES_CODE_OK && viFlagHttpLen == WIZ_HTTP_CONTEXT_LEN_OK){
; 0022 01C8 
; 0022 01C9                  iReturn =  WIZ_DATA_AVAILABLE;
; 0022 01CA             }
; 0022 01CB 
; 0022 01CC //        }else{
; 0022 01CD //           printDebug("[iWizRead]can 't allocate mem(%d).\r\n",index0Buffer);
; 0022 01CE //           iReturn =  WIZ_DATA_EMPTY;
; 0022 01CF //        }
; 0022 01D0     }else{
; 0022 01D1         iReturn =  WIZ_DATA_EMPTY;
; 0022 01D2     }
; 0022 01D3     index0Buffer = 0;
; 0022 01D4     //free(pviWizRead);
; 0022 01D5     return iReturn;
; 0022 01D6 }

	.DSEG
_0x440040:
	.BYTE 0x1E
;
;void iWizReadConfig(){
; 0022 01D8 void iWizReadConfig(){

	.CSEG
_iWizReadConfig:
; 0022 01D9     iChar_t viCmdModeChar[] = "+++";
; 0022 01DA 
; 0022 01DB     iChar_t viCmdMAC[] = "<RA>";                 //Get MAC Address
; 0022 01DC     iChar_t viCmdIP[] = "<RI>";                  //Get Local IP
; 0022 01DD     iChar_t viCmdSubnet[] = "<RS>";              //Get Subnet mask
; 0022 01DE     iChar_t viCmdGateWay[] = "<RG>";             //Get Gateway
; 0022 01DF     iChar_t viCmdLocalPort[] = "<RP>";           //Get Local IPs port number
; 0022 01E0     iChar_t viCmdIPMethod[] = "<RD>";            //Get the IP configuration method
; 0022 01E1     iChar_t viCmdOperMode[] = "<RM>";            //Get the operation mode
; 0022 01E2     iChar_t viCmdProtocal[] = "<RK>";            //Get the Protocol
; 0022 01E3     iChar_t viCmdBaudRate[] = "<RB>";            //Get the serial baud rate
; 0022 01E4     iChar_t viCmdCmdSerialMeth[] = "<RT>";       //Get the serial command method
; 0022 01E5     iChar_t viCmdCmdDomainName[] = "<RW>";       //Get the serial command method
; 0022 01E6 
; 0022 01E7     iChar_t viCmdRestart[] = "<WR>";       //Restart
; 0022 01E8 
; 0022 01E9     iChar_t viConfigMode;
; 0022 01EA     iChar_t * pviCheckResponse;
; 0022 01EB 
; 0022 01EC     iChar_t viWizReadBuffer[30];
; 0022 01ED     iChar_t viI = 0;
; 0022 01EE     TIMER   timeout;
; 0022 01EF 
; 0022 01F0     //Read configuration mode
; 0022 01F1     //viConfigMode = WIZ_CONFIG_READ_MODE;
; 0022 01F2     iWizRXMode = WIZ_CONFIG_READ_MODE;
	SBIW R28,63
	SBIW R28,35
	LDI  R24,64
	LDI  R26,LOW(34)
	LDI  R27,HIGH(34)
	LDI  R30,LOW(_0x440053*2)
	LDI  R31,HIGH(_0x440053*2)
	LDI  R22,BYTE3(_0x440053*2)
	CALL __INITLOCB
	CALL __SAVELOCR4
;	viCmdModeChar -> Y+98
;	viCmdMAC -> Y+93
;	viCmdIP -> Y+88
;	viCmdSubnet -> Y+83
;	viCmdGateWay -> Y+78
;	viCmdLocalPort -> Y+73
;	viCmdIPMethod -> Y+68
;	viCmdOperMode -> Y+63
;	viCmdProtocal -> Y+58
;	viCmdBaudRate -> Y+53
;	viCmdCmdSerialMeth -> Y+48
;	viCmdCmdDomainName -> Y+43
;	viCmdRestart -> Y+38
;	viConfigMode -> R17
;	*pviCheckResponse -> R18,R19
;	viWizReadBuffer -> Y+8
;	viI -> R16
;	timeout -> Y+4
	LDI  R16,0
	LDI  R30,LOW(4)
	STS  _iWizRXMode,R30
; 0022 01F3     //send +++
; 0022 01F4 
; 0022 01F5     index0Buffer = 0;
	CALL SUBOPT_0x77
; 0022 01F6     for(viI=0;viI<strlen(viCmdModeChar);viI++){
	LDI  R16,LOW(0)
_0x440055:
	MOVW R26,R28
	SUBI R26,LOW(-(98))
	SBCI R27,HIGH(-(98))
	CALL SUBOPT_0x7D
	BRSH _0x440056
; 0022 01F7         putchar0(viCmdModeChar[viI]);
	CALL SUBOPT_0x2A
	MOVW R26,R28
	SUBI R26,LOW(-(98))
	SBCI R27,HIGH(-(98))
	CALL SUBOPT_0x7E
; 0022 01F8     }
	SUBI R16,-1
	RJMP _0x440055
_0x440056:
; 0022 01F9 
; 0022 01FA     //wait wiz module response
; 0022 01FB     TIMER_setTimer(&timeout, 1);
	CALL SUBOPT_0x78
	CALL SUBOPT_0x7F
; 0022 01FC     while(!TIMER_checkTimerExceed(timeout)){
_0x440057:
	CALL SUBOPT_0x80
	BRNE _0x440059
; 0022 01FD        #asm("wdr")
	wdr
; 0022 01FE        if(index0Buffer>0){
	CALL SUBOPT_0x81
	BRSH _0x44005A
; 0022 01FF            delay_ms(100);
	CALL SUBOPT_0x5
; 0022 0200            memset(viWizReadBuffer,0,sizeof(viWizReadBuffer));
	MOVW R30,R28
	ADIW R30,8
	CALL SUBOPT_0x64
	LDI  R26,LOW(30)
	CALL SUBOPT_0x76
; 0022 0201            memcpy(&viWizReadBuffer[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0x82
	CALL SUBOPT_0x79
; 0022 0202 
; 0022 0203            pviCheckResponse = strstr(viWizReadBuffer,"<E>");
	CALL SUBOPT_0x82
	__POINTW2MN _0x44005B,0
	CALL _strstr
	MOVW R18,R30
; 0022 0204            if(pviCheckResponse){
; 0022 0205 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 0206                printDebug("[iWizReadConfig]can config mode(Read).\r\n");
; 0022 0207 #endif
; 0022 0208            }else{
; 0022 0209 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 020A                printDebug("[iWizReadConfig]can config mode(Read).\r\n");
_0x4400AE:
	__POINTD1FN _0x440000,481
	CALL SUBOPT_0x0
; 0022 020B #endif
; 0022 020C            }
; 0022 020D            break;
	RJMP _0x440059
; 0022 020E        }
; 0022 020F     }
_0x44005A:
	RJMP _0x440057
_0x440059:
; 0022 0210 
; 0022 0211     if(iWizConfigSend(viCmdMAC,viWizReadBuffer)==1){
	MOVW R30,R28
	SUBI R30,LOW(-(93))
	SBCI R31,HIGH(-(93))
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x44005E
; 0022 0212         iWizConfigMACParser(iWiz100srConfig.macAddress,viWizReadBuffer);
	LDI  R30,LOW(_iWiz100srConfig)
	LDI  R31,HIGH(_iWiz100srConfig)
	CALL SUBOPT_0x83
	RCALL _iWizConfigMACParser
; 0022 0213         printDebug("[iWizReadConfig]MAC:");
	__POINTD1FN _0x440000,522
	CALL SUBOPT_0x0
; 0022 0214         for(viI=0;viI<sizeof(iWiz100srConfig.macAddress);viI++){
	LDI  R16,LOW(0)
_0x440060:
	CPI  R16,12
	BRSH _0x440061
; 0022 0215             if(viI!=sizeof(iWiz100srConfig.macAddress)-1){
	CPI  R16,11
	BREQ _0x440062
; 0022 0216                 printDebug("%02x:",iWiz100srConfig.macAddress[viI]);
	__POINTD1FN _0x440000,543
	RJMP _0x4400AF
; 0022 0217             }else{
_0x440062:
; 0022 0218                 printDebug("%02x",iWiz100srConfig.macAddress[viI]);
	CALL SUBOPT_0x84
_0x4400AF:
	CALL __PUTPARD1
	CALL SUBOPT_0x2A
	SUBI R30,LOW(-_iWiz100srConfig)
	SBCI R31,HIGH(-_iWiz100srConfig)
	LD   R30,Z
	CALL SUBOPT_0x85
; 0022 0219             }
; 0022 021A         }
	SUBI R16,-1
	RJMP _0x440060
_0x440061:
; 0022 021B 
; 0022 021C         printDebug("\r\n");
	CALL SUBOPT_0x86
; 0022 021D     }
; 0022 021E 
; 0022 021F     if(iWizConfigSend(viCmdIP,viWizReadBuffer)==1){
_0x44005E:
	MOVW R30,R28
	SUBI R30,LOW(-(88))
	SBCI R31,HIGH(-(88))
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x440064
; 0022 0220         iWizConfigIPParser(iWiz100srConfig.ip,viWizReadBuffer);
	__POINTW1MN _iWiz100srConfig,13
	CALL SUBOPT_0x83
	RCALL _iWizConfigIPParser
; 0022 0221         printDebug("[iWizReadConfig]IP:");
	__POINTD1FN _0x440000,554
	CALL SUBOPT_0x0
; 0022 0222         for(viI=0;viI<sizeof(iWiz100srConfig.ip);viI++){
	LDI  R16,LOW(0)
_0x440066:
	CPI  R16,4
	BRSH _0x440067
; 0022 0223             if(viI!=sizeof(iWiz100srConfig.ip)-1){
	CPI  R16,3
	BREQ _0x440068
; 0022 0224                 printDebug("%02x.",iWiz100srConfig.ip[viI]);
	CALL SUBOPT_0x87
	RJMP _0x4400B0
; 0022 0225             }else{
_0x440068:
; 0022 0226                 printDebug("%02x",iWiz100srConfig.ip[viI]);
	CALL SUBOPT_0x84
_0x4400B0:
	CALL __PUTPARD1
	__POINTW2MN _iWiz100srConfig,13
	CALL SUBOPT_0x88
; 0022 0227             }
; 0022 0228         }
	SUBI R16,-1
	RJMP _0x440066
_0x440067:
; 0022 0229         printDebug("\r\n");
	CALL SUBOPT_0x86
; 0022 022A     }
; 0022 022B 
; 0022 022C     if(iWizConfigSend(viCmdSubnet,viWizReadBuffer)==1){
_0x440064:
	MOVW R30,R28
	SUBI R30,LOW(-(83))
	SBCI R31,HIGH(-(83))
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x44006A
; 0022 022D         iWizConfigIPParser(iWiz100srConfig.subnet,viWizReadBuffer);
	__POINTW1MN _iWiz100srConfig,17
	CALL SUBOPT_0x83
	RCALL _iWizConfigIPParser
; 0022 022E         printDebug("[iWizReadConfig]Subnet mask:");
	__POINTD1FN _0x440000,580
	CALL SUBOPT_0x0
; 0022 022F         for(viI=0;viI<sizeof(iWiz100srConfig.subnet);viI++){
	LDI  R16,LOW(0)
_0x44006C:
	CPI  R16,4
	BRSH _0x44006D
; 0022 0230             if(viI!=sizeof(iWiz100srConfig.subnet)-1){
	CPI  R16,3
	BREQ _0x44006E
; 0022 0231                 printDebug("%02x.",iWiz100srConfig.subnet[viI]);
	CALL SUBOPT_0x87
	RJMP _0x4400B1
; 0022 0232             }else{
_0x44006E:
; 0022 0233                 printDebug("%02x",iWiz100srConfig.subnet[viI]);
	CALL SUBOPT_0x84
_0x4400B1:
	CALL __PUTPARD1
	__POINTW2MN _iWiz100srConfig,17
	CALL SUBOPT_0x88
; 0022 0234             }
; 0022 0235         }
	SUBI R16,-1
	RJMP _0x44006C
_0x44006D:
; 0022 0236         printDebug("\r\n");
	CALL SUBOPT_0x86
; 0022 0237     }
; 0022 0238 
; 0022 0239     if(iWizConfigSend(viCmdGateWay,viWizReadBuffer)==1){
_0x44006A:
	MOVW R30,R28
	SUBI R30,LOW(-(78))
	SBCI R31,HIGH(-(78))
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
	CPI  R30,LOW(0x1)
	BRNE _0x440070
; 0022 023A         iWizConfigIPParser(iWiz100srConfig.gateWay,viWizReadBuffer);
	__POINTW1MN _iWiz100srConfig,21
	CALL SUBOPT_0x83
	RCALL _iWizConfigIPParser
; 0022 023B         printDebug("[iWizReadConfig]Gateway:");
	__POINTD1FN _0x440000,609
	CALL SUBOPT_0x0
; 0022 023C         for(viI=0;viI<sizeof(iWiz100srConfig.gateWay);viI++){
	LDI  R16,LOW(0)
_0x440072:
	CPI  R16,4
	BRSH _0x440073
; 0022 023D             if(viI!=sizeof(iWiz100srConfig.gateWay)-1){
	CPI  R16,3
	BREQ _0x440074
; 0022 023E                 printDebug("%02x.",iWiz100srConfig.gateWay[viI]);
	CALL SUBOPT_0x87
	RJMP _0x4400B2
; 0022 023F             }else{
_0x440074:
; 0022 0240                 printDebug("%02x",iWiz100srConfig.gateWay[viI]);
	CALL SUBOPT_0x84
_0x4400B2:
	CALL __PUTPARD1
	__POINTW2MN _iWiz100srConfig,21
	CALL SUBOPT_0x88
; 0022 0241             }
; 0022 0242         }
	SUBI R16,-1
	RJMP _0x440072
_0x440073:
; 0022 0243         printDebug("\r\n");
	CALL SUBOPT_0x86
; 0022 0244     }
; 0022 0245 
; 0022 0246     iWizConfigSend(viCmdLocalPort,viWizReadBuffer);
_0x440070:
	MOVW R30,R28
	SUBI R30,LOW(-(73))
	SBCI R31,HIGH(-(73))
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
; 0022 0247     iWizConfigSend(viCmdIPMethod,viWizReadBuffer);
	MOVW R30,R28
	SUBI R30,LOW(-(68))
	SBCI R31,HIGH(-(68))
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
; 0022 0248     iWizConfigSend(viCmdOperMode,viWizReadBuffer);
	MOVW R30,R28
	ADIW R30,63
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
; 0022 0249 
; 0022 024A     if(iWizConfigSend(viCmdCmdDomainName,viWizReadBuffer)){
	MOVW R30,R28
	ADIW R30,43
	CALL SUBOPT_0x83
	RCALL _iWizConfigSend
	CPI  R30,0
	BREQ _0x440076
; 0022 024B         memcpy(iWiz100srConfig.sdn,&viWizReadBuffer[2],sizeof(iWiz100srConfig.sdn));
	__POINTW1MN _iWiz100srConfig,56
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,12
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(32)
	CALL SUBOPT_0x72
; 0022 024C         printDebug("[iWizReadConfig]SDN:%s\r\n",iWiz100srConfig.sdn);
	__POINTD1FN _0x440000,634
	CALL __PUTPARD1
	__POINTW1MN _iWiz100srConfig,56
	CALL SUBOPT_0x55
; 0022 024D     }
; 0022 024E 
; 0022 024F 
; 0022 0250 
; 0022 0251     index0Buffer = 0;
_0x440076:
	CALL SUBOPT_0x77
; 0022 0252     for(viI=0;viI<strlen(viCmdRestart);viI++){
	LDI  R16,LOW(0)
_0x440078:
	MOVW R26,R28
	ADIW R26,38
	CALL SUBOPT_0x7D
	BRSH _0x440079
; 0022 0253         putchar0(viCmdRestart[viI]);
	CALL SUBOPT_0x2A
	MOVW R26,R28
	ADIW R26,38
	CALL SUBOPT_0x7E
; 0022 0254     }
	SUBI R16,-1
	RJMP _0x440078
_0x440079:
; 0022 0255 
; 0022 0256     //wait wiz module response
; 0022 0257     TIMER_setTimer(&timeout, 1);
	CALL SUBOPT_0x78
	CALL SUBOPT_0x7F
; 0022 0258     while(!TIMER_checkTimerExceed(timeout)){
_0x44007A:
	CALL SUBOPT_0x80
	BRNE _0x44007C
; 0022 0259        #asm("wdr")
	wdr
; 0022 025A        if(index0Buffer>0){
	CALL SUBOPT_0x81
	BRSH _0x44007D
; 0022 025B            delay_ms(100);
	CALL SUBOPT_0x5
; 0022 025C            memset(viWizReadBuffer,0,sizeof(viWizReadBuffer));
	MOVW R30,R28
	ADIW R30,8
	CALL SUBOPT_0x64
	LDI  R26,LOW(30)
	CALL SUBOPT_0x76
; 0022 025D            memcpy(&viWizReadBuffer[0],&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0x82
	CALL SUBOPT_0x79
; 0022 025E 
; 0022 025F            pviCheckResponse = strstr(viWizReadBuffer,"<S>");
	CALL SUBOPT_0x82
	__POINTW2MN _0x44005B,4
	CALL _strstr
	MOVW R18,R30
; 0022 0260            if(pviCheckResponse){
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x44007E
; 0022 0261 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 0262                printDebug("[iWizReadConfig]Restart Wiz100SR success.\r\n");
	__POINTD1FN _0x440000,663
	RJMP _0x4400B3
; 0022 0263 #endif
; 0022 0264            }else{
_0x44007E:
; 0022 0265 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 0266                printDebug("[iWizReadConfig]Restart Wiz100SR unsuccess.\r\n");
	__POINTD1FN _0x440000,707
_0x4400B3:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0022 0267 #endif
; 0022 0268            }
; 0022 0269            break;
	RJMP _0x44007C
; 0022 026A        }
; 0022 026B     }
_0x44007D:
	RJMP _0x44007A
_0x44007C:
; 0022 026C 
; 0022 026D     index0Buffer = 0;
	CALL SUBOPT_0x77
; 0022 026E     viConfigMode = WIZ_CONFIG_NORMAL_MODE;
	LDI  R17,LOW(6)
; 0022 026F }
	CALL __LOADLOCR4
	ADIW R28,63
	ADIW R28,39
	RET

	.DSEG
_0x44005B:
	.BYTE 0x8
;
;iChar_t iWizConfigSend(iChar_t * pviCmd_arg,iChar_t *pviDataBuff_arg){
; 0022 0271 iChar_t iWizConfigSend(iChar_t * pviCmd_arg,iChar_t *pviDataBuff_arg){

	.CSEG
_iWizConfigSend:
; 0022 0272     iChar_t viReturn = 0;
; 0022 0273     TIMER   timeout;
; 0022 0274     iChar_t viI = 0;
; 0022 0275     iChar_t * pviCheckResponse;
; 0022 0276 
; 0022 0277     index0Buffer = 0;
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
;	*pviCmd_arg -> Y+10
;	*pviDataBuff_arg -> Y+8
;	viReturn -> R17
;	timeout -> Y+4
;	viI -> R16
;	*pviCheckResponse -> R18,R19
	LDI  R17,0
	LDI  R16,0
	CALL SUBOPT_0x77
; 0022 0278     for(viI=0;viI<strlen(pviCmd_arg);viI++){
	LDI  R16,LOW(0)
_0x440081:
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL SUBOPT_0x7D
	BRSH _0x440082
; 0022 0279         putchar0(*(pviCmd_arg+viI));
	CALL SUBOPT_0x2A
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL SUBOPT_0x7E
; 0022 027A     }
	SUBI R16,-1
	RJMP _0x440081
_0x440082:
; 0022 027B 
; 0022 027C     //wait wiz module response
; 0022 027D     TIMER_setTimer(&timeout, 1);
	CALL SUBOPT_0x78
	CALL SUBOPT_0x7F
; 0022 027E     while(!TIMER_checkTimerExceed(timeout)){
_0x440083:
	CALL SUBOPT_0x80
	BRNE _0x440085
; 0022 027F        #asm("wdr")
	wdr
; 0022 0280        if(index0Buffer>0){
	CALL SUBOPT_0x81
	BRSH _0x440086
; 0022 0281            delay_ms(100);
	CALL SUBOPT_0x5
; 0022 0282            memset(pviDataBuff_arg,0,sizeof(pviDataBuff_arg));
	CALL SUBOPT_0x51
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL SUBOPT_0x4
	CALL _memset
; 0022 0283            memcpy(pviDataBuff_arg,&rx0Buffer[0],index0Buffer);
	CALL SUBOPT_0x51
	CALL SUBOPT_0x79
; 0022 0284 
; 0022 0285            pviCheckResponse = strstr(pviDataBuff_arg,"<S");
	CALL SUBOPT_0x51
	__POINTW2MN _0x440087,0
	CALL _strstr
	MOVW R18,R30
; 0022 0286            if(pviCheckResponse){
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x440088
; 0022 0287 #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 0288                printDebug("[iWizReadConfig]response data[.\r\n");
	__POINTD1FN _0x440000,756
	CALL SUBOPT_0x0
; 0022 0289                print_payload(pviDataBuff_arg,strlen(pviDataBuff_arg));
	CALL SUBOPT_0x51
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CALL _strlen
	MOVW R26,R30
	CALL _print_payload
; 0022 028A                printDebug("].\r\n");
	__POINTD1FN _0x440000,790
	RJMP _0x4400B4
; 0022 028B #endif
; 0022 028C            }else{
_0x440088:
; 0022 028D #if (WIZ100SR_PRINT_DEBUG == 1)
; 0022 028E                printDebug("[iWizReadConfig]wiz is not response.\r\n");
	__POINTD1FN _0x440000,795
_0x4400B4:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0022 028F #endif
; 0022 0290            }
; 0022 0291            break;
	RJMP _0x440085
; 0022 0292        }
; 0022 0293     }
_0x440086:
	RJMP _0x440083
_0x440085:
; 0022 0294     viReturn = 1;
	LDI  R17,LOW(1)
; 0022 0295     return viReturn;
	MOV  R30,R17
	CALL __LOADLOCR4
_0x20E002D:
	ADIW R28,12
	RET
; 0022 0296 }

	.DSEG
_0x440087:
	.BYTE 0x3
;
;unsigned int* hex_decode(char *in, unsigned int len, unsigned int *out)
; 0022 0299 {

	.CSEG
; 0022 029A     unsigned int i, t, hn, ln;
; 0022 029B 
; 0022 029C     for (t = 0,i = 0; i < len; i+=2,++t) {
;	*in -> Y+12
;	len -> Y+10
;	*out -> Y+8
;	i -> R16,R17
;	t -> R18,R19
;	hn -> R20,R21
;	ln -> Y+6
; 0022 029D 
; 0022 029E             hn = in[i] > '9' ? (in[i]|32) - 'a' + 10 : in[i] - '0';
; 0022 029F             ln = in[i+1] > '9' ? (in[i+1]|32) - 'a' + 10 : in[i+1] - '0';
; 0022 02A0 
; 0022 02A1             out[t] = (hn << 4 ) | ln;
; 0022 02A2             printf("%s",out[t]);
; 0022 02A3     }
; 0022 02A4     return out;
; 0022 02A5 }
;
;iChar_t iWizConfigIPParser(iChar_t *pviOutData_arg,iChar_t *pviInData_arg){
; 0022 02A7 iChar_t iWizConfigIPParser(iChar_t *pviOutData_arg,iChar_t *pviInData_arg){
_iWizConfigIPParser:
; 0022 02A8     iChar_t *ptrCh;
; 0022 02A9     iChar_t viIP[4];   //ip,subnet,gateway
; 0022 02AA     iInt_t viNumber;
; 0022 02AB     iChar_t viReturn = 0;
; 0022 02AC     iChar_t viI=0;
; 0022 02AD 
; 0022 02AE     ptrCh = strtok((pviInData_arg+2),".");   //2= <S
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR6
;	*pviOutData_arg -> Y+12
;	*pviInData_arg -> Y+10
;	*ptrCh -> R16,R17
;	viIP -> Y+6
;	viNumber -> R18,R19
;	viReturn -> R21
;	viI -> R20
	LDI  R21,0
	LDI  R20,0
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL SUBOPT_0x89
; 0022 02AF 
; 0022 02B0 	viI=0;
; 0022 02B1 	while(ptrCh != NULL) {
_0x440093:
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x440095
; 0022 02B2 		viIP[viI] = (unsigned char)(atoi(ptrCh));
	MOV  R30,R20
	LDI  R31,0
	MOVW R26,R28
	ADIW R26,6
	ADD  R30,R26
	ADC  R31,R27
	PUSH R31
	PUSH R30
	MOVW R26,R16
	CALL _atoi
	POP  R26
	POP  R27
	ST   X,R30
; 0022 02B3 		ptrCh = strtok(NULL,".");
	CALL SUBOPT_0x7C
	CALL SUBOPT_0x8A
; 0022 02B4 		viI++;
	SUBI R20,-1
; 0022 02B5 	}
	RJMP _0x440093
_0x440095:
; 0022 02B6     memcpy(pviOutData_arg,viIP,4);
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x82
	LDI  R26,LOW(4)
	CALL SUBOPT_0x72
; 0022 02B7 //	printf("\r\n");
; 0022 02B8 //	for(i=0; i<4; i++) {
; 0022 02B9 //		printf("%02x ",ip[i]);
; 0022 02BA //	}
; 0022 02BB 
; 0022 02BC     viReturn = 1;
	LDI  R21,LOW(1)
; 0022 02BD     return viReturn;
	MOV  R30,R21
_0x20E002C:
	CALL __LOADLOCR6
	ADIW R28,14
	RET
; 0022 02BE }
;
;//iChar_t iWizConfigMACParser(iUChar_t *pviOutData_arg,iChar_t *pviInData_arg){
;//    iChar_t *ptrCh;
;//    iChar_t viMAC[6];
;//    iInt_t viNumber;
;//    iChar_t viReturn = 0;
;//    iChar_t viI=0;
;//
;//    ptrCh = strtok((pviInData_arg+2),".");    //2= <S
;//	viI=0;
;//	while(ptrCh != NULL){
;//		viMAC[viI] = iMapAsciiHexToChar(ptrCh);
;//		ptrCh = strtok(NULL,".");
;//		viI++;
;//	}
;//    memcpy(pviOutData_arg,viMAC,6);
;//    //printDebug("[iWizConfigMACParser]MAC:%02x:%02x:%02x:%02x:%02x:%02x\r\n",*pviOutData_arg,*(pviOutData_arg+1),*(pviOutData_arg+2),*(pviOutData_arg+3),*(pviOutData_arg+4),*(pviOutData_arg+5));
;//
;//    viReturn = 1;
;//    return viReturn;
;//}
;iChar_t iWizConfigMACParser(iUChar_t *pviOutData_arg,iChar_t *pviInData_arg){
; 0022 02D4 iChar_t iWizConfigMACParser(iUChar_t *pviOutData_arg,iChar_t *pviInData_arg){
_iWizConfigMACParser:
; 0022 02D5     iChar_t *ptrCh;
; 0022 02D6     iChar_t viMAC[12];
; 0022 02D7     iInt_t viNumber;
; 0022 02D8     iChar_t viReturn = 0;
; 0022 02D9     iChar_t viI=0;
; 0022 02DA 
; 0022 02DB     ptrCh = strtok((pviInData_arg+2),".");    //2= <S
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,12
	CALL __SAVELOCR6
;	*pviOutData_arg -> Y+20
;	*pviInData_arg -> Y+18
;	*ptrCh -> R16,R17
;	viMAC -> Y+6
;	viNumber -> R18,R19
;	viReturn -> R21
;	viI -> R20
	LDI  R21,0
	LDI  R20,0
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CALL SUBOPT_0x89
; 0022 02DC 	viI=0;
; 0022 02DD 	while(ptrCh != NULL){
_0x440096:
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x440098
; 0022 02DE 		//viMAC[viI] = iMapAsciiHexToChar(ptrCh);
; 0022 02DF         memcpy((pviOutData_arg+viI),ptrCh,2);
	MOV  R30,R20
	LDI  R31,0
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	CALL SUBOPT_0x8B
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x4
	CALL _memcpy
; 0022 02E0 		ptrCh = strtok(NULL,".");
	CALL SUBOPT_0x7C
	CALL SUBOPT_0x8A
; 0022 02E1 		viI+=2;
	SUBI R20,-LOW(2)
; 0022 02E2 	}
	RJMP _0x440096
_0x440098:
; 0022 02E3     viReturn = 1;
	LDI  R21,LOW(1)
; 0022 02E4     return viReturn;
	MOV  R30,R21
	CALL __LOADLOCR6
	ADIW R28,22
	RET
; 0022 02E5 }
;
;iChar_t iMapAsciiHexToChar(iChar_t *chIn_arg){      //ascii hex 2 byte => char 1 byte
; 0022 02E7 iChar_t iMapAsciiHexToChar(iChar_t *chIn_arg){
; 0022 02E8 	iChar_t ivChar=0x00;
; 0022 02E9 	iChar_t *ptrCh;
; 0022 02EA 	iChar_t chReturn;
; 0022 02EB 	iChar_t i,j,k,l;
; 0022 02EC 
; 0022 02ED 	ptrCh = chIn_arg;
;	*chIn_arg -> Y+8
;	ivChar -> R17
;	*ptrCh -> R18,R19
;	chReturn -> R16
;	i -> R21
;	j -> R20
;	k -> Y+7
;	l -> Y+6
; 0022 02EE 
; 0022 02EF 	for(i=0,j=0x41,k=0x61,l=10; i<6; i++,j++,k++,l++) { //41='A' //61='a'
; 0022 02F0 		//printDebug("[hex1]%02x:%02x:%02x (%d) \r\n",i,j,k,l);
; 0022 02F1 		if((*(ptrCh) == j) || (*(ptrCh) == k)) {
; 0022 02F2 			ivChar = l;
; 0022 02F3 			break;
; 0022 02F4 		}
; 0022 02F5 	}
; 0022 02F6 	for(i=0,j=0x30; i<10; i++,j++) { //0-9 = 0x30-0x39
; 0022 02F7 		if(*(ptrCh) == j) {
; 0022 02F8 			ivChar = i;
; 0022 02F9 			break;
; 0022 02FA 		}
; 0022 02FB 	}
; 0022 02FC 	//printDebug("hex1:%02x \r\n",ivChar);
; 0022 02FD 	ptrCh++;
; 0022 02FE 
; 0022 02FF 	for(i=0,j=0x41,k=0x61,l=10; i<6; i++,j++,k++,l++) { //41='A' //61='a'
; 0022 0300 		//printDebug("[hex1]%02x:%02x:%02x (%d) \r\n",i,j,k,l);
; 0022 0301 		if((*(ptrCh) == j) || (*(ptrCh) == k)) {
; 0022 0302 			ivChar = (ivChar<<4)|l;
; 0022 0303 			break;
; 0022 0304 		}
; 0022 0305 	}
; 0022 0306 	for(i=0,j=0x30; i<10; i++,j++) { //0-9 = 0x30-0x39
; 0022 0307 		if(*(ptrCh) == j) {
; 0022 0308 			ivChar = (ivChar<<4)|i;
; 0022 0309 			break;
; 0022 030A 		}
; 0022 030B 	}
; 0022 030C 	//printDebug("hex2:%02x \r\n",ivChar);
; 0022 030D 	chReturn = ivChar;
; 0022 030E 	return chReturn;
; 0022 030F }
;#include "interruptTask.h"
;#include "timer.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "wiz100rs.h"
;int wiz100srSetTimer = -1;

	.DSEG
;//int viUart0TimeOutTemp = -1;
;piInterrupt_t pviUart0TimeOut = -1;
;extern void (*pfiWiz100rs)(void);
;
;void interruptTask(void *pviParameter){
; 0023 0009 void interruptTask(void *pviParameter){

	.CSEG
; 0023 000A 
; 0023 000B      printDebug("<interruptTask>Task Running...\r\n");
;	*pviParameter -> Y+0
; 0023 000C 
; 0023 000D //     if(pviUart0TimeOut == 1){    //start interrupt start timeout
; 0023 000E //        printf("<interruptTask>start count pviUart0TimeOut\r\n");
; 0023 000F //
; 0023 0010 //        if(wiz100srSetTimer == -1){
; 0023 0011 //           wiz100srSetTimer = countTimerIntpTask;
; 0023 0012 //        }else if((countTimerIntpTask - wiz100srSetTimer) > 2){                  //set timer = 1 sec
; 0023 0013 //             printDebug("<interruptTask>wiz100srSetTimer(timeout %d)\r\n",(countTimerIntpTask - wiz100srSetTimer));
; 0023 0014 //             wiz100srSetTimer = -1;
; 0023 0015 //             pviUart0TimeOut = 0;
; 0023 0016 //        }
; 0023 0017 //     }
; 0023 0018 
; 0023 0019      printDebug("<interruptTask>pviUart0TimeOut(%d),wiz100srSetTimer(%d)\r\n",pviUart0TimeOut,wiz100srSetTimer);
; 0023 001A      if(pviUart0TimeOut >= 0){    //start interrupt start timeout
; 0023 001B          printDebug("<interruptTask>start count pviUart0TimeOut\r\n");
; 0023 001C          if(wiz100srSetTimer == -1){
; 0023 001D              wiz100srSetTimer = countTimerIntpTask;
; 0023 001E              //viUart0TimeOutTemp = pviUart0TimeOut;
; 0023 001F          }else if((countTimerIntpTask - wiz100srSetTimer) > 2){                  //set timer = 1 sec
; 0023 0020              printDebug("<interruptTask>wiz100srSetTimer(timeout %d)\r\n",(countTimerIntpTask - wiz100srSetTimer));
; 0023 0021              pfiWiz100rs = &iWizRXTimeOut;
; 0023 0022              pfiWiz100rs();
; 0023 0023              wiz100srSetTimer = -1;
; 0023 0024              pviUart0TimeOut = -1;
; 0023 0025          }
; 0023 0026      }else if(pviUart0TimeOut == -1){
; 0023 0027          wiz100srSetTimer = -1;
; 0023 0028      }
; 0023 0029 
; 0023 002A 
; 0023 002B 
; 0023 002C }
;#include "deviceTask.h"
;#include "config.h"
;
;iUChar_t viFlagTerInit = 0;
;
;extern piQueueHandle_t pviQueueMangToConfig;
;
;iConfigFormat_t viDataConfig;
;
;void deviceTask(void *pviParameter){
; 0024 000A void deviceTask(void *pviParameter){

	.CSEG
; 0024 000B     printDebug("[deviceTask]Task Running...\r\n");
;	*pviParameter -> Y+0
; 0024 000C 
; 0024 000D     if(viFlagTerInit!=0){
; 0024 000E 
; 0024 000F     }else{
; 0024 0010 
; 0024 0011     }
; 0024 0012 
; 0024 0013     if(iQueueReceive(pviQueueMangToConfig,&viDataConfig)==1){
; 0024 0014         printDebug("[deviceTask]There is configuration.\r\n");
; 0024 0015 	}else{
; 0024 0016 		printDebug("[deviceTask]There is not config.\r\n");
; 0024 0017 	}
; 0024 0018 }
;#include "ad595.h"
;
;//iAD595 ad595Get(unsigned int adcValue_p){
;//     iAD595.tempCelsius = (3 * adcValue_p * 100.0)/1024;              //100.0 = 10 mV
;//     return iAD595;
;//}
;#include "logTask.h"
;#include "debug.h"
;
;void logTask(void *pviParameter){
; 0026 0004 void logTask(void *pviParameter){

	.CSEG
; 0026 0005      printDebug("[logTask]Running...\r\n");
;	*pviParameter -> Y+0
; 0026 0006 
; 0026 0007      printDebug("Hello World!.\r\n");
; 0026 0008 }
;#include "sdManager.h"
;
;// global variable
;iChar_t viFolderDataName[] = "Data";

	.DSEG
;iChar_t viFolderDataLogName[] = "Data_Log";
;iChar_t viFolderEventName[] = "Event";
;iChar_t viFolderStatusName[] = "Status";
;iChar_t viFolderErrorName[] = "Error";
;iChar_t viFolderConfigName[] = "Config";
;
;iChar_t viDirRootPath[] = "0:/";
;iChar_t viDirDataPath[] = "0:/DATA";
;iChar_t viDirDataLogPath[] = "0:/DATA_LOG";
;iChar_t viDirEventPath[] = "0:/EVENT";
;iChar_t viDirStatusPath[] = "0:/STATUS";
;iChar_t viDirErrorPath[] = "0:/ERROR";
;iChar_t viDirConfigPath[] = "0:/CONFIG";
;
;iChar_t viDataFName[] = "0:./data1.nc";
;iChar_t viDataLogFName[] = "0:./dataLog1.nc";
;iChar_t viEventFName[] = "0:./event1.nc";
;iChar_t viStatusFName[] = "0:./status1.nc";
;iChar_t viErrorFName[] = "0:./error1.nc";
;iChar_t viConfigFName[] = "0:./config1.nc";
;
;/* will hold file/directory information returned by f_readdir*/
;FILINFO file_info;
;
;
;/* recursively scan directory entries and display them */
;FRESULT directory_scan(char *path){
; 0027 001F FRESULT directory_scan(char *path){

	.CSEG
; 0027 0020     /* will hold the directory information */
; 0027 0021     DIR directory;
; 0027 0022     /* FAT function result */
; 0027 0023     FRESULT res;
; 0027 0024     int i;
; 0027 0025 
; 0027 0026 
; 0027 0027     if ((res=f_opendir(&directory,path))==FR_OK){
;	*path -> Y+26
;	directory -> Y+4
;	res -> R17
;	i -> R18,R19
; 0027 0028        while (((res=f_readdir(&directory,&file_info))==FR_OK) &&
; 0027 0029              file_info.fname[0])
; 0027 002A              {
; 0027 002B              /* display file/directory name and associated information */
; 0027 002C              printDebug("%c%c%c%c%c %02u/%02u/%u %02u:%02u:%02u %9lu"                 "  %s/%s\r\n",
; 0027 002D                     (file_info.fattrib & AM_DIR) ? 'D' : '-',
; 0027 002E                     (file_info.fattrib & AM_RDO) ? 'R' : '-',
; 0027 002F                     (file_info.fattrib & AM_HID) ? 'H' : '-',
; 0027 0030                     (file_info.fattrib & AM_SYS) ? 'S' : '-',
; 0027 0031                     (file_info.fattrib & AM_ARC) ? 'A' : '-',
; 0027 0032                     file_info.fdate & 0x1F,(file_info.fdate >> 5) & 0xF,
; 0027 0033                     (file_info.fdate >> 9)+1980,
; 0027 0034                     file_info.ftime >> 11,(file_info.ftime >> 5) & 0x3F,
; 0027 0035                     (file_info.ftime & 0xF) << 1,
; 0027 0036                     file_info.fsize,path,file_info.fname);
; 0027 0037              if (file_info.fattrib & AM_DIR)
; 0027 0038                 {
; 0027 0039                 /* its a subdirectory */
; 0027 003A                 /* make sure to skip past "." and ".." when recursing */
; 0027 003B                 if (file_info.fname[0]!='.')
; 0027 003C                    {
; 0027 003D                    i=strlen(path);
; 0027 003E                    /* append the subdirectory name to the path */
; 0027 003F                    if (path[i-1]!='/') strcatf(path,"/");
; 0027 0040                    strcat(path,file_info.fname);
; 0027 0041                    /* scan subdirectory */
; 0027 0042                    res=directory_scan(path);
; 0027 0043                    /* restore the old path name */
; 0027 0044                    path[i]=0;
; 0027 0045                    /* remove any eventual '/' from the end of the path */
; 0027 0046                    --i;
; 0027 0047                    if (path[i]=='/') path[i]=0;
; 0027 0048                    /* stop if an error occured */
; 0027 0049                    if (res!=FR_OK) break;
; 0027 004A                    }
; 0027 004B                 }
; 0027 004C               }
; 0027 004D     }
; 0027 004E    return res;
; 0027 004F }
;
;
;
;iInt_t iCreateFolder(iUChar_t viFolderName_arg){
; 0027 0053 iInt_t iCreateFolder(iUChar_t viFolderName_arg){
; 0027 0054 
; 0027 0055 }
;
;
;iInt_t iInitSDCard(){
; 0027 0058 iInt_t iInitSDCard(){
_iInitSDCard:
; 0027 0059     //Check SD folder
; 0027 005A //    char viFolderDataName[] = "Data";
; 0027 005B //    char viFolderEventName[] = "Event";
; 0027 005C //    char viFolderStatusName[] = "Status";
; 0027 005D //    char viFolderErrorName[] = "Error";
; 0027 005E //    char viFolderConfigName[] = "Config";
; 0027 005F //    char viDirRootPath[] = "0:/";
; 0027 0060 //    char viDirDataPath[] = "0:/DATA";
; 0027 0061 //    char viDirEventPath[] = "0:/EVENT";
; 0027 0062 //    char viDirStatusPath[] = "0:/STATUS";
; 0027 0063 //    char viDirErrorPath[] = "0:/ERROR";
; 0027 0064 //    char viDirConfigPath[] = "0:/CONFIG";
; 0027 0065     FRESULT viFReturn;
; 0027 0066     DIR viOutDir;
; 0027 0067 
; 0027 0068 
; 0027 0069     viFReturn = f_opendir(&viOutDir, viDirDataPath);
	SBIW R28,22
	ST   -Y,R17
;	viFReturn -> R17
;	viOutDir -> Y+1
	CALL SUBOPT_0x5A
	LDI  R26,LOW(_viDirDataPath)
	LDI  R27,HIGH(_viDirDataPath)
	CALL SUBOPT_0x8C
; 0027 006A     if(viFReturn == FR_OK){
	BRNE _0x4E0030
; 0027 006B         printDebug("[iInitSDCard]Data dir is exist.\r\n");
	__POINTD1FN _0x4E0000,55
	RJMP _0x4E0074
; 0027 006C     }else{
_0x4E0030:
; 0027 006D         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0x8D
; 0027 006E         if(viFReturn == FR_NO_PATH){
	BRNE _0x4E0032
; 0027 006F             viFReturn = f_mkdir(viFolderDataName);
	LDI  R26,LOW(_viFolderDataName)
	LDI  R27,HIGH(_viFolderDataName)
	CALL SUBOPT_0x8E
; 0027 0070             if(viFReturn == FR_OK){
	BRNE _0x4E0033
; 0027 0071                printDebug("[iInitSDCard]mkdir Data success.\r\n");
	__POINTD1FN _0x4E0000,89
	RJMP _0x4E0074
; 0027 0072             }else{
_0x4E0033:
; 0027 0073                printDebug("[iInitSDCard]mkdir Data error.\r\n");
	__POINTD1FN _0x4E0000,124
_0x4E0074:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0027 0074             }
; 0027 0075         }
; 0027 0076     }
_0x4E0032:
; 0027 0077 
; 0027 0078     viFReturn = f_opendir(&viOutDir, viDirDataLogPath);
	CALL SUBOPT_0x5A
	LDI  R26,LOW(_viDirDataLogPath)
	LDI  R27,HIGH(_viDirDataLogPath)
	CALL SUBOPT_0x8C
; 0027 0079     if(viFReturn == FR_OK){
	BRNE _0x4E0035
; 0027 007A         printDebug("[iInitSDCard]DataLog dir is exist.\r\n");
	__POINTD1FN _0x4E0000,157
	RJMP _0x4E0075
; 0027 007B     }else{
_0x4E0035:
; 0027 007C         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0x8D
; 0027 007D         if(viFReturn == FR_NO_PATH){
	BRNE _0x4E0037
; 0027 007E             viFReturn = f_mkdir(viFolderDataLogName);
	LDI  R26,LOW(_viFolderDataLogName)
	LDI  R27,HIGH(_viFolderDataLogName)
	CALL SUBOPT_0x8E
; 0027 007F             if(viFReturn == FR_OK){
	BRNE _0x4E0038
; 0027 0080                printDebug("[iInitSDCard]mkdir DataLog success.\r\n");
	__POINTD1FN _0x4E0000,194
	RJMP _0x4E0075
; 0027 0081             }else{
_0x4E0038:
; 0027 0082                printDebug("[iInitSDCard]mkdir DataLog error.\r\n");
	__POINTD1FN _0x4E0000,232
_0x4E0075:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0027 0083             }
; 0027 0084         }
; 0027 0085     }
_0x4E0037:
; 0027 0086 
; 0027 0087     viFReturn = f_opendir(&viOutDir, viDirEventPath);
	CALL SUBOPT_0x5A
	LDI  R26,LOW(_viDirEventPath)
	LDI  R27,HIGH(_viDirEventPath)
	CALL SUBOPT_0x8C
; 0027 0088     if(viFReturn == FR_OK){
	BRNE _0x4E003A
; 0027 0089         printDebug("[iInitSDCard]Event dir is exist.\r\n");
	__POINTD1FN _0x4E0000,268
	RJMP _0x4E0076
; 0027 008A     }else{
_0x4E003A:
; 0027 008B         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0x8D
; 0027 008C         if(viFReturn == FR_NO_PATH){
	BRNE _0x4E003C
; 0027 008D             viFReturn = f_mkdir(viFolderEventName);
	LDI  R26,LOW(_viFolderEventName)
	LDI  R27,HIGH(_viFolderEventName)
	CALL SUBOPT_0x8E
; 0027 008E             if(viFReturn == FR_OK){
	BRNE _0x4E003D
; 0027 008F                printDebug("[iInitSDCard]mkdir Event success.\r\n");
	__POINTD1FN _0x4E0000,303
	RJMP _0x4E0076
; 0027 0090             }else{
_0x4E003D:
; 0027 0091                printDebug("[iInitSDCard]mkdir Event error.\r\n");
	__POINTD1FN _0x4E0000,339
_0x4E0076:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0027 0092             }
; 0027 0093         }
; 0027 0094     }
_0x4E003C:
; 0027 0095 
; 0027 0096     viFReturn = f_opendir(&viOutDir, viDirStatusPath);
	CALL SUBOPT_0x5A
	LDI  R26,LOW(_viDirStatusPath)
	LDI  R27,HIGH(_viDirStatusPath)
	CALL SUBOPT_0x8C
; 0027 0097     if(viFReturn == FR_OK){
	BRNE _0x4E003F
; 0027 0098         printDebug("[iInitSDCard]Status dir is exist.\r\n");
	__POINTD1FN _0x4E0000,373
	RJMP _0x4E0077
; 0027 0099     }else{
_0x4E003F:
; 0027 009A         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0x8D
; 0027 009B         if(viFReturn == FR_NO_PATH){
	BRNE _0x4E0041
; 0027 009C             viFReturn = f_mkdir(viFolderStatusName);
	LDI  R26,LOW(_viFolderStatusName)
	LDI  R27,HIGH(_viFolderStatusName)
	CALL SUBOPT_0x8E
; 0027 009D             if(viFReturn == FR_OK){
	BRNE _0x4E0042
; 0027 009E                printDebug("[iInitSDCard]mkdir Status success.\r\n");
	__POINTD1FN _0x4E0000,409
	RJMP _0x4E0077
; 0027 009F             }else{
_0x4E0042:
; 0027 00A0                printDebug("[iInitSDCard]mkdir Status error.\r\n");
	__POINTD1FN _0x4E0000,446
_0x4E0077:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0027 00A1             }
; 0027 00A2         }
; 0027 00A3     }
_0x4E0041:
; 0027 00A4 
; 0027 00A5     viFReturn = f_opendir(&viOutDir, viDirErrorPath);
	CALL SUBOPT_0x5A
	LDI  R26,LOW(_viDirErrorPath)
	LDI  R27,HIGH(_viDirErrorPath)
	CALL SUBOPT_0x8C
; 0027 00A6     if(viFReturn == FR_OK){
	BRNE _0x4E0044
; 0027 00A7         printDebug("[iInitSDCard]Error dir is exist.\r\n");
	__POINTD1FN _0x4E0000,481
	RJMP _0x4E0078
; 0027 00A8     }else{
_0x4E0044:
; 0027 00A9         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0x8D
; 0027 00AA         if(viFReturn == FR_NO_PATH){
	BRNE _0x4E0046
; 0027 00AB             viFReturn = f_mkdir(viFolderErrorName);
	LDI  R26,LOW(_viFolderErrorName)
	LDI  R27,HIGH(_viFolderErrorName)
	CALL SUBOPT_0x8E
; 0027 00AC             if(viFReturn == FR_OK){
	BRNE _0x4E0047
; 0027 00AD                printDebug("[iInitSDCard]mkdir Error success.\r\n");
	__POINTD1FN _0x4E0000,516
	RJMP _0x4E0078
; 0027 00AE             }else{
_0x4E0047:
; 0027 00AF                printDebug("[iInitSDCard]mkdir Error error.\r\n");
	__POINTD1FN _0x4E0000,552
_0x4E0078:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0027 00B0             }
; 0027 00B1         }
; 0027 00B2     }
_0x4E0046:
; 0027 00B3 
; 0027 00B4     viFReturn = f_opendir(&viOutDir, viDirConfigPath);
	CALL SUBOPT_0x5A
	LDI  R26,LOW(_viDirConfigPath)
	LDI  R27,HIGH(_viDirConfigPath)
	CALL SUBOPT_0x8C
; 0027 00B5     if(viFReturn == FR_OK){
	BRNE _0x4E0049
; 0027 00B6         printDebug("[iInitSDCard]Config dir is exist.\r\n");
	__POINTD1FN _0x4E0000,586
	RJMP _0x4E0079
; 0027 00B7     }else{
_0x4E0049:
; 0027 00B8         iFDisplayReturn(viFReturn);
	CALL SUBOPT_0x8D
; 0027 00B9         if(viFReturn == FR_NO_PATH){
	BRNE _0x4E004B
; 0027 00BA             viFReturn = f_mkdir(viFolderConfigName);
	LDI  R26,LOW(_viFolderConfigName)
	LDI  R27,HIGH(_viFolderConfigName)
	CALL SUBOPT_0x8E
; 0027 00BB             if(viFReturn == FR_OK){
	BRNE _0x4E004C
; 0027 00BC                printDebug("[iInitSDCard]mkdir Config success.\r\n");
	__POINTD1FN _0x4E0000,622
	RJMP _0x4E0079
; 0027 00BD             }else{
_0x4E004C:
; 0027 00BE                printDebug("[iInitSDCard]mkdir Config error.\r\n");
	__POINTD1FN _0x4E0000,659
_0x4E0079:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0027 00BF             }
; 0027 00C0         }
; 0027 00C1     }
_0x4E004B:
; 0027 00C2 }
	LDD  R17,Y+0
	ADIW R28,23
	RET
;
;
;void iFDisplayReturn(FRESULT viFResulyt_arg){
; 0027 00C5 void iFDisplayReturn(FRESULT viFResulyt_arg){
_iFDisplayReturn:
; 0027 00C6     switch(viFResulyt_arg){
	ST   -Y,R26
;	viFResulyt_arg -> Y+0
	LD   R30,Y
	LDI  R31,0
; 0027 00C7         case FR_OK:{
	SBIW R30,0
	BRNE _0x4E0051
; 0027 00C8             printDebug("success.\r\n");
	__POINTD1FN _0x4E0000,113
	RJMP _0x4E007A
; 0027 00C9             break;
; 0027 00CA         }
; 0027 00CB         case FR_NO_PATH:{
_0x4E0051:
	CPI  R30,LOW(0x5)
	LDI  R26,HIGH(0x5)
	CPC  R31,R26
	BRNE _0x4E0052
; 0027 00CC             printDebug("couldn't find the path.\r\n");
	__POINTD1FN _0x4E0000,694
	RJMP _0x4E007A
; 0027 00CD             break;
; 0027 00CE         }
; 0027 00CF         case FR_INVALID_NAME:{
_0x4E0052:
	CPI  R30,LOW(0x6)
	LDI  R26,HIGH(0x6)
	CPC  R31,R26
	BRNE _0x4E0053
; 0027 00D0             printDebug("the directory name is invalid.\r\n");
	__POINTD1FN _0x4E0000,720
	RJMP _0x4E007A
; 0027 00D1             break;
; 0027 00D2         }
; 0027 00D3         case FR_INVALID_DRIVE:{
_0x4E0053:
	CPI  R30,LOW(0xB)
	LDI  R26,HIGH(0xB)
	CPC  R31,R26
	BRNE _0x4E0054
; 0027 00D4             printDebug("the drive number is invalid.\r\n");
	__POINTD1FN _0x4E0000,753
	RJMP _0x4E007A
; 0027 00D5             break;
; 0027 00D6         }
; 0027 00D7         case FR_NOT_READY:{
_0x4E0054:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x4E0055
; 0027 00D8             printDebug("no disk access was possible due to missing media or other reason.\r\n");
	__POINTD1FN _0x4E0000,784
	RJMP _0x4E007A
; 0027 00D9             break;
; 0027 00DA         }
; 0027 00DB         case FR_DISK_ERR:{
_0x4E0055:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x4E0056
; 0027 00DC             printDebug("the function failed because of a physical disk access function failure.\r\n");
	__POINTD1FN _0x4E0000,852
	RJMP _0x4E007A
; 0027 00DD             break;
; 0027 00DE         }
; 0027 00DF         case FR_INT_ERR:{
_0x4E0056:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x4E0057
; 0027 00E0             printDebug("the function failed due to a wrong FAT structure or an internal error.\r\n");
	__POINTD1FN _0x4E0000,926
	RJMP _0x4E007A
; 0027 00E1             break;
; 0027 00E2         }
; 0027 00E3         case FR_NOT_ENABLED:{
_0x4E0057:
	CPI  R30,LOW(0xC)
	LDI  R26,HIGH(0xC)
	CPC  R31,R26
	BRNE _0x4E0058
; 0027 00E4             printDebug("the logical drive was not mounted with f_mount.\r\n");
	__POINTD1FN _0x4E0000,999
	RJMP _0x4E007A
; 0027 00E5             break;
; 0027 00E6         }
; 0027 00E7         case FR_NO_FILESYSTEM:{
_0x4E0058:
	CPI  R30,LOW(0xD)
	LDI  R26,HIGH(0xD)
	CPC  R31,R26
	BRNE _0x4E0059
; 0027 00E8             printDebug("there is no valid FAT partition on the disk.\r\n");
	__POINTD1FN _0x4E0000,1049
	RJMP _0x4E007A
; 0027 00E9             break;
; 0027 00EA         }
; 0027 00EB         case FR_DENIED:{
_0x4E0059:
	CPI  R30,LOW(0x7)
	LDI  R26,HIGH(0x7)
	CPC  R31,R26
	BRNE _0x4E005A
; 0027 00EC             printDebug("file access was denied because it was opened in read-only mode.\r\n");
	__POINTD1FN _0x4E0000,1096
	RJMP _0x4E007A
; 0027 00ED             break;
; 0027 00EE         }
; 0027 00EF         case FR_INVALID_OBJECT:{
_0x4E005A:
	CPI  R30,LOW(0x9)
	LDI  R26,HIGH(0x9)
	CPC  R31,R26
	BRNE _0x4E005B
; 0027 00F0             printDebug("the file was not opened with f_open.\r\n");
	__POINTD1FN _0x4E0000,1162
	RJMP _0x4E007A
; 0027 00F1             break;
; 0027 00F2         }
; 0027 00F3         case FR_NO_FILE:{
_0x4E005B:
	CPI  R30,LOW(0x4)
	LDI  R26,HIGH(0x4)
	CPC  R31,R26
	BRNE _0x4E005C
; 0027 00F4             printDebug("couldn't find the file or directory.\r\n");
	__POINTD1FN _0x4E0000,1201
	RJMP _0x4E007A
; 0027 00F5             break;
; 0027 00F6         }
; 0027 00F7         case FR_WRITE_PROTECTED:{
_0x4E005C:
	CPI  R30,LOW(0xA)
	LDI  R26,HIGH(0xA)
	CPC  R31,R26
	BRNE _0x4E0050
; 0027 00F8             printDebug("the media in the drive is write protected.\r\n");
	__POINTD1FN _0x4E0000,1240
_0x4E007A:
	CALL __PUTPARD1
	CALL SUBOPT_0x2
; 0027 00F9             break;
; 0027 00FA         }
; 0027 00FB     }
_0x4E0050:
; 0027 00FC }
	JMP  _0x20E0028
;
;
;void iFCreate(FIL *pviOutFilePtr_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0027 00FF void iFCreate(FIL *pviOutFilePtr_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0027 0100     FRESULT viFReturn;
; 0027 0101     //iUChar_t viReturn = 0;
; 0027 0102     DIR viOutDir;
; 0027 0103     FIL pviFilePtr;
; 0027 0104 
; 0027 0105     if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
;	*pviOutFilePtr_arg -> Y+571
;	*pviDirPath_arg -> Y+569
;	*pviFilename_arg -> Y+567
;	viFReturn -> R17
;	viOutDir -> Y+545
;	pviFilePtr -> Y+1
; 0027 0106        printDebug("[iFCreate]Current directory : %s.\r\n",pviDirPath_arg);
; 0027 0107        if((viFReturn=f_open(pviOutFilePtr_arg,pviFilename_arg,FA_CREATE_NEW))==FR_OK){
; 0027 0108            printDebug("[iFCreate]File %s is created.\r\n",pviFilename_arg);
; 0027 0109            if((viFReturn=f_close(pviOutFilePtr_arg))==FR_OK){
; 0027 010A            }else{
; 0027 010B               iFDisplayReturn(viFReturn);
; 0027 010C            }
; 0027 010D        }else{
; 0027 010E            printDebug("[iFCreate]File %s : %s.[\r\n",pviFilename_arg);
; 0027 010F            iFDisplayReturn(viFReturn);
; 0027 0110            printDebug("]\r\n");
; 0027 0111        }
; 0027 0112     }else{
; 0027 0113        printDebug("[iFCreate]directory : %s.[\r\n",pviDirPath_arg);
; 0027 0114        iFDisplayReturn(viFReturn);
; 0027 0115        printDebug("]\r\n");
; 0027 0116     }
; 0027 0117 }
;
;void iFRwite(const iChar_t * const pviDataBuff,iUInt_t ivLength_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0027 0119 void iFRwite(const iChar_t * const pviDataBuff,iUInt_t ivLength_arg,iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0027 011A     FIL *viFilePtr;
; 0027 011B     FRESULT viFReturn;
; 0027 011C     unsigned int nbytes;
; 0027 011D     const iChar_t * pviDataBuffRef = (iChar_t * const )pviDataBuff;
; 0027 011E 
; 0027 011F     //print_payload((const iChar_t *)pviDataBuff,ivLength_arg);
; 0027 0120     print_payload(pviDataBuffRef,ivLength_arg);
;	*pviDataBuff -> Y+14
;	ivLength_arg -> Y+12
;	*pviDirPath_arg -> Y+10
;	*pviFilename_arg -> Y+8
;	*viFilePtr -> R16,R17
;	viFReturn -> R19
;	nbytes -> R20,R21
;	*pviDataBuffRef -> Y+6
; 0027 0121     viFilePtr = (FIL * const)malloc(sizeof(FIL));
; 0027 0122     if(viFilePtr!=NULL){
; 0027 0123         if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
; 0027 0124            printDebug("[iFRwite]Current directory : %s.\r\n",pviDirPath_arg);
; 0027 0125            if((viFReturn=f_open(viFilePtr,pviFilename_arg,FA_WRITE|FA_OPEN_ALWAYS))==FR_OK){
; 0027 0126                printDebug("[iFRwite]File %s is openned.\r\n",pviFilename_arg);
; 0027 0127 
; 0027 0128                /* Move to end of the file to append data */
; 0027 0129                printDebug("[iFRwite]File size(%ld).\r\n",viFilePtr->fsize);
; 0027 012A                if((viFReturn=f_lseek(viFilePtr, viFilePtr->fsize))==FR_OK){        //seek end of file in order append
; 0027 012B                    printDebug("[iFRwite]Pointer(seek) of File moved.\r\n");
; 0027 012C                    //print_payload((const iChar_t *)pviDataBuff,ivLength_arg);
; 0027 012D                    print_payload(pviDataBuffRef,ivLength_arg);
; 0027 012E                    if((viFReturn=f_write(viFilePtr,(const iChar_t *)pviDataBuff,ivLength_arg,&nbytes))==FR_OK){    //viFReturn=f_write(viFilePtr,&pviDataBuff[0],strlen(pviDataBuff),&nbytes)
; 0027 012F                        printDebug("[iFRwite]%d bytes written of %d\r\n",nbytes,ivLength_arg);
; 0027 0130                    }else{
; 0027 0131                        printDebug("[iFRwite]Write error(%d)\r\n",viFReturn);
; 0027 0132                        iFDisplayReturn(viFReturn);
; 0027 0133                    }
; 0027 0134                }else{
; 0027 0135                    iFDisplayReturn(viFReturn);
; 0027 0136                }
; 0027 0137 
; 0027 0138                if((viFReturn=f_close(viFilePtr))==FR_OK){
; 0027 0139                }else{
; 0027 013A                   iFDisplayReturn(viFReturn);
; 0027 013B                }
; 0027 013C            }else{
; 0027 013D                printDebug("[iFRwite]File %s : %s.[\r\n",pviFilename_arg);
; 0027 013E                iFDisplayReturn(viFReturn);
; 0027 013F                printDebug("]\r\n");
; 0027 0140            }
; 0027 0141         }else{
; 0027 0142            printDebug("[iFRwite]directory : %s.[\r\n",pviDirPath_arg);
; 0027 0143            iFDisplayReturn(viFReturn);
; 0027 0144            printDebug("]\r\n");
; 0027 0145         }
; 0027 0146         free(viFilePtr);
; 0027 0147     }else{
; 0027 0148         printDebug("[iFRwite]can't allocate mem.\r\n");
; 0027 0149     }
; 0027 014A 
; 0027 014B }
;
;void iFDelete(iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0027 014D void iFDelete(iChar_t *pviDirPath_arg,iChar_t *pviFilename_arg){
; 0027 014E     FRESULT viFReturn;
; 0027 014F     if((viFReturn=f_chdir(pviDirPath_arg))==FR_OK){
;	*pviDirPath_arg -> Y+3
;	*pviFilename_arg -> Y+1
;	viFReturn -> R17
; 0027 0150        printDebug("[iFDelete]Current directory : %s.\r\n",pviDirPath_arg);
; 0027 0151        if((viFReturn=f_unlink(pviFilename_arg))==FR_OK){
; 0027 0152            printDebug("[iFDelete]File %s is deleted.\r\n",pviFilename_arg);
; 0027 0153        }else{
; 0027 0154            printDebug("[iFDelete]File %s : %s. can't delete.[\r\n",pviFilename_arg);
; 0027 0155            iFDisplayReturn(viFReturn);
; 0027 0156            printDebug("]\r\n");
; 0027 0157        }
; 0027 0158     }else{
; 0027 0159        printDebug("[iFDelete]directory : %s.[\r\n",pviDirPath_arg);
; 0027 015A        iFDisplayReturn(viFReturn);
; 0027 015B        printDebug("]\r\n");
; 0027 015C     }
; 0027 015D }
;#include "database.h"
;#include "sdManager.h"
;
;
;extern iChar_t viFolderDataName[];
;extern iChar_t viFolderDataLogName[];
;extern iChar_t viFolderEventName[];
;extern iChar_t viFolderStatusName[];
;extern iChar_t viFolderErrorName[];
;extern iChar_t viFolderConfigName[];
;
;extern iChar_t viDirRootPath[];
;extern iChar_t viDirDataPath[];
;extern iChar_t viDirDataLogPath[];
;extern iChar_t viDirEventPath[];
;extern iChar_t viDirStatusPath[];
;extern iChar_t viDirErrorPath[];
;extern iChar_t viDirConfigPath[];
;
;extern iChar_t viDataFName[];
;extern iChar_t viDataLogFName[];
;extern iChar_t viEventFName[];
;extern iChar_t viStatusFName[];
;extern iChar_t viErrorFName[];
;extern iChar_t viConfigFName[];
;
;piDataBaseHandle_t pviDataBaseHandle = NULL;
;
;iChar_t iDataLogInsert(iChar_t const * const pviDataBuffer_arg,iUInt_t viLength_arg){
; 0028 001D iChar_t iDataLogInsert(iChar_t const * const pviDataBuffer_arg,iUInt_t viLength_arg){

	.CSEG
; 0028 001E     iDB_t *pviDBLogger;
; 0028 001F     iChar_t viReturn = 0;
; 0028 0020     iChar_t *pviDataBuffInsert;
; 0028 0021     const iChar_t viStatusField = 'N';
; 0028 0022     const iChar_t viTokenSplite = '|';
; 0028 0023     const iChar_t viNewLine[] = {0x0d,0x0a};           //"\r\n"
; 0028 0024     iChar_t viDataBuff[255];
; 0028 0025 
; 0028 0026 
; 0028 0027 
; 0028 0028 
; 0028 0029     pviDBLogger = (iDB_t * const)malloc(sizeof(iDB_t));
;	*pviDataBuffer_arg -> Y+266
;	viLength_arg -> Y+264
;	*pviDBLogger -> R16,R17
;	viReturn -> R19
;	*pviDataBuffInsert -> R20,R21
;	viStatusField -> R18
;	viTokenSplite -> Y+263
;	viNewLine -> Y+261
;	viDataBuff -> Y+6
; 0028 002A     if(pviDBLogger!=NULL){
; 0028 002B         pviDBLogger->dirPath = viDirDataLogPath;
; 0028 002C         pviDBLogger->fileName = viDataLogFName;
; 0028 002D         pviDBLogger->viTable.status = 'N';
; 0028 002E 
; 0028 002F         memcpy(&viDataBuff[0],&viStatusField,1);
; 0028 0030         memcpy(&viDataBuff[1],&viTokenSplite,1);
; 0028 0031         memcpy(&viDataBuff[1+1],&pviDataBuffer_arg[0],viLength_arg);
; 0028 0032         memcpy(&viDataBuff[1+1+viLength_arg],viNewLine,2);
; 0028 0033 
; 0028 0034         pviDBLogger->viTable.length = viLength_arg+4;
; 0028 0035         pviDBLogger->viTable.value = viDataBuff;
; 0028 0036         iFRwite(pviDBLogger->viTable.value,pviDBLogger->viTable.length,pviDBLogger->dirPath,pviDBLogger->fileName);
; 0028 0037         viReturn = 1;
; 0028 0038 
; 0028 0039         free(pviDBLogger);
; 0028 003A         printDebug("[iDataLogInsert]Insert is success.\r\n");
; 0028 003B     }else{
; 0028 003C         printDebug("[iDataLogInsert]Databuff_arg can't allocate mem.\r\n");
; 0028 003D     }
; 0028 003E     return viReturn;
; 0028 003F }
;
;
;
;iChar_t iDataLogUpdate(iChar_t *pviDataBuffer_arg,iUInt_t viLineID_arg){
; 0028 0043 iChar_t iDataLogUpdate(iChar_t *pviDataBuffer_arg,iUInt_t viLineID_arg){
; 0028 0044     iDB_t *pviDBLogger;
; 0028 0045     iChar_t viReturn = 0;
; 0028 0046 
; 0028 0047     return viReturn;
;	*pviDataBuffer_arg -> Y+6
;	viLineID_arg -> Y+4
;	*pviDBLogger -> R16,R17
;	viReturn -> R19
; 0028 0048 }
;
;iChar_t iDataLogSelect(iChar_t *pviDataBuffer_arg,iUInt_t viLineID_arg){
; 0028 004A iChar_t iDataLogSelect(iChar_t *pviDataBuffer_arg,iUInt_t viLineID_arg){
; 0028 004B     iDB_t *pviDBLogger;
; 0028 004C     iChar_t viReturn = 0;
; 0028 004D 
; 0028 004E     return viReturn;
;	*pviDataBuffer_arg -> Y+6
;	viLineID_arg -> Y+4
;	*pviDBLogger -> R16,R17
;	viReturn -> R19
; 0028 004F }
;
;
;iChar_t iDataInsert(iChar_t const * const pviDataBuffer_arg,iUInt_t viLength_arg){
; 0028 0052 iChar_t iDataInsert(iChar_t const * const pviDataBuffer_arg,iUInt_t viLength_arg){
; 0028 0053     iDB_t *pviDBLogger;
; 0028 0054     iChar_t viReturn = 0;
; 0028 0055     iChar_t *pviDataBuffInsert;
; 0028 0056     const iChar_t viStatusField = 'N';
; 0028 0057     const iChar_t viTokenSplite = '|';
; 0028 0058     const iChar_t viNewLine[] = {0x0d,0x0a};           //"\r\n"
; 0028 0059     iChar_t viDataBuff[255];
; 0028 005A 
; 0028 005B 
; 0028 005C 
; 0028 005D 
; 0028 005E     pviDBLogger = (iDB_t * const)malloc(sizeof(iDB_t));
;	*pviDataBuffer_arg -> Y+266
;	viLength_arg -> Y+264
;	*pviDBLogger -> R16,R17
;	viReturn -> R19
;	*pviDataBuffInsert -> R20,R21
;	viStatusField -> R18
;	viTokenSplite -> Y+263
;	viNewLine -> Y+261
;	viDataBuff -> Y+6
; 0028 005F     if(pviDBLogger!=NULL){
; 0028 0060         pviDBLogger->dirPath = viDirDataPath;
; 0028 0061         pviDBLogger->fileName = viDataFName;
; 0028 0062         pviDBLogger->viTable.status = 'N';
; 0028 0063 
; 0028 0064         memcpy(&viDataBuff[0],&viStatusField,1);
; 0028 0065         memcpy(&viDataBuff[1],&viTokenSplite,1);
; 0028 0066         memcpy(&viDataBuff[1+1],&pviDataBuffer_arg[0],viLength_arg);
; 0028 0067         memcpy(&viDataBuff[1+1+viLength_arg],viNewLine,2);
; 0028 0068 
; 0028 0069         pviDBLogger->viTable.length = viLength_arg+4;
; 0028 006A         pviDBLogger->viTable.value = viDataBuff;
; 0028 006B         iFRwite(pviDBLogger->viTable.value,pviDBLogger->viTable.length,pviDBLogger->dirPath,pviDBLogger->fileName);
; 0028 006C         viReturn = 1;
; 0028 006D 
; 0028 006E         free(pviDBLogger);
; 0028 006F         printDebug("[iDataInsert]Insert is success.\r\n");
; 0028 0070     }else{
; 0028 0071         printDebug("[iDataInsert]Databuff_arg can't allocate mem.\r\n");
; 0028 0072     }
; 0028 0073     return viReturn;
; 0028 0074 }
;#include "event.h"
;//See appendex B
;iEVENT_t viEvent[33]={
;    {0x10,{0x00,0x01,0xff},3},
;    {0x20,{0x00,0x01,0xff},3},
;    {0x30,{0x00,0x01,0xff},3},
;    {0x40,{0x00,0x01,0xff},3},
;    {0x50,{0x00,0x01,0xff},3},
;    {0x60,{0x00,0x01,0xff},3},
;    {0x70,{0x00,0x01,0xff},3},
;    {0x80,{0x00,0x01,0xff},3},
;    {0x81,{0x00,0x01,0xff},3},
;    {0x82,{0x00,0x01,0xff},3},
;    {0x83,{0x00,0x01,0xff},3},
;    {0x84,{0x00,0x01,0xff},3},
;    {0x85,{0x00,0x01,0xff},3},
;    {0x86,{0x00,0x01,0xff},3},
;    {0x87,{0x00,0x01,0xff},3},
;    {0x90,{0x00,0x01,0xff},3},
;    {0x91,{0x00,0x01,0xff},3},
;    {0x92,{0x00,0x01,0xff},3},
;    {0x93,{0x00,0x01,0xff},3},
;    {0x94,{0x00,0x01,0xff},3},
;    {0x95,{0x00,0x01,0xff},3},
;    {0x96,{0x00,0x01,0xff},3},
;    {0x97,{0x00,0x01,0xff},3},
;    {0xa0,{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0xff},8},
;    {0xa1,{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0xff},8},
;    {0xa2,{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0xff},8},
;    {0xa3,{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0xff},8},
;    {0xa4,{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0xff},8},
;    {0xb0,{0x00,0x01,0x02,0x03,0x04,0x05,0xff},7},
;    {0xb1,{0x00,0x01,0x02,0x03,0x04,0x05,0xff},7},
;    {0xb2,{0x00,0x01,0x02,0x03,0x04,0x05,0xff},7},
;    {0xb3,{0x00,0x01,0x02,0x03,0x04,0x05,0xff},7},
;    {0xb4,{0x00,0x01,0x02,0x03,0x04,0x05,0xff},7}
;};

	.DSEG
;#include "sensorManager.h"
;#include "config.h"
;#include "sensor.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;#include "managerTask.h"
;extern eeprom iDVConfig_t viDVConfigUpdate;
;iDataReport_t viDataReportBuff;
;
;extern iDataMini_t viDataReport;
;extern iDataMini_t viStatusReport;
;
;iChar_t iSensorRead(iDataMini_t *pviOutData_arg){
; 002A 000B iChar_t iSensorRead(iDataMini_t *pviOutData_arg){

	.CSEG
_iSensorRead:
; 002A 000C     iChar_t i;
; 002A 000D     iChar_t viReturn = 0;
; 002A 000E     const iChar_t viCMD[2] = {0x5a,0x07};
; 002A 000F     iUChar_t viIndexWrite = 0;
; 002A 0010 
; 002A 0011     /*test*/
; 002A 0012     viDVConfigUpdate.viOperate.viSensorEnable[0] = 1;
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	LDI  R30,LOW(90)
	ST   Y,R30
	LDI  R30,LOW(7)
	STD  Y+1,R30
	CALL __SAVELOCR4
;	*pviOutData_arg -> Y+6
;	i -> R17
;	viReturn -> R16
;	viCMD -> Y+4
;	viIndexWrite -> R19
	LDI  R16,0
	LDI  R19,0
	__POINTW2MN _viDVConfigUpdate,163
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002A 0013     viDVConfigUpdate.viOperate.viSensorEnable[1] = 1;
	__POINTW2MN _viDVConfigUpdate,164
	CALL __EEPROMWRB
; 002A 0014     viDVConfigUpdate.viOperate.viSensorEnable[2] = 1;
	__POINTW2MN _viDVConfigUpdate,165
	CALL __EEPROMWRB
; 002A 0015     viDVConfigUpdate.viOperate.viSensorEnable[3] = 1;
	__POINTW2MN _viDVConfigUpdate,166
	CALL __EEPROMWRB
; 002A 0016     viDVConfigUpdate.viOperate.viSensorEnable[4] = 1;
	__POINTW2MN _viDVConfigUpdate,167
	CALL __EEPROMWRB
; 002A 0017     viDVConfigUpdate.viSensorConfig[0].viChannelID = 0;
	__POINTW2MN _viDVConfigUpdate,168
	LDI  R30,LOW(0)
	CALL __EEPROMWRB
; 002A 0018     viDVConfigUpdate.viSensorConfig[1].viChannelID = 1;
	__POINTW2MN _viDVConfigUpdate,196
	LDI  R30,LOW(1)
	CALL __EEPROMWRB
; 002A 0019     viDVConfigUpdate.viSensorConfig[2].viChannelID = 2;
	__POINTW2MN _viDVConfigUpdate,224
	LDI  R30,LOW(2)
	CALL __EEPROMWRB
; 002A 001A     viDVConfigUpdate.viSensorConfig[3].viChannelID = 3;
	__POINTW2MN _viDVConfigUpdate,252
	LDI  R30,LOW(3)
	CALL __EEPROMWRB
; 002A 001B     viDVConfigUpdate.viSensorConfig[4].viChannelID = 4;
	__POINTW2MN _viDVConfigUpdate,280
	LDI  R30,LOW(4)
	CALL __EEPROMWRB
; 002A 001C     viDVConfigUpdate.viSensorConfig[0].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,169
	LDI  R30,LOW(17)
	CALL __EEPROMWRB
; 002A 001D     viDVConfigUpdate.viSensorConfig[1].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,197
	CALL __EEPROMWRB
; 002A 001E     viDVConfigUpdate.viSensorConfig[2].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,225
	CALL __EEPROMWRB
; 002A 001F     viDVConfigUpdate.viSensorConfig[3].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,253
	CALL __EEPROMWRB
; 002A 0020     viDVConfigUpdate.viSensorConfig[4].viSensorID = SEN_ADC_TYPE;
	__POINTW2MN _viDVConfigUpdate,281
	CALL __EEPROMWRB
; 002A 0021     viDVConfigUpdate.viSensorConfig[0].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,170
	LDI  R30,LOW(49)
	CALL __EEPROMWRB
; 002A 0022     viDVConfigUpdate.viSensorConfig[1].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,198
	CALL __EEPROMWRB
; 002A 0023     viDVConfigUpdate.viSensorConfig[2].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,226
	CALL __EEPROMWRB
; 002A 0024     viDVConfigUpdate.viSensorConfig[3].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,254
	CALL __EEPROMWRB
; 002A 0025     viDVConfigUpdate.viSensorConfig[4].viUnitID = SEN_ADC10BIT_UNIT;
	__POINTW2MN _viDVConfigUpdate,282
	CALL __EEPROMWRB
; 002A 0026 
; 002A 0027 #if (0)
; 002A 0028     printDebug("viOperate\r\n");
; 002A 0029     printConfig((char eeprom *)&viDVConfigUpdate.viOperate,sizeof(viDVConfigUpdate.viOperate));
; 002A 002A     printDebug("SensorConfig[0]\r\n");
; 002A 002B     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[0],sizeof(viDVConfigUpdate.viSensorConfig));
; 002A 002C     printDebug("SensorConfig[1]\r\n");
; 002A 002D     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[1],sizeof(viDVConfigUpdate.viSensorConfig));
; 002A 002E     printDebug("SensorConfig[2]\r\n");
; 002A 002F     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[2],sizeof(viDVConfigUpdate.viSensorConfig));
; 002A 0030     printDebug("SensorConfig[3]\r\n");
; 002A 0031     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[3],sizeof(viDVConfigUpdate.viSensorConfig));
; 002A 0032     printDebug("SensorConfig[4]\r\n");
; 002A 0033     printConfig((char eeprom *)&viDVConfigUpdate.viSensorConfig[4],sizeof(viDVConfigUpdate.viSensorConfig));
; 002A 0034     /////////
; 002A 0035 #endif
; 002A 0036 
; 002A 0037     viIndexWrite = 0;
	LDI  R19,LOW(0)
; 002A 0038     for(i=0;i<5;i++){
	LDI  R17,LOW(0)
_0x540004:
	CPI  R17,5
	BRLO PC+3
	JMP _0x540005
; 002A 0039         #asm("wdr")
	wdr
; 002A 003A        if(viDVConfigUpdate.viOperate.viSensorEnable[i]==1){
	__POINTW2MN _viDVConfigUpdate,163
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	CALL __EEPROMRDB
	CPI  R30,LOW(0x1)
	BRNE _0x540006
; 002A 003B            viDataReportBuff.viChannelID = viDVConfigUpdate.viSensorConfig[i].viChannelID;
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x90
	ADD  R26,R30
	ADC  R27,R31
	CALL __EEPROMRDB
	STS  _viDataReportBuff,R30
; 002A 003C            viDataReportBuff.viSensorID = viDVConfigUpdate.viSensorConfig[i].viSensorID;
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x90
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,1
	CALL __EEPROMRDB
	__PUTB1MN _viDataReportBuff,1
; 002A 003D            viDataReportBuff.viUnitID =   viDVConfigUpdate.viSensorConfig[i].viUnitID;
	CALL SUBOPT_0x8F
	CALL SUBOPT_0x90
	ADD  R26,R30
	ADC  R27,R31
	ADIW R26,2
	CALL __EEPROMRDB
	__PUTB1MN _viDataReportBuff,2
; 002A 003E            iSensorReadByType(&viDataReportBuff);
	LDI  R26,LOW(_viDataReportBuff)
	LDI  R27,HIGH(_viDataReportBuff)
	RCALL _iSensorReadByType
; 002A 003F            memcpy(&pviOutData_arg->value[viIndexWrite],viCMD,2);
	CALL SUBOPT_0x91
	CALL SUBOPT_0x8B
	CALL SUBOPT_0x92
	CALL _memcpy
; 002A 0040            viIndexWrite += 2;
	SUBI R19,-LOW(2)
; 002A 0041            memcpy(&pviOutData_arg->value[viIndexWrite],&viDataReportBuff,sizeof(viDataReportBuff));
	CALL SUBOPT_0x91
	CALL SUBOPT_0x8B
	LDI  R30,LOW(_viDataReportBuff)
	LDI  R31,HIGH(_viDataReportBuff)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(7)
	CALL SUBOPT_0x72
; 002A 0042            viIndexWrite += sizeof(viDataReportBuff);
	SUBI R19,-LOW(7)
; 002A 0043            pviOutData_arg->length = viIndexWrite;
	CALL SUBOPT_0x93
; 002A 0044        }
; 002A 0045     }
_0x540006:
	SUBI R17,-1
	RJMP _0x540004
_0x540005:
; 002A 0046     printDebug("[iSensorRead]Data:[\r\n");
	__POINTD1FN _0x540000,0
	CALL SUBOPT_0x0
; 002A 0047     print_payload(&pviOutData_arg->value[0],pviOutData_arg->length);
	CALL SUBOPT_0x94
; 002A 0048     printDebug("]\r\n");
	__POINTD1FN _0x540000,22
	CALL SUBOPT_0x0
; 002A 0049     viReturn = 1;
	LDI  R16,LOW(1)
; 002A 004A     return viReturn;
	MOV  R30,R16
	CALL __LOADLOCR4
	JMP  _0x20E0025
; 002A 004B }
;
;void iSensorReadByType(iDataReport_t *pviInOutData_arg){
; 002A 004D void iSensorReadByType(iDataReport_t *pviInOutData_arg){
_iSensorReadByType:
; 002A 004E     switch(pviInOutData_arg->viSensorID){
	CALL SUBOPT_0x20
;	*pviInOutData_arg -> Y+0
	LDD  R30,Z+1
	LDI  R31,0
; 002A 004F         case SEN_ADC_TYPE:{
	CPI  R30,LOW(0x11)
	LDI  R26,HIGH(0x11)
	CPC  R31,R26
	BRNE _0x540009
; 002A 0050             pviInOutData_arg->viData = read_adc(8+pviInOutData_arg->viChannelID);
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X
	SUBI R30,-LOW(8)
	MOV  R26,R30
	CALL _read_adc
	LD   R26,Y
	LDD  R27,Y+1
	ADIW R26,3
	CALL SUBOPT_0x23
; 002A 0051             printDebug("[iSensorReadByType]Channel[%d] data : %f\r\n",pviInOutData_arg->viChannelID,pviInOutData_arg->viData);
	__POINTD1FN _0x540000,26
	CALL __PUTPARD1
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R30,X
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	__GETD2Z 3
	CALL __PUTPARD2
	LDI  R24,8
	CALL _printDebug
	ADIW R28,12
; 002A 0052             break;
; 002A 0053         }
; 002A 0054     }
_0x540009:
; 002A 0055 }
_0x20E002B:
	ADIW R28,2
	RET
;
;float iADCTypeCalculator(){
; 002A 0057 float iADCTypeCalculator(){
; 002A 0058     float viReturn = 0;
; 002A 0059     return viReturn;
;	viReturn -> Y+0
; 002A 005A }
;
;float iKTypeCalculator(){
; 002A 005C float iKTypeCalculator(){
; 002A 005D     float viReturn = 0;
; 002A 005E     return viReturn;
;	viReturn -> Y+0
; 002A 005F }
;
;float iTP100TypeCalculator(){
; 002A 0061 float iTP100TypeCalculator(){
; 002A 0062     float viReturn = 0;
; 002A 0063     return viReturn;
;	viReturn -> Y+0
; 002A 0064 }
;
;float iVoltTypeCalculator(){
; 002A 0066 float iVoltTypeCalculator(){
; 002A 0067     float viReturn = 0;
; 002A 0068     return viReturn;
;	viReturn -> Y+0
; 002A 0069 }
;
;float iAmpTypeCalculator(){
; 002A 006B float iAmpTypeCalculator(){
; 002A 006C     float viReturn = 0;
; 002A 006D     return viReturn;
;	viReturn -> Y+0
; 002A 006E }
;
;float i420TypeCalculator(){
; 002A 0070 float i420TypeCalculator(){
; 002A 0071     float viReturn = 0;
; 002A 0072     return viReturn;
;	viReturn -> Y+0
; 002A 0073 }
;
;float iDHT11TypeCalculator(){
; 002A 0075 float iDHT11TypeCalculator(){
; 002A 0076     float viReturn = 0;
; 002A 0077     return viReturn;
;	viReturn -> Y+0
; 002A 0078 }
;
;float iDHT22TypeCalculator(){
; 002A 007A float iDHT22TypeCalculator(){
; 002A 007B     float viReturn = 0;
; 002A 007C     return viReturn;
;	viReturn -> Y+0
; 002A 007D }
;#include "statusManager.h"
;#include "adc.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif
;
;extern eeprom iDVConfig_t viDVConfigUpdate;
;iStatusReport_t viStatusReportBuff;
;
;extern iDataMini_t viDataReport;
;extern iDataMini_t viStatusReport;
;
;iChar_t iStatusRead(iDataMini_t *pviOutData_arg){
; 002B 000A iChar_t iStatusRead(iDataMini_t *pviOutData_arg){

	.CSEG
_iStatusRead:
; 002B 000B     iChar_t i;
; 002B 000C     iChar_t viReturn = 0;
; 002B 000D     const iChar_t viCMD[2] = {0x2a,0x06};
; 002B 000E     iUChar_t viIndexWrite = 0;
; 002B 000F 
; 002B 0010     /*test*/
; 002B 0011     #asm("wdr")
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	LDI  R30,LOW(42)
	ST   Y,R30
	LDI  R30,LOW(6)
	STD  Y+1,R30
	CALL __SAVELOCR4
;	*pviOutData_arg -> Y+6
;	i -> R17
;	viReturn -> R16
;	viCMD -> Y+4
;	viIndexWrite -> R19
	LDI  R16,0
	LDI  R19,0
	wdr
; 002B 0012     viStatusReportBuff.viStatusType = STATUS_BATTERY_TYPE;
	LDI  R30,LOW(1)
	STS  _viStatusReportBuff,R30
; 002B 0013     viStatusReportBuff.viDataType =  STATUS_FLOAT;
	LDI  R30,LOW(4)
	__PUTB1MN _viStatusReportBuff,1
; 002B 0014     iStatusReadByType(&viStatusReportBuff);
	LDI  R26,LOW(_viStatusReportBuff)
	LDI  R27,HIGH(_viStatusReportBuff)
	RCALL _iStatusReadByType
; 002B 0015 
; 002B 0016     viIndexWrite = 0;
	LDI  R19,LOW(0)
; 002B 0017     memcpy(&pviOutData_arg->value[viIndexWrite],viCMD,2);
	CALL SUBOPT_0x91
	CALL SUBOPT_0x8B
	CALL SUBOPT_0x92
	CALL _memcpy
; 002B 0018     viIndexWrite += 2;
	SUBI R19,-LOW(2)
; 002B 0019     memcpy(&pviOutData_arg->value[viIndexWrite],&viStatusReportBuff,sizeof(viStatusReportBuff));
	CALL SUBOPT_0x91
	CALL SUBOPT_0x8B
	LDI  R30,LOW(_viStatusReportBuff)
	LDI  R31,HIGH(_viStatusReportBuff)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(6)
	CALL SUBOPT_0x72
; 002B 001A     viIndexWrite += sizeof(viStatusReportBuff);
	SUBI R19,-LOW(6)
; 002B 001B     pviOutData_arg->length = viIndexWrite;
	CALL SUBOPT_0x93
; 002B 001C 
; 002B 001D     printDebug("[iStatusRead]Data:[\r\n");
	__POINTD1FN _0x560000,0
	CALL SUBOPT_0x0
; 002B 001E     print_payload(&pviOutData_arg->value[0],pviOutData_arg->length);
	CALL SUBOPT_0x94
; 002B 001F     printDebug("]\r\n");
	__POINTD1FN _0x560000,22
	CALL SUBOPT_0x0
; 002B 0020 
; 002B 0021 
; 002B 0022     viReturn = 1;
	LDI  R16,LOW(1)
; 002B 0023 
; 002B 0024     return viReturn;
	MOV  R30,R16
	CALL __LOADLOCR4
	JMP  _0x20E0025
; 002B 0025 }
;
;float iStatusReadByType(iStatusReport_t *pviInOutData_arg){
; 002B 0027 float iStatusReadByType(iStatusReport_t *pviInOutData_arg){
_iStatusReadByType:
; 002B 0028      float viReturn = 0.0;
; 002B 0029      switch(pviInOutData_arg->viStatusType){
	CALL SUBOPT_0x69
	ST   Y,R30
	LDI  R30,LOW(0)
	STD  Y+1,R30
	STD  Y+2,R30
	STD  Y+3,R30
;	*pviInOutData_arg -> Y+4
;	viReturn -> Y+0
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL SUBOPT_0x95
; 002B 002A           case STATUS_BATTERY_TYPE:{
	BRNE _0x560005
; 002B 002B             pviInOutData_arg->viData = iStatusReadBattery();
	RCALL _iStatusReadBattery
	__PUTD1SNS 4,2
; 002B 002C             break;
; 002B 002D           }
; 002B 002E      }
_0x560005:
; 002B 002F      viReturn = 1.0;
	__GETD1N 0x3F800000
	CALL SUBOPT_0x17
; 002B 0030      return viReturn;
	JMP  _0x20E0023
; 002B 0031 }
;
;float iStatusReadBattery(){
; 002B 0033 float iStatusReadBattery(){
_iStatusReadBattery:
; 002B 0034     float  viBatt = 0.0;
; 002B 0035     float  viADCDividerMax = 635.5;//2.05      // from voltage divider 120k & 150k
; 002B 0036     float  viVoltMaxBatt = 3.7;
; 002B 0037 
; 002B 0038     //viBatt = (float)((read_adc(14)/viADCDividerMax) * viVoltMaxBatt);                // Battery Read
; 002B 0039 
; 002B 003A     return viBatt;
	SBIW R28,12
	LDI  R24,12
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	LDI  R30,LOW(_0x560007*2)
	LDI  R31,HIGH(_0x560007*2)
	LDI  R22,BYTE3(_0x560007*2)
	CALL __INITLOCB
;	viBatt -> Y+8
;	viADCDividerMax -> Y+4
;	viVoltMaxBatt -> Y+0
	CALL SUBOPT_0x49
	JMP  _0x20E0024
; 002B 003B }
;
;float iStatusReadMainPower(iChar_t viStatusType_arg){
; 002B 003D float iStatusReadMainPower(iChar_t viStatusType_arg){
; 002B 003E      float viMainPwr = 0.0;
; 002B 003F      if(MAIN_POWER_CONNECT){
;	viStatusType_arg -> Y+4
;	viMainPwr -> Y+0
; 002B 0040          viMainPwr = 1.0;
; 002B 0041      }else{
; 002B 0042          viMainPwr = 0.0;
; 002B 0043      }
; 002B 0044      return viMainPwr;
; 002B 0045 }
;
;float iStatusReadSDCard(iChar_t viStatusType_arg){
; 002B 0047 float iStatusReadSDCard(iChar_t viStatusType_arg){
; 002B 0048      float viReturn = 0.0;
; 002B 0049 
; 002B 004A      return viReturn;
;	viStatusType_arg -> Y+4
;	viReturn -> Y+0
; 002B 004B }
;
;float iStatusReadLan(iChar_t viStatusType_arg){
; 002B 004D float iStatusReadLan(iChar_t viStatusType_arg){
; 002B 004E      float viReturn = 0.0;
; 002B 004F 
; 002B 0050      return viReturn;
;	viStatusType_arg -> Y+4
;	viReturn -> Y+0
; 002B 0051 }
;
;float iStatusReadWifi(iChar_t viStatusType_arg){
; 002B 0053 float iStatusReadWifi(iChar_t viStatusType_arg){
; 002B 0054      float viReturn = 0.0;
; 002B 0055 
; 002B 0056      return viReturn;
;	viStatusType_arg -> Y+4
;	viReturn -> Y+0
; 002B 0057 }
;
;float iStatusReadDI0(iChar_t viStatusType_arg){
; 002B 0059 float iStatusReadDI0(iChar_t viStatusType_arg){
; 002B 005A      float viReturn = 0.0;
; 002B 005B 
; 002B 005C      return viReturn;
;	viStatusType_arg -> Y+4
;	viReturn -> Y+0
; 002B 005D }
;
;float iStatusReadDI1(iChar_t viStatusType_arg){
; 002B 005F float iStatusReadDI1(iChar_t viStatusType_arg){
; 002B 0060      float viReturn = 0.0;
; 002B 0061 
; 002B 0062      return viReturn;
;	viStatusType_arg -> Y+4
;	viReturn -> Y+0
; 002B 0063 }
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif

	.DSEG

	.CSEG
_wait_ready_G100:
	ST   -Y,R17
	LDI  R30,LOW(50)
	STS  _timer2_G100,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000004:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000004
_0x2000008:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200000A:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200000A
	IN   R17,46
	CPI  R17,255
	BREQ _0x200000D
	LDS  R30,_timer2_G100
	CPI  R30,0
	BRNE _0x200000E
_0x200000D:
	RJMP _0x2000009
_0x200000E:
	RJMP _0x2000008
_0x2000009:
	MOV  R30,R17
	LD   R17,Y+
	RET
_release_spi_G100:
	SBI  0x5,0
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200000F:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200000F
	RET
_rx_datablock_G100:
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR4
	LDI  R30,LOW(10)
	STS  _timer1_G100,R30
_0x2000013:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000015:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000015
	IN   R17,46
	CPI  R17,255
	BRNE _0x2000018
	LDS  R30,_timer1_G100
	CPI  R30,0
	BRNE _0x2000019
_0x2000018:
	RJMP _0x2000014
_0x2000019:
	RJMP _0x2000013
_0x2000014:
	CPI  R17,254
	BREQ _0x200001A
	LDI  R30,LOW(0)
	CALL __LOADLOCR4
	RJMP _0x20E0025
_0x200001A:
	__GETWRS 18,19,6
_0x200001C:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200001E:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200001E
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000021:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000021
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000024:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000024
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000027:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000027
	PUSH R19
	PUSH R18
	__ADDWRN 18,19,1
	IN   R30,0x2E
	POP  R26
	POP  R27
	ST   X,R30
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	SBIW R30,4
	STD  Y+4,R30
	STD  Y+4+1,R31
	BRNE _0x200001C
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200002A:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200002A
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200002D:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200002D
	LDI  R30,LOW(1)
	CALL __LOADLOCR4
	RJMP _0x20E0025
_tx_datablock_G100:
	ST   -Y,R26
	CALL __SAVELOCR4
	RCALL _wait_ready_G100
	CPI  R30,LOW(0xFF)
	BREQ _0x2000030
	LDI  R30,LOW(0)
	CALL __LOADLOCR4
	RJMP _0x20E0026
_0x2000030:
	LDD  R30,Y+4
	OUT  0x2E,R30
_0x2000031:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000031
	LDD  R26,Y+4
	CPI  R26,LOW(0xFD)
	BREQ _0x2000034
	LDI  R16,LOW(0)
	__GETWRS 18,19,5
_0x2000036:
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R30,X
	OUT  0x2E,R30
_0x2000038:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000038
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R30,X
	OUT  0x2E,R30
_0x200003B:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200003B
	SUBI R16,LOW(1)
	CPI  R16,0
	BRNE _0x2000036
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200003E:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200003E
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000041:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000041
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000044:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000044
	IN   R17,46
	MOV  R30,R17
	ANDI R30,LOW(0x1F)
	CPI  R30,LOW(0x5)
	BREQ _0x2000047
	LDI  R30,LOW(0)
	CALL __LOADLOCR4
	RJMP _0x20E0026
_0x2000047:
_0x2000034:
	LDI  R30,LOW(1)
	CALL __LOADLOCR4
	RJMP _0x20E0026
_send_cmd_G100:
	CALL __PUTPARD2
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+6
	ANDI R30,LOW(0x80)
	BREQ _0x2000048
	LDD  R30,Y+6
	ANDI R30,0x7F
	STD  Y+6,R30
	LDI  R30,LOW(119)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	MOV  R16,R30
	CPI  R16,2
	BRLO _0x2000049
	MOV  R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0026
_0x2000049:
_0x2000048:
	SBI  0x5,0
	CBI  0x5,0
	RCALL _wait_ready_G100
	CPI  R30,LOW(0xFF)
	BREQ _0x200004A
	LDI  R30,LOW(255)
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0026
_0x200004A:
	LDD  R30,Y+6
	OUT  0x2E,R30
_0x200004B:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200004B
	LDD  R30,Y+5
	OUT  0x2E,R30
_0x200004E:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200004E
	LDD  R30,Y+4
	OUT  0x2E,R30
_0x2000051:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000051
	LDD  R30,Y+3
	OUT  0x2E,R30
_0x2000054:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000054
	LDD  R30,Y+2
	OUT  0x2E,R30
_0x2000057:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000057
	LDI  R17,LOW(1)
	LDD  R26,Y+6
	CPI  R26,LOW(0x40)
	BRNE _0x200005A
	LDI  R17,LOW(149)
	RJMP _0x200005B
_0x200005A:
	LDD  R26,Y+6
	CPI  R26,LOW(0x48)
	BRNE _0x200005C
	LDI  R17,LOW(135)
_0x200005C:
_0x200005B:
	OUT  0x2E,R17
_0x200005D:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200005D
	LDD  R26,Y+6
	CPI  R26,LOW(0x4C)
	BRNE _0x2000060
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000061:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000061
_0x2000060:
	LDI  R17,LOW(255)
_0x2000065:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x2000067:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x2000067
	IN   R16,46
	SBRS R16,7
	RJMP _0x200006A
	SUBI R17,LOW(1)
	CPI  R17,0
	BRNE _0x200006B
_0x200006A:
	RJMP _0x2000066
_0x200006B:
	RJMP _0x2000065
_0x2000066:
	MOV  R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20E0026
_rx_spi4_G100:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	LDI  R17,4
_0x200006D:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200006F:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200006F
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,1
	STD  Y+1,R26
	STD  Y+1+1,R27
	SBIW R26,1
	IN   R30,0x2E
	ST   X,R30
	SUBI R17,LOW(1)
	CPI  R17,0
	BRNE _0x200006D
	RJMP _0x20E0021
_disk_initialize:
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
	LDD  R30,Y+8
	CPI  R30,0
	BREQ _0x2000072
	LDI  R30,LOW(1)
	RJMP _0x20E002A
_0x2000072:
	CBI  0x1,0
	CBI  0x1,1
	LDI  R30,LOW(10)
	STS  _timer1_G100,R30
_0x2000073:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BRNE _0x2000073
	LDS  R30,_status_G100
	ANDI R30,LOW(0x2)
	BREQ _0x2000076
	RJMP _0x20E0029
_0x2000076:
	SBI  0x4,0
	SBI  0x5,0
	IN   R30,0x5
	ANDI R30,LOW(0xF9)
	OUT  0x5,R30
	SBI  0x5,3
	CBI  0x4,3
	IN   R30,0x4
	ORI  R30,LOW(0x7)
	OUT  0x4,R30
	LDI  R30,LOW(82)
	OUT  0x2C,R30
	LDI  R30,LOW(0)
	OUT  0x2D,R30
	LDI  R19,LOW(255)
_0x2000078:
	LDI  R17,LOW(10)
_0x200007B:
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x200007D:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x200007D
	SUBI R17,LOW(1)
	CPI  R17,0
	BRNE _0x200007B
	LDI  R30,LOW(64)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	MOV  R16,R30
	SUBI R19,LOW(1)
	CPI  R16,1
	BREQ _0x2000080
	CPI  R19,0
	BRNE _0x2000081
_0x2000080:
	RJMP _0x2000079
_0x2000081:
	RJMP _0x2000078
_0x2000079:
	LDI  R19,LOW(0)
	CPI  R16,1
	BREQ PC+3
	JMP _0x2000082
	LDI  R30,LOW(100)
	STS  _timer1_G100,R30
	LDI  R30,LOW(72)
	ST   -Y,R30
	__GETD2N 0x1AA
	RCALL _send_cmd_G100
	CPI  R30,LOW(0x1)
	BRNE _0x2000083
	MOVW R26,R28
	ADIW R26,4
	RCALL _rx_spi4_G100
	LDD  R26,Y+6
	CPI  R26,LOW(0x1)
	BRNE _0x2000085
	LDD  R26,Y+7
	CPI  R26,LOW(0xAA)
	BREQ _0x2000086
_0x2000085:
	RJMP _0x2000084
_0x2000086:
_0x2000087:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x200008A
	LDI  R30,LOW(233)
	ST   -Y,R30
	__GETD2N 0x40000000
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x200008B
_0x200008A:
	RJMP _0x2000089
_0x200008B:
	RJMP _0x2000087
_0x2000089:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x200008D
	LDI  R30,LOW(122)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BREQ _0x200008E
_0x200008D:
	RJMP _0x200008C
_0x200008E:
	MOVW R26,R28
	ADIW R26,4
	RCALL _rx_spi4_G100
	LDD  R30,Y+4
	ANDI R30,LOW(0x40)
	BREQ _0x200008F
	LDI  R30,LOW(12)
	RJMP _0x2000090
_0x200008F:
	LDI  R30,LOW(4)
_0x2000090:
	MOV  R19,R30
_0x200008C:
_0x2000084:
	RJMP _0x2000092
_0x2000083:
	LDI  R30,LOW(233)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,LOW(0x2)
	BRSH _0x2000093
	LDI  R19,LOW(2)
	LDI  R16,LOW(233)
	RJMP _0x2000094
_0x2000093:
	LDI  R19,LOW(1)
	LDI  R16,LOW(65)
_0x2000094:
_0x2000095:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x2000098
	ST   -Y,R16
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x2000099
_0x2000098:
	RJMP _0x2000097
_0x2000099:
	RJMP _0x2000095
_0x2000097:
	LDS  R30,_timer1_G100
	CPI  R30,0
	BREQ _0x200009B
	LDI  R30,LOW(80)
	ST   -Y,R30
	__GETD2N 0x200
	RCALL _send_cmd_G100
	CPI  R30,0
	BREQ _0x200009A
_0x200009B:
	LDI  R19,LOW(0)
_0x200009A:
_0x2000092:
_0x2000082:
	STS  _card_type_G100,R19
	RCALL _release_spi_G100
	CPI  R19,0
	BREQ _0x200009D
	LDS  R30,_status_G100
	ANDI R30,0xFE
	STS  _status_G100,R30
	LDI  R30,LOW(80)
	OUT  0x2C,R30
	LDI  R30,LOW(1)
	OUT  0x2D,R30
	RJMP _0x200009E
_0x200009D:
	CBI  0x5,0
	RCALL _wait_ready_G100
	RCALL _release_spi_G100
	LDI  R30,LOW(0)
	OUT  0x2C,R30
	IN   R30,0x4
	ANDI R30,LOW(0xF0)
	OUT  0x4,R30
	IN   R30,0x5
	ANDI R30,LOW(0xF0)
	OUT  0x5,R30
	CBI  0x4,0
	LDS  R30,_status_G100
	ORI  R30,1
	STS  _status_G100,R30
_0x200009E:
_0x20E0029:
	LDS  R30,_status_G100
_0x20E002A:
	CALL __LOADLOCR4
	ADIW R28,9
	RET
_disk_status:
	ST   -Y,R26
	LD   R30,Y
	CPI  R30,0
	BREQ _0x200009F
	LDI  R30,LOW(1)
	RJMP _0x20E0028
_0x200009F:
	LDS  R30,_status_G100
_0x20E0028:
	ADIW R28,1
	RET
_disk_read:
	ST   -Y,R26
	LDD  R30,Y+7
	CPI  R30,0
	BRNE _0x20000A1
	LD   R30,Y
	CPI  R30,0
	BRNE _0x20000A0
_0x20000A1:
	LDI  R30,LOW(4)
	RJMP _0x20E0025
_0x20000A0:
	LDS  R30,_status_G100
	ANDI R30,LOW(0x1)
	BREQ _0x20000A3
	LDI  R30,LOW(3)
	RJMP _0x20E0025
_0x20000A3:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x8)
	BRNE _0x20000A4
	__GETD1S 1
	__GETD2N 0x200
	CALL __MULD12U
	__PUTD1S 1
_0x20000A4:
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRNE _0x20000A5
	LDI  R30,LOW(81)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000A7
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000A8
_0x20000A7:
	RJMP _0x20000A6
_0x20000A8:
	LDI  R30,LOW(0)
	ST   Y,R30
_0x20000A6:
	RJMP _0x20000A9
_0x20000A5:
	LDI  R30,LOW(82)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000AA
_0x20000AC:
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	RCALL _rx_datablock_G100
	CPI  R30,0
	BREQ _0x20000AD
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	SUBI R30,LOW(-512)
	SBCI R31,HIGH(-512)
	STD  Y+5,R30
	STD  Y+5+1,R31
	LD   R30,Y
	SUBI R30,LOW(1)
	ST   Y,R30
	BRNE _0x20000AC
_0x20000AD:
	LDI  R30,LOW(76)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
_0x20000AA:
_0x20000A9:
	RCALL _release_spi_G100
	LD   R30,Y
	CPI  R30,0
	BREQ _0x20000AF
	LDI  R30,LOW(1)
	RJMP _0x20000B0
_0x20000AF:
	LDI  R30,LOW(0)
_0x20000B0:
	RJMP _0x20E0025
_disk_write:
	ST   -Y,R26
	LDD  R30,Y+7
	CPI  R30,0
	BRNE _0x20000B3
	LD   R30,Y
	CPI  R30,0
	BRNE _0x20000B2
_0x20000B3:
	LDI  R30,LOW(4)
	RJMP _0x20E0025
_0x20000B2:
	LDS  R30,_status_G100
	ANDI R30,LOW(0x1)
	BREQ _0x20000B5
	LDI  R30,LOW(3)
	RJMP _0x20E0025
_0x20000B5:
	LDS  R30,_status_G100
	ANDI R30,LOW(0x4)
	BREQ _0x20000B6
	LDI  R30,LOW(2)
	RJMP _0x20E0025
_0x20000B6:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x8)
	BRNE _0x20000B7
	__GETD1S 1
	__GETD2N 0x200
	CALL __MULD12U
	__PUTD1S 1
_0x20000B7:
	LD   R26,Y
	CPI  R26,LOW(0x1)
	BRNE _0x20000B8
	LDI  R30,LOW(88)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000BA
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(254)
	RCALL _tx_datablock_G100
	CPI  R30,0
	BRNE _0x20000BB
_0x20000BA:
	RJMP _0x20000B9
_0x20000BB:
	LDI  R30,LOW(0)
	ST   Y,R30
_0x20000B9:
	RJMP _0x20000BC
_0x20000B8:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x6)
	BREQ _0x20000BD
	LDI  R30,LOW(215)
	ST   -Y,R30
	LDD  R26,Y+1
	CLR  R27
	CLR  R24
	CLR  R25
	RCALL _send_cmd_G100
_0x20000BD:
	LDI  R30,LOW(89)
	ST   -Y,R30
	__GETD2S 2
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000BE
_0x20000C0:
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(252)
	RCALL _tx_datablock_G100
	CPI  R30,0
	BREQ _0x20000C1
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	SUBI R30,LOW(-512)
	SBCI R31,HIGH(-512)
	STD  Y+5,R30
	STD  Y+5+1,R31
	LD   R30,Y
	SUBI R30,LOW(1)
	ST   Y,R30
	BRNE _0x20000C0
_0x20000C1:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(253)
	RCALL _tx_datablock_G100
	CPI  R30,0
	BRNE _0x20000C3
	LDI  R30,LOW(1)
	ST   Y,R30
_0x20000C3:
_0x20000BE:
_0x20000BC:
	RCALL _release_spi_G100
	LD   R30,Y
	CPI  R30,0
	BREQ _0x20000C4
	LDI  R30,LOW(1)
	RJMP _0x20000C5
_0x20000C4:
	LDI  R30,LOW(0)
_0x20000C5:
	RJMP _0x20E0025
_disk_ioctl:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,16
	CALL __SAVELOCR6
	LDD  R30,Y+25
	CPI  R30,0
	BREQ _0x20000C7
	LDI  R30,LOW(4)
	RJMP _0x20E0027
_0x20000C7:
	LDI  R17,LOW(1)
	LDS  R30,_status_G100
	ANDI R30,LOW(0x1)
	BREQ _0x20000C8
	LDI  R30,LOW(3)
	RJMP _0x20E0027
_0x20000C8:
	__GETWRS 20,21,22
	LDD  R30,Y+24
	CPI  R30,0
	BRNE _0x20000CC
	CBI  0x5,0
	RCALL _wait_ready_G100
	CPI  R30,LOW(0xFF)
	BRNE _0x20000CD
	LDI  R17,LOW(0)
_0x20000CD:
	RJMP _0x20000CB
_0x20000CC:
	CPI  R30,LOW(0x1)
	BREQ PC+3
	JMP _0x20000CE
	LDI  R30,LOW(73)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000D0
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000D1
_0x20000D0:
	RJMP _0x20000CF
_0x20000D1:
	LDD  R30,Y+6
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	LSR  R30
	CPI  R30,LOW(0x1)
	BRNE _0x20000D2
	LDI  R30,0
	LDD  R31,Y+14
	LDD  R26,Y+15
	LDI  R27,0
	ADD  R30,R26
	ADC  R31,R27
	ADIW R30,1
	MOVW R18,R30
	MOVW R26,R18
	CLR  R24
	CLR  R25
	LDI  R30,LOW(10)
	RJMP _0x2000101
_0x20000D2:
	LDD  R30,Y+11
	ANDI R30,LOW(0xF)
	MOV  R26,R30
	LDD  R30,Y+16
	ANDI R30,LOW(0x80)
	ROL  R30
	LDI  R30,0
	ROL  R30
	ADD  R26,R30
	LDD  R30,Y+15
	ANDI R30,LOW(0x3)
	LSL  R30
	ADD  R30,R26
	SUBI R30,-LOW(2)
	MOV  R16,R30
	LDD  R30,Y+14
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	LSR  R30
	MOV  R26,R30
	LDD  R30,Y+13
	LDI  R31,0
	CALL __LSLW2
	LDI  R27,0
	ADD  R26,R30
	ADC  R27,R31
	LDD  R30,Y+12
	ANDI R30,LOW(0x3)
	LDI  R31,0
	CALL __LSLW2
	MOV  R31,R30
	LDI  R30,0
	ADD  R30,R26
	ADC  R31,R27
	ADIW R30,1
	MOVW R18,R30
	MOVW R26,R18
	CLR  R24
	CLR  R25
	MOV  R30,R16
	SUBI R30,LOW(9)
_0x2000101:
	CALL __LSLD12
	MOVW R26,R20
	CALL __PUTDP1
	LDI  R17,LOW(0)
_0x20000CF:
	RJMP _0x20000CB
_0x20000CE:
	CPI  R30,LOW(0x2)
	BRNE _0x20000D4
	MOVW R26,R20
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	ST   X+,R30
	ST   X,R31
	LDI  R17,LOW(0)
	RJMP _0x20000CB
_0x20000D4:
	CPI  R30,LOW(0x3)
	BREQ PC+3
	JMP _0x20000D5
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x4)
	BREQ _0x20000D6
	LDI  R30,LOW(205)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000D7
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x20000D8:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x20000D8
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BREQ _0x20000DB
	LDI  R16,LOW(48)
_0x20000DD:
	CPI  R16,0
	BREQ _0x20000DE
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x20000DF:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x20000DF
	SUBI R16,1
	RJMP _0x20000DD
_0x20000DE:
	LDD  R30,Y+16
	SWAP R30
	ANDI R30,0xF
	__GETD2N 0x10
	CALL __LSLD12
	MOVW R26,R20
	CALL __PUTDP1
	LDI  R17,LOW(0)
_0x20000DB:
_0x20000D7:
	RJMP _0x20000E2
_0x20000D6:
	LDI  R30,LOW(73)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000E4
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000E5
_0x20000E4:
	RJMP _0x20000E3
_0x20000E5:
	LDS  R30,_card_type_G100
	ANDI R30,LOW(0x2)
	BREQ _0x20000E6
	LDD  R30,Y+16
	ANDI R30,LOW(0x3F)
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __LSLD1
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+17
	ANDI R30,LOW(0x80)
	CLR  R31
	CLR  R22
	CLR  R23
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(7)
	CALL __LSRD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ADDD12
	__ADDD1N 1
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+19
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	LSR  R30
	SUBI R30,LOW(1)
	CALL __LSLD12
	RJMP _0x2000102
_0x20000E6:
	LDD  R30,Y+16
	ANDI R30,LOW(0x7C)
	LSR  R30
	LSR  R30
	CLR  R31
	CLR  R22
	CLR  R23
	__ADDD1N 1
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+17
	ANDI R30,LOW(0x3)
	CLR  R31
	CLR  R22
	CLR  R23
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(3)
	CALL __LSLD12
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+17
	ANDI R30,LOW(0xE0)
	SWAP R30
	ANDI R30,0xF
	LSR  R30
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __ADDD12
	__ADDD1N 1
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __MULD12U
_0x2000102:
	MOVW R26,R20
	CALL __PUTDP1
	LDI  R17,LOW(0)
_0x20000E3:
_0x20000E2:
	RJMP _0x20000CB
_0x20000D5:
	CPI  R30,LOW(0xA)
	BRNE _0x20000E8
	LDS  R30,_card_type_G100
	MOVW R26,R20
	ST   X,R30
	LDI  R17,LOW(0)
	RJMP _0x20000CB
_0x20000E8:
	CPI  R30,LOW(0xB)
	BRNE _0x20000E9
	LDI  R30,LOW(73)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000EB
	ST   -Y,R21
	ST   -Y,R20
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000EC
_0x20000EB:
	RJMP _0x20000EA
_0x20000EC:
	LDI  R17,LOW(0)
_0x20000EA:
	RJMP _0x20000CB
_0x20000E9:
	CPI  R30,LOW(0xC)
	BRNE _0x20000ED
	LDI  R30,LOW(74)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000EF
	ST   -Y,R21
	ST   -Y,R20
	LDI  R26,LOW(16)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BRNE _0x20000F0
_0x20000EF:
	RJMP _0x20000EE
_0x20000F0:
	LDI  R17,LOW(0)
_0x20000EE:
	RJMP _0x20000CB
_0x20000ED:
	CPI  R30,LOW(0xD)
	BRNE _0x20000F1
	LDI  R30,LOW(122)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000F2
	MOVW R26,R20
	RCALL _rx_spi4_G100
	LDI  R17,LOW(0)
_0x20000F2:
	RJMP _0x20000CB
_0x20000F1:
	CPI  R30,LOW(0xE)
	BRNE _0x20000F9
	LDI  R30,LOW(205)
	ST   -Y,R30
	__GETD2N 0x0
	RCALL _send_cmd_G100
	CPI  R30,0
	BRNE _0x20000F4
	LDI  R30,LOW(255)
	OUT  0x2E,R30
_0x20000F5:
	IN   R30,0x2D
	SBRS R30,7
	RJMP _0x20000F5
	ST   -Y,R21
	ST   -Y,R20
	LDI  R26,LOW(64)
	LDI  R27,0
	RCALL _rx_datablock_G100
	CPI  R30,0
	BREQ _0x20000F8
	LDI  R17,LOW(0)
_0x20000F8:
_0x20000F4:
	RJMP _0x20000CB
_0x20000F9:
	LDI  R17,LOW(4)
_0x20000CB:
	RCALL _release_spi_G100
	MOV  R30,R17
_0x20E0027:
	CALL __LOADLOCR6
	ADIW R28,26
	RET
_disk_timerproc:
	ST   -Y,R17
	ST   -Y,R16
	LDS  R17,_timer1_G100
	CPI  R17,0
	BREQ _0x20000FA
	SUBI R17,LOW(1)
	STS  _timer1_G100,R17
_0x20000FA:
	LDS  R17,_timer2_G100
	CPI  R17,0
	BREQ _0x20000FB
	SUBI R17,LOW(1)
	STS  _timer2_G100,R17
_0x20000FB:
	LDS  R17,_pv_S100000B000
	IN   R30,0x0
	ANDI R30,LOW(0x2)
	MOV  R26,R30
	IN   R30,0x0
	ANDI R30,LOW(0x1)
	OR   R30,R26
	STS  _pv_S100000B000,R30
	CP   R30,R17
	BRNE _0x20000FC
	LDS  R16,_status_G100
	ANDI R30,LOW(0x2)
	BREQ _0x20000FD
	ORI  R16,LOW(4)
	RJMP _0x20000FE
_0x20000FD:
	ANDI R16,LOW(251)
_0x20000FE:
	LDS  R30,_pv_S100000B000
	ANDI R30,LOW(0x1)
	BREQ _0x20000FF
	ORI  R16,LOW(3)
	RJMP _0x2000100
_0x20000FF:
	ANDI R16,LOW(253)
_0x2000100:
	STS  _status_G100,R16
_0x20000FC:
	LD   R16,Y+
	LD   R17,Y+
	RET

	.CSEG
_get_fattime:
	SBIW R28,7
	LDS  R26,_prtc_get_time
	LDS  R27,_prtc_get_time+1
	LDS  R24,_prtc_get_time+2
	LDS  R25,_prtc_get_time+3
	CALL __CPD02
	BREQ _0x2020004
	LDS  R26,_prtc_get_date
	LDS  R27,_prtc_get_date+1
	LDS  R24,_prtc_get_date+2
	LDS  R25,_prtc_get_date+3
	CALL __CPD02
	BRNE _0x2020003
_0x2020004:
	__GETD1N 0x3A210000
	RJMP _0x20E0026
_0x2020003:
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,7
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,8
	__CALL1MN _prtc_get_time,0
	MOVW R30,R28
	ADIW R30,3
	CALL SUBOPT_0x5D
	MOVW R26,R28
	ADIW R26,4
	__CALL1MN _prtc_get_date,0
	LD   R30,Y
	LDD  R31,Y+1
	SUBI R30,LOW(1980)
	SBCI R31,HIGH(1980)
	CLR  R22
	CLR  R23
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(25)
	CALL __LSLD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+2
	CALL SUBOPT_0x96
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(21)
	CALL __LSLD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ORD12
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+3
	CALL SUBOPT_0x96
	CALL __LSLD16
	CALL __ORD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+6
	CALL SUBOPT_0x96
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(11)
	CALL __LSLD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ORD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R30,Y+5
	CALL SUBOPT_0x96
	MOVW R26,R30
	MOVW R24,R22
	LDI  R30,LOW(5)
	CALL __LSLD12
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ORD12
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+4
	LDI  R31,0
	ASR  R31
	ROR  R30
	CALL __CWD1
	CALL __ORD12
_0x20E0026:
	ADIW R28,7
	RET
_mem_cpy_G101:
	CALL SUBOPT_0x4C
	__GETWRS 16,17,8
	__GETWRS 18,19,6
_0x2020006:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	SBIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	ADIW R30,1
	BREQ _0x2020008
	PUSH R17
	PUSH R16
	__ADDWRN 16,17,1
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R30,X
	POP  R26
	POP  R27
	ST   X,R30
	RJMP _0x2020006
_0x2020008:
	CALL __LOADLOCR4
	RJMP _0x20E001E
_mem_set_G101:
	CALL SUBOPT_0x5E
	__GETWRS 16,17,6
_0x202000C:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,1
	STD  Y+2,R30
	STD  Y+2+1,R31
	ADIW R30,1
	BREQ _0x202000E
	PUSH R17
	PUSH R16
	__ADDWRN 16,17,1
	LDD  R30,Y+4
	POP  R26
	POP  R27
	ST   X,R30
	RJMP _0x202000C
_0x202000E:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E0025:
	ADIW R28,8
	RET
_mem_cmp_G101:
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR6
	__GETWRS 16,17,10
	__GETWRS 18,19,8
	__GETWRN 20,21,0
_0x202000F:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,1
	STD  Y+6,R30
	STD  Y+6+1,R31
	ADIW R30,1
	BREQ _0x2020012
	MOVW R26,R16
	__ADDWRN 16,17,1
	LD   R0,X
	CLR  R1
	MOVW R26,R18
	__ADDWRN 18,19,1
	LD   R26,X
	CLR  R27
	MOVW R30,R0
	SUB  R30,R26
	SBC  R31,R27
	MOVW R20,R30
	SBIW R30,0
	BREQ _0x2020013
_0x2020012:
	RJMP _0x2020011
_0x2020013:
	RJMP _0x202000F
_0x2020011:
	MOVW R30,R20
	CALL __LOADLOCR6
_0x20E0024:
	ADIW R28,12
	RET
_chk_chrf_G101:
	ST   -Y,R27
	ST   -Y,R26
_0x2020014:
	CALL SUBOPT_0x33
	__GETBRPF 30
	CPI  R30,0
	BREQ _0x2020017
	CALL SUBOPT_0x33
	__GETBRPF 26
	LD   R30,Y
	LDD  R31,Y+1
	LDI  R27,0
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x2020018
_0x2020017:
	RJMP _0x2020016
_0x2020018:
	MOVW R26,R28
	ADIW R26,2
	CALL SUBOPT_0x97
	RJMP _0x2020014
_0x2020016:
	CALL SUBOPT_0x33
	__GETBRPF 30
	LDI  R31,0
_0x20E0023:
	ADIW R28,6
	RET
_move_window_G101:
	CALL __PUTPARD2
	SBIW R28,4
	ST   -Y,R17
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,46
	CALL SUBOPT_0x98
	CALL SUBOPT_0x99
	CALL SUBOPT_0x58
	CALL __CPD12
	BRNE PC+3
	JMP _0x2020019
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R30,Z+4
	CPI  R30,0
	BREQ _0x202001A
	CALL SUBOPT_0x9A
	CPI  R30,0
	BREQ _0x202001B
	LDI  R30,LOW(1)
	RJMP _0x20E0022
_0x202001B:
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,4
	LDI  R30,LOW(0)
	ST   X,R30
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	CALL SUBOPT_0x9B
	MOVW R0,R26
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,26
	CALL __GETD1P
	MOVW R26,R0
	CALL __ADDD12
	CALL SUBOPT_0x58
	CALL __CPD21
	BRSH _0x202001C
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R17,Z+3
_0x202001E:
	CPI  R17,2
	BRLO _0x202001F
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,26
	CALL __GETD1P
	CALL SUBOPT_0x58
	CALL __ADDD12
	__PUTD1S 1
	CALL SUBOPT_0x9A
	SUBI R17,1
	RJMP _0x202001E
_0x202001F:
_0x202001C:
_0x202001A:
	CALL SUBOPT_0x99
	CALL __CPD10
	BREQ _0x2020020
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	ADIW R30,50
	CALL SUBOPT_0x9C
	BREQ _0x2020021
	LDI  R30,LOW(1)
	RJMP _0x20E0022
_0x2020021:
	CALL SUBOPT_0x99
	__PUTD1SNS 9,46
_0x2020020:
_0x2020019:
	LDI  R30,LOW(0)
_0x20E0022:
	LDD  R17,Y+0
	ADIW R28,11
	RET
_sync_G101:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	CALL SUBOPT_0x9D
	MOV  R17,R30
	CPI  R17,0
	BREQ PC+3
	JMP _0x2020022
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R26,X
	CPI  R26,LOW(0x3)
	BRNE _0x2020024
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	LDD  R30,Z+5
	CPI  R30,0
	BRNE _0x2020025
_0x2020024:
	RJMP _0x2020023
_0x2020025:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,46
	CALL SUBOPT_0x9E
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x7C
	CALL SUBOPT_0x9F
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	SUBI R30,LOW(-510)
	SBCI R31,HIGH(-510)
	LDI  R26,LOW(43605)
	LDI  R27,HIGH(43605)
	STD  Z+0,R26
	STD  Z+1,R27
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	__GETD2N 0x41615252
	CALL SUBOPT_0xA0
	SUBI R30,LOW(-484)
	SBCI R31,HIGH(-484)
	__GETD2N 0x61417272
	CALL SUBOPT_0xA0
	SUBI R30,LOW(-488)
	SBCI R31,HIGH(-488)
	MOVW R0,R30
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,14
	CALL SUBOPT_0xA1
	ADIW R30,50
	SUBI R30,LOW(-492)
	SBCI R31,HIGH(-492)
	MOVW R0,R30
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,10
	CALL SUBOPT_0xA1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0xA2
	RCALL _disk_write
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	ADIW R26,5
	LDI  R30,LOW(0)
	ST   X,R30
_0x2020023:
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	RCALL _disk_ioctl
	CPI  R30,0
	BREQ _0x2020026
	LDI  R17,LOW(1)
_0x2020026:
_0x2020022:
	MOV  R30,R17
_0x20E0021:
	LDD  R17,Y+0
	ADIW R28,3
	RET
_get_fat:
	CALL __PUTPARD2
	SBIW R28,4
	CALL __SAVELOCR4
	CALL SUBOPT_0xA3
	CALL SUBOPT_0xA4
	BRLO _0x2020028
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,30
	CALL __GETD1P
	CALL SUBOPT_0xA3
	CALL __CPD21
	BRLO _0x2020027
_0x2020028:
	CALL SUBOPT_0xA5
	RJMP _0x20E0020
_0x2020027:
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,34
	CALL SUBOPT_0xA6
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	CALL SUBOPT_0x95
	BRNE _0x202002D
	__GETWRS 18,19,8
	MOVW R30,R18
	LSR  R31
	ROR  R30
	__ADDWRR 18,19,30,31
	CALL SUBOPT_0x4E
	CALL SUBOPT_0xA7
	BREQ _0x202002E
	RJMP _0x202002C
_0x202002E:
	CALL SUBOPT_0xA8
	LD   R16,X
	CLR  R17
	__ADDWRN 18,19,1
	CALL SUBOPT_0x4E
	CALL SUBOPT_0xA7
	BRNE _0x202002C
	CALL SUBOPT_0xA8
	LD   R30,X
	MOV  R31,R30
	LDI  R30,0
	__ORWRR 16,17,30,31
	LDD  R30,Y+8
	ANDI R30,LOW(0x1)
	BREQ _0x2020030
	MOVW R30,R16
	CALL __LSRW4
	RJMP _0x202022B
_0x2020030:
	MOVW R30,R16
	ANDI R31,HIGH(0xFFF)
_0x202022B:
	CLR  R22
	CLR  R23
	RJMP _0x20E0020
_0x202002D:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x2020033
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x4F
	CALL SUBOPT_0xA9
	CALL SUBOPT_0xAA
	BRNE _0x202002C
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(2)
	CALL SUBOPT_0xAB
	CALL SUBOPT_0xAC
	RJMP _0x20E0020
_0x2020033:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x202002C
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x4F
	CALL SUBOPT_0xAD
	CALL SUBOPT_0xAA
	BRNE _0x202002C
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(4)
	CALL SUBOPT_0xAB
	CALL SUBOPT_0xAE
	RJMP _0x20E0020
_0x202002C:
	CALL SUBOPT_0x16
_0x20E0020:
	CALL __LOADLOCR4
	ADIW R28,14
	RET
_put_fat:
	CALL __PUTPARD2
	SBIW R28,4
	CALL __SAVELOCR6
	CALL SUBOPT_0xAF
	CALL SUBOPT_0xA4
	BRLO _0x2020038
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,30
	CALL __GETD1P
	CALL SUBOPT_0xAF
	CALL __CPD21
	BRLO _0x2020037
_0x2020038:
	LDI  R21,LOW(2)
	RJMP _0x202003A
_0x2020037:
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,34
	CALL __GETD1P
	CALL SUBOPT_0x36
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL SUBOPT_0x95
	BREQ PC+3
	JMP _0x202003E
	__GETWRS 16,17,14
	MOVW R30,R16
	LSR  R31
	ROR  R30
	__ADDWRR 16,17,30,31
	CALL SUBOPT_0xB0
	BREQ _0x202003F
	RJMP _0x202003D
_0x202003F:
	CALL SUBOPT_0xB1
	BREQ _0x2020040
	MOVW R26,R18
	LD   R30,X
	ANDI R30,LOW(0xF)
	MOV  R26,R30
	LDD  R30,Y+10
	LDI  R31,0
	CALL __LSLW4
	OR   R30,R26
	RJMP _0x2020041
_0x2020040:
	LDD  R30,Y+10
_0x2020041:
	MOVW R26,R18
	ST   X,R30
	__ADDWRN 16,17,1
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	CALL SUBOPT_0xB0
	BREQ _0x2020043
	RJMP _0x202003D
_0x2020043:
	CALL SUBOPT_0xB1
	BREQ _0x2020044
	CALL SUBOPT_0x4F
	LDI  R30,LOW(4)
	CALL __LSRD12
	CLR  R31
	CLR  R22
	CLR  R23
	RJMP _0x2020045
_0x2020044:
	MOVW R26,R18
	LD   R30,X
	ANDI R30,LOW(0xF0)
	MOV  R1,R30
	CALL SUBOPT_0x4F
	LDI  R30,LOW(8)
	CALL __LSRD12
	CLR  R31
	CLR  R22
	CLR  R23
	ANDI R30,LOW(0xF)
	OR   R30,R1
_0x2020045:
	MOVW R26,R18
	ST   X,R30
	RJMP _0x202003D
_0x202003E:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x2020047
	CALL SUBOPT_0xB2
	CALL SUBOPT_0xA9
	CALL SUBOPT_0xB3
	BRNE _0x202003D
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	LDI  R30,LOW(2)
	CALL SUBOPT_0xB4
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	STD  Z+0,R26
	STD  Z+1,R27
	RJMP _0x202003D
_0x2020047:
	CPI  R30,LOW(0x3)
	LDI  R26,HIGH(0x3)
	CPC  R31,R26
	BRNE _0x202004B
	CALL SUBOPT_0xB2
	CALL SUBOPT_0xAD
	CALL SUBOPT_0xB3
	BRNE _0x202003D
	LDD  R26,Y+14
	LDD  R27,Y+14+1
	LDI  R30,LOW(4)
	CALL SUBOPT_0xB4
	CALL SUBOPT_0x4F
	CALL SUBOPT_0xB5
	RJMP _0x202003D
_0x202004B:
	LDI  R21,LOW(2)
_0x202003D:
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
_0x202003A:
	MOV  R30,R21
	CALL __LOADLOCR6
	ADIW R28,20
	RET
_remove_chain_G101:
	CALL __PUTPARD2
	SBIW R28,4
	ST   -Y,R17
	CALL SUBOPT_0xB6
	CALL SUBOPT_0xA4
	BRLO _0x202004D
	CALL SUBOPT_0xB7
	BRLO _0x202004C
_0x202004D:
	LDI  R17,LOW(2)
	RJMP _0x202004F
_0x202004C:
	LDI  R17,LOW(0)
_0x2020050:
	CALL SUBOPT_0xB7
	BRLO PC+3
	JMP _0x2020052
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	ST   -Y,R31
	ST   -Y,R30
	__GETD2S 7
	RCALL _get_fat
	__PUTD1S 1
	CALL SUBOPT_0xB8
	CALL __CPD10
	BREQ _0x2020052
	CALL SUBOPT_0x58
	CALL SUBOPT_0xB9
	BRNE _0x2020054
	LDI  R17,LOW(2)
	RJMP _0x2020052
_0x2020054:
	CALL SUBOPT_0x58
	CALL SUBOPT_0x47
	BRNE _0x2020055
	LDI  R17,LOW(1)
	RJMP _0x2020052
_0x2020055:
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	ST   -Y,R31
	ST   -Y,R30
	__GETD1S 7
	CALL __PUTPARD1
	CALL SUBOPT_0xBA
	RCALL _put_fat
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x2020052
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	CALL SUBOPT_0xBB
	BREQ _0x2020057
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,14
	CALL SUBOPT_0x1E
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,5
	LDI  R30,LOW(1)
	ST   X,R30
_0x2020057:
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xBC
	RJMP _0x2020050
_0x2020052:
_0x202004F:
	MOV  R30,R17
	LDD  R17,Y+0
	RJMP _0x20E001C
_create_chain_G101:
	CALL __PUTPARD2
	SBIW R28,16
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,30
	CALL __GETD1P
	CALL SUBOPT_0xBD
	CALL SUBOPT_0x4A
	CALL __CPD10
	BRNE _0x2020058
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,10
	CALL SUBOPT_0xA6
	CALL SUBOPT_0x26
	CALL __CPD02
	BREQ _0x202005A
	CALL SUBOPT_0x13
	CALL SUBOPT_0x26
	CALL __CPD21
	BRLO _0x2020059
_0x202005A:
	CALL SUBOPT_0xA5
	CALL SUBOPT_0x25
_0x2020059:
	RJMP _0x202005C
_0x2020058:
	CALL SUBOPT_0xBE
	CALL SUBOPT_0xBF
	CALL SUBOPT_0xC0
	CALL SUBOPT_0xC1
	CALL SUBOPT_0xA4
	BRSH _0x202005D
	CALL SUBOPT_0xA5
	RJMP _0x20E001F
_0x202005D:
	CALL SUBOPT_0x13
	CALL SUBOPT_0xC1
	CALL __CPD21
	BRSH _0x202005E
	CALL SUBOPT_0x71
	RJMP _0x20E001F
_0x202005E:
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x25
_0x202005C:
	CALL SUBOPT_0x15
	CALL SUBOPT_0xC2
_0x2020060:
	CALL SUBOPT_0x49
	CALL SUBOPT_0x3B
	CALL SUBOPT_0xC2
	CALL SUBOPT_0x13
	CALL SUBOPT_0xA3
	CALL __CPD21
	BRLO _0x2020062
	CALL SUBOPT_0xC3
	CALL SUBOPT_0xC2
	CALL SUBOPT_0xC4
	BRSH _0x2020063
	CALL SUBOPT_0x1B
	RJMP _0x20E001F
_0x2020063:
_0x2020062:
	CALL SUBOPT_0xBE
	CALL SUBOPT_0x4F
	CALL SUBOPT_0xC0
	CALL SUBOPT_0xC5
	BREQ _0x2020061
	CALL SUBOPT_0xC6
	BREQ _0x2020066
	CALL SUBOPT_0xC7
	BRNE _0x2020065
_0x2020066:
	CALL SUBOPT_0x71
	RJMP _0x20E001F
_0x2020065:
	CALL SUBOPT_0xC4
	BRNE _0x2020068
	CALL SUBOPT_0x1B
	RJMP _0x20E001F
_0x2020068:
	RJMP _0x2020060
_0x2020061:
	CALL SUBOPT_0xBE
	CALL SUBOPT_0x44
	CALL __PUTPARD1
	__GETD2N 0xFFFFFFF
	RCALL _put_fat
	CPI  R30,0
	BREQ _0x2020069
	CALL SUBOPT_0x16
	RJMP _0x20E001F
_0x2020069:
	CALL SUBOPT_0x4A
	CALL __CPD10
	BREQ _0x202006A
	CALL SUBOPT_0xBE
	CALL SUBOPT_0x42
	CALL __PUTPARD1
	CALL SUBOPT_0xAF
	RCALL _put_fat
	CPI  R30,0
	BREQ _0x202006B
	CALL SUBOPT_0x16
	RJMP _0x20E001F
_0x202006B:
_0x202006A:
	CALL SUBOPT_0x49
	__PUTD1SNS 20,10
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	CALL SUBOPT_0xBB
	BREQ _0x202006C
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,14
	CALL __GETD1P_INC
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	CALL __PUTDP1_DEC
	LDD  R26,Y+20
	LDD  R27,Y+20+1
	ADIW R26,5
	LDI  R30,LOW(1)
	ST   X,R30
_0x202006C:
	CALL SUBOPT_0x49
_0x20E001F:
	ADIW R28,22
	RET
_clust2sect:
	CALL SUBOPT_0x12
	__SUBD1N 2
	CALL SUBOPT_0xBD
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	__GETD2Z 30
	CALL SUBOPT_0xC3
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x19
	CALL __CPD21
	BRLO _0x202006D
	CALL SUBOPT_0x1B
	RJMP _0x20E0018
_0x202006D:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x57
	CALL SUBOPT_0x19
	CALL SUBOPT_0x59
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,42
	CALL __GETD1P
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __ADDD12
	RJMP _0x20E0018
_dir_seek_G101:
	CALL SUBOPT_0x45
	ST   -Y,R16
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	__PUTW1SNS 8,4
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,6
	CALL __GETD1P
	CALL SUBOPT_0x46
	CALL SUBOPT_0xB9
	BREQ _0x202006F
	CALL SUBOPT_0xC8
	CALL SUBOPT_0xC9
	BRLO _0x202006E
_0x202006F:
	LDI  R30,LOW(2)
	RJMP _0x20E001D
_0x202006E:
	CALL SUBOPT_0x33
	CALL __CPD10
	BRNE _0x2020072
	CALL SUBOPT_0xC8
	LD   R26,Z
	CPI  R26,LOW(0x3)
	BREQ _0x2020073
_0x2020072:
	RJMP _0x2020071
_0x2020073:
	CALL SUBOPT_0xC8
	ADIW R30,38
	MOVW R26,R30
	CALL __GETD1P
	CALL SUBOPT_0x32
_0x2020071:
	CALL SUBOPT_0x33
	CALL __CPD10
	BRNE _0x2020074
	CALL SUBOPT_0xCA
	ADIW R30,8
	MOVW R26,R30
	CALL __GETW1P
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x2020075
	LDI  R30,LOW(2)
	RJMP _0x20E001D
_0x2020075:
	CALL SUBOPT_0xC8
	ADIW R30,38
	MOVW R26,R30
	CALL __GETD1P
	RJMP _0x202022C
_0x2020074:
	CALL SUBOPT_0xC8
	LDD  R30,Z+2
	LDI  R26,LOW(16)
	MUL  R30,R26
	MOVW R16,R0
_0x2020077:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CP   R26,R16
	CPC  R27,R17
	BRLO _0x2020079
	CALL SUBOPT_0xC8
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x26
	RCALL _get_fat
	CALL SUBOPT_0x46
	CALL SUBOPT_0x47
	BRNE _0x202007A
	LDI  R30,LOW(1)
	RJMP _0x20E001D
_0x202007A:
	CALL SUBOPT_0x34
	CALL SUBOPT_0xA4
	BRLO _0x202007C
	CALL SUBOPT_0xC8
	CALL SUBOPT_0xC9
	BRLO _0x202007B
_0x202007C:
	LDI  R30,LOW(2)
	RJMP _0x20E001D
_0x202007B:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SUB  R30,R16
	SBC  R31,R17
	STD  Y+6,R30
	STD  Y+6+1,R31
	RJMP _0x2020077
_0x2020079:
	CALL SUBOPT_0xCA
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x26
	RCALL _clust2sect
_0x202022C:
	MOVW R26,R30
	MOVW R24,R22
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL __LSRW4
	CALL SUBOPT_0xCB
	__PUTD1SNS 8,14
	CALL SUBOPT_0xC8
	ADIW R30,50
	MOVW R26,R30
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0xCC
	__PUTW1SNS 8,18
	LDI  R30,LOW(0)
_0x20E001D:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E001E:
	ADIW R28,10
	RET
_dir_next_G101:
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,4
	CALL __GETW1P
	ADIW R30,1
	MOVW R16,R30
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x202007F
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,14
	CALL SUBOPT_0xCD
	BRNE _0x202007E
_0x202007F:
	LDI  R30,LOW(4)
	RJMP _0x20E001B
_0x202007E:
	MOVW R30,R16
	ANDI R30,LOW(0xF)
	BREQ PC+3
	JMP _0x2020081
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,14
	CALL SUBOPT_0x1E
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,10
	CALL SUBOPT_0xCD
	BRNE _0x2020082
	CALL SUBOPT_0xCE
	ADIW R30,8
	MOVW R26,R30
	CALL __GETW1P
	CP   R16,R30
	CPC  R17,R31
	BRLO _0x2020083
	LDI  R30,LOW(4)
	RJMP _0x20E001B
_0x2020083:
	RJMP _0x2020084
_0x2020082:
	MOVW R30,R16
	CALL __LSRW4
	MOVW R0,R30
	CALL SUBOPT_0xCE
	CALL SUBOPT_0x57
	SBIW R30,1
	AND  R30,R0
	AND  R31,R1
	SBIW R30,0
	BREQ PC+3
	JMP _0x2020085
	CALL SUBOPT_0xCE
	CALL SUBOPT_0xCF
	RCALL _get_fat
	CALL SUBOPT_0x25
	CALL SUBOPT_0x26
	CALL SUBOPT_0xA4
	BRSH _0x2020086
	LDI  R30,LOW(2)
	RJMP _0x20E001B
_0x2020086:
	CALL SUBOPT_0x26
	CALL SUBOPT_0x47
	BRNE _0x2020087
	LDI  R30,LOW(1)
	RJMP _0x20E001B
_0x2020087:
	CALL SUBOPT_0xCE
	CALL SUBOPT_0xD0
	CALL SUBOPT_0x26
	CALL __CPD21
	BRSH PC+3
	JMP _0x2020088
	LDD  R30,Y+8
	CPI  R30,0
	BRNE _0x2020089
	LDI  R30,LOW(4)
	RJMP _0x20E001B
_0x2020089:
	CALL SUBOPT_0xCE
	CALL SUBOPT_0xCF
	RCALL _create_chain_G101
	CALL SUBOPT_0x2D
	CALL __CPD10
	BRNE _0x202008A
	LDI  R30,LOW(7)
	RJMP _0x20E001B
_0x202008A:
	CALL SUBOPT_0x26
	CALL SUBOPT_0xB9
	BRNE _0x202008B
	LDI  R30,LOW(2)
	RJMP _0x20E001B
_0x202008B:
	CALL SUBOPT_0x26
	CALL SUBOPT_0x47
	BRNE _0x202008C
	LDI  R30,LOW(1)
	RJMP _0x20E001B
_0x202008C:
	CALL SUBOPT_0xCE
	CALL SUBOPT_0x9D
	CPI  R30,0
	BREQ _0x202008D
	LDI  R30,LOW(1)
	RJMP _0x20E001B
_0x202008D:
	CALL SUBOPT_0xCE
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x7C
	CALL SUBOPT_0x9F
	CALL SUBOPT_0xCE
	MOVW R26,R30
	ADIW R30,46
	PUSH R31
	PUSH R30
	MOVW R30,R26
	CALL SUBOPT_0xD1
	POP  R26
	POP  R27
	CALL __PUTDP1
	LDI  R19,LOW(0)
_0x202008F:
	CALL SUBOPT_0xCE
	LDD  R30,Z+2
	CP   R19,R30
	BRSH _0x2020090
	CALL SUBOPT_0xCE
	ADIW R30,4
	LDI  R26,LOW(1)
	STD  Z+0,R26
	CALL SUBOPT_0xCE
	CALL SUBOPT_0x9D
	CPI  R30,0
	BREQ _0x2020091
	LDI  R30,LOW(1)
	RJMP _0x20E001B
_0x2020091:
	CALL SUBOPT_0xCE
	ADIW R30,46
	MOVW R26,R30
	CALL SUBOPT_0x1E
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	SUBI R19,-1
	RJMP _0x202008F
_0x2020090:
	CALL SUBOPT_0xCE
	ADIW R30,46
	PUSH R31
	PUSH R30
	MOVW R26,R30
	CALL __GETD1P
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0x28
	CALL __CWD1
	CALL SUBOPT_0x3D
	POP  R26
	POP  R27
	CALL __PUTDP1
_0x2020088:
	CALL SUBOPT_0x15
	__PUTD1SNS 9,10
	CALL SUBOPT_0xCE
	CALL SUBOPT_0xD1
	__PUTD1SNS 9,14
_0x2020085:
_0x2020084:
_0x2020081:
	MOVW R30,R16
	__PUTW1SNS 9,4
	CALL SUBOPT_0xCE
	ADIW R30,50
	MOVW R26,R30
	MOVW R30,R16
	CALL SUBOPT_0xCC
	__PUTW1SNS 9,18
	LDI  R30,LOW(0)
_0x20E001B:
	CALL __LOADLOCR4
_0x20E001C:
	ADIW R28,11
	RET
_dir_find_G101:
	CALL SUBOPT_0x4C
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x4B
	RCALL _dir_seek_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x2020092
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20E0018
_0x2020092:
_0x2020094:
	CALL SUBOPT_0xD2
	BRNE _0x2020095
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	MOVW R26,R18
	LD   R16,X
	CPI  R16,0
	BRNE _0x2020097
	LDI  R17,LOW(4)
	RJMP _0x2020095
_0x2020097:
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x8)
	BRNE _0x2020099
	CALL SUBOPT_0xD3
	RCALL _mem_cmp_G101
	SBIW R30,0
	BREQ _0x202009A
_0x2020099:
	RJMP _0x2020098
_0x202009A:
	RJMP _0x2020095
_0x2020098:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(0)
	RCALL _dir_next_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x2020094
_0x2020095:
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20E0018
_dir_register_G101:
	CALL SUBOPT_0x4C
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0x4B
	RCALL _dir_seek_G101
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x20200A7
_0x20200A9:
	CALL SUBOPT_0xD2
	BRNE _0x20200AA
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	LDD  R26,Z+18
	LDD  R27,Z+19
	LD   R16,X
	CPI  R16,229
	BREQ _0x20200AD
	CPI  R16,0
	BRNE _0x20200AC
_0x20200AD:
	RJMP _0x20200AA
_0x20200AC:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(1)
	RCALL _dir_next_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x20200A9
_0x20200AA:
_0x20200A7:
	CPI  R17,0
	BRNE _0x20200AF
	CALL SUBOPT_0xD2
	BRNE _0x20200B0
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	CALL SUBOPT_0xD4
	LDI  R26,LOW(32)
	CALL SUBOPT_0xD5
	CALL SUBOPT_0xD3
	RCALL _mem_cpy_G101
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	ADIW R26,20
	CALL __GETW1P
	LDD  R30,Z+11
	ANDI R30,LOW(0x18)
	__PUTB1RNS 18,12
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL __GETW1P
	ADIW R30,4
	LDI  R26,LOW(1)
	STD  Z+0,R26
_0x20200B0:
_0x20200AF:
	MOV  R30,R17
	CALL __LOADLOCR4
	RJMP _0x20E0018
_create_name_G101:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,5
	CALL __SAVELOCR6
	LDD  R26,Y+13
	LDD  R27,Y+13+1
	ADIW R26,20
	LD   R20,X+
	LD   R21,X
	ST   -Y,R21
	ST   -Y,R20
	CALL SUBOPT_0xD6
	LDI  R30,LOW(0)
	STD  Y+8,R30
	STD  Y+8+1,R30
	MOV  R17,R30
	MOV  R18,R30
	LDI  R30,LOW(8)
	STD  Y+10,R30
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	CALL __GETW1P
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CALL SUBOPT_0xD7
	LD   R26,X
	CPI  R26,LOW(0x2E)
	BRNE _0x20200B3
_0x20200B5:
	CALL SUBOPT_0xD8
	LD   R16,X
	CPI  R16,46
	BRNE _0x20200B8
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,3
	BRLT _0x20200B7
_0x20200B8:
	RJMP _0x20200B6
_0x20200B7:
	CALL SUBOPT_0xD9
	RJMP _0x20200B5
_0x20200B6:
	CPI  R16,47
	BREQ _0x20200BB
	CPI  R16,92
	BREQ _0x20200BB
	CPI  R16,33
	BRSH _0x20200BC
_0x20200BB:
	RJMP _0x20200BA
_0x20200BC:
	LDI  R30,LOW(6)
	RJMP _0x20E0019
_0x20200BA:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CALL SUBOPT_0x6B
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	ST   X+,R30
	ST   X,R31
	CPI  R16,33
	BRSH _0x20200BD
	LDI  R30,LOW(36)
	RJMP _0x20200BE
_0x20200BD:
	LDI  R30,LOW(32)
_0x20200BE:
	__PUTB1RNS 20,11
	RJMP _0x20E001A
_0x20200B3:
_0x20200C1:
	CALL SUBOPT_0xD8
	LD   R16,X
	CPI  R16,33
	BRLO _0x20200C4
	CPI  R16,47
	BREQ _0x20200C4
	CPI  R16,92
	BRNE _0x20200C3
_0x20200C4:
	RJMP _0x20200C2
_0x20200C3:
	CPI  R16,46
	BREQ _0x20200C7
	LDD  R30,Y+10
	CP   R18,R30
	BRLO _0x20200C6
_0x20200C7:
	LDD  R26,Y+10
	CPI  R26,LOW(0x8)
	BRNE _0x20200CA
	CPI  R16,46
	BREQ _0x20200C9
_0x20200CA:
	LDI  R30,LOW(6)
	RJMP _0x20E0019
_0x20200C9:
	LDI  R18,LOW(8)
	LDI  R30,LOW(11)
	STD  Y+10,R30
	LSL  R17
	LSL  R17
	RJMP _0x20200C0
_0x20200C6:
	CPI  R16,128
	BRLO _0x20200CC
	ORI  R17,LOW(3)
	LDI  R30,LOW(6)
	RJMP _0x20E0019
_0x20200CC:
	__POINTD1FN _k1,0
	CALL __PUTPARD1
	MOV  R26,R16
	CLR  R27
	RCALL _chk_chrf_G101
	SBIW R30,0
	BREQ _0x20200D2
	LDI  R30,LOW(6)
	RJMP _0x20E0019
_0x20200D2:
	CPI  R16,65
	BRLO _0x20200D4
	CPI  R16,91
	BRLO _0x20200D5
_0x20200D4:
	RJMP _0x20200D3
_0x20200D5:
	ORI  R17,LOW(2)
	RJMP _0x20200D6
_0x20200D3:
	CPI  R16,97
	BRLO _0x20200D8
	CPI  R16,123
	BRLO _0x20200D9
_0x20200D8:
	RJMP _0x20200D7
_0x20200D9:
	ORI  R17,LOW(1)
	SUBI R16,LOW(32)
_0x20200D7:
_0x20200D6:
	CALL SUBOPT_0xD9
_0x20200C0:
	RJMP _0x20200C1
_0x20200C2:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	CALL SUBOPT_0x6B
	LDD  R26,Y+11
	LDD  R27,Y+11+1
	ST   X+,R30
	ST   X,R31
	CPI  R16,33
	BRSH _0x20200DA
	LDI  R30,LOW(4)
	RJMP _0x20200DB
_0x20200DA:
	LDI  R30,LOW(0)
_0x20200DB:
	MOV  R16,R30
	CPI  R18,0
	BRNE _0x20200DD
	LDI  R30,LOW(6)
	RJMP _0x20E0019
_0x20200DD:
	MOVW R26,R20
	LD   R26,X
	CPI  R26,LOW(0xE5)
	BRNE _0x20200DE
	MOVW R26,R20
	LDI  R30,LOW(5)
	ST   X,R30
_0x20200DE:
	LDD  R26,Y+10
	CPI  R26,LOW(0x8)
	BRNE _0x20200DF
	LSL  R17
	LSL  R17
_0x20200DF:
	MOV  R30,R17
	ANDI R30,LOW(0x3)
	CPI  R30,LOW(0x1)
	BRNE _0x20200E0
	ORI  R16,LOW(16)
_0x20200E0:
	MOV  R30,R17
	ANDI R30,LOW(0xC)
	CPI  R30,LOW(0x4)
	BRNE _0x20200E1
	ORI  R16,LOW(8)
_0x20200E1:
	MOVW R30,R20
	__PUTBZR 16,11
_0x20E001A:
	LDI  R30,LOW(0)
_0x20E0019:
	CALL __LOADLOCR6
	ADIW R28,15
	RET
_follow_path_G101:
	CALL SUBOPT_0x4C
_0x20200F7:
	LDI  R30,LOW(1)
	CPI  R30,0
	BREQ _0x20200FA
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x20)
	BREQ _0x20200FB
_0x20200FA:
	RJMP _0x20200F9
_0x20200FB:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	RJMP _0x20200F7
_0x20200F9:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x2F)
	BREQ _0x20200FD
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CPI  R26,LOW(0x5C)
	BRNE _0x20200FC
_0x20200FD:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,1
	STD  Y+4,R30
	STD  Y+4+1,R31
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,6
	CALL SUBOPT_0x9E
	RJMP _0x20200FF
_0x20200FC:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL __GETW1P
	ADIW R30,22
	MOVW R26,R30
	CALL __GETD1P
	CALL SUBOPT_0xDA
_0x20200FF:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LD   R26,X
	CLR  R27
	SBIW R26,32
	BRSH _0x2020100
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x4B
	RCALL _dir_seek_G101
	MOV  R17,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,18
	CALL SUBOPT_0x6E
	RJMP _0x2020101
_0x2020100:
_0x2020103:
	CALL SUBOPT_0x52
	MOVW R26,R28
	ADIW R26,6
	RCALL _create_name_G101
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x2020104
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	RCALL _dir_find_G101
	MOV  R17,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,20
	CALL __GETW1P
	LDD  R30,Z+11
	ANDI R30,LOW(0x4)
	MOV  R16,R30
	CPI  R17,0
	BREQ _0x2020106
	CPI  R17,4
	BRNE _0x2020108
	CPI  R16,0
	BREQ _0x2020109
_0x2020108:
	RJMP _0x2020107
_0x2020109:
	LDI  R17,LOW(5)
_0x2020107:
	RJMP _0x2020104
_0x2020106:
	CPI  R16,0
	BRNE _0x2020104
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BRNE _0x202010B
	LDI  R17,LOW(5)
	RJMP _0x2020104
_0x202010B:
	CALL SUBOPT_0xDB
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xDC
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0xDD
	CALL SUBOPT_0xDA
	RJMP _0x2020103
_0x2020104:
_0x2020101:
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,8
	RET
_check_fs_G101:
	CALL __PUTPARD2
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+5
	LDD  R31,Y+5+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	__GETD1S 3
	CALL SUBOPT_0xDE
	BREQ _0x202010C
	LDI  R30,LOW(3)
	RJMP _0x20E0018
_0x202010C:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	CALL SUBOPT_0xDF
	BREQ _0x202010D
	LDI  R30,LOW(2)
	RJMP _0x20E0018
_0x202010D:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	SUBI R26,LOW(-104)
	SBCI R27,HIGH(-104)
	CALL SUBOPT_0xE0
	BRNE _0x202010E
	LDI  R30,LOW(0)
	RJMP _0x20E0018
_0x202010E:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	ADIW R30,50
	SUBI R30,LOW(-82)
	SBCI R31,HIGH(-82)
	MOVW R26,R30
	CALL SUBOPT_0xE0
	BRNE _0x202010F
	LDI  R30,LOW(0)
	RJMP _0x20E0018
_0x202010F:
	LDI  R30,LOW(1)
_0x20E0018:
	ADIW R28,6
	RET
_chk_mounted:
	ST   -Y,R26
	SBIW R28,20
	CALL __SAVELOCR6
	LDD  R26,Y+29
	LDD  R27,Y+29+1
	CALL __GETW1P
	STD  Y+8,R30
	STD  Y+8+1,R31
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LD   R30,X
	SUBI R30,LOW(48)
	MOV  R16,R30
	CPI  R16,10
	BRSH _0x2020111
	ADIW R26,1
	LD   R26,X
	CPI  R26,LOW(0x3A)
	BREQ _0x2020112
_0x2020111:
	RJMP _0x2020110
_0x2020112:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,2
	STD  Y+8,R30
	STD  Y+8+1,R31
	LDD  R26,Y+29
	LDD  R27,Y+29+1
	ST   X+,R30
	ST   X,R31
	RJMP _0x2020113
_0x2020110:
	LDS  R16,_Drive_G101
_0x2020113:
	CPI  R16,1
	BRLO _0x2020114
	LDI  R30,LOW(11)
	RJMP _0x20E0016
_0x2020114:
	MOV  R30,R16
	CALL SUBOPT_0xE1
	CALL SUBOPT_0x75
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+27
	LDD  R27,Y+27+1
	ST   X+,R30
	ST   X,R31
	SBIW R30,0
	BRNE _0x2020115
	LDI  R30,LOW(12)
	RJMP _0x20E0016
_0x2020115:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R30,X
	CPI  R30,0
	BREQ _0x2020116
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+1
	CALL _disk_status
	MOV  R21,R30
	SBRC R21,0
	RJMP _0x2020117
	LDD  R30,Y+26
	CPI  R30,0
	BREQ _0x2020119
	SBRC R21,2
	RJMP _0x202011A
_0x2020119:
	RJMP _0x2020118
_0x202011A:
	LDI  R30,LOW(10)
	RJMP _0x20E0016
_0x2020118:
	RJMP _0x20E0017
_0x2020117:
_0x2020116:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
	MOV  R30,R16
	__PUTB1SNS 6,1
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+1
	CALL _disk_initialize
	MOV  R21,R30
	SBRS R21,0
	RJMP _0x202011B
	LDI  R30,LOW(3)
	RJMP _0x20E0016
_0x202011B:
	LDD  R30,Y+26
	CPI  R30,0
	BREQ _0x202011D
	SBRC R21,2
	RJMP _0x202011E
_0x202011D:
	RJMP _0x202011C
_0x202011E:
	LDI  R30,LOW(10)
	RJMP _0x20E0016
_0x202011C:
	CALL SUBOPT_0x52
	CALL SUBOPT_0x1B
	__PUTD1S 24
	MOVW R26,R30
	MOVW R24,R22
	RCALL _check_fs_G101
	MOV  R17,R30
	CPI  R17,1
	BRNE _0x202011F
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-446)
	SBCI R31,HIGH(-446)
	MOVW R18,R30
	MOVW R30,R18
	LDD  R30,Z+4
	CPI  R30,0
	BREQ _0x2020120
	MOVW R26,R18
	ADIW R26,8
	CALL __GETD1P
	CALL SUBOPT_0x3E
	CALL SUBOPT_0x52
	__GETD2S 24
	RCALL _check_fs_G101
	MOV  R17,R30
_0x2020120:
_0x202011F:
	CPI  R17,3
	BRNE _0x2020121
	LDI  R30,LOW(1)
	RJMP _0x20E0016
_0x2020121:
	CPI  R17,0
	BRNE _0x2020123
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,61
	CALL __GETW1P
	CPI  R30,LOW(0x200)
	LDI  R26,HIGH(0x200)
	CPC  R31,R26
	BREQ _0x2020122
_0x2020123:
	LDI  R30,LOW(13)
	RJMP _0x20E0016
_0x2020122:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-72)
	SBCI R27,HIGH(-72)
	CALL SUBOPT_0xAC
	CALL SUBOPT_0xE2
	CALL SUBOPT_0x42
	CALL __CPD10
	BRNE _0x2020125
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-86)
	SBCI R27,HIGH(-86)
	CALL __GETD1P
	CALL SUBOPT_0xE2
_0x2020125:
	CALL SUBOPT_0x42
	__PUTD1SNS 6,26
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SUBI R30,LOW(-66)
	SBCI R31,HIGH(-66)
	LD   R30,Z
	__PUTB1SNS 6,3
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R30,Z+3
	LDI  R31,0
	CALL SUBOPT_0xBF
	CALL SUBOPT_0x59
	CALL SUBOPT_0xE2
	CALL SUBOPT_0xE3
	CALL SUBOPT_0x40
	CALL SUBOPT_0xCB
	__PUTD1SNS 6,34
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R30,Z+63
	__PUTB1SNS 6,2
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-67)
	SBCI R27,HIGH(-67)
	CALL __GETW1P
	__PUTW1SNS 6,8
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-69)
	SBCI R27,HIGH(-69)
	CALL SUBOPT_0xAC
	CALL SUBOPT_0xE4
	CALL SUBOPT_0x43
	CALL __CPD10
	BRNE _0x2020126
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-82)
	SBCI R27,HIGH(-82)
	CALL __GETD1P
	CALL SUBOPT_0xE4
_0x2020126:
	CALL SUBOPT_0xE3
	CALL SUBOPT_0xAF
	CLR  R22
	CLR  R23
	CALL SUBOPT_0x3D
	CALL SUBOPT_0xBF
	CALL __SUBD12
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xE5
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CLR  R22
	CLR  R23
	CALL __SUBD21
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0x57
	CALL __CWD1
	CALL __DIVD21U
	__ADDD1N 2
	__PUTD1S 10
	__PUTD1SNS 6,30
	LDI  R17,LOW(1)
	CALL SUBOPT_0x4F
	__CPD2N 0xFF7
	BRLO _0x2020127
	LDI  R17,LOW(2)
_0x2020127:
	CALL SUBOPT_0x4F
	__CPD2N 0xFFF7
	BRLO _0x2020128
	LDI  R17,LOW(3)
_0x2020128:
	CPI  R17,3
	BRNE _0x2020129
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-94)
	SBCI R27,HIGH(-94)
	CALL __GETD1P
	RJMP _0x202022D
_0x2020129:
	CALL SUBOPT_0xE6
_0x202022D:
	__PUTD1SNS 6,38
	CALL SUBOPT_0xE6
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xE5
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0xCB
	__PUTD1SNS 6,42
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,14
	CALL SUBOPT_0x16
	CALL __PUTDP1
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,4
	LDI  R30,LOW(0)
	ST   X,R30
	CPI  R17,3
	BREQ PC+3
	JMP _0x202012B
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,5
	ST   X,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-98)
	SBCI R27,HIGH(-98)
	CALL __GETW1P
	CALL SUBOPT_0x40
	CALL SUBOPT_0xCB
	__PUTD1SNS 6,18
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	CALL SUBOPT_0xA2
	CALL _disk_read
	CPI  R30,0
	BRNE _0x202012D
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL SUBOPT_0xDF
	BRNE _0x202012D
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,50
	CALL __GETD1P
	__CPD1N 0x41615252
	BRNE _0x202012D
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-484)
	SBCI R31,HIGH(-484)
	MOVW R26,R30
	CALL __GETD1P
	__CPD1N 0x61417272
	BREQ _0x202012E
_0x202012D:
	RJMP _0x202012C
_0x202012E:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-492)
	SBCI R31,HIGH(-492)
	MOVW R26,R30
	CALL __GETD1P
	__PUTD1SNS 6,10
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,50
	SUBI R30,LOW(-488)
	SBCI R31,HIGH(-488)
	MOVW R26,R30
	CALL __GETD1P
	__PUTD1SNS 6,14
_0x202012C:
_0x202012B:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ST   X,R17
	ADIW R26,46
	CALL SUBOPT_0x9E
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,22
	CALL SUBOPT_0x9E
	LDI  R26,LOW(_Fsid_G101)
	LDI  R27,HIGH(_Fsid_G101)
	CALL SUBOPT_0xE
	__PUTW1SNS 6,6
_0x20E0017:
	LDI  R30,LOW(0)
_0x20E0016:
	CALL __LOADLOCR6
	ADIW R28,31
	RET
_validate_G101:
	ST   -Y,R27
	ST   -Y,R26
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,0
	BREQ _0x2020130
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LD   R30,X
	CPI  R30,0
	BREQ _0x2020130
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	LDD  R26,Z+6
	LDD  R27,Z+7
	LD   R30,Y
	LDD  R31,Y+1
	CP   R30,R26
	CPC  R31,R27
	BREQ _0x202012F
_0x2020130:
	LDI  R30,LOW(9)
	RJMP _0x20E0015
_0x202012F:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	LDD  R26,Z+1
	CALL _disk_status
	ANDI R30,LOW(0x1)
	BREQ _0x2020132
	LDI  R30,LOW(3)
	RJMP _0x20E0015
_0x2020132:
	LDI  R30,LOW(0)
_0x20E0015:
	ADIW R28,4
	RET
_f_mount:
	CALL SUBOPT_0x5E
	LDD  R26,Y+4
	CPI  R26,LOW(0x1)
	BRLO _0x2020133
	LDI  R30,LOW(11)
	RJMP _0x20E0014
_0x2020133:
	LDD  R30,Y+4
	CALL SUBOPT_0xE1
	LSL  R30
	ROL  R31
	ADD  R26,R30
	ADC  R27,R31
	LD   R16,X+
	LD   R17,X
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x2020134
	MOVW R26,R16
	LDI  R30,LOW(0)
	ST   X,R30
_0x2020134:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,0
	BREQ _0x2020135
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(0)
	ST   X,R30
_0x2020135:
	LDD  R30,Y+4
	CALL SUBOPT_0xE1
	CALL SUBOPT_0x6F
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	STD  Z+0,R26
	STD  Z+1,R27
	LDI  R30,LOW(0)
_0x20E0014:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,5
	RET
_f_open:
	ST   -Y,R26
	SBIW R28,34
	CALL __SAVELOCR4
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	CALL SUBOPT_0x6E
	LDD  R30,Y+38
	ANDI R30,LOW(0x1F)
	STD  Y+38,R30
	MOVW R30,R28
	ADIW R30,39
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,18
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+42
	ANDI R30,LOW(0x1E)
	MOV  R26,R30
	CALL SUBOPT_0xE7
	BREQ _0x2020136
	MOV  R30,R17
	RJMP _0x20E0013
_0x2020136:
	MOVW R30,R28
	ADIW R30,4
	STD  Y+36,R30
	STD  Y+36+1,R31
	MOVW R30,R28
	ADIW R30,16
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	RCALL _follow_path_G101
	MOV  R17,R30
	LDD  R30,Y+38
	ANDI R30,LOW(0x1C)
	BRNE PC+3
	JMP _0x2020137
	SBIW R28,8
	CPI  R17,0
	BREQ _0x2020138
	CPI  R17,4
	BRNE _0x2020139
	MOVW R26,R28
	ADIW R26,24
	RCALL _dir_register_G101
	MOV  R17,R30
_0x2020139:
	CPI  R17,0
	BREQ _0x202013A
	MOV  R30,R17
	ADIW R28,8
	RJMP _0x20E0013
_0x202013A:
	LDD  R30,Y+46
	ORI  R30,8
	STD  Y+46,R30
	__GETWRS 18,19,42
	RJMP _0x202013B
_0x2020138:
	LDD  R30,Y+46
	ANDI R30,LOW(0x4)
	BREQ _0x202013C
	LDI  R30,LOW(8)
	ADIW R28,8
	RJMP _0x20E0013
_0x202013C:
	__GETWRS 18,19,42
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x202013E
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x11)
	BREQ _0x202013D
_0x202013E:
	LDI  R30,LOW(7)
	ADIW R28,8
	RJMP _0x20E0013
_0x202013D:
	LDD  R30,Y+46
	ANDI R30,LOW(0x8)
	BRNE PC+3
	JMP _0x2020140
	CALL SUBOPT_0xDB
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xDC
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0xDD
	CALL SUBOPT_0xBD
	MOVW R30,R18
	ADIW R30,20
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	STD  Z+0,R26
	STD  Z+1,R27
	MOVW R30,R18
	ADIW R30,26
	STD  Z+0,R26
	STD  Z+1,R27
	MOVW R30,R18
	ADIW R30,28
	CALL SUBOPT_0xBA
	CALL SUBOPT_0xB5
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	ADIW R26,46
	CALL SUBOPT_0xA6
	CALL SUBOPT_0x13
	CALL __CPD10
	BREQ _0x2020141
	CALL SUBOPT_0xE8
	CALL SUBOPT_0x34
	RCALL _remove_chain_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x2020142
	MOV  R30,R17
	ADIW R28,8
	RJMP _0x20E0013
_0x2020142:
	CALL SUBOPT_0x13
	CALL SUBOPT_0xE9
	__PUTD1SNS 24,10
_0x2020141:
	CALL SUBOPT_0xE8
	CALL SUBOPT_0x31
	CALL SUBOPT_0xEA
	BREQ _0x2020143
	MOV  R30,R17
	ADIW R28,8
	RJMP _0x20E0013
_0x2020143:
_0x2020140:
_0x202013B:
	LDD  R30,Y+46
	ANDI R30,LOW(0x8)
	BREQ _0x2020144
	MOVW R30,R18
	ADIW R30,11
	LDI  R26,LOW(0)
	STD  Z+0,R26
	CALL SUBOPT_0xEB
	__PUTD1RNS 18,14
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	LDD  R30,Y+46
	ORI  R30,0x20
	STD  Y+46,R30
_0x2020144:
	ADIW R28,8
	RJMP _0x2020145
_0x2020137:
	CPI  R17,0
	BREQ _0x2020146
	MOV  R30,R17
	RJMP _0x20E0013
_0x2020146:
	__GETWRS 18,19,34
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x2020148
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BREQ _0x2020147
_0x2020148:
	LDI  R30,LOW(4)
	RJMP _0x20E0013
_0x2020147:
	LDD  R30,Y+38
	ANDI R30,LOW(0x2)
	BREQ _0x202014B
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x1)
	BRNE _0x202014C
_0x202014B:
	RJMP _0x202014A
_0x202014C:
	LDI  R30,LOW(7)
	RJMP _0x20E0013
_0x202014A:
_0x2020145:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,46
	CALL __GETD1P
	__PUTD1SNS 41,26
	LDD  R30,Y+34
	LDD  R31,Y+34+1
	__PUTW1SNS 41,30
	LDD  R30,Y+38
	__PUTB1SNS 41,4
	CALL SUBOPT_0xDB
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xDC
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0xDD
	__PUTD1SNS 41,14
	MOVW R26,R18
	ADIW R26,28
	CALL __GETD1P
	__PUTD1SNS 41,10
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ADIW R26,6
	CALL SUBOPT_0x9E
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ADIW R26,5
	LDI  R30,LOW(255)
	ST   X,R30
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ADIW R26,22
	CALL SUBOPT_0x9E
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	LDD  R26,Y+41
	LDD  R27,Y+41+1
	ST   X+,R30
	ST   X,R31
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,6
	CALL __GETW1P
	__PUTW1SNS 41,2
	LDI  R30,LOW(0)
_0x20E0013:
	CALL __LOADLOCR4
	ADIW R28,43
	RET
_f_write:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,10
	CALL __SAVELOCR6
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	CALL SUBOPT_0x6E
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xED
	CALL SUBOPT_0xEE
	BREQ _0x2020167
	MOV  R30,R17
	RJMP _0x20E0012
_0x2020167:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x80)
	BREQ _0x2020168
	LDI  R30,LOW(2)
	RJMP _0x20E0012
_0x2020168:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x2)
	BRNE _0x2020169
	LDI  R30,LOW(7)
	RJMP _0x20E0012
_0x2020169:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	__GETD2Z 10
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CALL SUBOPT_0xCB
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xEF
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD21
	BRSH _0x202016A
	LDI  R30,LOW(0)
	STD  Y+18,R30
	STD  Y+18+1,R30
_0x202016A:
_0x202016C:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	SBIW R30,0
	BRNE PC+3
	JMP _0x202016D
	CALL SUBOPT_0xF0
	MOVW R30,R26
	MOVW R22,R24
	ANDI R31,HIGH(0x1FF)
	SBIW R30,0
	BREQ PC+3
	JMP _0x202016E
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R0,Z+5
	CALL SUBOPT_0xEC
	LDD  R30,Z+2
	CP   R0,R30
	BRSH PC+3
	JMP _0x202016F
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,6
	CALL SUBOPT_0xCD
	BRNE _0x2020170
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,14
	CALL SUBOPT_0xF1
	CALL SUBOPT_0xC5
	BRNE _0x2020171
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xF2
	CALL SUBOPT_0xF3
	__PUTD1SNS 22,14
_0x2020171:
	RJMP _0x2020172
_0x2020170:
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xED
	__GETD2Z 18
	CALL _create_chain_G101
	CALL SUBOPT_0xF3
_0x2020172:
	CALL SUBOPT_0xC5
	BRNE _0x2020173
	RJMP _0x202016D
_0x2020173:
	CALL SUBOPT_0xC7
	BRNE _0x2020174
	CALL SUBOPT_0xF4
	LDI  R30,LOW(2)
	RJMP _0x20E0012
_0x2020174:
	CALL SUBOPT_0xC6
	BRNE _0x2020175
	CALL SUBOPT_0xF4
	LDI  R30,LOW(1)
	RJMP _0x20E0012
_0x2020175:
	CALL SUBOPT_0x71
	__PUTD1SNS 22,18
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,5
	LDI  R30,LOW(0)
	ST   X,R30
_0x202016F:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x2020176
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xF5
	LDD  R30,Y+25
	LDD  R31,Y+25+1
	CALL SUBOPT_0xF6
	CALL SUBOPT_0xF7
	BREQ _0x2020177
	CALL SUBOPT_0xF4
	LDI  R30,LOW(1)
	RJMP _0x20E0012
_0x2020177:
	CALL SUBOPT_0xF8
_0x2020176:
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xED
	__GETD2Z 18
	RCALL _clust2sect
	CALL SUBOPT_0xC2
	CALL SUBOPT_0x49
	CALL __CPD10
	BRNE _0x2020178
	CALL SUBOPT_0xF4
	LDI  R30,LOW(2)
	RJMP _0x20E0012
_0x2020178:
	CALL SUBOPT_0xF9
	CALL SUBOPT_0xA3
	CALL SUBOPT_0x2C
	CALL SUBOPT_0xC2
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	CALL __DIVW21U
	MOVW R20,R30
	MOV  R0,R20
	OR   R0,R21
	BRNE PC+3
	JMP _0x2020179
	CALL SUBOPT_0xF9
	ADD  R30,R20
	ADC  R31,R21
	MOVW R0,R30
	CALL SUBOPT_0xEC
	LDD  R30,Z+2
	MOVW R26,R0
	LDI  R31,0
	CP   R30,R26
	CPC  R31,R27
	BRSH _0x202017A
	CALL SUBOPT_0xEC
	CALL SUBOPT_0x57
	MOVW R26,R30
	CALL SUBOPT_0xF9
	SUB  R26,R30
	SBC  R27,R31
	MOVW R20,R26
_0x202017A:
	CALL SUBOPT_0xEC
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+7
	LDD  R31,Y+7+1
	ST   -Y,R31
	ST   -Y,R30
	__GETD1S 11
	CALL __PUTPARD1
	MOV  R26,R20
	CALL _disk_write
	CPI  R30,0
	BREQ _0x202017B
	CALL SUBOPT_0xF4
	LDI  R30,LOW(1)
	RJMP _0x20E0012
_0x202017B:
	CALL SUBOPT_0xFA
	CALL __SUBD21
	MOVW R30,R20
	CLR  R22
	CLR  R23
	CALL __CPD21
	BRSH _0x202017C
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ADIW R30,32
	CALL SUBOPT_0xED
	CALL SUBOPT_0xF6
	CALL SUBOPT_0x44
	CALL __SUBD21
	__GETD1N 0x200
	CALL __MULD12U
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CLR  R24
	CLR  R25
	CALL SUBOPT_0x8B
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	CALL _mem_cpy_G101
	CALL SUBOPT_0xF8
_0x202017C:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,5
	LD   R30,X
	ADD  R30,R20
	ST   X,R30
	MOVW R30,R20
	LSL  R30
	ROL  R31
	MOV  R31,R30
	LDI  R30,0
	MOVW R18,R30
	RJMP _0x202016B
_0x2020179:
	CALL SUBOPT_0xFA
	CALL __CPD12
	BREQ _0x202017D
	CALL SUBOPT_0xF0
	MOVW R0,R26
	CALL SUBOPT_0xEF
	MOVW R26,R0
	CALL __CPD21
	BRSH _0x202017F
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xF5
	__GETD1S 11
	CALL SUBOPT_0xDE
	BRNE _0x2020180
_0x202017F:
	RJMP _0x202017E
_0x2020180:
	CALL SUBOPT_0xF4
	LDI  R30,LOW(1)
	RJMP _0x20E0012
_0x202017E:
_0x202017D:
	CALL SUBOPT_0x49
	__PUTD1SNS 22,22
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,5
	LD   R30,X
	SUBI R30,-LOW(1)
	ST   X,R30
_0x202016E:
	CALL SUBOPT_0xFB
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	SUB  R26,R30
	SBC  R27,R31
	MOVW R18,R26
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CP   R30,R18
	CPC  R31,R19
	BRSH _0x2020181
	__GETWRS 18,19,18
_0x2020181:
	CALL SUBOPT_0xFB
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,32
	CALL SUBOPT_0x8B
	CALL SUBOPT_0x51
	MOVW R26,R18
	CALL _mem_cpy_G101
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x40
	ST   X,R30
_0x202016B:
	MOVW R30,R18
	CALL SUBOPT_0x6B
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	CALL SUBOPT_0xFC
	MOVW R26,R30
	MOVW R24,R22
	MOVW R30,R18
	CALL SUBOPT_0xCB
	MOVW R26,R0
	CALL __PUTDP1
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	LD   R30,X+
	LD   R31,X+
	ADD  R30,R18
	ADC  R31,R19
	ST   -X,R31
	ST   -X,R30
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	SUB  R30,R18
	SBC  R31,R19
	STD  Y+18,R30
	STD  Y+18+1,R31
	RJMP _0x202016C
_0x202016D:
	CALL SUBOPT_0xF0
	MOVW R0,R26
	CALL SUBOPT_0xEF
	MOVW R26,R0
	CALL __CPD12
	BRSH _0x2020182
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,6
	CALL __GETD1P
	__PUTD1SNS 22,10
_0x2020182:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x20
	ST   X,R30
	LDI  R30,LOW(0)
_0x20E0012:
	CALL __LOADLOCR6
	ADIW R28,24
	RET
_f_sync:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	CALL __SAVELOCR4
	CALL SUBOPT_0xC8
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL SUBOPT_0xEE
	BREQ PC+3
	JMP _0x2020183
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x20)
	BRNE PC+3
	JMP _0x2020184
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x2020185
	CALL SUBOPT_0xC8
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+11
	LDD  R31,Y+11+1
	CALL SUBOPT_0xF6
	CALL SUBOPT_0xF7
	BREQ _0x2020186
	LDI  R30,LOW(1)
	RJMP _0x20E0011
_0x2020186:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,4
	LD   R30,X
	ANDI R30,0xBF
	ST   X,R30
_0x2020185:
	CALL SUBOPT_0xC8
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	__GETD2Z 26
	CALL SUBOPT_0xEA
	BRNE _0x2020187
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,30
	LD   R18,X+
	LD   R19,X
	MOVW R26,R18
	ADIW R26,11
	LD   R30,X
	ORI  R30,0x20
	ST   X,R30
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,10
	CALL __GETD1P
	__PUTD1RNS 18,28
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,14
	CALL __GETW1P
	CALL SUBOPT_0xFD
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	__GETD2Z 14
	MOVW R30,R26
	MOVW R22,R24
	CALL SUBOPT_0xFE
	CALL SUBOPT_0xEB
	CALL SUBOPT_0xFF
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,4
	LD   R30,X
	ANDI R30,0xDF
	ST   X,R30
	CALL SUBOPT_0xC8
	ADIW R30,4
	LDI  R26,LOW(1)
	STD  Z+0,R26
	CALL SUBOPT_0xC8
	MOVW R26,R30
	CALL _sync_G101
	MOV  R17,R30
_0x2020187:
_0x2020184:
_0x2020183:
	MOV  R30,R17
_0x20E0011:
	CALL __LOADLOCR4
	ADIW R28,10
	RET
_f_close:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	RCALL _f_sync
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x2020188
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CALL SUBOPT_0x6E
_0x2020188:
	MOV  R30,R17
	JMP  _0x20E000B
_f_lseek:
	CALL __PUTPARD2
	SBIW R28,16
	ST   -Y,R17
	CALL SUBOPT_0x100
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+23
	LDD  R31,Y+23+1
	CALL SUBOPT_0xEE
	BREQ _0x2020191
	RJMP _0x20E0010
_0x2020191:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x80)
	BREQ _0x2020192
	LDI  R30,LOW(2)
	RJMP _0x20E000F
_0x2020192:
	CALL SUBOPT_0x101
	CALL SUBOPT_0x102
	CALL __CPD12
	BRSH _0x2020194
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x2)
	BREQ _0x2020195
_0x2020194:
	RJMP _0x2020193
_0x2020195:
	CALL SUBOPT_0x101
	CALL SUBOPT_0x103
_0x2020193:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,6
	CALL SUBOPT_0x98
	CALL SUBOPT_0x1B
	CALL SUBOPT_0xBC
	CALL SUBOPT_0x104
	ADIW R26,5
	LDI  R30,LOW(255)
	ST   X,R30
	CALL SUBOPT_0x102
	CALL __CPD02
	BRLO PC+3
	JMP _0x2020196
	CALL SUBOPT_0x100
	CALL SUBOPT_0x57
	CALL __CWD1
	__GETD2N 0x200
	CALL __MULD12U
	CALL SUBOPT_0x105
	CALL SUBOPT_0x58
	CALL __CPD02
	BRSH _0x2020198
	CALL SUBOPT_0x106
	CALL SUBOPT_0x107
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xB8
	CALL SUBOPT_0x107
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD21
	BRSH _0x2020199
_0x2020198:
	RJMP _0x2020197
_0x2020199:
	CALL SUBOPT_0xB8
	CALL SUBOPT_0xE9
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0x108
	CALL SUBOPT_0xE9
	CALL __COMD1
	CALL __ANDD12
	CALL SUBOPT_0x104
	ADIW R26,6
	CALL __GETD1P
	CALL SUBOPT_0x102
	CALL __SUBD21
	__PUTD2S 17
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,18
	CALL SUBOPT_0x109
	RJMP _0x202019A
_0x2020197:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,14
	CALL SUBOPT_0x109
	CALL SUBOPT_0x10A
	CALL __CPD10
	BRNE _0x202019B
	CALL SUBOPT_0x100
	CALL SUBOPT_0xF2
	CALL SUBOPT_0x10B
	CALL SUBOPT_0x10C
	CALL SUBOPT_0xB9
	BRNE _0x202019C
	CALL SUBOPT_0x10D
	LDI  R30,LOW(2)
	RJMP _0x20E000F
_0x202019C:
	CALL SUBOPT_0x10C
	CALL SUBOPT_0x47
	BRNE _0x202019D
	CALL SUBOPT_0x10D
	LDI  R30,LOW(1)
	RJMP _0x20E000F
_0x202019D:
	CALL SUBOPT_0x10A
	__PUTD1SNS 21,14
_0x202019B:
	CALL SUBOPT_0x10E
_0x202019A:
	CALL SUBOPT_0x10A
	CALL __CPD10
	BRNE PC+3
	JMP _0x202019E
_0x202019F:
	CALL SUBOPT_0x108
	CALL SUBOPT_0x102
	CALL __CPD12
	BRLO PC+3
	JMP _0x20201A1
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x2)
	BREQ _0x20201A2
	CALL SUBOPT_0x100
	CALL SUBOPT_0x10F
	CALL _create_chain_G101
	CALL SUBOPT_0x10B
	CALL SUBOPT_0x10A
	CALL __CPD10
	BRNE _0x20201A3
	CALL SUBOPT_0x108
	CALL SUBOPT_0x103
	RJMP _0x20201A1
_0x20201A3:
	RJMP _0x20201A4
_0x20201A2:
	CALL SUBOPT_0x100
	CALL SUBOPT_0x10F
	CALL _get_fat
	CALL SUBOPT_0x10B
_0x20201A4:
	CALL SUBOPT_0x10C
	CALL SUBOPT_0x47
	BRNE _0x20201A5
	CALL SUBOPT_0x10D
	LDI  R30,LOW(1)
	RJMP _0x20E000F
_0x20201A5:
	CALL SUBOPT_0x10C
	CALL SUBOPT_0xA4
	BRLO _0x20201A7
	CALL SUBOPT_0x100
	CALL SUBOPT_0xD0
	CALL SUBOPT_0x10C
	CALL __CPD21
	BRLO _0x20201A6
_0x20201A7:
	CALL SUBOPT_0x10D
	LDI  R30,LOW(2)
	RJMP _0x20E000F
_0x20201A6:
	CALL SUBOPT_0x10E
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	CALL SUBOPT_0xFC
	CALL SUBOPT_0x110
	CALL __ADDD12
	MOVW R26,R0
	CALL __PUTDP1
	CALL SUBOPT_0x110
	CALL SUBOPT_0x106
	CALL __SUBD12
	CALL SUBOPT_0x103
	RJMP _0x202019F
_0x20201A1:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	CALL SUBOPT_0xFC
	CALL SUBOPT_0x102
	CALL __ADDD12
	MOVW R26,R0
	CALL __PUTDP1
	CALL SUBOPT_0x102
	__GETD1N 0x200
	CALL __DIVD21U
	__PUTB1SNS 21,5
	CALL SUBOPT_0x106
	ANDI R31,HIGH(0x1FF)
	SBIW R30,0
	BREQ _0x20201A9
	CALL SUBOPT_0x100
	CALL SUBOPT_0x10F
	CALL _clust2sect
	CALL SUBOPT_0xBC
	CALL SUBOPT_0x99
	CALL __CPD10
	BRNE _0x20201AA
	CALL SUBOPT_0x10D
	LDI  R30,LOW(2)
	RJMP _0x20E000F
_0x20201AA:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R30,Z+5
	LDI  R31,0
	CALL SUBOPT_0xB6
	CALL SUBOPT_0x2C
	CALL SUBOPT_0xBC
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,5
	LD   R30,X
	SUBI R30,-LOW(1)
	ST   X,R30
_0x20201A9:
_0x202019E:
_0x2020196:
	CALL SUBOPT_0x111
	MOVW R30,R26
	MOVW R22,R24
	ANDI R31,HIGH(0x1FF)
	SBIW R30,0
	BREQ _0x20201AC
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,22
	CALL __GETD1P
	CALL SUBOPT_0xB6
	CALL __CPD12
	BRNE _0x20201AD
_0x20201AC:
	RJMP _0x20201AB
_0x20201AD:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	LDD  R26,Z+4
	ANDI R26,LOW(0x40)
	BREQ _0x20201AE
	CALL SUBOPT_0x100
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ADIW R30,32
	CALL SUBOPT_0xED
	CALL SUBOPT_0xF6
	CALL SUBOPT_0xF7
	BREQ _0x20201AF
	CALL SUBOPT_0x10D
	LDI  R30,LOW(1)
	RJMP _0x20E000F
_0x20201AF:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	LD   R30,X
	ANDI R30,0xBF
	ST   X,R30
_0x20201AE:
	CALL SUBOPT_0x100
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	ADIW R30,32
	CALL SUBOPT_0x9C
	BREQ _0x20201B0
	CALL SUBOPT_0x10D
	LDI  R30,LOW(1)
	RJMP _0x20E000F
_0x20201B0:
	CALL SUBOPT_0x99
	__PUTD1SNS 21,22
_0x20201AB:
	CALL SUBOPT_0x111
	MOVW R0,R26
	CALL SUBOPT_0x101
	MOVW R26,R0
	CALL __CPD12
	BRSH _0x20201B1
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,6
	CALL __GETD1P
	__PUTD1SNS 21,10
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x20
	ST   X,R30
_0x20201B1:
_0x20E0010:
	MOV  R30,R17
_0x20E000F:
	LDD  R17,Y+0
	ADIW R28,23
	RET
_f_opendir:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,12
	CALL __SAVELOCR4
	MOVW R30,R28
	ADIW R30,16
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xBE
	LDI  R26,LOW(0)
	CALL SUBOPT_0xE7
	BREQ PC+3
	JMP _0x20201B2
	MOVW R30,R28
	ADIW R30,4
	__PUTW1SNS 18,20
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL _follow_path_G101
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x20201B3
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,18
	LD   R18,X+
	LD   R19,X
	MOV  R0,R18
	OR   R0,R19
	BREQ _0x20201B4
	MOVW R30,R18
	LDD  R30,Z+11
	ANDI R30,LOW(0x10)
	BREQ _0x20201B5
	CALL SUBOPT_0xDB
	CALL __LSLD16
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xDC
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL SUBOPT_0xDD
	__PUTD1SNS 18,6
	RJMP _0x20201B6
_0x20201B5:
	LDI  R17,LOW(5)
_0x20201B6:
_0x20201B4:
	CPI  R17,0
	BRNE _0x20201B7
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	CALL __GETW1P
	ADIW R30,6
	MOVW R26,R30
	CALL __GETW1P
	__PUTW1SNS 18,2
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	CALL SUBOPT_0x4B
	CALL _dir_seek_G101
	MOV  R17,R30
_0x20201B7:
_0x20201B3:
	CPI  R17,4
	BRNE _0x20201B8
	LDI  R17,LOW(5)
_0x20201B8:
_0x20201B2:
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,20
	RET
_f_getfree:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,16
	CALL __SAVELOCR6
	MOVW R30,R28
	ADIW R30,26
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xE8
	LDI  R26,LOW(0)
	CALL SUBOPT_0xE7
	BREQ _0x20201C3
	MOV  R30,R17
	RJMP _0x20E000D
_0x20201C3:
	CALL SUBOPT_0xEC
	MOVW R0,R30
	ADIW R30,14
	MOVW R26,R30
	CALL __GETD1P
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R26,R0
	ADIW R26,30
	CALL __GETD1P
	__SUBD1N 2
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD12
	BRLO _0x20201C4
	CALL SUBOPT_0xEC
	ADIW R30,14
	MOVW R26,R30
	CALL __GETD1P
	RJMP _0x20E000E
_0x20201C4:
	CALL SUBOPT_0xEC
	LD   R16,Z
	LDI  R30,LOW(0)
	__CLRD1S 18
	CPI  R16,1
	BRNE _0x20201C5
	CALL SUBOPT_0xC3
	CALL SUBOPT_0xE4
_0x20201C7:
	CALL SUBOPT_0xEC
	ST   -Y,R31
	ST   -Y,R30
	__GETD2S 16
	CALL _get_fat
	CALL SUBOPT_0x36
	CALL SUBOPT_0x31
	CALL SUBOPT_0x47
	BRNE _0x20201C9
	LDI  R30,LOW(1)
	RJMP _0x20E000D
_0x20201C9:
	CALL SUBOPT_0x31
	CALL SUBOPT_0xB9
	BRNE _0x20201CA
	LDI  R30,LOW(2)
	RJMP _0x20E000D
_0x20201CA:
	CALL SUBOPT_0x35
	CALL __CPD10
	BRNE _0x20201CB
	CALL SUBOPT_0x112
_0x20201CB:
	CALL SUBOPT_0x43
	CALL SUBOPT_0x3B
	CALL SUBOPT_0xE4
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xD0
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	CALL __CPD21
	BRLO _0x20201C7
	RJMP _0x20201CC
_0x20201C5:
	CALL SUBOPT_0xEC
	CALL SUBOPT_0xD0
	CALL SUBOPT_0xE4
	CALL SUBOPT_0xEC
	ADIW R30,34
	MOVW R26,R30
	CALL __GETD1P
	__PUTD1S 10
	__GETWRN 18,19,0
	__GETWRN 20,21,0
_0x20201CE:
	MOV  R0,R18
	OR   R0,R19
	BRNE _0x20201D0
	CALL SUBOPT_0xEC
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x71
	CALL SUBOPT_0x3B
	CALL SUBOPT_0xF3
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	MOVW R26,R30
	MOVW R24,R22
	CALL SUBOPT_0xEA
	BREQ _0x20201D1
	MOV  R30,R17
	RJMP _0x20E000D
_0x20201D1:
	CALL SUBOPT_0xEC
	ADIW R30,50
	MOVW R20,R30
	__GETWRN 18,19,512
_0x20201D0:
	CPI  R16,2
	BRNE _0x20201D2
	MOVW R26,R20
	CALL __GETW1P
	SBIW R30,0
	BRNE _0x20201D3
	CALL SUBOPT_0x112
_0x20201D3:
	__ADDWRN 20,21,2
	__SUBWRN 18,19,2
	RJMP _0x20201D4
_0x20201D2:
	MOVW R26,R20
	CALL SUBOPT_0xAE
	CALL __CPD10
	BRNE _0x20201D5
	CALL SUBOPT_0x112
_0x20201D5:
	__ADDWRN 20,21,4
	__SUBWRN 18,19,4
_0x20201D4:
	CALL SUBOPT_0x43
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	CALL SUBOPT_0xE4
	BREQ _0x20201CF
	RJMP _0x20201CE
_0x20201CF:
_0x20201CC:
	CALL SUBOPT_0xEC
	ADIW R30,14
	CALL SUBOPT_0xBF
	CALL SUBOPT_0xB5
	CPI  R16,3
	BRNE _0x20201D6
	CALL SUBOPT_0xEC
	ADIW R30,5
	LDI  R26,LOW(1)
	STD  Z+0,R26
_0x20201D6:
	CALL SUBOPT_0x42
_0x20E000E:
	LDD  R26,Y+24
	LDD  R27,Y+24+1
	CALL __PUTDP1
	LDI  R30,LOW(0)
_0x20E000D:
	CALL __LOADLOCR6
	ADIW R28,28
	RET
_f_mkdir:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,50
	CALL __SAVELOCR4
	MOVW R30,R28
	ADIW R30,54
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,34
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(1)
	CALL SUBOPT_0xE7
	BREQ _0x20201F3
	RJMP _0x20E000C
_0x20201F3:
	MOVW R30,R28
	ADIW R30,20
	STD  Y+52,R30
	STD  Y+52+1,R31
	MOVW R30,R28
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+56
	LDD  R27,Y+56+1
	CALL _follow_path_G101
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x20201F4
	LDI  R17,LOW(8)
_0x20201F4:
	LDI  R30,LOW(1)
	CPI  R30,0
	BREQ _0x20201F6
	CPI  R17,4
	BRNE _0x20201F6
	LDD  R30,Y+52
	LDD  R31,Y+52+1
	LDD  R30,Z+11
	ANDI R30,LOW(0x20)
	BRNE _0x20201F7
_0x20201F6:
	RJMP _0x20201F5
_0x20201F7:
	LDI  R17,LOW(6)
_0x20201F5:
	CPI  R17,4
	BREQ _0x20201F8
	RJMP _0x20E000C
_0x20201F8:
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	CALL SUBOPT_0xF2
	CALL SUBOPT_0xF3
	LDI  R17,LOW(0)
	CALL SUBOPT_0xC5
	BRNE _0x20201F9
	LDI  R17,LOW(7)
_0x20201F9:
	CALL SUBOPT_0xC7
	BRNE _0x20201FA
	LDI  R17,LOW(2)
_0x20201FA:
	CALL SUBOPT_0xC6
	BRNE _0x20201FB
	LDI  R17,LOW(1)
_0x20201FB:
	CPI  R17,0
	BRNE _0x20201FC
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	CALL SUBOPT_0x9D
	MOV  R17,R30
_0x20201FC:
	CPI  R17,0
	BREQ _0x20201FD
	RJMP _0x20E000C
_0x20201FD:
	CALL SUBOPT_0x113
	CALL _clust2sect
	CALL SUBOPT_0x114
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	ADIW R30,50
	MOVW R18,R30
	CALL SUBOPT_0xD4
	CALL SUBOPT_0x9F
	MOVW R30,R18
	ADIW R30,0
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0xD6
	MOVW R26,R18
	LDI  R30,LOW(46)
	ST   X,R30
	MOVW R30,R18
	ADIW R30,11
	LDI  R26,LOW(16)
	STD  Z+0,R26
	CALL SUBOPT_0xEB
	CALL SUBOPT_0xFF
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	CALL SUBOPT_0xFD
	CALL SUBOPT_0x71
	CALL SUBOPT_0xFE
	MOVW R30,R18
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R19
	ST   -Y,R18
	LDI  R26,LOW(32)
	LDI  R27,0
	CALL _mem_cpy_G101
	MOVW R30,R18
	ADIW R30,33
	LDI  R26,LOW(46)
	STD  Z+0,R26
	CALL SUBOPT_0x3C
	CALL SUBOPT_0xC2
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	LD   R26,X
	CPI  R26,LOW(0x3)
	BRNE _0x20201FF
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	ADIW R26,38
	CALL __GETD1P
	CALL SUBOPT_0xA3
	CALL __CPD12
	BREQ _0x2020200
_0x20201FF:
	RJMP _0x20201FE
_0x2020200:
	LDI  R30,LOW(0)
	__CLRD1S 8
_0x20201FE:
	MOVW R30,R18
	ADIW R30,58
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	STD  Z+0,R26
	STD  Z+1,R27
	CALL SUBOPT_0x49
	CALL __LSRD16
	__PUTW1RNS 18,52
	LDI  R16,LOW(0)
_0x2020202:
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	LDD  R30,Z+2
	CP   R16,R30
	BRSH _0x2020203
	CALL SUBOPT_0x4A
	CALL SUBOPT_0x3B
	CALL SUBOPT_0x114
	SBIW R30,1
	SBCI R22,0
	SBCI R23,0
	__PUTD1SNS 32,46
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	CALL SUBOPT_0x9D
	MOV  R17,R30
	CPI  R17,0
	BRNE _0x20E000C
	CALL SUBOPT_0xD4
	CALL SUBOPT_0x9F
	SUBI R16,-1
	RJMP _0x2020202
_0x2020203:
	MOVW R26,R28
	ADIW R26,32
	CALL _dir_register_G101
	MOV  R17,R30
	CPI  R17,0
	BREQ _0x2020205
	CALL SUBOPT_0x113
	CALL _remove_chain_G101
	RJMP _0x2020206
_0x2020205:
	__GETWRS 18,19,50
	MOVW R30,R18
	ADIW R30,11
	LDI  R26,LOW(16)
	STD  Z+0,R26
	CALL SUBOPT_0x15
	CALL SUBOPT_0xFF
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	CALL SUBOPT_0xFD
	CALL SUBOPT_0x71
	CALL SUBOPT_0xFE
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	ADIW R26,4
	LDI  R30,LOW(1)
	ST   X,R30
	LDD  R26,Y+32
	LDD  R27,Y+32+1
	CALL _sync_G101
	MOV  R17,R30
_0x2020206:
_0x20E000C:
	MOV  R30,R17
	CALL __LOADLOCR4
	ADIW R28,56
	RET
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x01
	.EQU __sm_mask=0x0E
	.EQU __sm_powerdown=0x04
	.EQU __sm_powersave=0x06
	.EQU __sm_standby=0x0C
	.EQU __sm_ext_standby=0x0E
	.EQU __sm_adc_noise_red=0x02
	.SET power_ctrl_reg=smcr
	#endif

	.CSEG
_putchar:
	ST   -Y,R26
_0x2040003:
	LDS  R30,192
	ANDI R30,LOW(0x20)
	BREQ _0x2040003
	LD   R30,Y
	STS  198,R30
	ADIW R28,1
	RET
_puts:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
_0x2040006:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R30,X+
	STD  Y+1,R26
	STD  Y+1+1,R27
	MOV  R17,R30
	CPI  R30,0
	BREQ _0x2040008
	MOV  R26,R17
	RCALL _putchar
	RJMP _0x2040006
_0x2040008:
	LDI  R26,LOW(10)
	RCALL _putchar
_0x20E000B:
	LDD  R17,Y+0
	ADIW R28,3
	RET
_put_buff_G102:
	CALL SUBOPT_0x5E
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,2
	CALL __GETW1P
	SBIW R30,0
	BREQ _0x204002A
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,4
	CALL __GETW1P
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x204002C
	__CPWRN 16,17,2
	BRLO _0x204002D
	MOVW R30,R16
	SBIW R30,1
	MOVW R16,R30
	__PUTW1SNS 2,4
_0x204002C:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,2
	CALL SUBOPT_0xE
	SBIW R30,1
	LDD  R26,Y+4
	STD  Z+0,R26
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	CALL __GETW1P
	TST  R31
	BRMI _0x204002E
	CALL SUBOPT_0xE
_0x204002E:
_0x204002D:
	RJMP _0x204002F
_0x204002A:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	ST   X+,R30
	ST   X,R31
_0x204002F:
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20E0004
__ftoe_G102:
	CALL SUBOPT_0x69
	ST   Y,R30
	LDI  R30,LOW(0)
	STD  Y+1,R30
	LDI  R30,LOW(128)
	STD  Y+2,R30
	LDI  R30,LOW(63)
	STD  Y+3,R30
	CALL __SAVELOCR4
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	CPI  R30,LOW(0xFFFF)
	LDI  R26,HIGH(0xFFFF)
	CPC  R31,R26
	BRNE _0x2040037
	CALL SUBOPT_0x51
	__POINTD2FN _0x2040000,0
	CALL _strcpyf
	CALL __LOADLOCR4
	RJMP _0x20E0009
_0x2040037:
	CPI  R30,LOW(0x7FFF)
	LDI  R26,HIGH(0x7FFF)
	CPC  R31,R26
	BRNE _0x2040036
	CALL SUBOPT_0x51
	__POINTD2FN _0x2040000,1
	CALL _strcpyf
	CALL __LOADLOCR4
	RJMP _0x20E0009
_0x2040036:
	LDD  R26,Y+11
	CPI  R26,LOW(0x7)
	BRLO _0x2040039
	LDI  R30,LOW(6)
	STD  Y+11,R30
_0x2040039:
	LDD  R17,Y+11
_0x204003A:
	MOV  R30,R17
	SUBI R17,1
	CPI  R30,0
	BREQ _0x204003C
	CALL SUBOPT_0x115
	RJMP _0x204003A
_0x204003C:
	CALL SUBOPT_0xC5
	BRNE _0x204003D
	LDI  R19,LOW(0)
	CALL SUBOPT_0x115
	RJMP _0x204003E
_0x204003D:
	LDD  R19,Y+11
	CALL SUBOPT_0x116
	BREQ PC+2
	BRCC PC+3
	JMP  _0x204003F
	CALL SUBOPT_0x115
_0x2040040:
	CALL SUBOPT_0x116
	BRLO _0x2040042
	CALL SUBOPT_0x117
	RJMP _0x2040040
_0x2040042:
	RJMP _0x2040043
_0x204003F:
_0x2040044:
	CALL SUBOPT_0x116
	BRSH _0x2040046
	CALL SUBOPT_0xC1
	CALL SUBOPT_0x118
	CALL SUBOPT_0xF3
	SUBI R19,LOW(1)
	RJMP _0x2040044
_0x2040046:
	CALL SUBOPT_0x115
_0x2040043:
	CALL SUBOPT_0x71
	CALL SUBOPT_0x119
	CALL SUBOPT_0xF3
	CALL SUBOPT_0x116
	BRLO _0x2040047
	CALL SUBOPT_0x117
_0x2040047:
_0x204003E:
	LDI  R17,LOW(0)
_0x2040048:
	LDD  R30,Y+11
	CP   R30,R17
	BRLO _0x204004A
	CALL SUBOPT_0x26
	CALL SUBOPT_0x11A
	CALL SUBOPT_0x119
	MOVW R26,R30
	MOVW R24,R22
	CALL _floor
	CALL SUBOPT_0x2D
	CALL SUBOPT_0xC1
	CALL __DIVF21
	CALL __CFD1U
	MOV  R16,R30
	CALL SUBOPT_0x11B
	MOV  R30,R16
	SUBI R30,-LOW(48)
	ST   X,R30
	MOV  R30,R16
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __CDF1
	CALL SUBOPT_0x26
	CALL __MULF12
	CALL SUBOPT_0xC1
	CALL SUBOPT_0x11C
	CALL SUBOPT_0xF3
	MOV  R30,R17
	SUBI R17,-1
	CPI  R30,0
	BRNE _0x2040048
	CALL SUBOPT_0x11B
	LDI  R30,LOW(46)
	ST   X,R30
	RJMP _0x2040048
_0x204004A:
	CALL SUBOPT_0x11D
	SBIW R30,1
	LDD  R26,Y+10
	STD  Z+0,R26
	CPI  R19,0
	BRGE _0x204004C
	NEG  R19
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(45)
	RJMP _0x2040137
_0x204004C:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(43)
_0x2040137:
	ST   X,R30
	CALL SUBOPT_0x11D
	CALL SUBOPT_0x11D
	SBIW R30,1
	MOVW R22,R30
	MOV  R26,R19
	LDI  R30,LOW(10)
	CALL __DIVB21
	SUBI R30,-LOW(48)
	MOVW R26,R22
	ST   X,R30
	CALL SUBOPT_0x11D
	SBIW R30,1
	MOVW R22,R30
	MOV  R26,R19
	LDI  R30,LOW(10)
	CALL __MODB21
	SUBI R30,-LOW(48)
	MOVW R26,R22
	ST   X,R30
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDI  R30,LOW(0)
	ST   X,R30
	CALL __LOADLOCR4
	RJMP _0x20E0009
__print_G102:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,63
	SBIW R28,21
	CALL __SAVELOCR6
	LDI  R17,0
	__GETD1SX 92
	CALL SUBOPT_0xC2
	__GETW1SX 90
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL SUBOPT_0x6E
_0x204004E:
	MOVW R26,R28
	SUBI R26,LOW(-(98))
	SBCI R27,HIGH(-(98))
	CALL SUBOPT_0x97
	__GETBRPF 30
	MOV  R18,R30
	CPI  R30,0
	BRNE PC+3
	JMP _0x2040050
	MOV  R30,R17
	CPI  R30,0
	BRNE _0x2040054
	CPI  R18,37
	BRNE _0x2040055
	LDI  R17,LOW(1)
	RJMP _0x2040056
_0x2040055:
	CALL SUBOPT_0x11E
_0x2040056:
	RJMP _0x2040053
_0x2040054:
	CPI  R30,LOW(0x1)
	BRNE _0x2040057
	CPI  R18,37
	BRNE _0x2040058
	CALL SUBOPT_0x11E
	RJMP _0x2040138
_0x2040058:
	LDI  R17,LOW(2)
	LDI  R30,LOW(0)
	STD  Y+25,R30
	LDI  R16,LOW(0)
	CPI  R18,45
	BRNE _0x2040059
	LDI  R16,LOW(1)
	RJMP _0x2040053
_0x2040059:
	CPI  R18,43
	BRNE _0x204005A
	LDI  R30,LOW(43)
	STD  Y+25,R30
	RJMP _0x2040053
_0x204005A:
	CPI  R18,32
	BRNE _0x204005B
	LDI  R30,LOW(32)
	STD  Y+25,R30
	RJMP _0x2040053
_0x204005B:
	RJMP _0x204005C
_0x2040057:
	CPI  R30,LOW(0x2)
	BRNE _0x204005D
_0x204005C:
	LDI  R21,LOW(0)
	LDI  R17,LOW(3)
	CPI  R18,48
	BRNE _0x204005E
	ORI  R16,LOW(128)
	RJMP _0x2040053
_0x204005E:
	RJMP _0x204005F
_0x204005D:
	CPI  R30,LOW(0x3)
	BRNE _0x2040060
_0x204005F:
	CPI  R18,48
	BRLO _0x2040062
	CPI  R18,58
	BRLO _0x2040063
_0x2040062:
	RJMP _0x2040061
_0x2040063:
	LDI  R26,LOW(10)
	MUL  R21,R26
	MOV  R21,R0
	MOV  R30,R18
	SUBI R30,LOW(48)
	ADD  R21,R30
	RJMP _0x2040053
_0x2040061:
	LDI  R20,LOW(0)
	CPI  R18,46
	BRNE _0x2040064
	LDI  R17,LOW(4)
	RJMP _0x2040053
_0x2040064:
	RJMP _0x2040065
_0x2040060:
	CPI  R30,LOW(0x4)
	BRNE _0x2040067
	CPI  R18,48
	BRLO _0x2040069
	CPI  R18,58
	BRLO _0x204006A
_0x2040069:
	RJMP _0x2040068
_0x204006A:
	ORI  R16,LOW(32)
	LDI  R26,LOW(10)
	MUL  R20,R26
	MOV  R20,R0
	MOV  R30,R18
	SUBI R30,LOW(48)
	ADD  R20,R30
	RJMP _0x2040053
_0x2040068:
_0x2040065:
	CPI  R18,108
	BRNE _0x204006B
	ORI  R16,LOW(2)
	LDI  R17,LOW(5)
	RJMP _0x2040053
_0x204006B:
	RJMP _0x204006C
_0x2040067:
	CPI  R30,LOW(0x5)
	BREQ PC+3
	JMP _0x2040053
_0x204006C:
	MOV  R30,R18
	CPI  R30,LOW(0x63)
	BRNE _0x2040071
	CALL SUBOPT_0x11F
	CALL SUBOPT_0x120
	CALL SUBOPT_0x11F
	LDD  R26,Z+4
	ST   -Y,R26
	CALL SUBOPT_0x121
	RJMP _0x2040072
_0x2040071:
	CPI  R30,LOW(0x45)
	BREQ _0x2040075
	CPI  R30,LOW(0x65)
	BRNE _0x2040076
_0x2040075:
	RJMP _0x2040077
_0x2040076:
	CPI  R30,LOW(0x66)
	BREQ PC+3
	JMP _0x2040078
_0x2040077:
	MOVW R30,R28
	ADIW R30,26
	STD  Y+16,R30
	STD  Y+16+1,R31
	CALL SUBOPT_0x122
	CALL SUBOPT_0xF1
	CALL SUBOPT_0x123
	LDD  R26,Y+15
	TST  R26
	BRMI _0x2040079
	LDD  R26,Y+25
	CPI  R26,LOW(0x2B)
	BREQ _0x204007B
	RJMP _0x204007C
_0x2040079:
	CALL SUBOPT_0x71
	CALL __ANEGF1
	CALL SUBOPT_0xF3
	LDI  R30,LOW(45)
	STD  Y+25,R30
_0x204007B:
	SBRS R16,7
	RJMP _0x204007D
	LDD  R30,Y+25
	ST   -Y,R30
	CALL SUBOPT_0x121
	RJMP _0x204007E
_0x204007D:
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	ADIW R30,1
	STD  Y+16,R30
	STD  Y+16+1,R31
	SBIW R30,1
	LDD  R26,Y+25
	STD  Z+0,R26
_0x204007E:
_0x204007C:
	SBRS R16,5
	LDI  R20,LOW(6)
	CPI  R18,102
	BRNE _0x2040080
	CALL SUBOPT_0x71
	CALL __PUTPARD1
	ST   -Y,R20
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	CALL _ftoa
	RJMP _0x2040081
_0x2040080:
	CALL SUBOPT_0x71
	CALL __PUTPARD1
	ST   -Y,R20
	ST   -Y,R18
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	RCALL __ftoe_G102
_0x2040081:
	MOVW R30,R28
	ADIW R30,26
	CALL SUBOPT_0x124
	RJMP _0x2040082
_0x2040078:
	CPI  R30,LOW(0x73)
	BRNE _0x2040084
	CALL SUBOPT_0x123
	CALL SUBOPT_0x122
	ADIW R26,4
	CALL __GETW1P
	CALL SUBOPT_0x124
	RJMP _0x2040085
_0x2040084:
	CPI  R30,LOW(0x70)
	BRNE _0x2040087
	CALL SUBOPT_0x123
	CALL SUBOPT_0x122
	ADIW R26,4
	CALL __GETD1P
	CALL SUBOPT_0x114
	__GETD2S 16
	CALL _strlenf
	MOV  R17,R30
	ORI  R16,LOW(8)
_0x2040085:
	ANDI R16,LOW(127)
	CPI  R20,0
	BREQ _0x2040089
	CP   R20,R17
	BRLO _0x204008A
_0x2040089:
	RJMP _0x2040088
_0x204008A:
	MOV  R17,R20
_0x2040088:
_0x2040082:
	LDI  R20,LOW(0)
	LDI  R30,LOW(0)
	STD  Y+24,R30
	LDI  R19,LOW(0)
	RJMP _0x204008B
_0x2040087:
	CPI  R30,LOW(0x64)
	BREQ _0x204008E
	CPI  R30,LOW(0x69)
	BRNE _0x204008F
_0x204008E:
	ORI  R16,LOW(4)
	RJMP _0x2040090
_0x204008F:
	CPI  R30,LOW(0x75)
	BRNE _0x2040091
_0x2040090:
	LDI  R30,LOW(10)
	STD  Y+24,R30
	SBRS R16,1
	RJMP _0x2040092
	__GETD1N 0x3B9ACA00
	CALL SUBOPT_0x125
	LDI  R17,LOW(10)
	RJMP _0x2040093
_0x2040092:
	__GETD1N 0x2710
	CALL SUBOPT_0x125
	LDI  R17,LOW(5)
	RJMP _0x2040093
_0x2040091:
	CPI  R30,LOW(0x58)
	BRNE _0x2040095
	ORI  R16,LOW(8)
	RJMP _0x2040096
_0x2040095:
	CPI  R30,LOW(0x78)
	BREQ PC+3
	JMP _0x20400D4
_0x2040096:
	LDI  R30,LOW(16)
	STD  Y+24,R30
	SBRS R16,1
	RJMP _0x2040098
	__GETD1N 0x10000000
	CALL SUBOPT_0x125
	LDI  R17,LOW(8)
	RJMP _0x2040093
_0x2040098:
	__GETD1N 0x1000
	CALL SUBOPT_0x125
	LDI  R17,LOW(4)
_0x2040093:
	CPI  R20,0
	BREQ _0x2040099
	ANDI R16,LOW(127)
	RJMP _0x204009A
_0x2040099:
	LDI  R20,LOW(1)
_0x204009A:
	SBRS R16,1
	RJMP _0x204009B
	CALL SUBOPT_0x123
	CALL SUBOPT_0x122
	ADIW R26,4
	CALL __GETD1P
	RJMP _0x2040139
_0x204009B:
	SBRS R16,2
	RJMP _0x204009D
	CALL SUBOPT_0x123
	CALL SUBOPT_0x122
	ADIW R26,4
	CALL __GETW1P
	CALL __CWD1
	RJMP _0x2040139
_0x204009D:
	CALL SUBOPT_0x123
	CALL SUBOPT_0x122
	ADIW R26,4
	CALL SUBOPT_0xAC
_0x2040139:
	__PUTD1S 12
	SBRS R16,2
	RJMP _0x204009F
	LDD  R26,Y+15
	TST  R26
	BRPL _0x20400A0
	CALL SUBOPT_0x71
	CALL __ANEGD1
	CALL SUBOPT_0xF3
	LDI  R30,LOW(45)
	STD  Y+25,R30
_0x20400A0:
	LDD  R30,Y+25
	CPI  R30,0
	BREQ _0x20400A1
	SUBI R17,-LOW(1)
	SUBI R20,-LOW(1)
	RJMP _0x20400A2
_0x20400A1:
	ANDI R16,LOW(251)
_0x20400A2:
_0x204009F:
	MOV  R19,R20
_0x204008B:
	SBRC R16,0
	RJMP _0x20400A3
_0x20400A4:
	CP   R17,R21
	BRSH _0x20400A7
	CP   R19,R21
	BRLO _0x20400A8
_0x20400A7:
	RJMP _0x20400A6
_0x20400A8:
	SBRS R16,7
	RJMP _0x20400A9
	SBRS R16,2
	RJMP _0x20400AA
	ANDI R16,LOW(251)
	LDD  R18,Y+25
	SUBI R17,LOW(1)
	RJMP _0x20400AB
_0x20400AA:
	LDI  R18,LOW(48)
_0x20400AB:
	RJMP _0x20400AC
_0x20400A9:
	LDI  R18,LOW(32)
_0x20400AC:
	CALL SUBOPT_0x11E
	SUBI R21,LOW(1)
	RJMP _0x20400A4
_0x20400A6:
_0x20400A3:
_0x20400AD:
	CP   R17,R20
	BRSH _0x20400AF
	ORI  R16,LOW(16)
	SBRS R16,2
	RJMP _0x20400B0
	CALL SUBOPT_0x126
	BREQ _0x20400B1
	SUBI R21,LOW(1)
_0x20400B1:
	SUBI R17,LOW(1)
	SUBI R20,LOW(1)
_0x20400B0:
	LDI  R30,LOW(48)
	ST   -Y,R30
	CALL SUBOPT_0x121
	CPI  R21,0
	BREQ _0x20400B2
	SUBI R21,LOW(1)
_0x20400B2:
	SUBI R20,LOW(1)
	RJMP _0x20400AD
_0x20400AF:
	MOV  R19,R17
	LDD  R30,Y+24
	CPI  R30,0
	BRNE _0x20400B3
_0x20400B4:
	CPI  R19,0
	BREQ _0x20400B6
	SBRS R16,3
	RJMP _0x20400B7
	MOVW R26,R28
	ADIW R26,16
	CALL SUBOPT_0x97
	__GETBRPF 18
	RJMP _0x20400B8
_0x20400B7:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	LD   R18,X+
	STD  Y+16,R26
	STD  Y+16+1,R27
_0x20400B8:
	CALL SUBOPT_0x11E
	CPI  R21,0
	BREQ _0x20400B9
	SUBI R21,LOW(1)
_0x20400B9:
	SUBI R19,LOW(1)
	RJMP _0x20400B4
_0x20400B6:
	RJMP _0x20400BA
_0x20400B3:
_0x20400BC:
	CALL SUBOPT_0x127
	CALL __DIVD21U
	MOV  R18,R30
	CPI  R18,10
	BRLO _0x20400BE
	SBRS R16,3
	RJMP _0x20400BF
	SUBI R18,-LOW(55)
	RJMP _0x20400C0
_0x20400BF:
	SUBI R18,-LOW(87)
_0x20400C0:
	RJMP _0x20400C1
_0x20400BE:
	SUBI R18,-LOW(48)
_0x20400C1:
	SBRC R16,4
	RJMP _0x20400C3
	CPI  R18,49
	BRSH _0x20400C5
	__GETD2S 20
	CALL SUBOPT_0xB9
	BRNE _0x20400C4
_0x20400C5:
	RJMP _0x20400C7
_0x20400C4:
	CP   R20,R19
	BRSH _0x204013A
	CP   R21,R19
	BRLO _0x20400CA
	SBRS R16,0
	RJMP _0x20400CB
_0x20400CA:
	RJMP _0x20400C9
_0x20400CB:
	LDI  R18,LOW(32)
	SBRS R16,7
	RJMP _0x20400CC
_0x204013A:
	LDI  R18,LOW(48)
_0x20400C7:
	ORI  R16,LOW(16)
	SBRS R16,2
	RJMP _0x20400CD
	CALL SUBOPT_0x126
	BREQ _0x20400CE
	SUBI R21,LOW(1)
_0x20400CE:
_0x20400CD:
_0x20400CC:
_0x20400C3:
	CALL SUBOPT_0x11E
	CPI  R21,0
	BREQ _0x20400CF
	SUBI R21,LOW(1)
_0x20400CF:
_0x20400C9:
	SUBI R19,LOW(1)
	CALL SUBOPT_0x127
	CALL __MODD21U
	CALL SUBOPT_0xF3
	LDD  R30,Y+24
	__GETD2S 20
	CLR  R31
	CLR  R22
	CLR  R23
	CALL __DIVD21U
	CALL SUBOPT_0x125
	__GETD1S 20
	CALL __CPD10
	BREQ _0x20400BD
	RJMP _0x20400BC
_0x20400BD:
_0x20400BA:
	SBRS R16,0
	RJMP _0x20400D0
_0x20400D1:
	CPI  R21,0
	BREQ _0x20400D3
	SUBI R21,LOW(1)
	LDI  R30,LOW(32)
	ST   -Y,R30
	CALL SUBOPT_0x121
	RJMP _0x20400D1
_0x20400D3:
_0x20400D0:
_0x20400D4:
_0x2040072:
_0x2040138:
	LDI  R17,LOW(0)
_0x2040053:
	RJMP _0x204004E
_0x2040050:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL __GETW1P
	CALL __LOADLOCR6
	ADIW R28,63
	ADIW R28,39
	RET
_sprintf:
	PUSH R15
	MOV  R15,R24
	SBIW R28,6
	CALL __SAVELOCR4
	CALL SUBOPT_0x128
	SBIW R30,0
	BRNE _0x20400D5
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E000A
_0x20400D5:
	MOVW R26,R28
	ADIW R26,6
	CALL __ADDW2R15
	MOVW R16,R26
	CALL SUBOPT_0x128
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDI  R30,LOW(0)
	STD  Y+8,R30
	STD  Y+8+1,R30
	MOVW R26,R28
	ADIW R26,10
	CALL SUBOPT_0x65
	ST   -Y,R17
	ST   -Y,R16
	CALL SUBOPT_0x129
	MOVW R26,R28
	ADIW R26,14
	RCALL __print_G102
	MOVW R18,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
	MOVW R30,R18
_0x20E000A:
	CALL __LOADLOCR4
	ADIW R28,10
	POP  R15
	RET
_vsprintf:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,6
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	SBIW R30,0
	BRNE _0x20400D8
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20E0008
_0x20400D8:
	LDD  R30,Y+14
	LDD  R31,Y+14+1
	STD  Y+4,R30
	STD  Y+4+1,R31
	LDI  R30,LOW(0)
	STD  Y+6,R30
	STD  Y+6+1,R30
	CALL SUBOPT_0x44
	CALL __PUTPARD1
	CALL SUBOPT_0x4E
	CALL SUBOPT_0x129
	MOVW R26,R28
	ADIW R26,12
	RCALL __print_G102
	MOVW R16,R30
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	LDI  R30,LOW(0)
	ST   X,R30
	MOVW R30,R16
_0x20E0008:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20E0009:
	ADIW R28,16
	RET

	.CSEG
_atoi:
	ST   -Y,R27
	ST   -Y,R26
   	ldd  r27,y+1
   	ld   r26,y
__atoi0:
   	ld   r30,x
        mov  r24,r26
	MOV  R26,R30
	CALL _isspace
        mov  r26,r24
   	tst  r30
   	breq __atoi1
   	adiw r26,1
   	rjmp __atoi0
__atoi1:
   	clt
   	ld   r30,x
   	cpi  r30,'-'
   	brne __atoi2
   	set
   	rjmp __atoi3
__atoi2:
   	cpi  r30,'+'
   	brne __atoi4
__atoi3:
   	adiw r26,1
__atoi4:
   	clr  r22
   	clr  r23
__atoi5:
   	ld   r30,x
        mov  r24,r26
	MOV  R26,R30
	CALL _isdigit
        mov  r26,r24
   	tst  r30
   	breq __atoi6
   	movw r30,r22
   	lsl  r22
   	rol  r23
   	lsl  r22
   	rol  r23
   	add  r22,r30
   	adc  r23,r31
   	lsl  r22
   	rol  r23
   	ld   r30,x+
   	clr  r31
   	subi r30,'0'
   	add  r22,r30
   	adc  r23,r31
   	rjmp __atoi5
__atoi6:
   	movw r30,r22
   	brtc __atoi7
   	com  r30
   	com  r31
   	adiw r30,1
__atoi7:
   	adiw r28,2
   	ret
_ftoa:
	CALL SUBOPT_0x69
	ST   Y,R30
	LDI  R30,LOW(0)
	STD  Y+1,R30
	STD  Y+2,R30
	LDI  R30,LOW(63)
	STD  Y+3,R30
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+11
	LDD  R31,Y+11+1
	CPI  R30,LOW(0xFFFF)
	LDI  R26,HIGH(0xFFFF)
	CPC  R31,R26
	BRNE _0x206000D
	CALL SUBOPT_0x52
	__POINTD2FN _0x2060000,0
	CALL _strcpyf
	RJMP _0x20E0007
_0x206000D:
	CPI  R30,LOW(0x7FFF)
	LDI  R26,HIGH(0x7FFF)
	CPC  R31,R26
	BRNE _0x206000C
	CALL SUBOPT_0x52
	__POINTD2FN _0x2060000,1
	CALL _strcpyf
	RJMP _0x20E0007
_0x206000C:
	LDD  R26,Y+12
	TST  R26
	BRPL _0x206000F
	CALL SUBOPT_0x108
	CALL __ANEGF1
	CALL SUBOPT_0x105
	CALL SUBOPT_0x12A
	LDI  R30,LOW(45)
	ST   X,R30
_0x206000F:
	LDD  R26,Y+8
	CPI  R26,LOW(0x7)
	BRLO _0x2060010
	LDI  R30,LOW(6)
	STD  Y+8,R30
_0x2060010:
	LDD  R17,Y+8
_0x2060011:
	MOV  R30,R17
	SUBI R17,1
	CPI  R30,0
	BREQ _0x2060013
	CALL SUBOPT_0x34
	CALL SUBOPT_0x11A
	CALL SUBOPT_0x32
	RJMP _0x2060011
_0x2060013:
	CALL SUBOPT_0x12B
	CALL __ADDF12
	CALL SUBOPT_0x105
	LDI  R17,LOW(0)
	__GETD1N 0x3F800000
	CALL SUBOPT_0x32
_0x2060014:
	CALL SUBOPT_0x12B
	CALL __CMPF12
	BRLO _0x2060016
	CALL SUBOPT_0x34
	CALL SUBOPT_0x118
	CALL SUBOPT_0x32
	SUBI R17,-LOW(1)
	CPI  R17,39
	BRLO _0x2060017
	CALL SUBOPT_0x52
	__POINTD2FN _0x2060000,5
	CALL _strcpyf
	RJMP _0x20E0007
_0x2060017:
	RJMP _0x2060014
_0x2060016:
	CPI  R17,0
	BRNE _0x2060018
	CALL SUBOPT_0x12A
	LDI  R30,LOW(48)
	ST   X,R30
	RJMP _0x2060019
_0x2060018:
_0x206001A:
	MOV  R30,R17
	SUBI R17,1
	CPI  R30,0
	BREQ _0x206001C
	CALL SUBOPT_0x34
	CALL SUBOPT_0x11A
	CALL SUBOPT_0x119
	MOVW R26,R30
	MOVW R24,R22
	CALL _floor
	CALL SUBOPT_0x32
	CALL SUBOPT_0x12B
	CALL __DIVF21
	CALL __CFD1U
	MOV  R16,R30
	CALL SUBOPT_0x12A
	MOV  R30,R16
	SUBI R30,-LOW(48)
	ST   X,R30
	CALL SUBOPT_0x2A
	CALL SUBOPT_0x34
	CALL __CWD1
	CALL __CDF1
	CALL __MULF12
	CALL SUBOPT_0x110
	CALL SUBOPT_0x11C
	CALL SUBOPT_0x105
	RJMP _0x206001A
_0x206001C:
_0x2060019:
	LDD  R30,Y+8
	CPI  R30,0
	BREQ _0x20E0006
	CALL SUBOPT_0x12A
	LDI  R30,LOW(46)
	ST   X,R30
_0x206001E:
	LDD  R30,Y+8
	SUBI R30,LOW(1)
	STD  Y+8,R30
	SUBI R30,-LOW(1)
	BREQ _0x2060020
	CALL SUBOPT_0x110
	CALL SUBOPT_0x118
	CALL SUBOPT_0x105
	CALL SUBOPT_0x108
	CALL __CFD1U
	MOV  R16,R30
	CALL SUBOPT_0x12A
	MOV  R30,R16
	SUBI R30,-LOW(48)
	ST   X,R30
	CALL SUBOPT_0x2A
	CALL SUBOPT_0x110
	CALL __CWD1
	CALL __CDF1
	CALL SUBOPT_0x11C
	CALL SUBOPT_0x105
	RJMP _0x206001E
_0x2060020:
_0x20E0006:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
_0x20E0007:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,13
	RET

	.DSEG

	.CSEG
_srand:
	CALL SUBOPT_0x20
	CALL __CWD1
	STS  __seed_G103,R30
	STS  __seed_G103+1,R31
	STS  __seed_G103+2,R22
	STS  __seed_G103+3,R23
	ADIW R28,2
	RET
_allocate_block_G103:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,2
	CALL __SAVELOCR6
	__GETWRN 16,17,6420
	MOVW R26,R16
	CALL SUBOPT_0x6E
_0x2060061:
	MOV  R0,R16
	OR   R0,R17
	BREQ _0x2060063
	MOVW R26,R16
	CALL __GETW1P
	ADD  R30,R16
	ADC  R31,R17
	ADIW R30,4
	MOVW R20,R30
	ADIW R26,2
	CALL __GETW1P
	MOVW R18,R30
	SBIW R30,0
	BREQ _0x2060064
	__PUTWSR 18,19,6
	RJMP _0x2060065
_0x2060064:
	LDI  R30,LOW(8704)
	LDI  R31,HIGH(8704)
	STD  Y+6,R30
	STD  Y+6+1,R31
_0x2060065:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUB  R26,R20
	SBC  R27,R21
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,4
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x2060066
	MOVW R30,R20
	__PUTW1RNS 16,2
	MOVW R30,R18
	__PUTW1RNS 20,2
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	MOVW R26,R20
	ST   X+,R30
	ST   X,R31
	__ADDWRN 20,21,4
	MOVW R30,R20
	RJMP _0x20E0005
_0x2060066:
	MOVW R16,R18
	RJMP _0x2060061
_0x2060063:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
_0x20E0005:
	CALL __LOADLOCR6
	ADIW R28,10
	RET
_malloc:
	CALL SUBOPT_0x5E
	__GETWRN 16,17,0
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	SBIW R30,0
	BREQ _0x2060070
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	RCALL _allocate_block_G103
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x2060071
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDD  R26,Y+5
	LDD  R27,Y+5+1
	CALL _memset
_0x2060071:
_0x2060070:
	MOVW R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	JMP  _0x20E0001

	.CSEG
_memcpy:
	ST   -Y,R27
	ST   -Y,R26
    ldd  r25,y+1
    ld   r24,y
    adiw r24,0
    breq memcpy1
    ldd  r27,y+5
    ldd  r26,y+4
    ldd  r31,y+3
    ldd  r30,y+2
memcpy0:
    ld   r22,z+
    st   x+,r22
    sbiw r24,1
    brne memcpy0
memcpy1:
    ldd  r31,y+5
    ldd  r30,y+4
	JMP  _0x20E0003
_memset:
	ST   -Y,R27
	ST   -Y,R26
    ldd  r27,y+1
    ld   r26,y
    adiw r26,0
    breq memset1
    ldd  r31,y+4
    ldd  r30,y+3
    ldd  r22,y+2
memset0:
    st   z+,r22
    sbiw r26,1
    brne memset0
memset1:
    ldd  r30,y+3
    ldd  r31,y+4
_0x20E0004:
	ADIW R28,5
	RET
_strcpyf:
	CALL __PUTPARD2
    ld   r30,y+
    ld   r31,y+
    ld   r22,y+
    ld   r23,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
    out  rampz,r22
strcpyf0:
    elpm r0,z+
    st   x+,r0
    tst  r0
    brne strcpyf0
    movw r30,r24
    ret
_strlen:
	ST   -Y,R27
	ST   -Y,R26
    ld   r26,y+
    ld   r27,y+
    clr  r30
    clr  r31
strlen0:
    ld   r22,x+
    tst  r22
    breq strlen1
    adiw r30,1
    rjmp strlen0
strlen1:
    ret
_strlenf:
	CALL __PUTPARD2
    clr  r26
    clr  r27
    ld   r30,y+
    ld   r31,y+
    ld   r22,y+
    ld   r23,y+
    out  rampz,r22
strlenf0:
    elpm r0,z+
    tst  r0
    breq strlenf1
    adiw r26,1
    rjmp strlenf0
strlenf1:
    movw r30,r26
    ret
_strncmp:
	ST   -Y,R26
    clr  r22
    clr  r23
    ld   r24,y+
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
strncmp0:
    tst  r24
    breq strncmp1
    dec  r24
    ld   r22,x+
    ld   r23,z+
    cp   r22,r23
    brne strncmp1
    tst  r22
    brne strncmp0
strncmp3:
    clr  r30
    ret
strncmp1:
    sub  r22,r23
    breq strncmp3
    ldi  r30,1
    brcc strncmp2
    subi r30,2
strncmp2:
    ret
_strpbrkf:
	CALL __PUTPARD2
    ldd  r27,y+5
    ldd  r26,y+4
strpbrkf0:
    ld   r23,x
    tst  r23
    breq strpbrkf2
    ldd  r22,y+2
    ldd  r31,y+1
    ld   r30,y
strpbrkf1:
    out  rampz,r22
    elpm
    tst  r0
    breq strpbrkf3
    subi r30,255
    sbci r31,255
    sbci r22,255
    cp   r23,r0
    brne strpbrkf1
    movw r30,r26
    rjmp strpbrkf4
strpbrkf3:
    adiw r26,1
    rjmp strpbrkf0
strpbrkf2:
    clr  r30
    clr  r31
strpbrkf4:
	JMP  _0x20E0003
_strstr:
	ST   -Y,R27
	ST   -Y,R26
    ldd  r26,y+2
    ldd  r27,y+3
    movw r24,r26
strstr0:
    ld   r30,y
    ldd  r31,y+1
strstr1:
    ld   r23,z+
    tst  r23
    brne strstr2
    movw r30,r24
    rjmp strstr3
strstr2:
    ld   r22,x+
    cp   r22,r23
    breq strstr1
    adiw r24,1
    movw r26,r24
    tst  r22
    brne strstr0
    clr  r30
    clr  r31
strstr3:
	JMP  _0x20E0001
_strspnf:
	CALL __PUTPARD2
    ldd  r27,y+5
    ldd  r26,y+4
    clr  r24
    clr  r25
strspnf0:
    ld   r23,x+
    tst  r23
    breq strspnf2
    ldd  r22,y+2
    ldd  r31,y+1
    ld   r30,y
    out  rampz,r22
strspnf1:
    elpm r0,z+
    tst  r0
    breq strspnf2
    cp   r23,r0
    brne strspnf1
    adiw r24,1
    rjmp strspnf0
strspnf2:
    movw r30,r24
_0x20E0003:
	ADIW R28,6
	RET
_strtok:
	CALL __PUTPARD2
	ST   -Y,R17
	ST   -Y,R16
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	SBIW R30,0
	BRNE _0x2080003
	LDS  R30,_p_S1040026000
	LDS  R31,_p_S1040026000+1
	SBIW R30,0
	BRNE _0x2080004
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E0002
_0x2080004:
	LDS  R30,_p_S1040026000
	LDS  R31,_p_S1040026000+1
	STD  Y+6,R30
	STD  Y+6+1,R31
_0x2080003:
	CALL SUBOPT_0x52
	CALL SUBOPT_0x26
	CALL _strspnf
	CALL SUBOPT_0x6B
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R30,X
	CPI  R30,0
	BRNE _0x2080005
	LDI  R30,LOW(0)
	STS  _p_S1040026000,R30
	STS  _p_S1040026000+1,R30
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RJMP _0x20E0002
_0x2080005:
	CALL SUBOPT_0x52
	CALL SUBOPT_0x26
	CALL _strpbrkf
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x2080006
	MOVW R26,R16
	__ADDWRN 16,17,1
	LDI  R30,LOW(0)
	ST   X,R30
_0x2080006:
	__PUTWMRN _p_S1040026000,0,16,17
	LDD  R30,Y+6
	LDD  R31,Y+6+1
_0x20E0002:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,8
	RET

	.CSEG
_isdigit:
	ST   -Y,R26
    ldi  r30,1
    ld   r31,y+
    cpi  r31,'0'
    brlo isdigit0
    cpi  r31,'9'+1
    brlo isdigit1
isdigit0:
    clr  r30
isdigit1:
    ret
_isprint:
	ST   -Y,R26
    ldi  r30,1
    ld   r31,y+
    cpi  r31,32
    brlo isprint0
    cpi  r31,128
    brlo isprint1
isprint0:
    clr  r30
isprint1:
    ret
_isspace:
	ST   -Y,R26
    ldi  r30,1
    ld   r31,y+
    cpi  r31,' '
    breq isspace1
    cpi  r31,9
    brlo isspace0
    cpi  r31,13+1
    brlo isspace1
isspace0:
    clr  r30
isspace1:
    ret

	.CSEG
_ftrunc:
	CALL __PUTPARD2
   ldd  r23,y+3
   ldd  r22,y+2
   ldd  r31,y+1
   ld   r30,y
   bst  r23,7
   lsl  r23
   sbrc r22,7
   sbr  r23,1
   mov  r25,r23
   subi r25,0x7e
   breq __ftrunc0
   brcs __ftrunc0
   cpi  r25,24
   brsh __ftrunc1
   clr  r26
   clr  r27
   clr  r24
__ftrunc2:
   sec
   ror  r24
   ror  r27
   ror  r26
   dec  r25
   brne __ftrunc2
   and  r30,r26
   and  r31,r27
   and  r22,r24
   rjmp __ftrunc1
__ftrunc0:
   clt
   clr  r23
   clr  r30
   clr  r31
   clr  r22
__ftrunc1:
   cbr  r22,0x80
   lsr  r23
   brcc __ftrunc3
   sbr  r22,0x80
__ftrunc3:
   bld  r23,7
   ld   r26,y+
   ld   r27,y+
   ld   r24,y+
   ld   r25,y+
   cp   r30,r26
   cpc  r31,r27
   cpc  r22,r24
   cpc  r23,r25
   bst  r25,7
   ret
_floor:
	CALL __PUTPARD2
	RCALL SUBOPT_0x19
	CALL _ftrunc
	CALL SUBOPT_0xBD
    brne __floor1
__floor0:
	RCALL SUBOPT_0x13
	RJMP _0x20E0001
__floor1:
    brtc __floor0
	RCALL SUBOPT_0x13
	__GETD2N 0x3F800000
	CALL __SUBF12
_0x20E0001:
	ADIW R28,4
	RET

	.DSEG
_prtc_get_time:
	.BYTE 0x4
_prtc_get_date:
	.BYTE 0x4
_flag_PackageTerminate3:
	.BYTE 0x1
_rxPackage3:
	.BYTE 0x40
_rx_buffer0:
	.BYTE 0x2
_rx0Buffer:
	.BYTE 0x190
_rxBeginCount:
	.BYTE 0x2
_rx_rd_index0:
	.BYTE 0x2
_rx_counter0:
	.BYTE 0x2
_index0Buffer:
	.BYTE 0x2
_hwCalId:
	.BYTE 0x2
_pviQueueSensorToMang:
	.BYTE 0x2
_pviQueueMangToConfig:
	.BYTE 0x2
_pviQueueDeviceToMang:
	.BYTE 0x2
_viRXData:
	.BYTE 0x12E
_viDataReport:
	.BYTE 0x66
_viStatusReport:
	.BYTE 0x66
_baseCounter:
	.BYTE 0x4
_countTimerIntpTask:
	.BYTE 0x2

	.ESEG
_DEVICE_SERIAL:
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x2,0x22

	.DSEG
_ETH_current_mode:
	.BYTE 0x1
_pviUart0TimeOut:
	.BYTE 0x2
_wiz100srSetTimer:
	.BYTE 0x2
_viFlagTerInit:
	.BYTE 0x1
_iWizRXMode:
	.BYTE 0x1
_iWizData:
	.BYTE 0x4
_iHTTPStatus:
	.BYTE 0x4
_sdFreeSpace:
	.BYTE 0x4
_viFolderDataName:
	.BYTE 0x5
_viFolderDataLogName:
	.BYTE 0x9
_viFolderEventName:
	.BYTE 0x6
_viFolderStatusName:
	.BYTE 0x7
_viFolderErrorName:
	.BYTE 0x6
_viFolderConfigName:
	.BYTE 0x7
_viDirDataPath:
	.BYTE 0x8
_viDirDataLogPath:
	.BYTE 0xC
_viDirEventPath:
	.BYTE 0x9
_viDirStatusPath:
	.BYTE 0xA
_viDirErrorPath:
	.BYTE 0x9
_viDirConfigPath:
	.BYTE 0xA
_viDataFName:
	.BYTE 0xD
_viDataLogFName:
	.BYTE 0x10

	.ESEG
_viDVConfigUpdate:
	.BYTE 0x153

	.DSEG
_raw_rtc:
	.BYTE 0x4
_adcData:
	.BYTE 0x14

	.ESEG
_eep_vref_val:
	.DB  0xA,0xD7,0x23,0x40

	.DSEG
_LOGFILE_DATA:
	.BYTE 0x9
_LOGFILE_EVENT:
	.BYTE 0xA
_LOGFILE_ERROR:
	.BYTE 0xA
_LOG_INIT_STR:
	.BYTE 0x10
_isDataLogEmpty:
	.BYTE 0x1
_isEventLogEmpty:
	.BYTE 0x1
_adcBatt:
	.BYTE 0x4
_sensorCalConfig:
	.BYTE 0xC

	.ESEG
_sensorCalulate:
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0
	.DB  0x0,0x0

	.DSEG
_pfCalibrate:
	.BYTE 0x4
_dhtDevice:
	.BYTE 0xA
_dataQ:
	.BYTE 0x64
_last_wr_dataQ:
	.BYTE 0x2
_last_rd_dataQ:
	.BYTE 0x2
_dataQ_len:
	.BYTE 0x2
_eventQ:
	.BYTE 0x78
_last_wr_eventQ:
	.BYTE 0x2
_last_rd_eventQ:
	.BYTE 0x2
_eventQ_len:
	.BYTE 0x2
_fat:
	.BYTE 0x232
_pfat:
	.BYTE 0x2
_root_path:
	.BYTE 0x4
_eventLogQueue:
	.BYTE 0x8C
_eventLogQCount:
	.BYTE 0x1
_dataLogQueue:
	.BYTE 0x6E
_dataLogQCount:
	.BYTE 0x1
_n:
	.BYTE 0x2
_a:
	.BYTE 0x30
_iPTC_RX:
	.BYTE 0x16
_viMangQueue:
	.BYTE 0x23
_task_count_g:
	.BYTE 0x2
_pviTaskList:
	.BYTE 0xC
_viSwitchContextSensor:
	.BYTE 0x2
_pviSensorData:
	.BYTE 0x12
_iWiz100srConfig:
	.BYTE 0x59
_pfiWiz100rs:
	.BYTE 0x4
_viDataConfig:
	.BYTE 0x7
_file_info:
	.BYTE 0x16
_viDataReportBuff:
	.BYTE 0x7
_viStatusReportBuff:
	.BYTE 0x6
_status_G100:
	.BYTE 0x1
_timer1_G100:
	.BYTE 0x1
_timer2_G100:
	.BYTE 0x1
_card_type_G100:
	.BYTE 0x1
_pv_S100000B000:
	.BYTE 0x1
_FatFs_G101:
	.BYTE 0x2
_Fsid_G101:
	.BYTE 0x2
_Drive_G101:
	.BYTE 0x1
__seed_G103:
	.BYTE 0x4
_p_S1040026000:
	.BYTE 0x2

	.CSEG
;OPTIMIZER ADDED SUBROUTINE, CALLED 63 TIMES, CODE SIZE REDUCTION:245 WORDS
SUBOPT_0x0:
	CALL __PUTPARD1
	LDI  R24,0
	CALL _printDebug
	ADIW R28,4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x1:
	LDI  R27,0
	JMP  _iQueueCreate

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x2:
	LDI  R24,0
	CALL _printDebug
	ADIW R28,4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 25 TIMES, CODE SIZE REDUCTION:93 WORDS
SUBOPT_0x3:
	CALL __PUTPARD1
	LDI  R24,4
	CALL _printDebug
	ADIW R28,8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x4:
	LDI  R26,LOW(2)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x5:
	LDI  R26,LOW(100)
	LDI  R27,0
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x6:
	LDI  R27,0
	JMP  _enable_interrupt

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:29 WORDS
SUBOPT_0x7:
	STS  258,R30
	LDI  R26,LOW(200)
	LDI  R27,0
	CALL _delay_ms
	LDS  R30,258
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x8:
	LDI  R26,LOW(50)
	LDI  R27,0
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:42 WORDS
SUBOPT_0x9:
	ST   -Y,R0
	ST   -Y,R1
	ST   -Y,R15
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R24
	ST   -Y,R25
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,RAMPZ
	ST   -Y,R30
	IN   R30,EIND
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA:
	CALL __SAVELOCR4
	__GETWRN 18,19,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:16 WORDS
SUBOPT_0xB:
	LDI  R26,LOW(_index0Buffer)
	LDI  R27,HIGH(_index0Buffer)
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	SBIW R30,1
	SUBI R30,LOW(-_rx0Buffer)
	SBCI R31,HIGH(-_rx0Buffer)
	ST   Z,R16
	MOV  R26,R16
	CALL _putchar3
	LDS  R26,_index0Buffer
	LDS  R27,_index0Buffer+1
	CPI  R26,LOW(0x190)
	LDI  R30,HIGH(0x190)
	CPC  R27,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xC:
	CALL _send_uart
	LDI  R30,LOW(3)
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xD:
	CALL _send_uart
	LDI  R30,LOW(0)
	STS  _index0Buffer,R30
	STS  _index0Buffer+1,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0xE:
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0xF:
	LDS  R26,_index0Buffer
	LDS  R27,_index0Buffer+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x10:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	LD   R30,X
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x11:
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	LD   R26,X
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x12:
	CALL __PUTPARD2
	CALL __GETD1S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x13:
	CALL __GETD1S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x14:
	LDS  R26,_baseCounter
	LDS  R27,_baseCounter+1
	LDS  R24,_baseCounter+2
	LDS  R25,_baseCounter+3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 19 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0x15:
	__GETD1S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x16:
	__GETD1N 0xFFFFFFFF
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x17:
	CALL __PUTD1S0
	RJMP SUBOPT_0x13

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x18:
	LDS  R30,_baseCounter
	LDS  R31,_baseCounter+1
	LDS  R22,_baseCounter+2
	LDS  R23,_baseCounter+3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x19:
	CALL __GETD2S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x1A:
	CALL __PUTPARD1
	__GETD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x1B:
	__GETD1N 0x0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1C:
	LDI  R30,LOW(254)
	STS  133,R30
	LDI  R30,LOW(121)
	STS  132,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1D:
	LDI  R30,LOW(133)
	STS  149,R30
	LDI  R30,LOW(237)
	STS  148,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x1E:
	CALL __GETD1P_INC
	__SUBD1N -1
	CALL __PUTDP1_DEC
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1F:
	LDI  R30,LOW(133)
	STS  165,R30
	LDI  R30,LOW(237)
	STS  164,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x20:
	ST   -Y,R27
	ST   -Y,R26
	LD   R30,Y
	LDD  R31,Y+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:77 WORDS
SUBOPT_0x21:
	IN   R30,0x6
	ANDI R30,LOW(0xC0)
	LDI  R31,0
	CALL __ASRW2
	CALL __ASRW4
	COM  R30
	COM  R31
	ANDI R30,LOW(0x3)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x22:
	IN   R30,0x6
	ANDI R30,LOW(0xC0)
	LDI  R31,0
	CALL __ASRW2
	CALL __ASRW4
	COM  R30
	COM  R31
	ANDI R30,LOW(0x3)
	ANDI R31,HIGH(0x3)
	SBIW R30,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x23:
	CLR  R22
	CLR  R23
	CALL __CDF1
	CALL __PUTDP1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x24:
	CALL _i2c_start
	LDI  R26,LOW(208)
	JMP  _i2c_write

;OPTIMIZER ADDED SUBROUTINE, CALLED 22 TIMES, CODE SIZE REDUCTION:39 WORDS
SUBOPT_0x25:
	__PUTD1S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 26 TIMES, CODE SIZE REDUCTION:47 WORDS
SUBOPT_0x26:
	__GETD2S 4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x27:
	LDI  R30,LOW(8)
	CALL __LSLD12
	RJMP SUBOPT_0x25

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x28:
	MOV  R30,R19
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x29:
	RCALL SUBOPT_0x26
	CALL __CWD1
	CALL __ADDD12
	RCALL SUBOPT_0x25
	RCALL SUBOPT_0x26
	RJMP SUBOPT_0x27

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x2A:
	MOV  R30,R16
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2B:
	MOV  R30,R17
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2C:
	CALL __CWD1
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x2D:
	RCALL SUBOPT_0x25
	RJMP SUBOPT_0x15

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x2E:
	__GETD1N 0x3C
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2F:
	__PUTD1S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x30:
	__GETD2N 0x3C
	CALL __MULD12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x31:
	__GETD2S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x32:
	__PUTD1S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x33:
	__GETD1S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0x34:
	__GETD2S 2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x35:
	__GETD1S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x36:
	__PUTD1S 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x37:
	RCALL SUBOPT_0x31
	__GETD1N 0x5B5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x38:
	__PUTD1S 30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x39:
	__GETD2S 26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x3A:
	__CPD2N 0x3C
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x3B:
	__SUBD1N -1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x3C:
	__GETD1S 38
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3D:
	CALL __SWAPD12
	CALL __SUBD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x3E:
	__PUTD1S 22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x3F:
	__GETD1S 34
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x40:
	__GETD2S 22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x41:
	__ADDD1N 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x42:
	__GETD1S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x43:
	__GETD1S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x44:
	__GETD1S 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x45:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	ST   -Y,R17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x46:
	RCALL SUBOPT_0x32
	RJMP SUBOPT_0x34

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:57 WORDS
SUBOPT_0x47:
	__CPD2N 0xFFFFFFFF
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x48:
	CLR  R22
	CLR  R23
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0x49:
	__GETD1S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x4A:
	__GETD1S 16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x4B:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(0)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x4C:
	ST   -Y,R27
	ST   -Y,R26
	CALL __SAVELOCR4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x4D:
	LDS  R30,_sdFreeSpace
	LDS  R31,_sdFreeSpace+1
	LDS  R22,_sdFreeSpace+2
	LDS  R23,_sdFreeSpace+3
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x4E:
	LDD  R30,Y+12
	LDD  R31,Y+12+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x4F:
	__GETD2S 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x50:
	MOV  R26,R17
	CALL _error
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x51:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0x52:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x53:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,3
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x54:
	CALL __PUTPARD1
	LDI  R30,LOW(_root_path)
	LDI  R31,HIGH(_root_path)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 13 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x55:
	CLR  R22
	CLR  R23
	RJMP SUBOPT_0x3

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0x56:
	CALL _error
	LDI  R30,LOW(0)
	STS  _sdFreeSpace,R30
	STS  _sdFreeSpace+1,R30
	STS  _sdFreeSpace+2,R30
	STS  _sdFreeSpace+3,R30
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x57:
	LDD  R30,Z+2
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x58:
	__GETD2S 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x59:
	CALL __CWD1
	CALL __MULD12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x5A:
	MOVW R30,R28
	ADIW R30,1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5B:
	__POINTD1FN _0x240000,798
	RJMP SUBOPT_0x54

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x5C:
	MOVW R30,R28
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5D:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x5E:
	ST   -Y,R27
	ST   -Y,R26
	ST   -Y,R17
	ST   -Y,R16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x5F:
	LDI  R26,LOW(1000)
	LDI  R27,HIGH(1000)
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x60:
	CALL __PUTPARD1
	__GETW1SX 555
	RJMP SUBOPT_0x55

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x61:
	__GETW1SX 548
	ST   -Y,R31
	ST   -Y,R30
	__GETW2SX 548
	JMP  _print_payload

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x62:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(_LOG_INIT_STR)
	LDI  R31,HIGH(_LOG_INIT_STR)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(16)
	LDI  R27,0
	CALL _LOG_createFile
	MOVW R16,R30
	TST  R17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x63:
	__POINTD1FN _0x260000,1916
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x64:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x65:
	CALL __ADDW2R15
	CALL __GETD1P
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x66:
	CALL __PUTPARD1
	MOVW R26,R20
	LD   R30,X
	CLR  R31
	CLR  R22
	CLR  R23
	RJMP SUBOPT_0x3

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x67:
	__POINTD1FN _0x2A0000,147
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x68:
	__POINTD1FN _0x2A0000,1170
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x69:
	ST   -Y,R27
	ST   -Y,R26
	SBIW R28,4
	LDI  R30,LOW(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6A:
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	JMP  _print_hex_ascii_line

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x6B:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6C:
	LDD  R30,Y+4
	LDD  R31,Y+4+1
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	CALL __MULW12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6D:
	MOVW R26,R16
	ADIW R26,8
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x6E:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x6F:
	LSL  R30
	ROL  R31
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x70:
	SBIW R28,2
	LDI  R30,LOW(0)
	ST   Y,R30
	STD  Y+1,R30
	CALL __SAVELOCR6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 17 TIMES, CODE SIZE REDUCTION:29 WORDS
SUBOPT_0x71:
	__GETD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x72:
	LDI  R27,0
	JMP  _memcpy

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x73:
	LDS  R30,_task_count_g
	LDS  R31,_task_count_g+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x74:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDI  R26,LOW(_pviTaskList)
	LDI  R27,HIGH(_pviTaskList)
	LSL  R30
	ROL  R31
	ADD  R26,R30
	ADC  R27,R31
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x75:
	LSL  R30
	ROL  R31
	ADD  R26,R30
	ADC  R27,R31
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x76:
	LDI  R27,0
	JMP  _memset

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x77:
	LDI  R30,LOW(0)
	STS  _index0Buffer,R30
	STS  _index0Buffer+1,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x78:
	MOVW R30,R28
	ADIW R30,4
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x79:
	LDI  R30,LOW(_rx0Buffer)
	LDI  R31,HIGH(_rx0Buffer)
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0xF
	JMP  _memcpy

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x7A:
	__POINTD2FN _0x440000,314
	CALL _strtok
	MOVW R18,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x7B:
	__POINTD1FN _0x440000,316
	CALL __PUTPARD1
	MOVW R30,R18
	RJMP SUBOPT_0x55

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x7C:
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x7D:
	CALL _strlen
	MOV  R26,R16
	LDI  R27,0
	CP   R26,R30
	CPC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x7E:
	ADD  R26,R30
	ADC  R27,R31
	LD   R26,X
	JMP  _putchar0

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x7F:
	__GETD2N 0x1
	JMP  _TIMER_setTimer

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x80:
	RCALL SUBOPT_0x26
	CALL _TIMER_checkTimerExceed
	SBIW R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x81:
	RCALL SUBOPT_0xF
	CALL __CPW02
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x82:
	MOVW R30,R28
	ADIW R30,8
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0x83:
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R28
	ADIW R26,10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x84:
	__POINTD1FN _0x440000,549
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x85:
	CLR  R31
	CLR  R22
	CLR  R23
	RJMP SUBOPT_0x3

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x86:
	__POINTD1FN _0x440000,15
	RJMP SUBOPT_0x0

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x87:
	__POINTD1FN _0x440000,574
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x88:
	CLR  R30
	ADD  R26,R16
	ADC  R27,R30
	LD   R30,X
	RJMP SUBOPT_0x85

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x89:
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	__POINTD2FN _0x440000,578
	CALL _strtok
	MOVW R16,R30
	LDI  R20,LOW(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x8A:
	__POINTD2FN _0x440000,578
	CALL _strtok
	MOVW R16,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x8B:
	ADD  R30,R26
	ADC  R31,R27
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x8C:
	CALL _f_opendir
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x8D:
	MOV  R26,R17
	CALL _iFDisplayReturn
	CPI  R17,5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x8E:
	CALL _f_mkdir
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x8F:
	__POINTW2MN _viDVConfigUpdate,168
	RJMP SUBOPT_0x2B

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x90:
	MOVW R22,R26
	LDI  R26,LOW(28)
	LDI  R27,HIGH(28)
	CALL __MULW12U
	MOVW R26,R22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x91:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,2
	RJMP SUBOPT_0x28

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x92:
	MOVW R30,R28
	ADIW R30,6
	ST   -Y,R31
	ST   -Y,R30
	RJMP SUBOPT_0x4

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x93:
	MOV  R30,R19
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R31,0
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x94:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,2
	ST   -Y,R31
	ST   -Y,R30
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL __GETW1P
	MOVW R26,R30
	JMP  _print_payload

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x95:
	LD   R30,X
	LDI  R31,0
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x96:
	LDI  R31,0
	CALL __CWD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x97:
	CALL __GETD1P_INC
	RCALL SUBOPT_0x41
	CALL __PUTDP1_DEC
	__SUBD1N 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x98:
	CALL __GETD1P
	__PUTD1S 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x99:
	__GETD1S 5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x9A:
	LDD  R30,Y+9
	LDD  R31,Y+9+1
	LDD  R26,Z+1
	ST   -Y,R26
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	ADIW R30,50
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0x15
	CALL __PUTPARD1
	LDI  R26,LOW(1)
	JMP  _disk_write

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x9B:
	__GETD2Z 34
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x9C:
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0x49
	CALL __PUTPARD1
	LDI  R26,LOW(1)
	CALL _disk_read
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x9D:
	ST   -Y,R31
	ST   -Y,R30
	__GETD2N 0x0
	JMP  _move_window_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x9E:
	RCALL SUBOPT_0x1B
	CALL __PUTDP1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x9F:
	LDI  R26,LOW(512)
	LDI  R27,HIGH(512)
	JMP  _mem_set_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xA0:
	CALL __PUTDZ20
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,50
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xA1:
	CALL __GETD1P
	MOVW R26,R0
	CALL __PUTDP1
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xA2:
	__GETD2Z 18
	CALL __PUTPARD2
	LDI  R26,LOW(1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0xA3:
	__GETD2S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0xA4:
	__CPD2N 0x2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA5:
	__GETD1N 0x1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA6:
	CALL __GETD1P
	RJMP SUBOPT_0x25

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xA7:
	MOVW R26,R18
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	CALL __DIVW21U
	RCALL SUBOPT_0x31
	CLR  R22
	CLR  R23
	CALL __ADDD21
	CALL _move_window_G101
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xA8:
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,50
	MOVW R30,R18
	ANDI R31,HIGH(0x1FF)
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xA9:
	__GETD1N 0x100
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xAA:
	RCALL SUBOPT_0x31
	CALL __ADDD21
	CALL _move_window_G101
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xAB:
	CALL __MULB1W2U
	ANDI R31,HIGH(0x1FF)
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	ADIW R26,50
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0xAC:
	CALL __GETW1P
	CLR  R22
	CLR  R23
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xAD:
	__GETD1N 0x80
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xAE:
	CALL __GETD1P
	__ANDD1N 0xFFFFFFF
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xAF:
	__GETD2S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:14 WORDS
SUBOPT_0xB0:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ST   -Y,R31
	ST   -Y,R30
	MOVW R26,R16
	LDI  R30,LOW(512)
	LDI  R31,HIGH(512)
	CALL __DIVW21U
	RCALL SUBOPT_0xA3
	CLR  R22
	CLR  R23
	CALL __ADDD21
	CALL _move_window_G101
	MOV  R21,R30
	CPI  R21,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xB1:
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,50
	MOVW R30,R16
	ANDI R31,HIGH(0x1FF)
	ADD  R30,R26
	ADC  R31,R27
	MOVW R18,R30
	LDD  R30,Y+14
	ANDI R30,LOW(0x1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB2:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ST   -Y,R31
	ST   -Y,R30
	__GETD2S 16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB3:
	RCALL SUBOPT_0xA3
	CALL __ADDD21
	CALL _move_window_G101
	MOV  R21,R30
	CPI  R21,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB4:
	CALL __MULB1W2U
	ANDI R31,HIGH(0x1FF)
	LDD  R26,Y+18
	LDD  R27,Y+18+1
	ADIW R26,50
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xB5:
	CALL __PUTDZ20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xB6:
	__GETD2S 5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0xB7:
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	ADIW R26,30
	CALL __GETD1P
	RCALL SUBOPT_0xB6
	CALL __CPD21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xB8:
	__GETD1S 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:37 WORDS
SUBOPT_0xB9:
	__CPD2N 0x1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xBA:
	__GETD2N 0x0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xBB:
	__GETD2Z 14
	RJMP SUBOPT_0x47

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xBC:
	__PUTD1S 5
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xBD:
	CALL __PUTD1S0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xBE:
	LDD  R30,Y+20
	LDD  R31,Y+20+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xBF:
	__GETD2S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC0:
	CALL _get_fat
	__PUTD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 19 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0xC1:
	__GETD2S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xC2:
	__PUTD1S 8
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC3:
	__GETD1N 0x2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC4:
	RCALL SUBOPT_0x15
	RCALL SUBOPT_0xA3
	CALL __CPD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xC5:
	RCALL SUBOPT_0x71
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC6:
	RCALL SUBOPT_0xC1
	RJMP SUBOPT_0x47

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xC7:
	RCALL SUBOPT_0xC1
	RJMP SUBOPT_0xB9

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0xC8:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xC9:
	ADIW R30,30
	MOVW R26,R30
	CALL __GETD1P
	RCALL SUBOPT_0x34
	CALL __CPD21
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xCA:
	RCALL SUBOPT_0x33
	__PUTD1SNS 8,10
	RJMP SUBOPT_0xC8

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xCB:
	CLR  R22
	CLR  R23
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xCC:
	ANDI R30,LOW(0xF)
	ANDI R31,HIGH(0xF)
	LSL  R30
	CALL __LSLW4
	ADD  R30,R26
	ADC  R31,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xCD:
	CALL __GETD1P
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 15 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0xCE:
	LDD  R26,Y+9
	LDD  R27,Y+9+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xCF:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+11
	LDD  R31,Y+11+1
	__GETD2Z 10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD0:
	ADIW R30,30
	MOVW R26,R30
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD1:
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0x31
	JMP  _clust2sect

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0xD2:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	CALL __GETW1P
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	__GETD2Z 14
	CALL _move_window_G101
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xD3:
	ST   -Y,R19
	ST   -Y,R18
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+20
	LDD  R27,Z+21
	ST   -Y,R27
	ST   -Y,R26
	LDI  R26,LOW(11)
	LDI  R27,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD4:
	ST   -Y,R19
	ST   -Y,R18
	RJMP SUBOPT_0x7C

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD5:
	LDI  R27,0
	JMP  _mem_set_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xD6:
	LDI  R30,LOW(32)
	LDI  R31,HIGH(32)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R26,LOW(11)
	RJMP SUBOPT_0xD5

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD7:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADD  R26,R30
	ADC  R27,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xD8:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,1
	STD  Y+8,R30
	STD  Y+8+1,R31
	SBIW R30,1
	RJMP SUBOPT_0xD7

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0xD9:
	MOV  R30,R18
	SUBI R18,-1
	LDI  R31,0
	ADD  R30,R20
	ADC  R31,R21
	ST   Z,R16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xDA:
	__PUTD1SNS 6,6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xDB:
	MOVW R26,R18
	ADIW R26,20
	RJMP SUBOPT_0xAC

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xDC:
	MOVW R26,R18
	ADIW R26,26
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xDD:
	CLR  R22
	CLR  R23
	CALL __ORD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xDE:
	CALL __PUTPARD1
	LDI  R26,LOW(1)
	CALL _disk_read
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0xDF:
	ADIW R30,50
	SUBI R30,LOW(-510)
	SBCI R31,HIGH(-510)
	MOVW R26,R30
	CALL __GETW1P
	CPI  R30,LOW(0xAA55)
	LDI  R26,HIGH(0xAA55)
	CPC  R31,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0xE0:
	CALL __GETD1P
	__ANDD1N 0xFFFFFF
	__CPD1N 0x544146
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE1:
	LDI  R26,LOW(_FatFs_G101)
	LDI  R27,HIGH(_FatFs_G101)
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xE2:
	__PUTD1S 18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE3:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	SUBI R26,LOW(-64)
	SBCI R27,HIGH(-64)
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xE4:
	__PUTD1S 14
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xE5:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LDD  R26,Z+8
	LDD  R27,Z+9
	MOVW R30,R26
	CALL __LSRW4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE6:
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	RCALL SUBOPT_0x9B
	RCALL SUBOPT_0x42
	CALL __ADDD12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xE7:
	CALL _chk_mounted
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE8:
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xE9:
	__SUBD1N 1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xEA:
	CALL _move_window_G101
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xEB:
	CALL _get_fattime
	RJMP SUBOPT_0x2D

;OPTIMIZER ADDED SUBROUTINE, CALLED 21 TIMES, CODE SIZE REDUCTION:37 WORDS
SUBOPT_0xEC:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xED:
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+24
	LDD  R31,Y+24+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xEE:
	LDD  R26,Z+2
	LDD  R27,Z+3
	CALL _validate_G101
	MOV  R17,R30
	CPI  R17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xEF:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,10
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xF0:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	__GETD2Z 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF1:
	CALL __GETD1P
	__PUTD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xF2:
	ST   -Y,R31
	ST   -Y,R30
	RCALL SUBOPT_0xBA
	JMP  _create_chain_G101

;OPTIMIZER ADDED SUBROUTINE, CALLED 12 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0xF3:
	__PUTD1S 12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0xF4:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x80
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0xF5:
	LDD  R30,Z+1
	ST   -Y,R30
	LDD  R30,Y+23
	LDD  R31,Y+23+1
	ADIW R30,32
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0xF6:
	__GETD2Z 22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xF7:
	CALL __PUTPARD2
	LDI  R26,LOW(1)
	CALL _disk_write
	CPI  R30,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF8:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,4
	LD   R30,X
	ANDI R30,0xBF
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xF9:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	LDD  R30,Z+5
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xFA:
	LDD  R30,Y+22
	LDD  R31,Y+22+1
	RCALL SUBOPT_0xF6
	RJMP SUBOPT_0x49

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xFB:
	LDD  R26,Y+22
	LDD  R27,Y+22+1
	ADIW R26,6
	CALL __GETW1P
	ANDI R31,HIGH(0x1FF)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xFC:
	ADIW R30,6
	MOVW R0,R30
	MOVW R26,R30
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xFD:
	__PUTW1RNS 18,26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xFE:
	CALL __LSRD16
	__PUTW1RNS 18,20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0xFF:
	__PUTD1RNS 18,22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 9 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x100:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x101:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,10
	CALL __GETD1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x102:
	__GETD2S 17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x103:
	__PUTD1S 17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x104:
	__PUTD1SNS 21,6
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x105:
	__PUTD1S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x106:
	__GETD1S 17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x107:
	RCALL SUBOPT_0xE9
	MOVW R26,R30
	MOVW R24,R22
	__GETD1S 9
	CALL __DIVD21U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 14 TIMES, CODE SIZE REDUCTION:23 WORDS
SUBOPT_0x108:
	__GETD1S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x109:
	CALL __GETD1P
	__PUTD1S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x10A:
	__GETD1S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x10B:
	__PUTD1S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x10C:
	__GETD2S 13
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x10D:
	LDD  R26,Y+21
	LDD  R27,Y+21+1
	ADIW R26,4
	LD   R30,X
	ORI  R30,0x80
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x10E:
	RCALL SUBOPT_0x10A
	__PUTD1SNS 21,18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x10F:
	ST   -Y,R31
	ST   -Y,R30
	__GETD2S 15
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x110:
	__GETD2S 9
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x111:
	LDD  R30,Y+21
	LDD  R31,Y+21+1
	__GETD2Z 6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x112:
	RCALL SUBOPT_0x42
	RCALL SUBOPT_0x3B
	RJMP SUBOPT_0xE2

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x113:
	LDD  R30,Y+32
	LDD  R31,Y+32+1
	ST   -Y,R31
	ST   -Y,R30
	RJMP SUBOPT_0xAF

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x114:
	__PUTD1S 16
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x115:
	RCALL SUBOPT_0x26
	__GETD1N 0x41200000
	CALL __MULF12
	RJMP SUBOPT_0x25

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x116:
	RCALL SUBOPT_0x15
	RCALL SUBOPT_0xC1
	CALL __CMPF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x117:
	RCALL SUBOPT_0xC1
	__GETD1N 0x3DCCCCCD
	CALL __MULF12
	RCALL SUBOPT_0xF3
	SUBI R19,-LOW(1)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x118:
	__GETD1N 0x41200000
	CALL __MULF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x119:
	__GETD2N 0x3F000000
	CALL __ADDF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x11A:
	__GETD1N 0x3DCCCCCD
	CALL __MULF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x11B:
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	ADIW R26,1
	STD  Y+8,R26
	STD  Y+8+1,R27
	SBIW R26,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x11C:
	CALL __SWAPD12
	CALL __SUBF12
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x11D:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	ADIW R30,1
	STD  Y+8,R30
	STD  Y+8+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x11E:
	ST   -Y,R18
	LDD  R26,Y+7
	LDD  R27,Y+7+1
	RCALL SUBOPT_0x108
	OUT  EIND,R22
	EICALL
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:25 WORDS
SUBOPT_0x11F:
	__GETW1SX 96
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x120:
	SBIW R30,4
	__PUTW1SX 96
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x121:
	LDD  R26,Y+7
	LDD  R27,Y+7+1
	RCALL SUBOPT_0x108
	OUT  EIND,R22
	EICALL
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:17 WORDS
SUBOPT_0x122:
	__GETW2SX 96
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x123:
	RCALL SUBOPT_0x11F
	RJMP SUBOPT_0x120

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x124:
	STD  Y+16,R30
	STD  Y+16+1,R31
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	CALL _strlen
	MOV  R17,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x125:
	__PUTD1S 20
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x126:
	ANDI R16,LOW(251)
	LDD  R30,Y+25
	ST   -Y,R30
	__GETW2SX 91
	__GETD1SX 93
	OUT  EIND,R22
	EICALL
	CPI  R21,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x127:
	__GETD1S 20
	RJMP SUBOPT_0xC1

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x128:
	MOVW R26,R28
	ADIW R26,14
	CALL __ADDW2R15
	CALL __GETW1P
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x129:
	__POINTD1M _put_buff_G102
	CALL __PUTPARD1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x12A:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	ADIW R26,1
	STD  Y+6,R26
	STD  Y+6+1,R27
	SBIW R26,1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x12B:
	RCALL SUBOPT_0x33
	RJMP SUBOPT_0x110


	.CSEG
	.equ __i2c_dir=__i2c_port-1
	.equ __i2c_pin=__i2c_port-2

_i2c_init:
	cbi  __i2c_port,__scl_bit
	cbi  __i2c_port,__sda_bit
	sbi  __i2c_dir,__scl_bit
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_delay2
_i2c_start:
	cbi  __i2c_dir,__sda_bit
	cbi  __i2c_dir,__scl_bit
	clr  r30
	nop
	sbis __i2c_pin,__sda_bit
	ret
	sbis __i2c_pin,__scl_bit
	ret
	rcall __i2c_delay1
	sbi  __i2c_dir,__sda_bit
	rcall __i2c_delay1
	sbi  __i2c_dir,__scl_bit
	ldi  r30,1
__i2c_delay1:
	ldi  r22,13
	rjmp __i2c_delay2l
_i2c_stop:
	sbi  __i2c_dir,__sda_bit
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__sda_bit
__i2c_delay2:
	ldi  r22,27
__i2c_delay2l:
	dec  r22
	brne __i2c_delay2l
	ret
_i2c_read:
	ldi  r23,8
__i2c_read0:
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
__i2c_read3:
	sbis __i2c_pin,__scl_bit
	rjmp __i2c_read3
	rcall __i2c_delay1
	clc
	sbic __i2c_pin,__sda_bit
	sec
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	rol  r30
	dec  r23
	brne __i2c_read0
	mov  r23,r26
	tst  r23
	brne __i2c_read1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_read2
__i2c_read1:
	sbi  __i2c_dir,__sda_bit
__i2c_read2:
	rcall __i2c_delay1
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	sbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_delay1

_i2c_write:
	ldi  r23,8
__i2c_write0:
	lsl  r26
	brcc __i2c_write1
	cbi  __i2c_dir,__sda_bit
	rjmp __i2c_write2
__i2c_write1:
	sbi  __i2c_dir,__sda_bit
__i2c_write2:
	rcall __i2c_delay2
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay1
__i2c_write3:
	sbis __i2c_pin,__scl_bit
	rjmp __i2c_write3
	rcall __i2c_delay1
	sbi  __i2c_dir,__scl_bit
	dec  r23
	brne __i2c_write0
	cbi  __i2c_dir,__sda_bit
	rcall __i2c_delay1
	cbi  __i2c_dir,__scl_bit
	rcall __i2c_delay2
	ldi  r30,1
	sbic __i2c_pin,__sda_bit
	clr  r30
	sbi  __i2c_dir,__scl_bit
	rjmp __i2c_delay1

_delay_ms:
	adiw r26,0
	breq __delay_ms1
__delay_ms0:
	__DELAY_USW 0x7D0
	wdr
	sbiw r26,1
	brne __delay_ms0
__delay_ms1:
	ret

__ANEGF1:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	BREQ __ANEGF10
	SUBI R23,0x80
__ANEGF10:
	RET

__ROUND_REPACK:
	TST  R21
	BRPL __REPACK
	CPI  R21,0x80
	BRNE __ROUND_REPACK0
	SBRS R30,0
	RJMP __REPACK
__ROUND_REPACK0:
	ADIW R30,1
	ADC  R22,R25
	ADC  R23,R25
	BRVS __REPACK1

__REPACK:
	LDI  R21,0x80
	EOR  R21,R23
	BRNE __REPACK0
	PUSH R21
	RJMP __ZERORES
__REPACK0:
	CPI  R21,0xFF
	BREQ __REPACK1
	LSL  R22
	LSL  R0
	ROR  R21
	ROR  R22
	MOV  R23,R21
	RET
__REPACK1:
	PUSH R21
	TST  R0
	BRMI __REPACK2
	RJMP __MAXRES
__REPACK2:
	RJMP __MINRES

__UNPACK:
	LDI  R21,0x80
	MOV  R1,R25
	AND  R1,R21
	LSL  R24
	ROL  R25
	EOR  R25,R21
	LSL  R21
	ROR  R24

__UNPACK1:
	LDI  R21,0x80
	MOV  R0,R23
	AND  R0,R21
	LSL  R22
	ROL  R23
	EOR  R23,R21
	LSL  R21
	ROR  R22
	RET

__CFD1U:
	SET
	RJMP __CFD1U0
__CFD1:
	CLT
__CFD1U0:
	PUSH R21
	RCALL __UNPACK1
	CPI  R23,0x80
	BRLO __CFD10
	CPI  R23,0xFF
	BRCC __CFD10
	RJMP __ZERORES
__CFD10:
	LDI  R21,22
	SUB  R21,R23
	BRPL __CFD11
	NEG  R21
	CPI  R21,8
	BRTC __CFD19
	CPI  R21,9
__CFD19:
	BRLO __CFD17
	SER  R30
	SER  R31
	SER  R22
	LDI  R23,0x7F
	BLD  R23,7
	RJMP __CFD15
__CFD17:
	CLR  R23
	TST  R21
	BREQ __CFD15
__CFD18:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	DEC  R21
	BRNE __CFD18
	RJMP __CFD15
__CFD11:
	CLR  R23
__CFD12:
	CPI  R21,8
	BRLO __CFD13
	MOV  R30,R31
	MOV  R31,R22
	MOV  R22,R23
	SUBI R21,8
	RJMP __CFD12
__CFD13:
	TST  R21
	BREQ __CFD15
__CFD14:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	DEC  R21
	BRNE __CFD14
__CFD15:
	TST  R0
	BRPL __CFD16
	RCALL __ANEGD1
__CFD16:
	POP  R21
	RET

__CDF1U:
	SET
	RJMP __CDF1U0
__CDF1:
	CLT
__CDF1U0:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	BREQ __CDF10
	CLR  R0
	BRTS __CDF11
	TST  R23
	BRPL __CDF11
	COM  R0
	RCALL __ANEGD1
__CDF11:
	MOV  R1,R23
	LDI  R23,30
	TST  R1
__CDF12:
	BRMI __CDF13
	DEC  R23
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R1
	RJMP __CDF12
__CDF13:
	MOV  R30,R31
	MOV  R31,R22
	MOV  R22,R1
	PUSH R21
	RCALL __REPACK
	POP  R21
__CDF10:
	RET

__SWAPACC:
	PUSH R20
	MOVW R20,R30
	MOVW R30,R26
	MOVW R26,R20
	MOVW R20,R22
	MOVW R22,R24
	MOVW R24,R20
	MOV  R20,R0
	MOV  R0,R1
	MOV  R1,R20
	POP  R20
	RET

__UADD12:
	ADD  R30,R26
	ADC  R31,R27
	ADC  R22,R24
	RET

__NEGMAN1:
	COM  R30
	COM  R31
	COM  R22
	SUBI R30,-1
	SBCI R31,-1
	SBCI R22,-1
	RET

__SUBF12:
	PUSH R21
	RCALL __UNPACK
	CPI  R25,0x80
	BREQ __ADDF129
	LDI  R21,0x80
	EOR  R1,R21

	RJMP __ADDF120

__ADDF12:
	PUSH R21
	RCALL __UNPACK
	CPI  R25,0x80
	BREQ __ADDF129

__ADDF120:
	CPI  R23,0x80
	BREQ __ADDF128
__ADDF121:
	MOV  R21,R23
	SUB  R21,R25
	BRVS __ADDF1211
	BRPL __ADDF122
	RCALL __SWAPACC
	RJMP __ADDF121
__ADDF122:
	CPI  R21,24
	BRLO __ADDF123
	CLR  R26
	CLR  R27
	CLR  R24
__ADDF123:
	CPI  R21,8
	BRLO __ADDF124
	MOV  R26,R27
	MOV  R27,R24
	CLR  R24
	SUBI R21,8
	RJMP __ADDF123
__ADDF124:
	TST  R21
	BREQ __ADDF126
__ADDF125:
	LSR  R24
	ROR  R27
	ROR  R26
	DEC  R21
	BRNE __ADDF125
__ADDF126:
	MOV  R21,R0
	EOR  R21,R1
	BRMI __ADDF127
	RCALL __UADD12
	BRCC __ADDF129
	ROR  R22
	ROR  R31
	ROR  R30
	INC  R23
	BRVC __ADDF129
	RJMP __MAXRES
__ADDF128:
	RCALL __SWAPACC
__ADDF129:
	RCALL __REPACK
	POP  R21
	RET
__ADDF1211:
	BRCC __ADDF128
	RJMP __ADDF129
__ADDF127:
	SUB  R30,R26
	SBC  R31,R27
	SBC  R22,R24
	BREQ __ZERORES
	BRCC __ADDF1210
	COM  R0
	RCALL __NEGMAN1
__ADDF1210:
	TST  R22
	BRMI __ADDF129
	LSL  R30
	ROL  R31
	ROL  R22
	DEC  R23
	BRVC __ADDF1210

__ZERORES:
	CLR  R30
	CLR  R31
	CLR  R22
	CLR  R23
	POP  R21
	RET

__MINRES:
	SER  R30
	SER  R31
	LDI  R22,0x7F
	SER  R23
	POP  R21
	RET

__MAXRES:
	SER  R30
	SER  R31
	LDI  R22,0x7F
	LDI  R23,0x7F
	POP  R21
	RET

__MULF12:
	PUSH R21
	RCALL __UNPACK
	CPI  R23,0x80
	BREQ __ZERORES
	CPI  R25,0x80
	BREQ __ZERORES
	EOR  R0,R1
	SEC
	ADC  R23,R25
	BRVC __MULF124
	BRLT __ZERORES
__MULF125:
	TST  R0
	BRMI __MINRES
	RJMP __MAXRES
__MULF124:
	PUSH R0
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	CLR  R17
	CLR  R18
	CLR  R25
	MUL  R22,R24
	MOVW R20,R0
	MUL  R24,R31
	MOV  R19,R0
	ADD  R20,R1
	ADC  R21,R25
	MUL  R22,R27
	ADD  R19,R0
	ADC  R20,R1
	ADC  R21,R25
	MUL  R24,R30
	RCALL __MULF126
	MUL  R27,R31
	RCALL __MULF126
	MUL  R22,R26
	RCALL __MULF126
	MUL  R27,R30
	RCALL __MULF127
	MUL  R26,R31
	RCALL __MULF127
	MUL  R26,R30
	ADD  R17,R1
	ADC  R18,R25
	ADC  R19,R25
	ADC  R20,R25
	ADC  R21,R25
	MOV  R30,R19
	MOV  R31,R20
	MOV  R22,R21
	MOV  R21,R18
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	POP  R0
	TST  R22
	BRMI __MULF122
	LSL  R21
	ROL  R30
	ROL  R31
	ROL  R22
	RJMP __MULF123
__MULF122:
	INC  R23
	BRVS __MULF125
__MULF123:
	RCALL __ROUND_REPACK
	POP  R21
	RET

__MULF127:
	ADD  R17,R0
	ADC  R18,R1
	ADC  R19,R25
	RJMP __MULF128
__MULF126:
	ADD  R18,R0
	ADC  R19,R1
__MULF128:
	ADC  R20,R25
	ADC  R21,R25
	RET

__DIVF21:
	PUSH R21
	RCALL __UNPACK
	CPI  R23,0x80
	BRNE __DIVF210
	TST  R1
__DIVF211:
	BRPL __DIVF219
	RJMP __MINRES
__DIVF219:
	RJMP __MAXRES
__DIVF210:
	CPI  R25,0x80
	BRNE __DIVF218
__DIVF217:
	RJMP __ZERORES
__DIVF218:
	EOR  R0,R1
	SEC
	SBC  R25,R23
	BRVC __DIVF216
	BRLT __DIVF217
	TST  R0
	RJMP __DIVF211
__DIVF216:
	MOV  R23,R25
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	CLR  R1
	CLR  R17
	CLR  R18
	CLR  R19
	CLR  R20
	CLR  R21
	LDI  R25,32
__DIVF212:
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	CPC  R20,R17
	BRLO __DIVF213
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R20,R17
	SEC
	RJMP __DIVF214
__DIVF213:
	CLC
__DIVF214:
	ROL  R21
	ROL  R18
	ROL  R19
	ROL  R1
	ROL  R26
	ROL  R27
	ROL  R24
	ROL  R20
	DEC  R25
	BRNE __DIVF212
	MOVW R30,R18
	MOV  R22,R1
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	TST  R22
	BRMI __DIVF215
	LSL  R21
	ROL  R30
	ROL  R31
	ROL  R22
	DEC  R23
	BRVS __DIVF217
__DIVF215:
	RCALL __ROUND_REPACK
	POP  R21
	RET

__CMPF12:
	TST  R25
	BRMI __CMPF120
	TST  R23
	BRMI __CMPF121
	CP   R25,R23
	BRLO __CMPF122
	BRNE __CMPF121
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	BRLO __CMPF122
	BREQ __CMPF123
__CMPF121:
	CLZ
	CLC
	RET
__CMPF122:
	CLZ
	SEC
	RET
__CMPF123:
	SEZ
	CLC
	RET
__CMPF120:
	TST  R23
	BRPL __CMPF122
	CP   R25,R23
	BRLO __CMPF121
	BRNE __CMPF122
	CP   R30,R26
	CPC  R31,R27
	CPC  R22,R24
	BRLO __CMPF122
	BREQ __CMPF123
	RJMP __CMPF121

__ADDW2R15:
	CLR  R0
	ADD  R26,R15
	ADC  R27,R0
	RET

__ADDD12:
	ADD  R30,R26
	ADC  R31,R27
	ADC  R22,R24
	ADC  R23,R25
	RET

__ADDD21:
	ADD  R26,R30
	ADC  R27,R31
	ADC  R24,R22
	ADC  R25,R23
	RET

__SUBD12:
	SUB  R30,R26
	SBC  R31,R27
	SBC  R22,R24
	SBC  R23,R25
	RET

__SUBD21:
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R25,R23
	RET

__ANDD12:
	AND  R30,R26
	AND  R31,R27
	AND  R22,R24
	AND  R23,R25
	RET

__ORD12:
	OR   R30,R26
	OR   R31,R27
	OR   R22,R24
	OR   R23,R25
	RET

__ANEGW1:
	NEG  R31
	NEG  R30
	SBCI R31,0
	RET

__ANEGD1:
	COM  R31
	COM  R22
	COM  R23
	NEG  R30
	SBCI R31,-1
	SBCI R22,-1
	SBCI R23,-1
	RET

__LSLD12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	MOVW R22,R24
	BREQ __LSLD12R
__LSLD12L:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	DEC  R0
	BRNE __LSLD12L
__LSLD12R:
	RET

__LSRD12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	MOVW R22,R24
	BREQ __LSRD12R
__LSRD12L:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	DEC  R0
	BRNE __LSRD12L
__LSRD12R:
	RET

__LSLW4:
	LSL  R30
	ROL  R31
__LSLW3:
	LSL  R30
	ROL  R31
__LSLW2:
	LSL  R30
	ROL  R31
	LSL  R30
	ROL  R31
	RET

__ASRW4:
	ASR  R31
	ROR  R30
__ASRW3:
	ASR  R31
	ROR  R30
__ASRW2:
	ASR  R31
	ROR  R30
	ASR  R31
	ROR  R30
	RET

__LSRW4:
	LSR  R31
	ROR  R30
__LSRW3:
	LSR  R31
	ROR  R30
__LSRW2:
	LSR  R31
	ROR  R30
	LSR  R31
	ROR  R30
	RET

__LSRD1:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	RET

__LSLD1:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	RET

__LSRD16:
	MOV  R30,R22
	MOV  R31,R23
	LDI  R22,0
	LDI  R23,0
	RET

__LSLD16:
	MOV  R22,R30
	MOV  R23,R31
	LDI  R30,0
	LDI  R31,0
	RET

__CBD1:
	MOV  R31,R30
	ADD  R31,R31
	SBC  R31,R31
	MOV  R22,R31
	MOV  R23,R31
	RET

__CWD1:
	MOV  R22,R31
	ADD  R22,R22
	SBC  R22,R22
	MOV  R23,R22
	RET

__COMD1:
	COM  R30
	COM  R31
	COM  R22
	COM  R23
	RET

__MULW12U:
	MUL  R31,R26
	MOV  R31,R0
	MUL  R30,R27
	ADD  R31,R0
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	RET

__MULD12U:
	MUL  R23,R26
	MOV  R23,R0
	MUL  R22,R27
	ADD  R23,R0
	MUL  R31,R24
	ADD  R23,R0
	MUL  R30,R25
	ADD  R23,R0
	MUL  R22,R26
	MOV  R22,R0
	ADD  R23,R1
	MUL  R31,R27
	ADD  R22,R0
	ADC  R23,R1
	MUL  R30,R24
	ADD  R22,R0
	ADC  R23,R1
	CLR  R24
	MUL  R31,R26
	MOV  R31,R0
	ADD  R22,R1
	ADC  R23,R24
	MUL  R30,R27
	ADD  R31,R0
	ADC  R22,R1
	ADC  R23,R24
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	ADC  R22,R24
	ADC  R23,R24
	RET

__MULB1W2U:
	MOV  R22,R30
	MUL  R22,R26
	MOVW R30,R0
	MUL  R22,R27
	ADD  R31,R0
	RET

__MULW12:
	RCALL __CHKSIGNW
	RCALL __MULW12U
	BRTC __MULW121
	RCALL __ANEGW1
__MULW121:
	RET

__DIVB21U:
	CLR  R0
	LDI  R25,8
__DIVB21U1:
	LSL  R26
	ROL  R0
	SUB  R0,R30
	BRCC __DIVB21U2
	ADD  R0,R30
	RJMP __DIVB21U3
__DIVB21U2:
	SBR  R26,1
__DIVB21U3:
	DEC  R25
	BRNE __DIVB21U1
	MOV  R30,R26
	MOV  R26,R0
	RET

__DIVB21:
	RCALL __CHKSIGNB
	RCALL __DIVB21U
	BRTC __DIVB211
	NEG  R30
__DIVB211:
	RET

__DIVW21U:
	CLR  R0
	CLR  R1
	LDI  R25,16
__DIVW21U1:
	LSL  R26
	ROL  R27
	ROL  R0
	ROL  R1
	SUB  R0,R30
	SBC  R1,R31
	BRCC __DIVW21U2
	ADD  R0,R30
	ADC  R1,R31
	RJMP __DIVW21U3
__DIVW21U2:
	SBR  R26,1
__DIVW21U3:
	DEC  R25
	BRNE __DIVW21U1
	MOVW R30,R26
	MOVW R26,R0
	RET

__DIVD21U:
	PUSH R19
	PUSH R20
	PUSH R21
	CLR  R0
	CLR  R1
	CLR  R20
	CLR  R21
	LDI  R19,32
__DIVD21U1:
	LSL  R26
	ROL  R27
	ROL  R24
	ROL  R25
	ROL  R0
	ROL  R1
	ROL  R20
	ROL  R21
	SUB  R0,R30
	SBC  R1,R31
	SBC  R20,R22
	SBC  R21,R23
	BRCC __DIVD21U2
	ADD  R0,R30
	ADC  R1,R31
	ADC  R20,R22
	ADC  R21,R23
	RJMP __DIVD21U3
__DIVD21U2:
	SBR  R26,1
__DIVD21U3:
	DEC  R19
	BRNE __DIVD21U1
	MOVW R30,R26
	MOVW R22,R24
	MOVW R26,R0
	MOVW R24,R20
	POP  R21
	POP  R20
	POP  R19
	RET

__MODB21:
	CLT
	SBRS R26,7
	RJMP __MODB211
	NEG  R26
	SET
__MODB211:
	SBRC R30,7
	NEG  R30
	RCALL __DIVB21U
	MOV  R30,R26
	BRTC __MODB212
	NEG  R30
__MODB212:
	RET

__MODW21:
	CLT
	SBRS R27,7
	RJMP __MODW211
	COM  R26
	COM  R27
	ADIW R26,1
	SET
__MODW211:
	SBRC R31,7
	RCALL __ANEGW1
	RCALL __DIVW21U
	MOVW R30,R26
	BRTC __MODW212
	RCALL __ANEGW1
__MODW212:
	RET

__MODD21U:
	RCALL __DIVD21U
	MOVW R30,R26
	MOVW R22,R24
	RET

__CHKSIGNB:
	CLT
	SBRS R30,7
	RJMP __CHKSB1
	NEG  R30
	SET
__CHKSB1:
	SBRS R26,7
	RJMP __CHKSB2
	NEG  R26
	BLD  R0,0
	INC  R0
	BST  R0,0
__CHKSB2:
	RET

__CHKSIGNW:
	CLT
	SBRS R31,7
	RJMP __CHKSW1
	RCALL __ANEGW1
	SET
__CHKSW1:
	SBRS R27,7
	RJMP __CHKSW2
	COM  R26
	COM  R27
	ADIW R26,1
	BLD  R0,0
	INC  R0
	BST  R0,0
__CHKSW2:
	RET

__GETW1P:
	LD   R30,X+
	LD   R31,X
	SBIW R26,1
	RET

__GETD1P:
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X
	SBIW R26,3
	RET

__GETD1P_INC:
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X+
	RET

__PUTDP1:
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	RET

__PUTDP1_DEC:
	ST   -X,R23
	ST   -X,R22
	ST   -X,R31
	ST   -X,R30
	RET

__GETD1PF:
	OUT  RAMPZ,R22
	ELPM R0,Z+
	ELPM R1,Z+
	ELPM R22,Z+
	ELPM R23,Z
	MOVW R30,R0
	RET

__GETD1S0:
	LD   R30,Y
	LDD  R31,Y+1
	LDD  R22,Y+2
	LDD  R23,Y+3
	RET

__GETD2S0:
	LD   R26,Y
	LDD  R27,Y+1
	LDD  R24,Y+2
	LDD  R25,Y+3
	RET

__PUTD1S0:
	ST   Y,R30
	STD  Y+1,R31
	STD  Y+2,R22
	STD  Y+3,R23
	RET

__PUTDZ20:
	ST   Z,R26
	STD  Z+1,R27
	STD  Z+2,R24
	STD  Z+3,R25
	RET

__PUTPARD1:
	ST   -Y,R23
	ST   -Y,R22
	ST   -Y,R31
	ST   -Y,R30
	RET

__PUTPARD2:
	ST   -Y,R25
	ST   -Y,R24
	ST   -Y,R27
	ST   -Y,R26
	RET

__PUTPARL:
	CLR  R27
__PUTPAR:
	ADD  R30,R26
	ADC  R31,R27
__PUTPAR0:
	LD   R0,-Z
	ST   -Y,R0
	SBIW R26,1
	BRNE __PUTPAR0
	RET

__SWAPD12:
	MOV  R1,R24
	MOV  R24,R22
	MOV  R22,R1
	MOV  R1,R25
	MOV  R25,R23
	MOV  R23,R1

__SWAPW12:
	MOV  R1,R27
	MOV  R27,R31
	MOV  R31,R1

__SWAPB12:
	MOV  R1,R26
	MOV  R26,R30
	MOV  R30,R1
	RET

__EEPROMRDB:
	SBIC EECR,EEWE
	RJMP __EEPROMRDB
	PUSH R31
	IN   R31,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R30,EEDR
	OUT  SREG,R31
	POP  R31
	RET

__EEPROMWRB:
	SBIS EECR,EEWE
	RJMP __EEPROMWRB1
	WDR
	RJMP __EEPROMWRB
__EEPROMWRB1:
	IN   R25,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R24,EEDR
	CP   R30,R24
	BREQ __EEPROMWRB0
	OUT  EEDR,R30
	SBI  EECR,EEMWE
	SBI  EECR,EEWE
__EEPROMWRB0:
	OUT  SREG,R25
	RET

__CPD10:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	RET

__CPW02:
	CLR  R0
	CP   R0,R26
	CPC  R0,R27
	RET

__CPD02:
	CLR  R0
	CP   R0,R26
	CPC  R0,R27
	CPC  R0,R24
	CPC  R0,R25
	RET

__CPD12:
	CP   R30,R26
	CPC  R31,R27
	CPC  R22,R24
	CPC  R23,R25
	RET

__CPD21:
	CP   R26,R30
	CPC  R27,R31
	CPC  R24,R22
	CPC  R25,R23
	RET

__SAVELOCR6:
	ST   -Y,R21
__SAVELOCR5:
	ST   -Y,R20
__SAVELOCR4:
	ST   -Y,R19
__SAVELOCR3:
	ST   -Y,R18
__SAVELOCR2:
	ST   -Y,R17
	ST   -Y,R16
	RET

__LOADLOCR6:
	LDD  R21,Y+5
__LOADLOCR5:
	LDD  R20,Y+4
__LOADLOCR4:
	LDD  R19,Y+3
__LOADLOCR3:
	LDD  R18,Y+2
__LOADLOCR2:
	LDD  R17,Y+1
	LD   R16,Y
	RET

__INITLOCB:
	CLR  R25
__INITLOCW:
	ADD  R26,R28
	ADC  R27,R29
	OUT  RAMPZ,R22
__INITLOC0:
	ELPM R0,Z+
	ST   X+,R0
	SBIW R24,1
	BRNE __INITLOC0
	RET

;END OF CODE MARKER
__END_OF_CODE:
